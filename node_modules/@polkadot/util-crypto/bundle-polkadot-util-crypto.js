const polkadotUtilCrypto = (function (exports, require$$0$3) {
  'use strict';

  const global = window;

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);

  // Copyright 2019-2021 @polkadot/wasm-crypto-asmjs authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const asmJsInit = null;

  // Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // MIT License
  //
  // Copyright (c) 2014 Jameson Little
  //
  // https://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js
  // This only contains the toByteArray function (no encoding)
  //
  // Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with
  // only the single required function provided
  const CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  const lookup$2 = [];
  const revLookup$2 = [];

  for (let i = 0; i < CODE.length; ++i) {
    lookup$2[i] = CODE[i];
    revLookup$2[CODE.charCodeAt(i)] = i;
  } // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications


  revLookup$2['-'.charCodeAt(0)] = 62;
  revLookup$2['_'.charCodeAt(0)] = 63;

  function getLens$1(b64) {
    const len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42


    const validLen = b64.indexOf('=');
    return validLen === -1 ? [len, 0] : [validLen, 4 - validLen % 4];
  }

  function toByteArray$2(b64) {
    const [validLen, placeHoldersLen] = getLens$1(b64);
    const arr = new Uint8Array((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);
    let curByte = 0;
    let i;
    let tmp; // if there are placeholders, only get up to the last complete 4 chars

    const len = placeHoldersLen > 0 ? validLen - 4 : validLen;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup$2[b64.charCodeAt(i)] << 18 | revLookup$2[b64.charCodeAt(i + 1)] << 12 | revLookup$2[b64.charCodeAt(i + 2)] << 6 | revLookup$2[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup$2[b64.charCodeAt(i)] << 2 | revLookup$2[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    } else if (placeHoldersLen === 1) {
      tmp = revLookup$2[b64.charCodeAt(i)] << 10 | revLookup$2[b64.charCodeAt(i + 1)] << 4 | revLookup$2[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function commonjsRequire (path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  // Copyright 2019-2021 @polkadot/wasm-crypto-wasm authors & contributors
  // SPDX-License-Identifier: Apache-2.0

  // Generated as part of the build, do not edit

  const sizeCompressed = 152872;
  const sizeUncompressed$1 = 300043;
  const bytes$1 = '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';

  var bytes_1 = { bytes: bytes$1, sizeCompressed, sizeUncompressed: sizeUncompressed$1 };

  // Copyright 2019-2021 @polkadot/wasm-crypto-wasm authors & contributors
  const bytes = bytes_1.bytes;
  const sizeUncompressed = bytes_1.sizeUncompressed;

  // Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // MIT License
  //
  // Copyright (c) 2020 Arjun Barrett
  //
  // Copied from https://github.com/101arrowz/fflate/blob/73c737941ec89d85cdf0ad39ee6f26c5fdc95fd7/src/index.ts
  // This only contains the unzlibSync function, no compression, no async, no workers
  //
  // These 2 issues are addressed as a short-term, stop-gap solution
  //   - https://github.com/polkadot-js/api/issues/2963
  //   - https://github.com/101arrowz/fflate/issues/17
  //
  // Only tweaks make here are some TS adjustments (we use strict null checks), the code is otherwise as-is with
  // only the single required function provided (compression is still being done in the build with fflate)

  /* eslint-disable */
  // inflate state
  // aliases for shorter compressed code (most minifers don't do this)
  const u8 = Uint8Array,
        u16 = Uint16Array,
        u32 = Uint32Array; // code length index map

  const clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // fixed length extra bits

  const fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
  /* unused */
  0, 0,
  /* impossible */
  0]); // fixed distance extra bits
  // see fleb note

  const fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
  /* unused */
  0, 0]); // get base, reverse index map from extra bits

  const freb = (eb, start) => {
    const b = new u16(31);

    for (let i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    } // numbers here are at max 18 bits


    const r = new u32(b[30]);

    for (let i = 1; i < 30; ++i) {
      for (let j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }

    return [b, r];
  };

  const [fl, revfl] = freb(fleb, 2); // we can ignore the fact that the other numbers are wrong; they never happen anyway

  fl[28] = 258, revfl[258] = 28;
  const [fd] = freb(fdeb, 0); // map of value to reverse (assuming 16 bits)

  const rev = new u16(32768);

  for (let i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
  } // create huffman tree from u8 "map": index -> code length for code index
  // mb (max bits) must be at most 15
  // TODO: optimize/split up?


  const hMap = (cd, mb, r) => {
    const s = cd.length; // index

    let i = 0; // u16 "map": index -> # of codes with bit length = index

    const l = new u16(mb); // length of cd must be 288 (total # of codes)

    for (; i < s; ++i) ++l[cd[i] - 1]; // u16 "map": index -> minimum code for bit length = index


    const le = new u16(mb);

    for (i = 0; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }

    let co;

    if (r) {
      // u16 "map": index -> number of actual bits, symbol for code
      co = new u16(1 << mb); // bits to remove for reverser

      const rvb = 15 - mb;

      for (i = 0; i < s; ++i) {
        // ignore 0 lengths
        if (cd[i]) {
          // num encoding both symbol and bits read
          const sv = i << 4 | cd[i]; // free bits

          const r = mb - cd[i]; // start value

          let v = le[cd[i] - 1]++ << r; // m is end value

          for (const m = v | (1 << r) - 1; v <= m; ++v) {
            // every 16 bit value starting with the code yields the same result
            co[rev[v] >>> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);

      for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
    }

    return co;
  }; // fixed length tree


  const flt = new u8(288);

  for (let i = 0; i < 144; ++i) flt[i] = 8;

  for (let i = 144; i < 256; ++i) flt[i] = 9;

  for (let i = 256; i < 280; ++i) flt[i] = 7;

  for (let i = 280; i < 288; ++i) flt[i] = 8; // fixed distance tree


  const fdt = new u8(32);

  for (let i = 0; i < 32; ++i) fdt[i] = 5; // fixed length map


  const flrm = hMap(flt, 9, 1); // fixed distance map

  const fdrm = hMap(fdt, 5, 1); // read d, starting at bit p and mask with m

  const bits = (d, p, m) => {
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;
  }; // read d, starting at bit p continuing for at least 16 bits


  const bits16 = (d, p) => {
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
  }; // get end of byte


  const shft = p => (p >>> 3) + (p & 7 && 1); // typed array slice - allows garbage collector to free original reference,
  // while being more compatible than .slice


  const slc = (v, s, e) => {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied

    const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
  }; // find max of array


  const max = a => {
    let m = a[0];

    for (let i = 1; i < a.length; ++i) {
      if (a[i] > m) m = a[i];
    }

    return m;
  }; // expands raw DEFLATE data


  const inflt = (dat, buf, st) => {
    const noSt = !st || st.i;
    if (!st) st = {}; // source length

    const sl = dat.length; // have to estimate size

    const noBuf = !buf || !noSt; // Assumes roughly 33% compression ratio average

    if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements

    const cbuf = l => {
      let bl = buf.length; // need to increase size to fit

      if (l > bl) {
        // Double or set to necessary, whichever is greater
        const nbuf = new u8(Math.max(bl << 1, l));
        nbuf.set(buf);
        buf = nbuf;
      }
    }; //  last chunk         bitpos           bytes


    let final = st.f || 0,
        pos = st.p || 0,
        bt = st.b || 0,
        lm = st.l,
        dm = st.d,
        lbt = st.m,
        dbt = st.n;
    if (final && !lm) return buf; // total bits

    const tbts = sl << 3;

    do {
      if (!lm) {
        // BFINAL - this is only 1 when last chunk is next
        st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman

        const type = bits(dat, pos + 1, 3);
        pos += 3;

        if (!type) {
          // go to end of byte boundary
          const s = shft(pos) + 4,
                l = dat[s - 4] | dat[s - 3] << 8,
                t = s + l;

          if (t > sl) {
            if (noSt) throw 'unexpected EOF';
            break;
          } // ensure size


          if (noBuf) cbuf(bt + l); // Copy over uncompressed data

          buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count

          st.b = bt += l, st.p = pos = t << 3;
          continue;
        } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {
          //  literal                            lengths
          const hLit = bits(dat, pos, 31) + 257,
                hcLen = bits(dat, pos + 10, 15) + 4;
          const tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14; // length+distance tree

          const ldt = new u8(tl); // code length tree

          const clt = new u8(19);

          for (let i = 0; i < hcLen; ++i) {
            // use index map to get real code
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }

          pos += hcLen * 3; // code lengths bits

          const clb = max(clt),
                clbmsk = (1 << clb) - 1;
          if (!noSt && pos + tl * (clb + 7) > tbts) break; // code lengths map

          const clm = hMap(clt, clb, 1);

          for (let i = 0; i < tl;) {
            const r = clm[bits(dat, pos, clbmsk)]; // bits read

            pos += r & 15; // symbol

            const s = r >>> 4; // code length to copy

            if (s < 16) {
              ldt[i++] = s;
            } else {
              //  copy   count
              let c = 0,
                  n = 0;
              if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;

              while (n--) ldt[i++] = c;
            }
          } //    length tree                 distance tree


          const lt = ldt.subarray(0, hLit),
                dt = ldt.subarray(hLit); // max length bits

          lbt = max(lt); // max dist bits

          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else throw 'invalid block type';

        if (pos > tbts) throw 'unexpected EOF';
      } // Make sure the buffer can hold this + the largest possible addition
      // maximum chunk size (practically, theoretically infinite) is 2^17;


      if (noBuf) cbuf(bt + 131072);
      const lms = (1 << lbt) - 1,
            dms = (1 << dbt) - 1;
      const mxa = lbt + dbt + 18;

      while (noSt || pos + mxa < tbts) {
        // bits read, code
        const c = lm[bits16(dat, pos) & lms],
              sym = c >>> 4;
        pos += c & 15;
        if (pos > tbts) throw 'unexpected EOF';
        if (!c) throw 'invalid length/literal';
        if (sym < 256) buf[bt++] = sym;else if (sym == 256) {
          lm = undefined;
          break;
        } else {
          let add = sym - 254; // no extra bits needed if less

          if (sym > 264) {
            // index
            const i = sym - 257,
                  b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          } // dist


          const d = dm[bits16(dat, pos) & dms],
                dsym = d >>> 4;
          if (!d) throw 'invalid distance';
          pos += d & 15;
          let dt = fd[dsym];

          if (dsym > 3) {
            const b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }

          if (pos > tbts) throw 'unexpected EOF';
          if (noBuf) cbuf(bt + 131072);
          const end = bt + add;

          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }

          bt = end;
        }
      }

      st.l = lm, st.p = pos, st.b = bt;
      if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);

    return bt == buf.length ? buf : slc(buf, 0, bt);
  }; // zlib valid


  const zlv = d => {
    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
    if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
  };
  /**
   * Expands Zlib data
   * @param data The data to decompress
   * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
   * @returns The decompressed version of the data
   */


  function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
  }

  // Copyright 2019-2021 @polkadot/wasm-crypto-wasm authors & contributors
  const wasmBytes = unzlibSync(toByteArray$2(bytes), new Uint8Array(sizeUncompressed));

  // Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors
  let wasm = null;
  let cachegetInt32 = null;
  let cachegetUint8 = null;
  async function initWasm(wasmBytes, asmFn, wbg) {
    try {
      require$$0$3.assert(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');
      const source = await WebAssembly.instantiate(wasmBytes, {
        wbg
      });
      wasm = source.instance.exports;
    } catch (error) {
      // if we have a valid supplied asm.js, return that
      if (asmFn) {
        wasm = asmFn(wbg);
      } else {
        console.error('FATAL: Unable to initialize @polkadot/wasm-crypto');
        console.error(error);
        wasm = null;
      }
    }
  } // FIXME We really would love to clean this up and have a sign like (wasm, ...params) => T
  // Alas, TypeScript foo is not that great today, so we sadly have an extra closure here

  function withWasm(fn) {
    return (...params) => {
      require$$0$3.assert(wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');
      return fn(wasm)(...params);
    };
  }
  function getWasm() {
    return wasm;
  }
  function getInt32() {
    if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {
      cachegetInt32 = new Int32Array(wasm.memory.buffer);
    }

    return cachegetInt32;
  }
  function getUint8() {
    if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {
      cachegetUint8 = new Uint8Array(wasm.memory.buffer);
    }

    return cachegetUint8;
  }
  function getU8a(ptr, len) {
    return getUint8().subarray(ptr / 1, ptr / 1 + len);
  }
  function getString(ptr, len) {
    return require$$0$3.u8aToString(getU8a(ptr, len));
  }
  function allocU8a(arg) {
    const ptr = wasm.__wbindgen_malloc(arg.length * 1);

    getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }
  function allocString(arg) {
    return allocU8a(require$$0$3.stringToU8a(arg));
  }
  function resultU8a() {
    const r0 = getInt32()[8 / 4 + 0];
    const r1 = getInt32()[8 / 4 + 1];
    const ret = getU8a(r0, r1).slice();

    wasm.__wbindgen_free(r0, r1 * 1);

    return ret;
  }
  function resultString() {
    return require$$0$3.u8aToString(resultU8a());
  }

  // Copyright 2017-2021 @polkadot/x-bundle authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const crypto$4 = {};

  const crypto$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': crypto$4
  });

  function getRandomValues(arr) {
    return crypto$4.getRandomValues(arr);
  }

  // Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors
  const DEFAULT_CRYPTO = {
    getRandomValues
  };
  const DEFAULT_SELF = {
    crypto: DEFAULT_CRYPTO
  };
  const heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
  let heapNext = heap.length;

  function getObject(idx) {
    return heap[idx];
  }

  function dropObject(idx) {
    if (idx < 36) {
      return;
    }

    heap[idx] = heapNext;
    heapNext = idx;
  }

  function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  }

  function addObject(obj) {
    if (heapNext === heap.length) {
      heap.push(heap.length + 1);
    }

    const idx = heapNext;
    heapNext = heap[idx];
    heap[idx] = obj;
    return idx;
  }

  function __wbindgen_is_undefined(idx) {
    return getObject(idx) === undefined;
  }
  function __wbg_self_1b7a39e3a92c949c() {
    return addObject(DEFAULT_SELF);
  }
  function __wbg_require_604837428532a733(ptr, len) {
    throw new Error(`Unable to require ${getString(ptr, len)}`);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars

  function __wbg_crypto_968f1772287e2df0(_idx) {
    return addObject(DEFAULT_CRYPTO);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars

  function __wbg_getRandomValues_a3d34b4fee3c2869(_idx) {
    return addObject(DEFAULT_CRYPTO.getRandomValues);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars

  function __wbg_getRandomValues_f5e14ab7ac8e995d(_arg0, ptr, len) {
    DEFAULT_CRYPTO.getRandomValues(getU8a(ptr, len));
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars

  function __wbg_randomFillSync_d5bd2d655fdf256a(_idx, _ptr, _len) {
    throw new Error('randomFillsync is not available'); // getObject(idx).randomFillSync(getU8a(ptr, len));
  }
  function __wbindgen_object_drop_ref(idx) {
    takeObject(idx);
  }
  function abort() {
    throw new Error('abort');
  }

  const imports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __wbindgen_is_undefined: __wbindgen_is_undefined,
    __wbg_self_1b7a39e3a92c949c: __wbg_self_1b7a39e3a92c949c,
    __wbg_require_604837428532a733: __wbg_require_604837428532a733,
    __wbg_crypto_968f1772287e2df0: __wbg_crypto_968f1772287e2df0,
    __wbg_getRandomValues_a3d34b4fee3c2869: __wbg_getRandomValues_a3d34b4fee3c2869,
    __wbg_getRandomValues_f5e14ab7ac8e995d: __wbg_getRandomValues_f5e14ab7ac8e995d,
    __wbg_randomFillSync_d5bd2d655fdf256a: __wbg_randomFillSync_d5bd2d655fdf256a,
    __wbindgen_object_drop_ref: __wbindgen_object_drop_ref,
    abort: abort
  });

  // Copyright 2019-2021 @polkadot/wasm-crypto authors & contributors
  const wasmPromise = initWasm(wasmBytes, asmJsInit, imports).catch(() => null);
  const bip39Generate = withWasm(wasm => words => {
    wasm.ext_bip39_generate(8, words);
    return resultString();
  });
  const bip39ToEntropy = withWasm(wasm => phrase => {
    const [ptr0, len0] = allocString(phrase);
    wasm.ext_bip39_to_entropy(8, ptr0, len0);
    return resultU8a();
  });
  const bip39ToMiniSecret = withWasm(wasm => (phrase, password) => {
    const [ptr0, len0] = allocString(phrase);
    const [ptr1, len1] = allocString(password);
    wasm.ext_bip39_to_mini_secret(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const bip39ToSeed = withWasm(wasm => (phrase, password) => {
    const [ptr0, len0] = allocString(phrase);
    const [ptr1, len1] = allocString(password);
    wasm.ext_bip39_to_seed(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const bip39Validate = withWasm(wasm => phrase => {
    const [ptr0, len0] = allocString(phrase);
    const ret = wasm.ext_bip39_validate(ptr0, len0);
    return ret !== 0;
  });
  const ed25519KeypairFromSeed = withWasm(wasm => seed => {
    const [ptr0, len0] = allocU8a(seed);
    wasm.ext_ed_from_seed(8, ptr0, len0);
    return resultU8a();
  });
  const ed25519Sign = withWasm(wasm => (pubkey, seckey, message) => {
    const [ptr0, len0] = allocU8a(pubkey);
    const [ptr1, len1] = allocU8a(seckey);
    const [ptr2, len2] = allocU8a(message);
    wasm.ext_ed_sign(8, ptr0, len0, ptr1, len1, ptr2, len2);
    return resultU8a();
  });
  const ed25519Verify = withWasm(wasm => (signature, message, pubkey) => {
    const [ptr0, len0] = allocU8a(signature);
    const [ptr1, len1] = allocU8a(message);
    const [ptr2, len2] = allocU8a(pubkey);
    const ret = wasm.ext_ed_verify(ptr0, len0, ptr1, len1, ptr2, len2);
    return ret !== 0;
  });
  const sr25519DeriveKeypairHard = withWasm(wasm => (pair, cc) => {
    const [ptr0, len0] = allocU8a(pair);
    const [ptr1, len1] = allocU8a(cc);
    wasm.ext_sr_derive_keypair_hard(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const sr25519DeriveKeypairSoft = withWasm(wasm => (pair, cc) => {
    const [ptr0, len0] = allocU8a(pair);
    const [ptr1, len1] = allocU8a(cc);
    wasm.ext_sr_derive_keypair_soft(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const sr25519DerivePublicSoft = withWasm(wasm => (pubkey, cc) => {
    const [ptr0, len0] = allocU8a(pubkey);
    const [ptr1, len1] = allocU8a(cc);
    wasm.ext_sr_derive_public_soft(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const sr25519KeypairFromSeed = withWasm(wasm => seed => {
    const [ptr0, len0] = allocU8a(seed);
    wasm.ext_sr_from_seed(8, ptr0, len0);
    return resultU8a();
  });
  const sr25519Sign = withWasm(wasm => (pubkey, secret, message) => {
    const [ptr0, len0] = allocU8a(pubkey);
    const [ptr1, len1] = allocU8a(secret);
    const [ptr2, len2] = allocU8a(message);
    wasm.ext_sr_sign(8, ptr0, len0, ptr1, len1, ptr2, len2);
    return resultU8a();
  });
  const sr25519Verify = withWasm(wasm => (signature, message, pubkey) => {
    const [ptr0, len0] = allocU8a(signature);
    const [ptr1, len1] = allocU8a(message);
    const [ptr2, len2] = allocU8a(pubkey);
    const ret = wasm.ext_sr_verify(ptr0, len0, ptr1, len1, ptr2, len2);
    return ret !== 0;
  });
  const sr25519Agree = withWasm(wasm => (pubkey, secret) => {
    const [ptr0, len0] = allocU8a(pubkey);
    const [ptr1, len1] = allocU8a(secret);
    wasm.ext_sr_agree(8, ptr0, len0, ptr1, len1);
    return resultU8a();
  });
  const vrfSign = withWasm(wasm => (secret, context, message, extra) => {
    const [ptr0, len0] = allocU8a(secret);
    const [ptr1, len1] = allocU8a(context);
    const [ptr2, len2] = allocU8a(message);
    const [ptr3, len3] = allocU8a(extra);
    wasm.ext_vrf_sign(8, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
    return resultU8a();
  });
  const vrfVerify = withWasm(wasm => (pubkey, context, message, extra, outAndProof) => {
    const [ptr0, len0] = allocU8a(pubkey);
    const [ptr1, len1] = allocU8a(context);
    const [ptr2, len2] = allocU8a(message);
    const [ptr3, len3] = allocU8a(extra);
    const [ptr4, len4] = allocU8a(outAndProof);
    const ret = wasm.ext_vrf_verify(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);
    return ret !== 0;
  });
  const blake2b$1 = withWasm(wasm => (data, key, size) => {
    const [ptr0, len0] = allocU8a(data);
    const [ptr1, len1] = allocU8a(key);
    wasm.ext_blake2b(8, ptr0, len0, ptr1, len1, size);
    return resultU8a();
  });
  const keccak256 = withWasm(wasm => data => {
    const [ptr0, len0] = allocU8a(data);
    wasm.ext_keccak256(8, ptr0, len0);
    return resultU8a();
  });
  const pbkdf2 = withWasm(wasm => (data, salt, rounds) => {
    const [ptr0, len0] = allocU8a(data);
    const [ptr1, len1] = allocU8a(salt);
    wasm.ext_pbkdf2(8, ptr0, len0, ptr1, len1, rounds);
    return resultU8a();
  });
  const scrypt$3 = withWasm(wasm => (password, salt, log2n, r, p) => {
    const [ptr0, len0] = allocU8a(password);
    const [ptr1, len1] = allocU8a(salt);
    wasm.ext_scrypt(8, ptr0, len0, ptr1, len1, log2n, r, p);
    return resultU8a();
  });
  const sha512 = withWasm(wasm => data => {
    const [ptr0, len0] = allocU8a(data);
    wasm.ext_sha512(8, ptr0, len0);
    return resultU8a();
  });
  const twox = withWasm(wasm => (data, rounds) => {
    const [ptr0, len0] = allocU8a(data);
    wasm.ext_twox(8, ptr0, len0, rounds);
    return resultU8a();
  });
  function isReady() {
    return !!getWasm();
  }
  function waitReady() {
    return wasmPromise.then(() => isReady());
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function cryptoIsReady() {
    return isReady();
  }
  function cryptoWaitReady() {
    return waitReady().then(() => true).catch(error => {
      console.error('Unable to initialize @polkadot/util-crypto', error);
      return false;
    });
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  cryptoWaitReady().catch(() => {// shouldn't happen, logged above
  });

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // Auto-generated by @polkadot/dev, do not edit
  const packageInfo = {
    name: '@polkadot/util-crypto',
    version: '7.6.1'
  };

  var safeBuffer = {exports: {}};

  var lookup$1 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init$2 () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup$1[i] = code[i];
      revLookup$1[code.charCodeAt(i)] = i;
    }

    revLookup$1['-'.charCodeAt(0)] = 62;
    revLookup$1['_'.charCodeAt(0)] = 63;
  }

  function toByteArray$1 (b64) {
    if (!inited) {
      init$2();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr$1(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 18) | (revLookup$1[b64.charCodeAt(i + 1)] << 12) | (revLookup$1[b64.charCodeAt(i + 2)] << 6) | revLookup$1[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 2) | (revLookup$1[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup$1[b64.charCodeAt(i)] << 10) | (revLookup$1[b64.charCodeAt(i + 1)] << 4) | (revLookup$1[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64$1 (num) {
    return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F]
  }

  function encodeChunk$1 (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64$1(tmp));
    }
    return output.join('')
  }

  function fromByteArray$1 (uint8) {
    if (!inited) {
      init$2();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk$1(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup$1[tmp >> 2];
      output += lookup$1[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup$1[tmp >> 10];
      output += lookup$1[(tmp >> 4) & 0x3F];
      output += lookup$1[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  const isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
    ? global.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength$1(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength$1 (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength$1;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray$1(buf)
    } else {
      return fromByteArray$1(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex$2(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex$2 (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray$1(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  // Copyright 2017-2021 @polkadot/x-bundle authors & contributors

  const buffer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Buffer,
    Buffer: Buffer
  });

  const require$$0$2 = /*@__PURE__*/getAugmentedNamespace(buffer);

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  (function (module, exports) {
  /* eslint-disable node/no-deprecated-api */
  var buffer = require$$0$2;
  var Buffer = buffer.Buffer;

  // alternative to using Object.keys for old browsers
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }

  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype);

  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  };
  }(safeBuffer, safeBuffer.exports));

  // base-x encoding / decoding
  // Copyright (c) 2018 base-x contributors
  // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
  // Distributed under the MIT software license, see the accompanying
  // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
  // @ts-ignore
  var _Buffer = safeBuffer.exports.Buffer;
  function base$1 (ALPHABET) {
    if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    function encode (source) {
      if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
      if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
      if (source.length === 0) { return '' }
          // Skip & count leading zeroes.
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
          // Allocate enough space in big-endian base58 representation.
      var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
      var b58 = new Uint8Array(size);
          // Process the bytes.
      while (pbegin !== pend) {
        var carry = source[pbegin];
              // Apply "b58 = b58 * 256 + ch".
        var i = 0;
        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
          carry += (256 * b58[it1]) >>> 0;
          b58[it1] = (carry % BASE) >>> 0;
          carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        pbegin++;
      }
          // Skip leading zeroes in base58 result.
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
          // Translate the result into a string.
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
      return str
    }
    function decodeUnsafe (source) {
      if (typeof source !== 'string') { throw new TypeError('Expected String') }
      if (source.length === 0) { return _Buffer.alloc(0) }
      var psz = 0;
          // Skip and count leading '1's.
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
          // Allocate enough space in big-endian base256 representation.
      var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
      var b256 = new Uint8Array(size);
          // Process the characters.
      while (source[psz]) {
              // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)];
              // Invalid character
        if (carry === 255) { return }
        var i = 0;
        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
          carry += (BASE * b256[it3]) >>> 0;
          b256[it3] = (carry % 256) >>> 0;
          carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        psz++;
      }
          // Skip leading zeroes in b256.
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0x00, 0, zeroes);
      var j = zeroes;
      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }
      return vch
    }
    function decode (string) {
      var buffer = decodeUnsafe(string);
      if (buffer) { return buffer }
      throw new Error('Non-base' + BASE + ' character')
    }
    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    }
  }
  var src = base$1;

  const baseX = src;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  const bs58 = baseX(BASE58_ALPHABET);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function createValidateFn({
    alphabet,
    ipfsChar,
    type
  }) {
    return (value, ipfsCompat) => {
      require$$0$3.assert(value && typeof value === 'string', () => `Expected non-null, non-empty ${type} string input`);
      require$$0$3.assert(!ipfsCompat || value[0] === ipfsChar, () => `Expected ${type} to start with '${ipfsChar}'`);

      for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {
        require$$0$3.assert(alphabet.includes(value[i]), () => `Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }

      return true;
    };
  }
  /**
   * @name base58Validate
   * @summary Validates a base58 value.
   * @description
   * Validates that the supplied value is valid base58
   */

  const base58Validate = createValidateFn({
    alphabet: BASE58_ALPHABET,
    ipfsChar: 'z',
    type: 'base58'
  });

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base58Decode
   * @summary Decodes a base58 value.
   * @description
   * From the provided input, decode the base58 and return the result as an `Uint8Array`.
   */

  function base58Decode(value, ipfsCompat) {
    base58Validate(value, ipfsCompat);
    return require$$0$3.bufferToU8a(bs58.decode(value.substr(ipfsCompat ? 1 : 0)));
  }

  const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';

  // For convenience, let people hash a string, not just a Uint8Array
  function normalizeInput (input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (input instanceof Buffer) {
      ret = new Uint8Array(input);
    } else if (typeof input === 'string') {
      ret = new Uint8Array(Buffer.from(input, 'utf8'));
    } else {
      throw new Error(ERROR_MSG_INPUT)
    }
    return ret
  }

  // Converts a Uint8Array to a hexadecimal string
  // For example, toHex([255, 0, 255]) returns "ff00ff"
  function toHex$1 (bytes) {
    return Array.prototype.map
      .call(bytes, function (n) {
        return (n < 16 ? '0' : '') + n.toString(16)
      })
      .join('')
  }

  // Converts any value in [0...2^32-1] to an 8-character hex string
  function uint32ToHex (val) {
    return (0x100000000 + val).toString(16).substring(1)
  }

  // For debugging: prints out hash state in the same format as the RFC
  // sample computation exactly, so that you can diff
  function debugPrint (label, arr, size) {
    let msg = '\n' + label + ' = ';
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += ' ';
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error('Invalid size ' + size)
      if (i % 6 === 4) {
        msg += '\n' + new Array(label.length + 4).join(' ');
      } else if (i < arr.length - 2) {
        msg += ' ';
      }
    }
    console.log(msg);
  }

  // For performance testing: generates N bytes of input, hashes M times
  // Measures and prints MB/second hash performance each time
  function testSpeed (hashFn, N, M) {
    let startMs = new Date().getTime();

    const input = new Uint8Array(N);
    for (let i = 0; i < N; i++) {
      input[i] = i % 256;
    }
    const genMs = new Date().getTime();
    console.log('Generated random input in ' + (genMs - startMs) + 'ms');
    startMs = genMs;

    for (let i = 0; i < M; i++) {
      const hashHex = hashFn(input);
      const hashMs = new Date().getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');
      console.log(
        Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
      );
    }
  }

  var util$2 = {
    normalizeInput: normalizeInput,
    toHex: toHex$1,
    debugPrint: debugPrint,
    testSpeed: testSpeed
  };

  // Blake2B in pure Javascript
  // Adapted from the reference implementation in RFC7693
  // Ported to Javascript by DC - https://github.com/dcposch

  const util$1 = util$2;

  // 64-bit unsigned addition
  // Sets v[a,a+1] += v[b,b+1]
  // v should be a Uint32Array
  function ADD64AA (v, a, b) {
    const o0 = v[a] + v[b];
    let o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
      o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
  }

  // 64-bit unsigned addition
  // Sets v[a,a+1] += b
  // b0 is the low 32 bits of b, b1 represents the high 32 bits
  function ADD64AC (v, a, b0, b1) {
    let o0 = v[a] + b0;
    if (b0 < 0) {
      o0 += 0x100000000;
    }
    let o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
      o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
  }

  // Little-endian byte access
  function B2B_GET32 (arr, i) {
    return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
  }

  // G Mixing function
  // The ROTRs are inlined for speed
  function B2B_G (a, b, c, d, ix, iy) {
    const x0 = m$1[ix];
    const x1 = m$1[ix + 1];
    const y0 = m$1[iy];
    const y1 = m$1[iy + 1];

    ADD64AA(v$1, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v$1, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    let xor0 = v$1[d] ^ v$1[a];
    let xor1 = v$1[d + 1] ^ v$1[a + 1];
    v$1[d] = xor1;
    v$1[d + 1] = xor0;

    ADD64AA(v$1, c, d);

    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v$1[b] ^ v$1[c];
    xor1 = v$1[b + 1] ^ v$1[c + 1];
    v$1[b] = (xor0 >>> 24) ^ (xor1 << 8);
    v$1[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);

    ADD64AA(v$1, a, b);
    ADD64AC(v$1, a, y0, y1);

    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v$1[d] ^ v$1[a];
    xor1 = v$1[d + 1] ^ v$1[a + 1];
    v$1[d] = (xor0 >>> 16) ^ (xor1 << 16);
    v$1[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);

    ADD64AA(v$1, c, d);

    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v$1[b] ^ v$1[c];
    xor1 = v$1[b + 1] ^ v$1[c + 1];
    v$1[b] = (xor1 >>> 31) ^ (xor0 << 1);
    v$1[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
  }

  // Initialization Vector
  const BLAKE2B_IV32 = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
  ]);

  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];

  // These are offsets into a uint64 buffer.
  // Multiply them all by 2 to make them offsets into a uint32 buffer,
  // because this is Javascript and we don't have uint64s
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function (x) {
      return x * 2
    })
  );

  // Compression function. 'last' flag indicates last block.
  // Note we're representing 16 uint64s as 32 uint32s
  const v$1 = new Uint32Array(32);
  const m$1 = new Uint32Array(32);
  function blake2bCompress (ctx, last) {
    let i = 0;

    // init work variables
    for (i = 0; i < 16; i++) {
      v$1[i] = ctx.h[i];
      v$1[i + 16] = BLAKE2B_IV32[i];
    }

    // low 64 bits of offset
    v$1[24] = v$1[24] ^ ctx.t;
    v$1[25] = v$1[25] ^ (ctx.t / 0x100000000);
    // high 64 bits not supported, offset may not be higher than 2**53-1

    // last block flag set ?
    if (last) {
      v$1[28] = ~v$1[28];
      v$1[29] = ~v$1[29];
    }

    // get little-endian words
    for (i = 0; i < 32; i++) {
      m$1[i] = B2B_GET32(ctx.b, 4 * i);
    }

    // twelve rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 64)
    for (i = 0; i < 12; i++) {
      // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    // util.debugPrint('   (i=12) v[16]', v, 64)

    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v$1[i] ^ v$1[i + 16];
    }
    // util.debugPrint('h[8]', ctx.h, 64)
  }

  // Creates a BLAKE2b hashing context
  // Requires an output length between 1 and 64 bytes
  // Takes an optional Uint8Array key
  function blake2bInit (outlen, key) {
    if (outlen === 0 || outlen > 64) {
      throw new Error('Illegal output length, expected 0 < length <= 64')
    }
    if (key && key.length > 64) {
      throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
    }

    // state, 'param block'
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0, // input count
      c: 0, // pointer within buffer
      outlen: outlen // output length in bytes
    };

    // initialize hash state
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i];
    }
    const keylen = key ? key.length : 0;
    ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

    // key the hash, if applicable
    if (key) {
      blake2bUpdate(ctx, key);
      // at the end
      ctx.c = 128;
    }

    return ctx
  }

  // Updates a BLAKE2b streaming hash
  // Requires hash context and Uint8Array (byte array)
  function blake2bUpdate (ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        // buffer full ?
        ctx.t += ctx.c; // add counters
        blake2bCompress(ctx, false); // compress (not last)
        ctx.c = 0; // counter to zero
      }
      ctx.b[ctx.c++] = input[i];
    }
  }

  // Completes a BLAKE2b streaming hash
  // Returns a Uint8Array containing the message digest
  function blake2bFinal (ctx) {
    ctx.t += ctx.c; // mark last block offset

    while (ctx.c < 128) {
      // fill up with zeros
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1

    // little endian convert and store
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
    }
    return out
  }

  // Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
  //
  // Returns a n-byte Uint8Array
  //
  // Parameters:
  // - input - the input bytes, as a string, Buffer or Uint8Array
  // - key - optional key Uint8Array, up to 64 bytes
  // - outlen - optional output length in bytes, default 64
  function blake2b (input, key, outlen) {
    // preprocess inputs
    outlen = outlen || 64;
    input = util$1.normalizeInput(input);

    // do the math
    const ctx = blake2bInit(outlen, key);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx)
  }

  // Computes the BLAKE2B hash of a string or byte array
  //
  // Returns an n-byte hash in hex, all lowercase
  //
  // Parameters:
  // - input - the input bytes, as a string, Buffer, or Uint8Array
  // - key - optional key Uint8Array, up to 64 bytes
  // - outlen - optional output length in bytes, default 64
  function blake2bHex (input, key, outlen) {
    const output = blake2b(input, key, outlen);
    return util$1.toHex(output)
  }

  var blake2b_1 = {
    blake2b: blake2b,
    blake2bHex: blake2bHex,
    blake2bInit: blake2bInit,
    blake2bUpdate: blake2bUpdate,
    blake2bFinal: blake2bFinal
  };

  // BLAKE2s hash function in pure Javascript
  // Adapted from the reference implementation in RFC7693
  // Ported to Javascript by DC - https://github.com/dcposch

  const util = util$2;

  // Little-endian byte access.
  // Expects a Uint8Array and an index
  // Returns the little-endian uint32 at v[i..i+3]
  function B2S_GET32 (v, i) {
    return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
  }

  // Mixing function G.
  function B2S_G (a, b, c, d, x, y) {
    v[a] = v[a] + v[b] + x;
    v[d] = ROTR32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = ROTR32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 7);
  }

  // 32-bit right rotation
  // x should be a uint32
  // y must be between 1 and 31, inclusive
  function ROTR32 (x, y) {
    return (x >>> y) ^ (x << (32 - y))
  }

  // Initialization Vector.
  const BLAKE2S_IV = new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
  ]);

  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);

  // Compression function. "last" flag indicates last block
  const v = new Uint32Array(16);
  const m = new Uint32Array(16);
  function blake2sCompress (ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      // init work variables
      v[i] = ctx.h[i];
      v[i + 8] = BLAKE2S_IV[i];
    }

    v[12] ^= ctx.t; // low 32 bits of offset
    v[13] ^= ctx.t / 0x100000000; // high 32 bits
    if (last) {
      // last block flag set ?
      v[14] = ~v[14];
    }

    for (i = 0; i < 16; i++) {
      // get little-endian words
      m[i] = B2S_GET32(ctx.b, 4 * i);
    }

    // ten rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 32)
    for (i = 0; i < 10; i++) {
      // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
      B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    // util.debugPrint('   (i=10) v[16]', v, 32)

    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v[i] ^ v[i + 8];
    }
    // util.debugPrint('h[8]', ctx.h, 32)
  }

  // Creates a BLAKE2s hashing context
  // Requires an output length between 1 and 32 bytes
  // Takes an optional Uint8Array key
  function blake2sInit (outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error('Incorrect output length, should be in [1, 32]')
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
      throw new Error('Incorrect key length, should be in [1, 32]')
    }

    const ctx = {
      h: new Uint32Array(BLAKE2S_IV), // hash state
      b: new Uint8Array(64), // input block
      c: 0, // pointer within block
      t: 0, // input count
      outlen: outlen // output length in bytes
    };
    ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

    if (keylen > 0) {
      blake2sUpdate(ctx, key);
      ctx.c = 64; // at the end
    }

    return ctx
  }

  // Updates a BLAKE2s streaming hash
  // Requires hash context and Uint8Array (byte array)
  function blake2sUpdate (ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        // buffer full ?
        ctx.t += ctx.c; // add counters
        blake2sCompress(ctx, false); // compress (not last)
        ctx.c = 0; // counter to zero
      }
      ctx.b[ctx.c++] = input[i];
    }
  }

  // Completes a BLAKE2s streaming hash
  // Returns a Uint8Array containing the message digest
  function blake2sFinal (ctx) {
    ctx.t += ctx.c; // mark last block offset
    while (ctx.c < 64) {
      // fill up with zeros
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true); // final block flag = 1

    // little endian convert and store
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff;
    }
    return out
  }

  // Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
  //
  // Returns a n-byte Uint8Array
  //
  // Parameters:
  // - input - the input bytes, as a string, Buffer, or Uint8Array
  // - key - optional key Uint8Array, up to 32 bytes
  // - outlen - optional output length in bytes, default 64
  function blake2s (input, key, outlen) {
    // preprocess inputs
    outlen = outlen || 32;
    input = util.normalizeInput(input);

    // do the math
    const ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx)
  }

  // Computes the BLAKE2S hash of a string or byte array
  //
  // Returns an n-byte hash in hex, all lowercase
  //
  // Parameters:
  // - input - the input bytes, as a string, Buffer, or Uint8Array
  // - key - optional key Uint8Array, up to 32 bytes
  // - outlen - optional output length in bytes, default 64
  function blake2sHex (input, key, outlen) {
    const output = blake2s(input, key, outlen);
    return util.toHex(output)
  }

  var blake2s_1 = {
    blake2s: blake2s,
    blake2sHex: blake2sHex,
    blake2sInit: blake2sInit,
    blake2sUpdate: blake2sUpdate,
    blake2sFinal: blake2sFinal
  };

  const b2b = blake2b_1;
  const b2s = blake2s_1;

  var blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };

  const js$1 = blakejs;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name blake2AsU8a
   * @summary Creates a blake2b u8a from the input.
   * @description
   * From a `Uint8Array` input, create the blake2b and return the result as a u8a with the specified `bitLength`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { blake2AsU8a } from '@polkadot/util-crypto';
   *
   * blake2AsU8a('abc'); // => [0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d]
   * ```
   */

  function blake2AsU8a(data, bitLength = 256, key, onlyJs = false) {
    const byteLength = Math.ceil(bitLength / 8);
    return isReady() && !onlyJs ? blake2b$1(require$$0$3.u8aToU8a(data), require$$0$3.u8aToU8a(key), byteLength) : js$1.blake2b(require$$0$3.u8aToU8a(data), key || undefined, byteLength);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const SS58_PREFIX = require$$0$3.stringToU8a('SS58PRE');
  function sshash(key) {
    return blake2AsU8a(require$$0$3.u8aConcat(SS58_PREFIX, key), 512);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function checkAddressChecksum(decoded) {
    const ss58Length = decoded[0] & 0b01000000 ? 2 : 1;
    const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 0b00111111) << 2 | decoded[1] >> 6 | (decoded[1] & 0b00111111) << 8; // 32/33 bytes public + 2 bytes checksum + prefix

    const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
    const length = decoded.length - (isPublicKey ? 2 : 1); // calculate the hash and do the checksum byte checks

    const hash = sshash(decoded.subarray(0, length));
    const isValid = (decoded[0] & 0b10000000) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
    return [isValid, length, ss58Length, ss58Decoded];
  }

  // Copyright 2017-2021 @polkadot/networks authors & contributors
  // are provided, it needs to be in reverse order, i.e. most-recent first, oldest
  // last. This make lookups for the current a simple genesisHash[0]
  // (See Kusama as an example)

  const knownGenesis = {
    bifrost: ['0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed'],
    centrifuge: ['0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5'],
    'dock-mainnet': ['0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9'],
    edgeware: ['0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b'],
    equilibrium: ['0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925'],
    hydradx: ['0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc', // Snakenet Gen3-1
    '0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9', // Snakenet Gen3
    '0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047', // Snakenet Gen2
    '0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2' // Snakenet Gen1
    ],
    karura: ['0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b'],
    kulupu: ['0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba'],
    kusama: ['0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe', // Kusama CC3,
    '0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636', // Kusama CC2
    '0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf' // Kusama CC1
    ],
    'nodle-chain': ['0xa3d114c2b8d0627c1aa9b134eafcf7d05ca561fdc19fb388bb9457f81809fb23'],
    plasm: ['0x3e86364d4b4894021cb2a0390bcf2feb5517d5292f2de2bb9404227e908b0b8b'],
    polkadot: ['0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3'],
    polymesh: ['0x9deeb940c92ae02111c3bd5baca89970384f4c9849f02a1b2e53e66414d30f9f'],
    stafi: ['0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80'],
    statemine: ['0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a'],
    subsocial: ['0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8']
  }; // these are icon overrides

  const knownIcon = {
    centrifuge: 'polkadot',
    kusama: 'polkadot',
    polkadot: 'polkadot',
    statemine: 'polkadot',
    statemint: 'polkadot',
    westmint: 'polkadot'
  }; // These match up with the keys of the ledgerApps object in the @polkadot/hw-ledger/defaults.ts
  // and maps to the known slip44 (minus the `0x8` hard derivation flag)
  // NOTE: Any network here needs to have a genesisHash attached in the config above

  const knownLedger = {
    centrifuge: 0x000002eb,
    'dock-mainnet': 0x00000252,
    edgeware: 0x0000020b,
    equilibrium: 0x05f5e0fd,
    kusama: 0x000001b2,
    'nodle-chain': 0x000003eb,
    polkadot: 0x00000162,
    polymesh: 0x00000253,
    statemine: 0x000001b2 // common-good on Kusama, shares derivation

  }; // testnets should not allow selection

  const knownTestnet = {
    '': true,
    // this is the default non-network entry
    'cess-testnet': true,
    'dock-testnet': true,
    jupiter: true,
    'mathchain-testnet': true,
    'zero-alphaville': true
  };

  // Copyright 2017-2021 @polkadot/networks authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  //
  // Auto-generated by yarn networks:sync (via scripts/fromSubstrate.mjs)
  //
  // This file should never be edited manually. Rather the process is as follow -
  //
  //   - make a PR to the upstream registry found at https://github.com/paritytech/ss58-registry/
  //   - ensure the PR gets merged
  //   - yarn networks:sync in this repo to sync
  //
  // Any manual changes to this file will make CI cron checks fail and will be
  // lost when the registry is updated alongside the above sync.
  //
  const knownSubstrate = [{
    decimals: [10],
    displayName: 'Polkadot Relay Chain',
    network: 'polkadot',
    prefix: 0,
    standardAccount: '*25519',
    symbols: ['DOT'],
    website: 'https://polkadot.network'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.',
    network: 'BareSr25519',
    prefix: 1,
    standardAccount: 'Sr25519',
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Kusama Relay Chain',
    network: 'kusama',
    prefix: 2,
    standardAccount: '*25519',
    symbols: ['KSM'],
    website: 'https://kusama.network'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit Ed25519 public key.',
    network: 'BareEd25519',
    prefix: 3,
    standardAccount: 'Ed25519',
    symbols: null,
    website: null
  }, {
    decimals: null,
    displayName: 'Katal Chain',
    network: 'katalchain',
    prefix: 4,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [15],
    displayName: 'Plasm Network',
    network: 'plasm',
    prefix: 5,
    standardAccount: '*25519',
    symbols: ['PLM'],
    website: 'https://plasmnet.io'
  }, {
    decimals: [12],
    displayName: 'Bifrost',
    network: 'bifrost',
    prefix: 6,
    standardAccount: '*25519',
    symbols: ['BNC'],
    website: 'https://bifrost.finance/'
  }, {
    decimals: [18],
    displayName: 'Edgeware',
    network: 'edgeware',
    prefix: 7,
    standardAccount: '*25519',
    symbols: ['EDG'],
    website: 'https://edgewa.re'
  }, {
    decimals: [12],
    displayName: 'Karura',
    network: 'karura',
    prefix: 8,
    standardAccount: '*25519',
    symbols: ['KAR'],
    website: 'https://karura.network/'
  }, {
    decimals: [18],
    displayName: 'Laminar Reynolds Canary',
    network: 'reynolds',
    prefix: 9,
    standardAccount: '*25519',
    symbols: ['REY'],
    website: 'http://laminar.network/'
  }, {
    decimals: [12],
    displayName: 'Acala',
    network: 'acala',
    prefix: 10,
    standardAccount: '*25519',
    symbols: ['ACA'],
    website: 'https://acala.network/'
  }, {
    decimals: [18],
    displayName: 'Laminar',
    network: 'laminar',
    prefix: 11,
    standardAccount: '*25519',
    symbols: ['LAMI'],
    website: 'http://laminar.network/'
  }, {
    decimals: [6],
    displayName: 'Polymesh',
    network: 'polymesh',
    prefix: 12,
    standardAccount: '*25519',
    symbols: ['POLYX'],
    website: 'https://polymath.network/'
  }, {
    decimals: [12],
    displayName: 'Integritee',
    network: 'integritee',
    prefix: 13,
    standardAccount: '*25519',
    symbols: ['TEER'],
    website: 'https://integritee.network'
  }, {
    decimals: [0],
    displayName: 'Totem',
    network: 'totem',
    prefix: 14,
    standardAccount: '*25519',
    symbols: ['XTX'],
    website: 'https://totemaccounting.com'
  }, {
    decimals: [12],
    displayName: 'Synesthesia',
    network: 'synesthesia',
    prefix: 15,
    standardAccount: '*25519',
    symbols: ['SYN'],
    website: 'https://synesthesia.network/'
  }, {
    decimals: [12],
    displayName: 'Kulupu',
    network: 'kulupu',
    prefix: 16,
    standardAccount: '*25519',
    symbols: ['KLP'],
    website: 'https://kulupu.network/'
  }, {
    decimals: null,
    displayName: 'Dark Mainnet',
    network: 'dark',
    prefix: 17,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [9, 9],
    displayName: 'Darwinia Network',
    network: 'darwinia',
    prefix: 18,
    standardAccount: '*25519',
    symbols: ['RING', 'KTON'],
    website: 'https://darwinia.network/'
  }, {
    decimals: [12],
    displayName: 'GeekCash',
    network: 'geek',
    prefix: 19,
    standardAccount: '*25519',
    symbols: ['GEEK'],
    website: 'https://geekcash.org'
  }, {
    decimals: [12],
    displayName: 'Stafi',
    network: 'stafi',
    prefix: 20,
    standardAccount: '*25519',
    symbols: ['FIS'],
    website: 'https://stafi.io'
  }, {
    decimals: [6],
    displayName: 'Dock Testnet',
    network: 'dock-testnet',
    prefix: 21,
    standardAccount: '*25519',
    symbols: ['DCK'],
    website: 'https://dock.io'
  }, {
    decimals: [6],
    displayName: 'Dock Mainnet',
    network: 'dock-mainnet',
    prefix: 22,
    standardAccount: '*25519',
    symbols: ['DCK'],
    website: 'https://dock.io'
  }, {
    decimals: null,
    displayName: 'ShiftNrg',
    network: 'shift',
    prefix: 23,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [18],
    displayName: 'ZERO',
    network: 'zero',
    prefix: 24,
    standardAccount: '*25519',
    symbols: ['PLAY'],
    website: 'https://zero.io'
  }, {
    decimals: [18],
    displayName: 'ZERO Alphaville',
    network: 'zero-alphaville',
    prefix: 25,
    standardAccount: '*25519',
    symbols: ['PLAY'],
    website: 'https://zero.io'
  }, {
    decimals: [10],
    displayName: 'Jupiter',
    network: 'jupiter',
    prefix: 26,
    standardAccount: '*25519',
    symbols: ['jDOT'],
    website: 'https://jupiter.patract.io'
  }, {
    decimals: null,
    displayName: 'Subsocial',
    network: 'subsocial',
    prefix: 28,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [18],
    displayName: 'Dhiway CORD Network',
    network: 'cord',
    prefix: 29,
    standardAccount: '*25519',
    symbols: ['DCU'],
    website: 'https://dhiway.com/'
  }, {
    decimals: [12],
    displayName: 'Phala Network',
    network: 'phala',
    prefix: 30,
    standardAccount: '*25519',
    symbols: ['PHA'],
    website: 'https://phala.network'
  }, {
    decimals: [12],
    displayName: 'Litentry Network',
    network: 'litentry',
    prefix: 31,
    standardAccount: '*25519',
    symbols: ['LIT'],
    website: 'https://litentry.com/'
  }, {
    decimals: [9],
    displayName: 'Robonomics',
    network: 'robonomics',
    prefix: 32,
    standardAccount: '*25519',
    symbols: ['XRT'],
    website: 'https://robonomics.network'
  }, {
    decimals: null,
    displayName: 'DataHighway',
    network: 'datahighway',
    prefix: 33,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Ares Protocol',
    network: 'ares',
    prefix: 34,
    standardAccount: '*25519',
    symbols: ['ARES'],
    website: 'https://www.aresprotocol.com/'
  }, {
    decimals: [15],
    displayName: 'Valiu Liquidity Network',
    network: 'vln',
    prefix: 35,
    standardAccount: '*25519',
    symbols: ['USDv'],
    website: 'https://valiu.com/'
  }, {
    decimals: [18],
    displayName: 'Centrifuge Chain',
    network: 'centrifuge',
    prefix: 36,
    standardAccount: '*25519',
    symbols: ['CFG'],
    website: 'https://centrifuge.io/'
  }, {
    decimals: [18],
    displayName: 'Nodle Chain',
    network: 'nodle',
    prefix: 37,
    standardAccount: '*25519',
    symbols: ['NODL'],
    website: 'https://nodle.io/'
  }, {
    decimals: [18],
    displayName: 'KILT Chain',
    network: 'kilt',
    prefix: 38,
    standardAccount: '*25519',
    symbols: ['KILT'],
    website: 'https://kilt.io/'
  }, {
    decimals: [18],
    displayName: 'MathChain mainnet',
    network: 'mathchain',
    prefix: 39,
    standardAccount: '*25519',
    symbols: ['MATH'],
    website: 'https://mathwallet.org'
  }, {
    decimals: [18],
    displayName: 'MathChain testnet',
    network: 'mathchain-testnet',
    prefix: 40,
    standardAccount: '*25519',
    symbols: ['MATH'],
    website: 'https://mathwallet.org'
  }, {
    decimals: null,
    displayName: 'Polimec Chain',
    network: 'poli',
    prefix: 41,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://polimec.io/'
  }, {
    decimals: null,
    displayName: 'Substrate',
    network: 'substrate',
    prefix: 42,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://substrate.io/'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit ECDSA SECP-256k1 public key.',
    network: 'BareSecp256k1',
    prefix: 43,
    standardAccount: 'secp256k1',
    symbols: null,
    website: null
  }, {
    decimals: [8],
    displayName: 'ChainX',
    network: 'chainx',
    prefix: 44,
    standardAccount: '*25519',
    symbols: ['PCX'],
    website: 'https://chainx.org/'
  }, {
    decimals: [12, 12],
    displayName: 'UniArts Network',
    network: 'uniarts',
    prefix: 45,
    standardAccount: '*25519',
    symbols: ['UART', 'UINK'],
    website: 'https://uniarts.me'
  }, {
    decimals: null,
    displayName: 'This prefix is reserved.',
    network: 'reserved46',
    prefix: 46,
    standardAccount: null,
    symbols: null,
    website: null
  }, {
    decimals: null,
    displayName: 'This prefix is reserved.',
    network: 'reserved47',
    prefix: 47,
    standardAccount: null,
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Neatcoin Mainnet',
    network: 'neatcoin',
    prefix: 48,
    standardAccount: '*25519',
    symbols: ['NEAT'],
    website: 'https://neatcoin.org'
  }, {
    decimals: [12],
    displayName: 'Picasso',
    network: 'picasso',
    prefix: 49,
    standardAccount: '*25519',
    symbols: ['PICA'],
    website: 'https://picasso.composable.finance'
  }, {
    decimals: [12],
    displayName: 'Composable',
    network: 'composable',
    prefix: 50,
    standardAccount: '*25519',
    symbols: ['LAYR'],
    website: 'https://composable.finance'
  }, {
    decimals: [12],
    displayName: 'HydraDX',
    network: 'hydradx',
    prefix: 63,
    standardAccount: '*25519',
    symbols: ['HDX'],
    website: 'https://hydradx.io'
  }, {
    decimals: [18],
    displayName: 'AvN Mainnet',
    network: 'aventus',
    prefix: 65,
    standardAccount: '*25519',
    symbols: ['AVT'],
    website: 'https://aventus.io'
  }, {
    decimals: [12],
    displayName: 'Crust Network',
    network: 'crust',
    prefix: 66,
    standardAccount: '*25519',
    symbols: ['CRU'],
    website: 'https://crust.network'
  }, {
    decimals: [0, 9, 9, 9, 9, 9, 9, 9],
    displayName: 'Equilibrium Network',
    network: 'equilibrium',
    prefix: 67,
    standardAccount: '*25519',
    symbols: ['Unknown', 'USD', 'EQ', 'ETH', 'BTC', 'EOS', 'DOT', 'CRV'],
    website: 'https://equilibrium.io'
  }, {
    decimals: [18],
    displayName: 'SORA Network',
    network: 'sora',
    prefix: 69,
    standardAccount: '*25519',
    symbols: ['XOR'],
    website: 'https://sora.org'
  }, {
    decimals: [10],
    displayName: 'Zeitgeist',
    network: 'zeitgeist',
    prefix: 73,
    standardAccount: '*25519',
    symbols: ['ZTG'],
    website: 'https://zeitgeist.pm'
  }, {
    decimals: [12],
    displayName: 'Manta network',
    network: 'manta',
    prefix: 77,
    standardAccount: '*25519',
    symbols: ['MA'],
    website: 'https://manta.network'
  }, {
    decimals: [12],
    displayName: 'Calamari: Manta Canary Network',
    network: 'calamari',
    prefix: 78,
    standardAccount: '*25519',
    symbols: ['KMA'],
    website: 'https://manta.network'
  }, {
    decimals: [12],
    displayName: 'Polkadex Mainnet',
    network: 'polkadex',
    prefix: 88,
    standardAccount: '*25519',
    symbols: ['PDEX'],
    website: 'https://polkadex.trade'
  }, {
    decimals: [18],
    displayName: 'PolkaSmith Canary Network',
    network: 'polkasmith',
    prefix: 98,
    standardAccount: '*25519',
    symbols: ['PKS'],
    website: 'https://polkafoundry.com'
  }, {
    decimals: [18],
    displayName: 'PolkaFoundry Network',
    network: 'polkafoundry',
    prefix: 99,
    standardAccount: '*25519',
    symbols: ['PKF'],
    website: 'https://polkafoundry.com'
  }, {
    decimals: [18],
    displayName: 'OriginTrail Parachain',
    network: 'origintrail-parachain',
    prefix: 101,
    standardAccount: 'secp256k1',
    symbols: ['TRAC'],
    website: 'https://origintrail.io'
  }, {
    decimals: [12],
    displayName: 'Heiko',
    network: 'heiko',
    prefix: 110,
    standardAccount: '*25519',
    symbols: ['HKO'],
    website: 'https://parallel.fi/'
  }, {
    decimals: null,
    displayName: 'Integritee Incognito',
    network: 'integritee-incognito',
    prefix: 113,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://integritee.network'
  }, {
    decimals: [18],
    displayName: 'Clover Finance',
    network: 'clover',
    prefix: 128,
    standardAccount: '*25519',
    symbols: ['CLV'],
    website: 'https://clover.finance'
  }, {
    decimals: [18],
    displayName: 'Altair',
    network: 'altair',
    prefix: 136,
    standardAccount: '*25519',
    symbols: ['AIR'],
    website: 'https://centrifuge.io/'
  }, {
    decimals: [12],
    displayName: 'Parallel',
    network: 'parallel',
    prefix: 172,
    standardAccount: '*25519',
    symbols: ['PARA'],
    website: 'https://parallel.fi/'
  }, {
    decimals: [18],
    displayName: 'Social Network',
    network: 'social-network',
    prefix: 252,
    standardAccount: '*25519',
    symbols: ['NET'],
    website: 'https://social.network'
  }, {
    decimals: [15],
    displayName: 'QUARTZ by UNIQUE',
    network: 'quartz_mainnet',
    prefix: 255,
    standardAccount: '*25519',
    symbols: ['QTZ'],
    website: 'https://unique.network'
  }, {
    decimals: [18],
    displayName: 'Moonbeam',
    network: 'moonbeam',
    prefix: 1284,
    standardAccount: 'secp256k1',
    symbols: ['GLMR'],
    website: 'https://moonbeam.network'
  }, {
    decimals: [18],
    displayName: 'Moonriver',
    network: 'moonriver',
    prefix: 1285,
    standardAccount: 'secp256k1',
    symbols: ['MOVR'],
    website: 'https://moonbeam.network'
  }, {
    decimals: [12],
    displayName: 'Basilisk',
    network: 'basilisk',
    prefix: 10041,
    standardAccount: '*25519',
    symbols: ['BSX'],
    website: 'https://bsx.fi'
  }, {
    decimals: [12],
    displayName: 'CESS Testnet',
    network: 'cess-testnet',
    prefix: 10042,
    standardAccount: '*25519',
    symbols: ['TCESS'],
    website: 'https://cess.cloud'
  }, {
    decimals: [12],
    displayName: 'CESS',
    network: 'cess',
    prefix: 10043,
    standardAccount: '*25519',
    symbols: ['CESS'],
    website: 'https://cess.cloud'
  }, {
    decimals: [18],
    displayName: 'Automata ContextFree',
    network: 'contextfree',
    prefix: 11820,
    standardAccount: '*25519',
    symbols: ['CTX'],
    website: 'https://ata.network'
  }];

  // Copyright 2017-2021 @polkadot/networks authors & contributors

  const UNSORTED = [0, 2, 42];
  const allNetworks = knownSubstrate.map(o => {
    const network = o.network || '';
    const n = o;
    n.slip44 = knownLedger[network];
    n.hasLedgerSupport = !!n.slip44;
    n.genesisHash = knownGenesis[network] || [];
    n.icon = knownIcon[network] || 'substrate';
    n.isIgnored = !!knownTestnet[network] || !(o.standardAccount && o.decimals && o.symbols) && o.prefix !== 42;
    return n;
  }); // The list of available/claimed prefixes
  //   - no testnets
  //   - we only include those where we have a standardAccount
  //   - sort by name, however we keep 0, 2, 42 first in the list

  const availableNetworks = allNetworks.filter(n => !n.isIgnored && !!n.network).sort((a, b) => UNSORTED.includes(a.prefix) === UNSORTED.includes(b.prefix) ? 0 : UNSORTED.includes(a.prefix) ? -1 : UNSORTED.includes(b.prefix) ? 1 : a.displayName.localeCompare(b.displayName)); // A filtered list of those chains we have details about (genesisHashes)

  const selectableNetworks = availableNetworks.filter(n => n.genesisHash.length || n.prefix === 42);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const defaults = {
    allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
    // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
    allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
    allowedPrefix: availableNetworks.map(({
      prefix
    }) => prefix),
    prefix: 42
  };

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
    require$$0$3.assert(encoded, 'Invalid empty address passed');

    if (require$$0$3.isU8a(encoded) || require$$0$3.isHex(encoded)) {
      return require$$0$3.u8aToU8a(encoded);
    }

    try {
      const decoded = base58Decode(encoded);
      require$$0$3.assert(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');
      const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
      require$$0$3.assert(ignoreChecksum || isValid, 'Invalid decoded address checksum');
      require$$0$3.assert([-1, ss58Decoded].includes(ss58Format), () => `Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
      return decoded.slice(ss58Length, endPos);
    } catch (error) {
      throw new Error(`Decoding ${encoded}: ${error.message}`);
    }
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name addressToEvm
   * @summary Converts an SS58 address to its corresponding EVM address.
   */

  function addressToEvm(address, ignoreChecksum) {
    const decoded = decodeAddress(address, ignoreChecksum);
    return decoded.subarray(0, 20);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name checkAddress
   * @summary Validates an ss58 address.
   * @description
   * From the provided input, validate that the address is a valid input.
   */

  function checkAddress(address, prefix) {
    let decoded;

    try {
      decoded = base58Decode(address);
    } catch (error) {
      return [false, error.message];
    }

    const [isValid,,, ss58Decoded] = checkAddressChecksum(decoded);

    if (ss58Decoded !== prefix) {
      return [false, `Prefix mismatch, expected ${prefix}, found ${ss58Decoded}`];
    } else if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      return [false, 'Invalid decoded address length'];
    }

    return [isValid, isValid ? null : 'Invalid decoded address checksum'];
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const PREFIX$1 = require$$0$3.stringToU8a('modlpy/utilisuba');
  function createKeyMulti(who, threshold) {
    return blake2AsU8a(require$$0$3.u8aConcat(PREFIX$1, require$$0$3.compactToU8a(who.length), ...require$$0$3.u8aSorted(who.map(who => decodeAddress(who))), require$$0$3.bnToU8a(threshold, {
      bitLength: 16,
      isLe: true
    })));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const PREFIX = require$$0$3.stringToU8a('modlpy/utilisuba');
  function createKeyDerived(who, index) {
    return blake2AsU8a(require$$0$3.u8aConcat(PREFIX, decodeAddress(who), require$$0$3.bnToU8a(index, {
      bitLength: 16,
      isLe: true
    })));
  }

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  var id = 0;
  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  const RE_NUMBER = /^\d+$/;
  const JUNCTION_ID_LEN = 32;
  const BN_OPTIONS = {
    bitLength: 256,
    isLe: true
  };

  var _chainCode = /*#__PURE__*/_classPrivateFieldKey("chainCode");

  var _isHard = /*#__PURE__*/_classPrivateFieldKey("isHard");

  class DeriveJunction {
    constructor() {
      Object.defineProperty(this, _chainCode, {
        writable: true,
        value: new Uint8Array(32)
      });
      Object.defineProperty(this, _isHard, {
        writable: true,
        value: false
      });
    }

    static from(value) {
      const result = new DeriveJunction();
      const [code, isHard] = value.startsWith('/') ? [value.substr(1), true] : [value, false];
      result.soft(RE_NUMBER.test(code) ? new require$$0$3.BN(code, 10) : code);
      return isHard ? result.harden() : result;
    }

    get chainCode() {
      return _classPrivateFieldBase(this, _chainCode)[_chainCode];
    }

    get isHard() {
      return _classPrivateFieldBase(this, _isHard)[_isHard];
    }

    get isSoft() {
      return !_classPrivateFieldBase(this, _isHard)[_isHard];
    }

    hard(value) {
      return this.soft(value).harden();
    }

    harden() {
      _classPrivateFieldBase(this, _isHard)[_isHard] = true;
      return this;
    }

    soft(value) {
      if (require$$0$3.isNumber(value) || require$$0$3.isBn(value) || require$$0$3.isBigInt(value)) {
        return this.soft(require$$0$3.bnToU8a(value, BN_OPTIONS));
      } else if (require$$0$3.isHex(value)) {
        return this.soft(require$$0$3.hexToU8a(value));
      } else if (require$$0$3.isString(value)) {
        return this.soft(require$$0$3.compactAddLength(require$$0$3.stringToU8a(value)));
      } else if (value.length > JUNCTION_ID_LEN) {
        return this.soft(blake2AsU8a(value));
      }

      _classPrivateFieldBase(this, _chainCode)[_chainCode].fill(0);

      _classPrivateFieldBase(this, _chainCode)[_chainCode].set(value, 0);

      return this;
    }

    soften() {
      _classPrivateFieldBase(this, _isHard)[_isHard] = false;
      return this;
    }

  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const RE_JUNCTION = /\/(\/?)([^/]+)/g;

  /**
   * @description Extract derivation junctions from the supplied path
   */
  function keyExtractPath(derivePath) {
    const parts = derivePath.match(RE_JUNCTION);
    const path = [];
    let constructed = '';

    if (parts) {
      constructed = parts.join('');
      parts.forEach(value => {
        path.push(DeriveJunction.from(value.substr(1)));
      });
    }

    require$$0$3.assert(constructed === derivePath, () => `Re-constructed path "${constructed}" does not match input`);
    return {
      parts,
      path
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const RE_CAPTURE = /^(\w+( \w+)*)((\/\/?[^/]+)*)(\/\/\/(.*))?$/;
  /**
   * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed).
   */

  function keyExtractSuri(suri) {
    // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
    const matches = suri.match(RE_CAPTURE);
    require$$0$3.assert(!require$$0$3.isNull(matches), 'Unable to match provided value to a secret URI');
    const [, phrase,, derivePath,,, password] = matches;
    const {
      path
    } = keyExtractPath(derivePath);
    return {
      derivePath,
      password,
      path,
      phrase
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const HDKD$1 = require$$0$3.compactAddLength(require$$0$3.stringToU8a('Secp256k1HDKD'));
  function secp256k1DeriveHard(seed, chainCode) {
    // NOTE This is specific to the Substrate HDD derivation, so always use the blake2 hasher
    return blake2AsU8a(require$$0$3.u8aConcat(HDKD$1, seed, chainCode), 256);
  }

  var elliptic = {};

  var name = "elliptic";
  var version = "6.5.4";
  var description = "EC cryptography";
  var main = "lib/elliptic.js";
  var files = [
  	"lib"
  ];
  var scripts = {
  	lint: "eslint lib test",
  	"lint:fix": "npm run lint -- --fix",
  	unit: "istanbul test _mocha --reporter=spec test/index.js",
  	test: "npm run lint && npm run unit",
  	version: "grunt dist && git add dist/"
  };
  var repository = {
  	type: "git",
  	url: "git@github.com:indutny/elliptic"
  };
  var keywords = [
  	"EC",
  	"Elliptic",
  	"curve",
  	"Cryptography"
  ];
  var author = "Fedor Indutny <fedor@indutny.com>";
  var license = "MIT";
  var bugs = {
  	url: "https://github.com/indutny/elliptic/issues"
  };
  var homepage = "https://github.com/indutny/elliptic";
  var devDependencies = {
  	brfs: "^2.0.2",
  	coveralls: "^3.1.0",
  	eslint: "^7.6.0",
  	grunt: "^1.2.1",
  	"grunt-browserify": "^5.3.0",
  	"grunt-cli": "^1.3.2",
  	"grunt-contrib-connect": "^3.0.0",
  	"grunt-contrib-copy": "^1.0.0",
  	"grunt-contrib-uglify": "^5.0.0",
  	"grunt-mocha-istanbul": "^5.0.2",
  	"grunt-saucelabs": "^9.0.1",
  	istanbul: "^0.4.5",
  	mocha: "^8.0.1"
  };
  var dependencies = {
  	"bn.js": "^4.11.9",
  	brorand: "^1.1.0",
  	"hash.js": "^1.0.0",
  	"hmac-drbg": "^1.0.1",
  	inherits: "^2.0.4",
  	"minimalistic-assert": "^1.0.1",
  	"minimalistic-crypto-utils": "^1.0.1"
  };
  const require$$0$1 = {
  	name: name,
  	version: version,
  	description: description,
  	main: main,
  	files: files,
  	scripts: scripts,
  	repository: repository,
  	keywords: keywords,
  	author: author,
  	license: license,
  	bugs: bugs,
  	homepage: homepage,
  	devDependencies: devDependencies,
  	dependencies: dependencies
  };

  var utils$n = {};

  // Copyright 2017-2021 @polkadot/x-bundle authors & contributors
  // SPDX-License-Identifier: Apache-2.0

  const { BN: BN$8 } = require$$0__default["default"];

  var bn = BN$8;

  var minimalisticAssert = assert$f;

  function assert$f(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  }

  assert$f.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
  };

  var utils$m = {};

  (function (exports) {

  var utils = exports;

  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;

  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;

  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;

  utils.encode = function encode(arr, enc) {
    if (enc === 'hex')
      return toHex(arr);
    else
      return arr;
  };
  }(utils$m));

  (function (exports) {

  var utils = exports;
  var BN = bn;
  var minAssert = minimalisticAssert;
  var minUtils = utils$m;

  utils.assert = minAssert;
  utils.toArray = minUtils.toArray;
  utils.zero2 = minUtils.zero2;
  utils.toHex = minUtils.toHex;
  utils.encode = minUtils.encode;

  // Represent num in a w-NAF form
  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);

    var ws = 1 << (w + 1);
    var k = num.clone();

    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }

      naf[i] = z;
      k.iushrn(1);
    }

    return naf;
  }
  utils.getNAF = getNAF;

  // Represent k1, k2 in a Joint Sparse Form
  function getJSF(k1, k2) {
    var jsf = [
      [],
      [],
    ];

    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      // First phase
      var m14 = (k1.andln(3) + d1) & 3;
      var m24 = (k2.andln(3) + d2) & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = (k1.andln(7) + d1) & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);

      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = (k2.andln(7) + d2) & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);

      // Second phase
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }

    return jsf;
  }
  utils.getJSF = getJSF;

  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] :
        this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;

  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
      bytes;
  }
  utils.parseBytes = parseBytes;

  function intFromLE(bytes) {
    return new BN(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
  }(utils$n));

  var brorand = {exports: {}};

  var r$1;

  brorand.exports = function rand(len) {
    if (!r$1)
      r$1 = new Rand(null);

    return r$1.generate(len);
  };

  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;

  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };

  // Emulate crypto API using randy
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);

    var res = new Uint8Array(n);
    for (var i = 0; i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };

  if (typeof self === 'object') {
    if (self.crypto && self.crypto.getRandomValues) {
      // Modern browsers
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      // IE
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };

    // Safari's WebWorkers do not have `crypto`
    } else if (typeof window === 'object') {
      // Old junk
      Rand.prototype._rand = function() {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    // Node.js or Web worker with no crypto support
    try {
      var crypto$3 = require('crypto');
      if (typeof crypto$3.randomBytes !== 'function')
        throw new Error('Not supported');

      Rand.prototype._rand = function _rand(n) {
        return crypto$3.randomBytes(n);
      };
    } catch (e) {
    }
  }

  var curve = {};

  var BN$7 = bn;
  var utils$l = utils$n;
  var getNAF = utils$l.getNAF;
  var getJSF = utils$l.getJSF;
  var assert$e = utils$l.assert;

  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN$7(conf.p, 16);

    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? BN$7.red(conf.prime) : BN$7.mont(this.p);

    // Useful for many curves
    this.zero = new BN$7(0).toRed(this.red);
    this.one = new BN$7(1).toRed(this.red);
    this.two = new BN$7(2).toRed(this.red);

    // Curve configuration, optional
    this.n = conf.n && new BN$7(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);

    this._bitLength = this.n ? this.n.bitLength() : 0;

    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  var base = BaseCurve;

  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };

  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };

  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert$e(p.precomputed);
    var doubles = p._getDoubles();

    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;

    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for (j = 0; j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1; l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }

    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (j = 0; j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };

  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;

    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;

    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);

    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      // Count zeroes
      for (var l = 0; i >= 0 && naf[i] === 0; i--)
        l++;
      if (i >= 0)
        l++;
      acc = acc.dblp(l);

      if (i < 0)
        break;
      var z = naf[i];
      assert$e(z !== 0);
      if (p.type === 'affine') {
        // J +- P
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        // J +- J
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };

  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
    points,
    coeffs,
    len,
    jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;

    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for (i = 0; i < len; i++) {
      p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }

    // Comb small window NAFs
    for (i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }

      var comb = [
        points[a], /* 1 */
        null, /* 3 */
        null, /* 5 */
        points[b], /* 7 */
      ];

      // Try to avoid Projective points, if possible
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }

      var index = [
        -3, /* -1 -1 */
        -1, /* -1 0 */
        -5, /* -1 1 */
        -7, /* 0 -1 */
        0, /* 0 0 */
        7, /* 0 1 */
        5, /* 1 -1 */
        1, /* 1 0 */
        3,  /* 1 1 */
      ];

      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;

        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }

    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i = max; i >= 0; i--) {
      var k = 0;

      while (i >= 0) {
        var zero = true;
        for (j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;

      for (j = 0; j < len; j++) {
        var z = tmp[j];
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();

        if (p.type === 'affine')
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    // Zeroify references
    for (i = 0; i < len; i++)
      wnd[i] = null;

    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };

  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;

  BasePoint.prototype.eq = function eq(/*other*/) {
    throw new Error('Not implemented');
  };

  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };

  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils$l.toArray(bytes, enc);

    var len = this.p.byteLength();

    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
        bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06)
        assert$e(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 0x07)
        assert$e(bytes[bytes.length - 1] % 2 === 1);

      var res =  this.point(bytes.slice(1, 1 + len),
        bytes.slice(1 + len, 1 + 2 * len));

      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
                bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }
    throw new Error('Unknown point format');
  };

  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };

  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);

    if (compact)
      return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

    return [ 0x04 ].concat(x, this.getY().toArray('be', len));
  };

  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils$l.encode(this._encode(compact), enc);
  };

  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;

    var precomputed = {
      doubles: null,
      naf: null,
      beta: null,
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;

    return this;
  };

  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;

    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;

    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };

  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;

    var doubles = [ this ];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles,
    };
  };

  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;

    var res = [ this ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res,
    };
  };

  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };

  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };

  var inherits_browser = {exports: {}};

  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }

  var utils$k = utils$n;
  var BN$6 = bn;
  var inherits$3 = inherits_browser.exports;
  var Base$2 = base;

  var assert$d = utils$k.assert;

  function ShortCurve(conf) {
    Base$2.call(this, 'short', conf);

    this.a = new BN$6(conf.a, 16).toRed(this.red);
    this.b = new BN$6(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();

    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits$3(ShortCurve, Base$2);
  var short = ShortCurve;

  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;

    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN$6(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      // Choose the smallest beta
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN$6(conf.lambda, 16);
    } else {
      // Choose the lambda that is matching selected beta
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$d(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }

    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN$6(vec.a, 16),
          b: new BN$6(vec.b, 16),
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }

    return {
      beta: beta,
      lambda: lambda,
      basis: basis,
    };
  };

  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN$6.mont(num);
    var tinv = new BN$6(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();

    var s = new BN$6(3).toRed(red).redNeg().redSqrt().redMul(tinv);

    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [ l1, l2 ];
  };

  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN$6(1);
    var y1 = new BN$6(0);
    var x2 = new BN$6(0);
    var y2 = new BN$6(1);

    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;

    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));

      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;

      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;

    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }

    // Normalize signs
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }

    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 },
    ];
  };

  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];

    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);

    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);

    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return { k1: k1, k2: k2 };
  };

  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$6(x, 16);
    if (!x.red)
      x = x.toRed(this.red);

    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');

    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();

    return this.point(x, y);
  };

  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;

    var x = point.x;
    var y = point.y;

    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };

  ShortCurve.prototype._endoWnafMulAdd =
      function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();

          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }

          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

        // Clean-up references to points and coefficients
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };

  function Point$2(curve, x, y, isRed) {
    Base$2.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN$6(x, 16);
      this.y = new BN$6(y, 16);
      // Force redgomery representation when loading from JSON
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits$3(Point$2, Base$2.BasePoint);

  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point$2(this, x, y, isRed);
  };

  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point$2.fromJSON(this, obj, red);
  };

  Point$2.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;

    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;

    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul),
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul),
        },
      };
    }
    return beta;
  };

  Point$2.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [ this.x, this.y ];

    return [ this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1),
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1),
      },
    } ];
  };

  Point$2.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string')
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;

    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }

    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [ res ].concat(pre.doubles.points.map(obj2point)),
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [ res ].concat(pre.naf.points.map(obj2point)),
      },
    };
    return res;
  };

  Point$2.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };

  Point$2.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };

  Point$2.prototype.add = function add(p) {
    // O + P = P
    if (this.inf)
      return p;

    // P + O = P
    if (p.inf)
      return this;

    // P + P = 2P
    if (this.eq(p))
      return this.dbl();

    // P + (-P) = O
    if (this.neg().eq(p))
      return this.curve.point(null, null);

    // P + Q = O
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);

    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };

  Point$2.prototype.dbl = function dbl() {
    if (this.inf)
      return this;

    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);

    var a = this.curve.a;

    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };

  Point$2.prototype.getX = function getX() {
    return this.x.fromRed();
  };

  Point$2.prototype.getY = function getY() {
    return this.y.fromRed();
  };

  Point$2.prototype.mul = function mul(k) {
    k = new BN$6(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([ this ], [ k ]);
    else
      return this.curve._wnafMul(this, k);
  };

  Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };

  Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };

  Point$2.prototype.eq = function eq(p) {
    return this === p ||
           this.inf === p.inf &&
               (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };

  Point$2.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;

    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate),
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate),
        },
      };
    }
    return res;
  };

  Point$2.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);

    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };

  function JPoint(curve, x, y, z) {
    Base$2.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN$6(0);
    } else {
      this.x = new BN$6(x, 16);
      this.y = new BN$6(y, 16);
      this.z = new BN$6(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);

    this.zOne = this.z === this.curve.one;
  }
  inherits$3(JPoint, Base$2.BasePoint);

  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };

  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);

    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);

    return this.curve.point(ax, ay);
  };

  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };

  JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity())
      return p;

    // P + O = P
    if (p.isInfinity())
      return this;

    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));

    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }

    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);

    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity())
      return p.toJ();

    // P + O = P
    if (p.isInfinity())
      return this;

    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);

    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }

    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);

    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();

    var i;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }

    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;

    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();

    // Reuse results
    var jyd = jy.redAdd(jy);
    for (i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);

      jx = nx;
      jz = nz;
      jyd = dny;
    }

    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };

  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;

    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };

  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 14A

      // XX = X1^2
      var xx = this.x.redSqr();
      // YY = Y1^2
      var yy = this.y.redSqr();
      // YYYY = YY^2
      var yyyy = yy.redSqr();
      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      // M = 3 * XX + a; a = 0
      var m = xx.redAdd(xx).redIAdd(xx);
      // T = M ^ 2 - 2*S
      var t = m.redSqr().redISub(s).redISub(s);

      // 8 * YYYY
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);

      // X3 = T
      nx = t;
      // Y3 = M * (S - T) - 8 * YYYY
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      // Z3 = 2*Y1
      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
      //     #doubling-dbl-2009-l
      // 2M + 5S + 13A

      // A = X1^2
      var a = this.x.redSqr();
      // B = Y1^2
      var b = this.y.redSqr();
      // C = B^2
      var c = b.redSqr();
      // D = 2 * ((X1 + B)^2 - A - C)
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      // E = 3 * A
      var e = a.redAdd(a).redIAdd(a);
      // F = E^2
      var f = e.redSqr();

      // 8 * C
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);

      // X3 = F - 2 * D
      nx = f.redISub(d).redISub(d);
      // Y3 = E * (D - X3) - 8 * C
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      // Z3 = 2 * Y1 * Z1
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
      //     #doubling-mdbl-2007-bl
      // 1M + 5S + 15A

      // XX = X1^2
      var xx = this.x.redSqr();
      // YY = Y1^2
      var yy = this.y.redSqr();
      // YYYY = YY^2
      var yyyy = yy.redSqr();
      // S = 2 * ((X1 + YY)^2 - XX - YYYY)
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      // M = 3 * XX + a
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      // T = M^2 - 2 * S
      var t = m.redSqr().redISub(s).redISub(s);
      // X3 = T
      nx = t;
      // Y3 = M * (S - T) - 8 * YYYY
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      // Z3 = 2 * Y1
      nz = this.y.redAdd(this.y);
    } else {
      // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
      // 3M + 5S

      // delta = Z1^2
      var delta = this.z.redSqr();
      // gamma = Y1^2
      var gamma = this.y.redSqr();
      // beta = X1 * gamma
      var beta = this.x.redMul(gamma);
      // alpha = 3 * (X1 - delta) * (X1 + delta)
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      // X3 = alpha^2 - 8 * beta
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      // Z3 = (Y1 + Z1)^2 - gamma - delta
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;

    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();

    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();

    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);

    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);

    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

    return this.curve.jpoint(nx, ny, nz);
  };

  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN$6(k, kbase);

    return this.curve._wnafMul(this, k);
  };

  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine')
      return this.eq(p.toJ());

    if (this === p)
      return true;

    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;

    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };

  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;

    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;

      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };

  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) +
        ' y: ' + this.y.toString(16, 2) +
        ' z: ' + this.z.toString(16, 2) + '>';
  };

  JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };

  var BN$5 = bn;
  var inherits$2 = inherits_browser.exports;
  var Base$1 = base;

  var utils$j = utils$n;

  function MontCurve(conf) {
    Base$1.call(this, 'mont', conf);

    this.a = new BN$5(conf.a, 16).toRed(this.red);
    this.b = new BN$5(conf.b, 16).toRed(this.red);
    this.i4 = new BN$5(4).toRed(this.red).redInvm();
    this.two = new BN$5(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits$2(MontCurve, Base$1);
  var mont = MontCurve;

  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();

    return y.redSqr().cmp(rhs) === 0;
  };

  function Point$1(curve, x, z) {
    Base$1.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN$5(x, 16);
      this.z = new BN$5(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits$2(Point$1, Base$1.BasePoint);

  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils$j.toArray(bytes, enc), 1);
  };

  MontCurve.prototype.point = function point(x, z) {
    return new Point$1(this, x, z);
  };

  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point$1.fromJSON(this, obj);
  };

  Point$1.prototype.precompute = function precompute() {
    // No-op
  };

  Point$1.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };

  Point$1.fromJSON = function fromJSON(curve, obj) {
    return new Point$1(curve, obj[0], obj[1] || curve.one);
  };

  Point$1.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };

  Point$1.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
  };

  Point$1.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A

    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };

  Point$1.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A

    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };

  Point$1.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q

    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));

    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
      } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
      }
    }
    return b;
  };

  Point$1.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };

  Point$1.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };

  Point$1.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };

  Point$1.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();

    return this.x.fromRed();
  };

  var utils$i = utils$n;
  var BN$4 = bn;
  var inherits$1 = inherits_browser.exports;
  var Base = base;

  var assert$c = utils$i.assert;

  function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;

    Base.call(this, 'edwards', conf);

    this.a = new BN$4(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN$4(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN$4(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);

    assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits$1(EdwardsCurve, Base);
  var edwards = EdwardsCurve;

  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };

  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };

  // Just for compatibility with Short curve
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };

  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$4(x, 16);
    if (!x.red)
      x = x.toRed(this.red);

    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');

    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();

    return this.point(x, y);
  };

  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN$4(y, 16);
    if (!y.red)
      y = y.toRed(this.red);

    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());

    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error('invalid point');
      else
        return this.point(this.zero, y);
    }

    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error('invalid point');

    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();

    return this.point(x, y);
  };

  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;

    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();

    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

    return lhs.cmp(rhs) === 0;
  };

  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN$4(x, 16);
      this.y = new BN$4(y, 16);
      this.z = z ? new BN$4(z, 16) : this.curve.one;
      this.t = t && new BN$4(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;

      // Use extended coordinates
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits$1(Point, Base.BasePoint);

  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };

  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };

  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };

  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };

  Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 &&
      (this.y.cmp(this.z) === 0 ||
      (this.zOne && this.y.cmp(this.curve.c) === 0));
  };

  Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };

  Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S

    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();

    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      // E = a * C
      e = this.curve._mulA(c);
      // F = E + D
      var f = e.redAdd(d);
      if (this.zOne) {
        // X3 = (B - C - D) * (F - 2)
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        // Y3 = F * (E - D)
        ny = f.redMul(e.redSub(d));
        // Z3 = F^2 - 2 * F
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        // H = Z1^2
        h = this.z.redSqr();
        // J = F - 2 * H
        j = f.redSub(h).redISub(h);
        // X3 = (B-C-D)*J
        nx = b.redSub(c).redISub(d).redMul(j);
        // Y3 = F * (E - D)
        ny = f.redMul(e.redSub(d));
        // Z3 = F * J
        nz = f.redMul(j);
      }
    } else {
      // E = C + D
      e = c.redAdd(d);
      // H = (c * Z1)^2
      h = this.curve._mulC(this.z).redSqr();
      // J = E - 2 * H
      j = e.redSub(h).redSub(h);
      // X3 = c * (B - E) * J
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      // Y3 = c * E * (C - D)
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      // Z3 = E * J
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };

  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;

    // Double in extended coordinates
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };

  Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M

    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };

  Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S

    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      // Y3 = A * G * (D - a * C)
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      // Z3 = F * G
      nz = f.redMul(g);
    } else {
      // Y3 = A * G * (D - C)
      ny = a.redMul(g).redMul(d.redSub(c));
      // Z3 = c * F * G
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };

  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;

    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };

  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };

  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
  };

  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
  };

  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;

    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };

  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg());
  };

  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };

  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };

  Point.prototype.eq = function eq(other) {
    return this === other ||
           this.getX().cmp(other.getX()) === 0 &&
           this.getY().cmp(other.getY()) === 0;
  };

  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;

    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;

      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };

  // Compatibility with BaseCurve
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;

  (function (exports) {

  var curve = exports;

  curve.base = base;
  curve.short = short;
  curve.mont = mont;
  curve.edwards = edwards;
  }(curve));

  var curves$2 = {};

  var hash$3 = {};

  var utils$h = {};

  var assert$b = minimalisticAssert;
  var inherits = inherits_browser.exports;

  utils$h.inherits = inherits;

  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
  }

  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        // Inspired by stringToUtf8ByteArray() in closure-library by Google
        // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
        // Apache License 2.0
        // https://github.com/google/closure-library/blob/master/LICENSE
        var p = 0;
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = (c >> 6) | 192;
            res[p++] = (c & 63) | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
            res[p++] = (c >> 18) | 240;
            res[p++] = ((c >> 12) & 63) | 128;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          } else {
            res[p++] = (c >> 12) | 224;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          }
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0)
          msg = '0' + msg;
        for (i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  utils$h.toArray = toArray;

  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils$h.toHex = toHex;

  function htonl(w) {
    var res = (w >>> 24) |
              ((w >>> 8) & 0xff00) |
              ((w << 8) & 0xff0000) |
              ((w & 0xff) << 24);
    return res >>> 0;
  }
  utils$h.htonl = htonl;

  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little')
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils$h.toHex32 = toHex32;

  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils$h.zero2 = zero2;

  function zero8(word) {
    if (word.length === 7)
      return '0' + word;
    else if (word.length === 6)
      return '00' + word;
    else if (word.length === 5)
      return '000' + word;
    else if (word.length === 4)
      return '0000' + word;
    else if (word.length === 3)
      return '00000' + word;
    else if (word.length === 2)
      return '000000' + word;
    else if (word.length === 1)
      return '0000000' + word;
    else
      return word;
  }
  utils$h.zero8 = zero8;

  function join32(msg, start, end, endian) {
    var len = end - start;
    assert$b(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big')
        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
      else
        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils$h.join32 = join32;

  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = (m >>> 16) & 0xff;
        res[k + 2] = (m >>> 8) & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = (m >>> 16) & 0xff;
        res[k + 1] = (m >>> 8) & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  utils$h.split32 = split32;

  function rotr32$1(w, b) {
    return (w >>> b) | (w << (32 - b));
  }
  utils$h.rotr32 = rotr32$1;

  function rotl32$2(w, b) {
    return (w << b) | (w >>> (32 - b));
  }
  utils$h.rotl32 = rotl32$2;

  function sum32$3(a, b) {
    return (a + b) >>> 0;
  }
  utils$h.sum32 = sum32$3;

  function sum32_3$1(a, b, c) {
    return (a + b + c) >>> 0;
  }
  utils$h.sum32_3 = sum32_3$1;

  function sum32_4$2(a, b, c, d) {
    return (a + b + c + d) >>> 0;
  }
  utils$h.sum32_4 = sum32_4$2;

  function sum32_5$2(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
  }
  utils$h.sum32_5 = sum32_5$2;

  function sum64$1(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];

    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils$h.sum64 = sum64$1;

  function sum64_hi$1(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils$h.sum64_hi = sum64_hi$1;

  function sum64_lo$1(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils$h.sum64_lo = sum64_lo$1;

  function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;

    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils$h.sum64_4_hi = sum64_4_hi$1;

  function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils$h.sum64_4_lo = sum64_4_lo$1;

  function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;

    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils$h.sum64_5_hi = sum64_5_hi$1;

  function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;

    return lo >>> 0;
  }
  utils$h.sum64_5_lo = sum64_5_lo$1;

  function rotr64_hi$1(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
  }
  utils$h.rotr64_hi = rotr64_hi$1;

  function rotr64_lo$1(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  utils$h.rotr64_lo = rotr64_lo$1;

  function shr64_hi$1(ah, al, num) {
    return ah >>> num;
  }
  utils$h.shr64_hi = shr64_hi$1;

  function shr64_lo$1(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  utils$h.shr64_lo = shr64_lo$1;

  var common$5 = {};

  var utils$g = utils$h;
  var assert$a = minimalisticAssert;

  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';

    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$5.BlockHash = BlockHash$4;

  BlockHash$4.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils$g.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;

    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
      msg = this.pending;

      // Process pending data in blocks
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;

      msg = utils$g.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }

    return this;
  };

  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$a(this.pending === null);

    return this._digest(enc);
  };

  BlockHash$4.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
      res[i] = 0;

    // Append length
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;

      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;

      for (t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }

    return res;
  };

  var sha = {};

  var common$4 = {};

  var utils$f = utils$h;
  var rotr32 = utils$f.rotr32;

  function ft_1$1(s, x, y, z) {
    if (s === 0)
      return ch32$1(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32$1(x, y, z);
  }
  common$4.ft_1 = ft_1$1;

  function ch32$1(x, y, z) {
    return (x & y) ^ ((~x) & z);
  }
  common$4.ch32 = ch32$1;

  function maj32$1(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
  }
  common$4.maj32 = maj32$1;

  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  common$4.p32 = p32;

  function s0_256$1(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  common$4.s0_256 = s0_256$1;

  function s1_256$1(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  common$4.s1_256 = s1_256$1;

  function g0_256$1(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
  }
  common$4.g0_256 = g0_256$1;

  function g1_256$1(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
  }
  common$4.g1_256 = g1_256$1;

  var utils$e = utils$h;
  var common$3 = common$5;
  var shaCommon$1 = common$4;

  var rotl32$1 = utils$e.rotl32;
  var sum32$2 = utils$e.sum32;
  var sum32_5$1 = utils$e.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;

  var sha1_K = [
    0x5A827999, 0x6ED9EBA1,
    0x8F1BBCDC, 0xCA62C1D6
  ];

  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();

    BlockHash$3.call(this);
    this.h = [
      0x67452301, 0xefcdab89, 0x98badcfe,
      0x10325476, 0xc3d2e1f0 ];
    this.W = new Array(80);
  }

  utils$e.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;

  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;

  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;

    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];

    for(; i < W.length; i++)
      W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];

    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32$1(b, 30);
      b = a;
      a = t;
    }

    this.h[0] = sum32$2(this.h[0], a);
    this.h[1] = sum32$2(this.h[1], b);
    this.h[2] = sum32$2(this.h[2], c);
    this.h[3] = sum32$2(this.h[3], d);
    this.h[4] = sum32$2(this.h[4], e);
  };

  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$e.toHex32(this.h, 'big');
    else
      return utils$e.split32(this.h, 'big');
  };

  var utils$d = utils$h;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$9 = minimalisticAssert;

  var sum32$1 = utils$d.sum32;
  var sum32_4$1 = utils$d.sum32_4;
  var sum32_5 = utils$d.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;

  var BlockHash$2 = common$2.BlockHash;

  var sha256_K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];

  function SHA256$1() {
    if (!(this instanceof SHA256$1))
      return new SHA256$1();

    BlockHash$2.call(this);
    this.h = [
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils$d.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;

  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;

  SHA256$1.prototype._update = function _update(msg, start) {
    var W = this.W;

    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];

    assert$9(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32$1(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32$1(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32$1(T1, T2);
    }

    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f);
    this.h[6] = sum32$1(this.h[6], g);
    this.h[7] = sum32$1(this.h[7], h);
  };

  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$d.toHex32(this.h, 'big');
    else
      return utils$d.split32(this.h, 'big');
  };

  var utils$c = utils$h;
  var SHA256 = _256;

  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();

    SHA256.call(this);
    this.h = [
      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
      0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
  }
  utils$c.inherits(SHA224, SHA256);
  var _224 = SHA224;

  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;

  SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === 'hex')
      return utils$c.toHex32(this.h.slice(0, 7), 'big');
    else
      return utils$c.split32(this.h.slice(0, 7), 'big');
  };

  var utils$b = utils$h;
  var common$1 = common$5;
  var assert$8 = minimalisticAssert;

  var rotr64_hi = utils$b.rotr64_hi;
  var rotr64_lo = utils$b.rotr64_lo;
  var shr64_hi = utils$b.shr64_hi;
  var shr64_lo = utils$b.shr64_lo;
  var sum64 = utils$b.sum64;
  var sum64_hi = utils$b.sum64_hi;
  var sum64_lo = utils$b.sum64_lo;
  var sum64_4_hi = utils$b.sum64_4_hi;
  var sum64_4_lo = utils$b.sum64_4_lo;
  var sum64_5_hi = utils$b.sum64_5_hi;
  var sum64_5_lo = utils$b.sum64_5_lo;

  var BlockHash$1 = common$1.BlockHash;

  var sha512_K = [
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  ];

  function SHA512$1() {
    if (!(this instanceof SHA512$1))
      return new SHA512$1();

    BlockHash$1.call(this);
    this.h = [
      0x6a09e667, 0xf3bcc908,
      0xbb67ae85, 0x84caa73b,
      0x3c6ef372, 0xfe94f82b,
      0xa54ff53a, 0x5f1d36f1,
      0x510e527f, 0xade682d1,
      0x9b05688c, 0x2b3e6c1f,
      0x1f83d9ab, 0xfb41bd6b,
      0x5be0cd19, 0x137e2179 ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils$b.inherits(SHA512$1, BlockHash$1);
  var _512 = SHA512$1;

  SHA512$1.blockSize = 1024;
  SHA512$1.outSize = 512;
  SHA512$1.hmacStrength = 192;
  SHA512$1.padLength = 128;

  SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;

    // 32 x 32bit words
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];  // i - 7
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];  // i - 16
      var c3_lo = W[i - 31];

      W[i] = sum64_4_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
    }
  };

  SHA512$1.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);

    var W = this.W;

    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];

    assert$8(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];

      var T1_hi = sum64_5_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);

      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

      hh = gh;
      hl = gl;

      gh = fh;
      gl = fl;

      fh = eh;
      fl = el;

      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);

      dh = ch;
      dl = cl;

      ch = bh;
      cl = bl;

      bh = ah;
      bl = al;

      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }

    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };

  SHA512$1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$b.toHex32(this.h, 'big');
    else
      return utils$b.split32(this.h, 'big');
  };

  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ ((~xh) & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ ((~xl) & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);  // 34
    var c2_hi = rotr64_hi(xl, xh, 7);  // 39

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);  // 34
    var c2_lo = rotr64_lo(xl, xh, 7);  // 39

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);  // 41

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);  // 41

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);  // 61
    var c2_hi = shr64_hi(xh, xl, 6);

    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);  // 61
    var c2_lo = shr64_lo(xh, xl, 6);

    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  var utils$a = utils$h;

  var SHA512 = _512;

  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();

    SHA512.call(this);
    this.h = [
      0xcbbb9d5d, 0xc1059ed8,
      0x629a292a, 0x367cd507,
      0x9159015a, 0x3070dd17,
      0x152fecd8, 0xf70e5939,
      0x67332667, 0xffc00b31,
      0x8eb44a87, 0x68581511,
      0xdb0c2e0d, 0x64f98fa7,
      0x47b5481d, 0xbefa4fa4 ];
  }
  utils$a.inherits(SHA384, SHA512);
  var _384 = SHA384;

  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;

  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$a.toHex32(this.h.slice(0, 12), 'big');
    else
      return utils$a.split32(this.h.slice(0, 12), 'big');
  };

  sha.sha1 = _1;
  sha.sha224 = _224;
  sha.sha256 = _256;
  sha.sha384 = _384;
  sha.sha512 = _512;

  var ripemd = {};

  var utils$9 = utils$h;
  var common = common$5;

  var rotl32 = utils$9.rotl32;
  var sum32 = utils$9.sum32;
  var sum32_3 = utils$9.sum32_3;
  var sum32_4 = utils$9.sum32_4;
  var BlockHash = common.BlockHash;

  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();

    BlockHash.call(this);

    this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
    this.endian = 'little';
  }
  utils$9.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;

  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;

  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
          s[j]),
        E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]),
        Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };

  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$9.toHex32(this.h, 'little');
    else
      return utils$9.split32(this.h, 'little');
  };

  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return (x & y) | ((~x) & z);
    else if (j <= 47)
      return (x | (~y)) ^ z;
    else if (j <= 63)
      return (x & z) | (y & (~z));
    else
      return x ^ (y | (~z));
  }

  function K(j) {
    if (j <= 15)
      return 0x00000000;
    else if (j <= 31)
      return 0x5a827999;
    else if (j <= 47)
      return 0x6ed9eba1;
    else if (j <= 63)
      return 0x8f1bbcdc;
    else
      return 0xa953fd4e;
  }

  function Kh(j) {
    if (j <= 15)
      return 0x50a28be6;
    else if (j <= 31)
      return 0x5c4dd124;
    else if (j <= 47)
      return 0x6d703ef3;
    else if (j <= 63)
      return 0x7a6d76e9;
    else
      return 0x00000000;
  }

  var r = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  ];

  var rh = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  ];

  var s = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  ];

  var sh = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  ];

  var utils$8 = utils$h;
  var assert$7 = minimalisticAssert;

  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;

    this._init(utils$8.toArray(key, enc));
  }
  var hmac = Hmac;

  Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert$7(key.length <= this.blockSize);

    // Add padding to key
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);

    for (i = 0; i < key.length; i++)
      key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);

    // 0x36 ^ 0x5c = 0x6a
    for (i = 0; i < key.length; i++)
      key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };

  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };

  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };

  (function (exports) {
  var hash = exports;

  hash.utils = utils$h;
  hash.common = common$5;
  hash.sha = sha;
  hash.ripemd = ripemd;
  hash.hmac = hmac;

  // Proxy hash functions to the main object
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  }(hash$3));

  const hash$2 = hash$3;

  (function (exports) {

  var curves = exports;

  var hash = hash$3;
  var curve$1 = curve;
  var utils = utils$n;

  var assert = utils.assert;

  function PresetCurve(options) {
    if (options.type === 'short')
      this.curve = new curve$1.short(options);
    else if (options.type === 'edwards')
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;

    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;

  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve,
        });
        return curve;
      },
    });
  }

  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: [
      '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
      '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
    ],
  });

  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: [
      'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
      'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
    ],
  });

  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: [
      '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
      '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
    ],
  });

  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
       '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
       'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: [
      'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
      '5502f25d bf55296c 3a545e38 72760ab7',
      '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
      '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
    ],
  });

  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
       '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
       '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
       'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: [
      '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
      '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
      'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
      '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
      '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
      '3fad0761 353c7086 a272c240 88be9476 9fd16650',
    ],
  });

  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '1',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '9',
    ],
  });

  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    // -121665 * (121666^(-1)) (mod P)
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

      // 4/5
      '6666666666666666666666666666666666666666666666666666666666666658',
    ],
  });

  var pre;
  try {
    pre = require('./precomputed/secp256k1');
  } catch (e) {
    pre = undefined;
  }

  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,

    // Precomputed endomorphism
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [
      {
        a: '3086d221a7d46bcde86c90e49284eb15',
        b: '-e4437ed6010e88286f547fa90abfe4c3',
      },
      {
        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
        b: '3086d221a7d46bcde86c90e49284eb15',
      },
    ],

    gRed: false,
    g: [
      '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
      '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      pre,
    ],
  });
  }(curves$2));

  var hash$1 = hash$3;
  var utils$7 = utils$m;
  var assert$6 = minimalisticAssert;

  function HmacDRBG$1(options) {
    if (!(this instanceof HmacDRBG$1))
      return new HmacDRBG$1(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;

    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;

    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;

    var entropy = utils$7.toArray(options.entropy, options.entropyEnc || 'hex');
    var nonce = utils$7.toArray(options.nonce, options.nonceEnc || 'hex');
    var pers = utils$7.toArray(options.pers, options.persEnc || 'hex');
    assert$6(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  var hmacDrbg = HmacDRBG$1;

  HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);

    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }

    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000;  // 2^48
  };

  HmacDRBG$1.prototype._hmac = function hmac() {
    return new hash$1.hmac(this.hash, this.K);
  };

  HmacDRBG$1.prototype._update = function update(seed) {
    var kmac = this._hmac()
                   .update(this.V)
                   .update([ 0x00 ]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;

    this.K = this._hmac()
                 .update(this.V)
                 .update([ 0x01 ])
                 .update(seed)
                 .digest();
    this.V = this._hmac().update(this.V).digest();
  };

  HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }

    entropy = utils$7.toArray(entropy, entropyEnc);
    add = utils$7.toArray(add, addEnc);

    assert$6(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };

  HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error('Reseed is required');

    // Optional encoding
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }

    // Optional additional data
    if (add) {
      add = utils$7.toArray(add, addEnc || 'hex');
      this._update(add);
    }

    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }

    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils$7.encode(res, enc);
  };

  var BN$3 = bn;
  var utils$6 = utils$n;
  var assert$5 = utils$6.assert;

  function KeyPair$3(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;

    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  var key$1 = KeyPair$3;

  KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair$3)
      return pub;

    return new KeyPair$3(ec, {
      pub: pub,
      pubEnc: enc,
    });
  };

  KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair$3)
      return priv;

    return new KeyPair$3(ec, {
      priv: priv,
      privEnc: enc,
    });
  };

  KeyPair$3.prototype.validate = function validate() {
    var pub = this.getPublic();

    if (pub.isInfinity())
      return { result: false, reason: 'Invalid public key' };
    if (!pub.validate())
      return { result: false, reason: 'Public key is not a point' };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: 'Public key * N != O' };

    return { result: true, reason: null };
  };

  KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }

    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);

    if (!enc)
      return this.pub;

    return this.pub.encode(enc, compact);
  };

  KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex')
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };

  KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN$3(key, enc || 16);

    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
  };

  KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      // Montgomery points only have an `x` coordinate.
      // Weierstrass/Edwards points on the other hand have both `x` and
      // `y` coordinates.
      if (this.ec.curve.type === 'mont') {
        assert$5(key.x, 'Need x coordinate');
      } else if (this.ec.curve.type === 'short' ||
                 this.ec.curve.type === 'edwards') {
        assert$5(key.x && key.y, 'Need both x and y coordinate');
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };

  // ECDH
  KeyPair$3.prototype.derive = function derive(pub) {
    if(!pub.validate()) {
      assert$5(pub.validate(), 'public point not validated');
    }
    return pub.mul(this.priv).getX();
  };

  // ECDSA
  KeyPair$3.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };

  KeyPair$3.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };

  KeyPair$3.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
           ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };

  var BN$2 = bn;

  var utils$5 = utils$n;
  var assert$4 = utils$5.assert;

  function Signature$3(options, enc) {
    if (options instanceof Signature$3)
      return options;

    if (this._importDER(options, enc))
      return;

    assert$4(options.r && options.s, 'Signature without r or s');
    this.r = new BN$2(options.r, 16);
    this.s = new BN$2(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  var signature$1 = Signature$3;

  function Position() {
    this.place = 0;
  }

  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) {
      return initial;
    }
    var octetLen = initial & 0xf;

    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }

    var val = 0;
    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }

    // Leading zeroes
    if (val <= 0x7f) {
      return false;
    }

    p.place = off;
    return val;
  }

  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }

  Signature$3.prototype._importDER = function _importDER(data, enc) {
    data = utils$5.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) {
      return false;
    }
    var len = getLength(data, p);
    if (len === false) {
      return false;
    }
    if ((len + p.place) !== data.length) {
      return false;
    }
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var rlen = getLength(data, p);
    if (rlen === false) {
      return false;
    }
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var slen = getLength(data, p);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 0x80) {
        r = r.slice(1);
      } else {
        // Leading zeroes
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 0x80) {
        s = s.slice(1);
      } else {
        // Leading zeroes
        return false;
      }
    }

    this.r = new BN$2(r);
    this.s = new BN$2(s);
    this.recoveryParam = null;

    return true;
  };

  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while (--octets) {
      arr.push((len >>> (octets << 3)) & 0xff);
    }
    arr.push(len);
  }

  Signature$3.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();

    // Pad values
    if (r[0] & 0x80)
      r = [ 0 ].concat(r);
    // Pad values
    if (s[0] & 0x80)
      s = [ 0 ].concat(s);

    r = rmPadding(r);
    s = rmPadding(s);

    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }
    var arr = [ 0x02 ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [ 0x30 ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils$5.encode(res, enc);
  };

  var BN$1 = bn;
  var HmacDRBG = hmacDrbg;
  var utils$4 = utils$n;
  var curves$1 = curves$2;
  var rand = brorand.exports;
  var assert$3 = utils$4.assert;

  var KeyPair$2 = key$1;
  var Signature$2 = signature$1;

  function EC$1(options) {
    if (!(this instanceof EC$1))
      return new EC$1(options);

    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === 'string') {
      assert$3(Object.prototype.hasOwnProperty.call(curves$1, options),
        'Unknown curve ' + options);

      options = curves$1[options];
    }

    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves$1.PresetCurve)
      options = { curve: options };

    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;

    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);

    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
  }
  var ec = EC$1;

  EC$1.prototype.keyPair = function keyPair(options) {
    return new KeyPair$2(this, options);
  };

  EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair$2.fromPrivate(this, priv, enc);
  };

  EC$1.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair$2.fromPublic(this, pub, enc);
  };

  EC$1.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};

    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || 'utf8',
      nonce: this.n.toArray(),
    });

    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN$1(2));
    for (;;) {
      var priv = new BN$1(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;

      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };

  EC$1.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };

  EC$1.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};

    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN$1(msg, 16));

    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);

    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray('be', bytes);

    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
    });

    // Number of bytes to generate
    var ns1 = this.n.sub(new BN$1(1));

    for (var iter = 0; ; iter++) {
      var k = options.k ?
        options.k(iter) :
        new BN$1(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;

      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;

      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;

      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;

      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                          (kpX.cmp(r) !== 0 ? 2 : 0);

      // Use complement of `s`, if it is > `n / 2`
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }

      return new Signature$2({ r: r, s: s, recoveryParam: recoveryParam });
    }
  };

  EC$1.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN$1(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature$2(signature, 'hex');

    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;

    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;

    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;

      return p.getX().umod(this.n).cmp(r) === 0;
    }

    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K

    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
  };

  EC$1.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert$3((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature$2(signature, enc);

    var n = this.n;
    var e = new BN$1(msg);
    var r = signature.r;
    var s = signature.s;

    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error('Unable to find sencond key candinate');

    // 1.1. Let x = r + jn.
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);

    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);

    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
  };

  EC$1.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature$2(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;

    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }

      if (Qprime.eq(Q))
        return i;
    }
    throw new Error('Unable to find valid recovery factor');
  };

  var utils$3 = utils$n;
  var assert$2 = utils$3.assert;
  var parseBytes$2 = utils$3.parseBytes;
  var cachedProperty$1 = utils$3.cachedProperty;

  /**
  * @param {EDDSA} eddsa - instance
  * @param {Object} params - public/private key parameters
  *
  * @param {Array<Byte>} [params.secret] - secret seed bytes
  * @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
  * @param {Array<Byte>} [params.pub] - public key point encoded as bytes
  *
  */
  function KeyPair$1(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes$2(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes$2(params.pub);
  }

  KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair$1)
      return pub;
    return new KeyPair$1(eddsa, { pub: pub });
  };

  KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair$1)
      return secret;
    return new KeyPair$1(eddsa, { secret: secret });
  };

  KeyPair$1.prototype.secret = function secret() {
    return this._secret;
  };

  cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });

  cachedProperty$1(KeyPair$1, 'pub', function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });

  cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;

    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;

    return a;
  });

  cachedProperty$1(KeyPair$1, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });

  cachedProperty$1(KeyPair$1, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });

  cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });

  KeyPair$1.prototype.sign = function sign(message) {
    assert$2(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };

  KeyPair$1.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };

  KeyPair$1.prototype.getSecret = function getSecret(enc) {
    assert$2(this._secret, 'KeyPair is public only');
    return utils$3.encode(this.secret(), enc);
  };

  KeyPair$1.prototype.getPublic = function getPublic(enc) {
    return utils$3.encode(this.pubBytes(), enc);
  };

  var key = KeyPair$1;

  var BN = bn;
  var utils$2 = utils$n;
  var assert$1 = utils$2.assert;
  var cachedProperty = utils$2.cachedProperty;
  var parseBytes$1 = utils$2.parseBytes;

  /**
  * @param {EDDSA} eddsa - eddsa instance
  * @param {Array<Bytes>|Object} sig -
  * @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
  * @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
  * @param {Array<Bytes>} [sig.Rencoded] - R point encoded
  * @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
  */
  function Signature$1(eddsa, sig) {
    this.eddsa = eddsa;

    if (typeof sig !== 'object')
      sig = parseBytes$1(sig);

    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength),
      };
    }

    assert$1(sig.R && sig.S, 'Signature without R or S');

    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;

    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }

  cachedProperty(Signature$1, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });

  cachedProperty(Signature$1, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });

  cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });

  cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });

  Signature$1.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };

  Signature$1.prototype.toHex = function toHex() {
    return utils$2.encode(this.toBytes(), 'hex').toUpperCase();
  };

  var signature = Signature$1;

  var hash = hash$3;
  var curves = curves$2;
  var utils$1 = utils$n;
  var assert = utils$1.assert;
  var parseBytes = utils$1.parseBytes;
  var KeyPair = key;
  var Signature = signature;

  function EDDSA(curve) {
    assert(curve === 'ed25519', 'only tested with ed25519 so far');

    if (!(this instanceof EDDSA))
      return new EDDSA(curve);

    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);

    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }

  var eddsa = EDDSA;

  /**
  * @param {Array|String} message - message bytes
  * @param {Array|String|KeyPair} secret - secret bytes or a keypair
  * @returns {Signature} - signature
  */
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
      .mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
  };

  /**
  * @param {Array} message - message bytes
  * @param {Array|String|Signature} sig - sig bytes
  * @param {Array|String|Point|KeyPair} pub - public key
  * @returns {Boolean} - true if public key matches sig of message
  */
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };

  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for (var i = 0; i < arguments.length; i++)
      hash.update(arguments[i]);
    return utils$1.intFromLE(hash.digest()).umod(this.curve.n);
  };

  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };

  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };

  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };

  /**
  * * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
  *
  * EDDSA defines methods for encoding and decoding points and integers. These are
  * helper convenience methods, that pass along to utility functions implied
  * parameters.
  *
  */
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };

  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils$1.parseBytes(bytes);

    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

    var y = utils$1.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };

  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };

  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils$1.intFromLE(bytes);
  };

  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };

  (function (exports) {

  var elliptic = exports;

  elliptic.version = require$$0$1.version;
  elliptic.utils = utils$n;
  elliptic.rand = brorand.exports;
  elliptic.curve = curve;
  elliptic.curves = curves$2;

  // Protocols
  elliptic.ec = ec;
  elliptic.eddsa = eddsa;
  }(elliptic));

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const EC = elliptic.ec;
  const secp256k1 = new EC('secp256k1');
  const EXPAND_OPT = {
    bitLength: 256,
    isLe: false
  };

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name secp256k1KeypairFromSeed
   * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
   */

  function secp256k1KeypairFromSeed(seed) {
    require$$0$3.assert(seed.length === 32, 'Expected valid 32-byte private key as a seed');
    const key = secp256k1.keyFromPrivate(seed);
    return {
      publicKey: new Uint8Array(key.getPublic().encodeCompressed()),
      secretKey: require$$0$3.bnToU8a(key.getPrivate(), EXPAND_OPT)
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function createSeedDeriveFn(fromSeed, derive) {
    return (keypair, {
      chainCode,
      isHard
    }) => {
      require$$0$3.assert(isHard, 'A soft key was found in the path and is not supported');
      return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const keyHdkdEcdsa = createSeedDeriveFn(secp256k1KeypairFromSeed, secp256k1DeriveHard);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const HDKD = require$$0$3.compactAddLength(require$$0$3.stringToU8a('Ed25519HDKD'));
  function naclDeriveHard(seed, chainCode) {
    return blake2AsU8a(require$$0$3.u8aConcat(HDKD, seed, chainCode));
  }

  var naclFast = {exports: {}};

  const require$$0 = /*@__PURE__*/getAugmentedNamespace(crypto$5);

  (function (module) {
  (function(nacl) {

  // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
  // Public domain.
  //
  // Implementation derived from TweetNaCl version 20140427.
  // See for details: http://tweetnacl.cr.yp.to/

  var gf = function(init) {
    var i, r = new Float64Array(16);
    if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
    return r;
  };

  //  Pluggable, initialized in high-level API below.
  var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

  var _0 = new Uint8Array(16);
  var _9 = new Uint8Array(32); _9[0] = 9;

  var gf0 = gf(),
      gf1 = gf([1]),
      _121665 = gf([0xdb41, 1]),
      D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
      D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
      X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
      Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
      I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

  function ts64(x, i, h, l) {
    x[i]   = (h >> 24) & 0xff;
    x[i+1] = (h >> 16) & 0xff;
    x[i+2] = (h >>  8) & 0xff;
    x[i+3] = h & 0xff;
    x[i+4] = (l >> 24)  & 0xff;
    x[i+5] = (l >> 16)  & 0xff;
    x[i+6] = (l >>  8)  & 0xff;
    x[i+7] = l & 0xff;
  }

  function vn(x, xi, y, yi, n) {
    var i,d = 0;
    for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
    return (1 & ((d - 1) >>> 8)) - 1;
  }

  function crypto_verify_16(x, xi, y, yi) {
    return vn(x,xi,y,yi,16);
  }

  function crypto_verify_32(x, xi, y, yi) {
    return vn(x,xi,y,yi,32);
  }

  function core_salsa20(o, p, k, c) {
    var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
        j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
        j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
        j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
        j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
        j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
        j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
        j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
        j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
        j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
        j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
        j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
        j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
        j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
        j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
        j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

    var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
        x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
        x15 = j15, u;

    for (var i = 0; i < 20; i += 2) {
      u = x0 + x12 | 0;
      x4 ^= u<<7 | u>>>(32-7);
      u = x4 + x0 | 0;
      x8 ^= u<<9 | u>>>(32-9);
      u = x8 + x4 | 0;
      x12 ^= u<<13 | u>>>(32-13);
      u = x12 + x8 | 0;
      x0 ^= u<<18 | u>>>(32-18);

      u = x5 + x1 | 0;
      x9 ^= u<<7 | u>>>(32-7);
      u = x9 + x5 | 0;
      x13 ^= u<<9 | u>>>(32-9);
      u = x13 + x9 | 0;
      x1 ^= u<<13 | u>>>(32-13);
      u = x1 + x13 | 0;
      x5 ^= u<<18 | u>>>(32-18);

      u = x10 + x6 | 0;
      x14 ^= u<<7 | u>>>(32-7);
      u = x14 + x10 | 0;
      x2 ^= u<<9 | u>>>(32-9);
      u = x2 + x14 | 0;
      x6 ^= u<<13 | u>>>(32-13);
      u = x6 + x2 | 0;
      x10 ^= u<<18 | u>>>(32-18);

      u = x15 + x11 | 0;
      x3 ^= u<<7 | u>>>(32-7);
      u = x3 + x15 | 0;
      x7 ^= u<<9 | u>>>(32-9);
      u = x7 + x3 | 0;
      x11 ^= u<<13 | u>>>(32-13);
      u = x11 + x7 | 0;
      x15 ^= u<<18 | u>>>(32-18);

      u = x0 + x3 | 0;
      x1 ^= u<<7 | u>>>(32-7);
      u = x1 + x0 | 0;
      x2 ^= u<<9 | u>>>(32-9);
      u = x2 + x1 | 0;
      x3 ^= u<<13 | u>>>(32-13);
      u = x3 + x2 | 0;
      x0 ^= u<<18 | u>>>(32-18);

      u = x5 + x4 | 0;
      x6 ^= u<<7 | u>>>(32-7);
      u = x6 + x5 | 0;
      x7 ^= u<<9 | u>>>(32-9);
      u = x7 + x6 | 0;
      x4 ^= u<<13 | u>>>(32-13);
      u = x4 + x7 | 0;
      x5 ^= u<<18 | u>>>(32-18);

      u = x10 + x9 | 0;
      x11 ^= u<<7 | u>>>(32-7);
      u = x11 + x10 | 0;
      x8 ^= u<<9 | u>>>(32-9);
      u = x8 + x11 | 0;
      x9 ^= u<<13 | u>>>(32-13);
      u = x9 + x8 | 0;
      x10 ^= u<<18 | u>>>(32-18);

      u = x15 + x14 | 0;
      x12 ^= u<<7 | u>>>(32-7);
      u = x12 + x15 | 0;
      x13 ^= u<<9 | u>>>(32-9);
      u = x13 + x12 | 0;
      x14 ^= u<<13 | u>>>(32-13);
      u = x14 + x13 | 0;
      x15 ^= u<<18 | u>>>(32-18);
    }
     x0 =  x0 +  j0 | 0;
     x1 =  x1 +  j1 | 0;
     x2 =  x2 +  j2 | 0;
     x3 =  x3 +  j3 | 0;
     x4 =  x4 +  j4 | 0;
     x5 =  x5 +  j5 | 0;
     x6 =  x6 +  j6 | 0;
     x7 =  x7 +  j7 | 0;
     x8 =  x8 +  j8 | 0;
     x9 =  x9 +  j9 | 0;
    x10 = x10 + j10 | 0;
    x11 = x11 + j11 | 0;
    x12 = x12 + j12 | 0;
    x13 = x13 + j13 | 0;
    x14 = x14 + j14 | 0;
    x15 = x15 + j15 | 0;

    o[ 0] = x0 >>>  0 & 0xff;
    o[ 1] = x0 >>>  8 & 0xff;
    o[ 2] = x0 >>> 16 & 0xff;
    o[ 3] = x0 >>> 24 & 0xff;

    o[ 4] = x1 >>>  0 & 0xff;
    o[ 5] = x1 >>>  8 & 0xff;
    o[ 6] = x1 >>> 16 & 0xff;
    o[ 7] = x1 >>> 24 & 0xff;

    o[ 8] = x2 >>>  0 & 0xff;
    o[ 9] = x2 >>>  8 & 0xff;
    o[10] = x2 >>> 16 & 0xff;
    o[11] = x2 >>> 24 & 0xff;

    o[12] = x3 >>>  0 & 0xff;
    o[13] = x3 >>>  8 & 0xff;
    o[14] = x3 >>> 16 & 0xff;
    o[15] = x3 >>> 24 & 0xff;

    o[16] = x4 >>>  0 & 0xff;
    o[17] = x4 >>>  8 & 0xff;
    o[18] = x4 >>> 16 & 0xff;
    o[19] = x4 >>> 24 & 0xff;

    o[20] = x5 >>>  0 & 0xff;
    o[21] = x5 >>>  8 & 0xff;
    o[22] = x5 >>> 16 & 0xff;
    o[23] = x5 >>> 24 & 0xff;

    o[24] = x6 >>>  0 & 0xff;
    o[25] = x6 >>>  8 & 0xff;
    o[26] = x6 >>> 16 & 0xff;
    o[27] = x6 >>> 24 & 0xff;

    o[28] = x7 >>>  0 & 0xff;
    o[29] = x7 >>>  8 & 0xff;
    o[30] = x7 >>> 16 & 0xff;
    o[31] = x7 >>> 24 & 0xff;

    o[32] = x8 >>>  0 & 0xff;
    o[33] = x8 >>>  8 & 0xff;
    o[34] = x8 >>> 16 & 0xff;
    o[35] = x8 >>> 24 & 0xff;

    o[36] = x9 >>>  0 & 0xff;
    o[37] = x9 >>>  8 & 0xff;
    o[38] = x9 >>> 16 & 0xff;
    o[39] = x9 >>> 24 & 0xff;

    o[40] = x10 >>>  0 & 0xff;
    o[41] = x10 >>>  8 & 0xff;
    o[42] = x10 >>> 16 & 0xff;
    o[43] = x10 >>> 24 & 0xff;

    o[44] = x11 >>>  0 & 0xff;
    o[45] = x11 >>>  8 & 0xff;
    o[46] = x11 >>> 16 & 0xff;
    o[47] = x11 >>> 24 & 0xff;

    o[48] = x12 >>>  0 & 0xff;
    o[49] = x12 >>>  8 & 0xff;
    o[50] = x12 >>> 16 & 0xff;
    o[51] = x12 >>> 24 & 0xff;

    o[52] = x13 >>>  0 & 0xff;
    o[53] = x13 >>>  8 & 0xff;
    o[54] = x13 >>> 16 & 0xff;
    o[55] = x13 >>> 24 & 0xff;

    o[56] = x14 >>>  0 & 0xff;
    o[57] = x14 >>>  8 & 0xff;
    o[58] = x14 >>> 16 & 0xff;
    o[59] = x14 >>> 24 & 0xff;

    o[60] = x15 >>>  0 & 0xff;
    o[61] = x15 >>>  8 & 0xff;
    o[62] = x15 >>> 16 & 0xff;
    o[63] = x15 >>> 24 & 0xff;
  }

  function core_hsalsa20(o,p,k,c) {
    var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
        j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
        j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
        j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
        j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
        j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
        j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
        j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
        j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
        j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
        j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
        j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
        j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
        j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
        j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
        j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

    var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
        x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
        x15 = j15, u;

    for (var i = 0; i < 20; i += 2) {
      u = x0 + x12 | 0;
      x4 ^= u<<7 | u>>>(32-7);
      u = x4 + x0 | 0;
      x8 ^= u<<9 | u>>>(32-9);
      u = x8 + x4 | 0;
      x12 ^= u<<13 | u>>>(32-13);
      u = x12 + x8 | 0;
      x0 ^= u<<18 | u>>>(32-18);

      u = x5 + x1 | 0;
      x9 ^= u<<7 | u>>>(32-7);
      u = x9 + x5 | 0;
      x13 ^= u<<9 | u>>>(32-9);
      u = x13 + x9 | 0;
      x1 ^= u<<13 | u>>>(32-13);
      u = x1 + x13 | 0;
      x5 ^= u<<18 | u>>>(32-18);

      u = x10 + x6 | 0;
      x14 ^= u<<7 | u>>>(32-7);
      u = x14 + x10 | 0;
      x2 ^= u<<9 | u>>>(32-9);
      u = x2 + x14 | 0;
      x6 ^= u<<13 | u>>>(32-13);
      u = x6 + x2 | 0;
      x10 ^= u<<18 | u>>>(32-18);

      u = x15 + x11 | 0;
      x3 ^= u<<7 | u>>>(32-7);
      u = x3 + x15 | 0;
      x7 ^= u<<9 | u>>>(32-9);
      u = x7 + x3 | 0;
      x11 ^= u<<13 | u>>>(32-13);
      u = x11 + x7 | 0;
      x15 ^= u<<18 | u>>>(32-18);

      u = x0 + x3 | 0;
      x1 ^= u<<7 | u>>>(32-7);
      u = x1 + x0 | 0;
      x2 ^= u<<9 | u>>>(32-9);
      u = x2 + x1 | 0;
      x3 ^= u<<13 | u>>>(32-13);
      u = x3 + x2 | 0;
      x0 ^= u<<18 | u>>>(32-18);

      u = x5 + x4 | 0;
      x6 ^= u<<7 | u>>>(32-7);
      u = x6 + x5 | 0;
      x7 ^= u<<9 | u>>>(32-9);
      u = x7 + x6 | 0;
      x4 ^= u<<13 | u>>>(32-13);
      u = x4 + x7 | 0;
      x5 ^= u<<18 | u>>>(32-18);

      u = x10 + x9 | 0;
      x11 ^= u<<7 | u>>>(32-7);
      u = x11 + x10 | 0;
      x8 ^= u<<9 | u>>>(32-9);
      u = x8 + x11 | 0;
      x9 ^= u<<13 | u>>>(32-13);
      u = x9 + x8 | 0;
      x10 ^= u<<18 | u>>>(32-18);

      u = x15 + x14 | 0;
      x12 ^= u<<7 | u>>>(32-7);
      u = x12 + x15 | 0;
      x13 ^= u<<9 | u>>>(32-9);
      u = x13 + x12 | 0;
      x14 ^= u<<13 | u>>>(32-13);
      u = x14 + x13 | 0;
      x15 ^= u<<18 | u>>>(32-18);
    }

    o[ 0] = x0 >>>  0 & 0xff;
    o[ 1] = x0 >>>  8 & 0xff;
    o[ 2] = x0 >>> 16 & 0xff;
    o[ 3] = x0 >>> 24 & 0xff;

    o[ 4] = x5 >>>  0 & 0xff;
    o[ 5] = x5 >>>  8 & 0xff;
    o[ 6] = x5 >>> 16 & 0xff;
    o[ 7] = x5 >>> 24 & 0xff;

    o[ 8] = x10 >>>  0 & 0xff;
    o[ 9] = x10 >>>  8 & 0xff;
    o[10] = x10 >>> 16 & 0xff;
    o[11] = x10 >>> 24 & 0xff;

    o[12] = x15 >>>  0 & 0xff;
    o[13] = x15 >>>  8 & 0xff;
    o[14] = x15 >>> 16 & 0xff;
    o[15] = x15 >>> 24 & 0xff;

    o[16] = x6 >>>  0 & 0xff;
    o[17] = x6 >>>  8 & 0xff;
    o[18] = x6 >>> 16 & 0xff;
    o[19] = x6 >>> 24 & 0xff;

    o[20] = x7 >>>  0 & 0xff;
    o[21] = x7 >>>  8 & 0xff;
    o[22] = x7 >>> 16 & 0xff;
    o[23] = x7 >>> 24 & 0xff;

    o[24] = x8 >>>  0 & 0xff;
    o[25] = x8 >>>  8 & 0xff;
    o[26] = x8 >>> 16 & 0xff;
    o[27] = x8 >>> 24 & 0xff;

    o[28] = x9 >>>  0 & 0xff;
    o[29] = x9 >>>  8 & 0xff;
    o[30] = x9 >>> 16 & 0xff;
    o[31] = x9 >>> 24 & 0xff;
  }

  function crypto_core_salsa20(out,inp,k,c) {
    core_salsa20(out,inp,k,c);
  }

  function crypto_core_hsalsa20(out,inp,k,c) {
    core_hsalsa20(out,inp,k,c);
  }

  var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
              // "expand 32-byte k"

  function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
    var z = new Uint8Array(16), x = new Uint8Array(64);
    var u, i;
    for (i = 0; i < 16; i++) z[i] = 0;
    for (i = 0; i < 8; i++) z[i] = n[i];
    while (b >= 64) {
      crypto_core_salsa20(x,z,k,sigma);
      for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
      u = 1;
      for (i = 8; i < 16; i++) {
        u = u + (z[i] & 0xff) | 0;
        z[i] = u & 0xff;
        u >>>= 8;
      }
      b -= 64;
      cpos += 64;
      mpos += 64;
    }
    if (b > 0) {
      crypto_core_salsa20(x,z,k,sigma);
      for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    }
    return 0;
  }

  function crypto_stream_salsa20(c,cpos,b,n,k) {
    var z = new Uint8Array(16), x = new Uint8Array(64);
    var u, i;
    for (i = 0; i < 16; i++) z[i] = 0;
    for (i = 0; i < 8; i++) z[i] = n[i];
    while (b >= 64) {
      crypto_core_salsa20(x,z,k,sigma);
      for (i = 0; i < 64; i++) c[cpos+i] = x[i];
      u = 1;
      for (i = 8; i < 16; i++) {
        u = u + (z[i] & 0xff) | 0;
        z[i] = u & 0xff;
        u >>>= 8;
      }
      b -= 64;
      cpos += 64;
    }
    if (b > 0) {
      crypto_core_salsa20(x,z,k,sigma);
      for (i = 0; i < b; i++) c[cpos+i] = x[i];
    }
    return 0;
  }

  function crypto_stream(c,cpos,d,n,k) {
    var s = new Uint8Array(32);
    crypto_core_hsalsa20(s,n,k,sigma);
    var sn = new Uint8Array(8);
    for (var i = 0; i < 8; i++) sn[i] = n[i+16];
    return crypto_stream_salsa20(c,cpos,d,sn,s);
  }

  function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
    var s = new Uint8Array(32);
    crypto_core_hsalsa20(s,n,k,sigma);
    var sn = new Uint8Array(8);
    for (var i = 0; i < 8; i++) sn[i] = n[i+16];
    return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
  }

  /*
  * Port of Andrew Moon's Poly1305-donna-16. Public domain.
  * https://github.com/floodyberry/poly1305-donna
  */

  var poly1305 = function(key) {
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.leftover = 0;
    this.fin = 0;

    var t0, t1, t2, t3, t4, t5, t6, t7;

    t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
    t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
    t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
    this.r[5] = ((t4 >>>  1)) & 0x1ffe;
    t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
    t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    this.r[9] = ((t7 >>>  5)) & 0x007f;

    this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
    this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
    this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
    this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
    this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
    this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
    this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
    this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
  };

  poly1305.prototype.blocks = function(m, mpos, bytes) {
    var hibit = this.fin ? 0 : (1 << 11);
    var t0, t1, t2, t3, t4, t5, t6, t7, c;
    var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

    var h0 = this.h[0],
        h1 = this.h[1],
        h2 = this.h[2],
        h3 = this.h[3],
        h4 = this.h[4],
        h5 = this.h[5],
        h6 = this.h[6],
        h7 = this.h[7],
        h8 = this.h[8],
        h9 = this.h[9];

    var r0 = this.r[0],
        r1 = this.r[1],
        r2 = this.r[2],
        r3 = this.r[3],
        r4 = this.r[4],
        r5 = this.r[5],
        r6 = this.r[6],
        r7 = this.r[7],
        r8 = this.r[8],
        r9 = this.r[9];

    while (bytes >= 16) {
      t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
      t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
      t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
      t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
      t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
      h5 += ((t4 >>>  1)) & 0x1fff;
      t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
      t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
      t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
      h9 += ((t7 >>> 5)) | hibit;

      c = 0;

      d0 = c;
      d0 += h0 * r0;
      d0 += h1 * (5 * r9);
      d0 += h2 * (5 * r8);
      d0 += h3 * (5 * r7);
      d0 += h4 * (5 * r6);
      c = (d0 >>> 13); d0 &= 0x1fff;
      d0 += h5 * (5 * r5);
      d0 += h6 * (5 * r4);
      d0 += h7 * (5 * r3);
      d0 += h8 * (5 * r2);
      d0 += h9 * (5 * r1);
      c += (d0 >>> 13); d0 &= 0x1fff;

      d1 = c;
      d1 += h0 * r1;
      d1 += h1 * r0;
      d1 += h2 * (5 * r9);
      d1 += h3 * (5 * r8);
      d1 += h4 * (5 * r7);
      c = (d1 >>> 13); d1 &= 0x1fff;
      d1 += h5 * (5 * r6);
      d1 += h6 * (5 * r5);
      d1 += h7 * (5 * r4);
      d1 += h8 * (5 * r3);
      d1 += h9 * (5 * r2);
      c += (d1 >>> 13); d1 &= 0x1fff;

      d2 = c;
      d2 += h0 * r2;
      d2 += h1 * r1;
      d2 += h2 * r0;
      d2 += h3 * (5 * r9);
      d2 += h4 * (5 * r8);
      c = (d2 >>> 13); d2 &= 0x1fff;
      d2 += h5 * (5 * r7);
      d2 += h6 * (5 * r6);
      d2 += h7 * (5 * r5);
      d2 += h8 * (5 * r4);
      d2 += h9 * (5 * r3);
      c += (d2 >>> 13); d2 &= 0x1fff;

      d3 = c;
      d3 += h0 * r3;
      d3 += h1 * r2;
      d3 += h2 * r1;
      d3 += h3 * r0;
      d3 += h4 * (5 * r9);
      c = (d3 >>> 13); d3 &= 0x1fff;
      d3 += h5 * (5 * r8);
      d3 += h6 * (5 * r7);
      d3 += h7 * (5 * r6);
      d3 += h8 * (5 * r5);
      d3 += h9 * (5 * r4);
      c += (d3 >>> 13); d3 &= 0x1fff;

      d4 = c;
      d4 += h0 * r4;
      d4 += h1 * r3;
      d4 += h2 * r2;
      d4 += h3 * r1;
      d4 += h4 * r0;
      c = (d4 >>> 13); d4 &= 0x1fff;
      d4 += h5 * (5 * r9);
      d4 += h6 * (5 * r8);
      d4 += h7 * (5 * r7);
      d4 += h8 * (5 * r6);
      d4 += h9 * (5 * r5);
      c += (d4 >>> 13); d4 &= 0x1fff;

      d5 = c;
      d5 += h0 * r5;
      d5 += h1 * r4;
      d5 += h2 * r3;
      d5 += h3 * r2;
      d5 += h4 * r1;
      c = (d5 >>> 13); d5 &= 0x1fff;
      d5 += h5 * r0;
      d5 += h6 * (5 * r9);
      d5 += h7 * (5 * r8);
      d5 += h8 * (5 * r7);
      d5 += h9 * (5 * r6);
      c += (d5 >>> 13); d5 &= 0x1fff;

      d6 = c;
      d6 += h0 * r6;
      d6 += h1 * r5;
      d6 += h2 * r4;
      d6 += h3 * r3;
      d6 += h4 * r2;
      c = (d6 >>> 13); d6 &= 0x1fff;
      d6 += h5 * r1;
      d6 += h6 * r0;
      d6 += h7 * (5 * r9);
      d6 += h8 * (5 * r8);
      d6 += h9 * (5 * r7);
      c += (d6 >>> 13); d6 &= 0x1fff;

      d7 = c;
      d7 += h0 * r7;
      d7 += h1 * r6;
      d7 += h2 * r5;
      d7 += h3 * r4;
      d7 += h4 * r3;
      c = (d7 >>> 13); d7 &= 0x1fff;
      d7 += h5 * r2;
      d7 += h6 * r1;
      d7 += h7 * r0;
      d7 += h8 * (5 * r9);
      d7 += h9 * (5 * r8);
      c += (d7 >>> 13); d7 &= 0x1fff;

      d8 = c;
      d8 += h0 * r8;
      d8 += h1 * r7;
      d8 += h2 * r6;
      d8 += h3 * r5;
      d8 += h4 * r4;
      c = (d8 >>> 13); d8 &= 0x1fff;
      d8 += h5 * r3;
      d8 += h6 * r2;
      d8 += h7 * r1;
      d8 += h8 * r0;
      d8 += h9 * (5 * r9);
      c += (d8 >>> 13); d8 &= 0x1fff;

      d9 = c;
      d9 += h0 * r9;
      d9 += h1 * r8;
      d9 += h2 * r7;
      d9 += h3 * r6;
      d9 += h4 * r5;
      c = (d9 >>> 13); d9 &= 0x1fff;
      d9 += h5 * r4;
      d9 += h6 * r3;
      d9 += h7 * r2;
      d9 += h8 * r1;
      d9 += h9 * r0;
      c += (d9 >>> 13); d9 &= 0x1fff;

      c = (((c << 2) + c)) | 0;
      c = (c + d0) | 0;
      d0 = c & 0x1fff;
      c = (c >>> 13);
      d1 += c;

      h0 = d0;
      h1 = d1;
      h2 = d2;
      h3 = d3;
      h4 = d4;
      h5 = d5;
      h6 = d6;
      h7 = d7;
      h8 = d8;
      h9 = d9;

      mpos += 16;
      bytes -= 16;
    }
    this.h[0] = h0;
    this.h[1] = h1;
    this.h[2] = h2;
    this.h[3] = h3;
    this.h[4] = h4;
    this.h[5] = h5;
    this.h[6] = h6;
    this.h[7] = h7;
    this.h[8] = h8;
    this.h[9] = h9;
  };

  poly1305.prototype.finish = function(mac, macpos) {
    var g = new Uint16Array(10);
    var c, mask, f, i;

    if (this.leftover) {
      i = this.leftover;
      this.buffer[i++] = 1;
      for (; i < 16; i++) this.buffer[i] = 0;
      this.fin = 1;
      this.blocks(this.buffer, 0, 16);
    }

    c = this.h[1] >>> 13;
    this.h[1] &= 0x1fff;
    for (i = 2; i < 10; i++) {
      this.h[i] += c;
      c = this.h[i] >>> 13;
      this.h[i] &= 0x1fff;
    }
    this.h[0] += (c * 5);
    c = this.h[0] >>> 13;
    this.h[0] &= 0x1fff;
    this.h[1] += c;
    c = this.h[1] >>> 13;
    this.h[1] &= 0x1fff;
    this.h[2] += c;

    g[0] = this.h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 0x1fff;
    for (i = 1; i < 10; i++) {
      g[i] = this.h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 0x1fff;
    }
    g[9] -= (1 << 13);

    mask = (c ^ 1) - 1;
    for (i = 0; i < 10; i++) g[i] &= mask;
    mask = ~mask;
    for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

    this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
    this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
    this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
    this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
    this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
    this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
    this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
    this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

    f = this.h[0] + this.pad[0];
    this.h[0] = f & 0xffff;
    for (i = 1; i < 8; i++) {
      f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
      this.h[i] = f & 0xffff;
    }

    mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
    mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
    mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
    mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
    mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
    mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
    mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
    mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
    mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
    mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
    mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
    mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
    mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
    mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
    mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
    mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
  };

  poly1305.prototype.update = function(m, mpos, bytes) {
    var i, want;

    if (this.leftover) {
      want = (16 - this.leftover);
      if (want > bytes)
        want = bytes;
      for (i = 0; i < want; i++)
        this.buffer[this.leftover + i] = m[mpos+i];
      bytes -= want;
      mpos += want;
      this.leftover += want;
      if (this.leftover < 16)
        return;
      this.blocks(this.buffer, 0, 16);
      this.leftover = 0;
    }

    if (bytes >= 16) {
      want = bytes - (bytes % 16);
      this.blocks(m, mpos, want);
      mpos += want;
      bytes -= want;
    }

    if (bytes) {
      for (i = 0; i < bytes; i++)
        this.buffer[this.leftover + i] = m[mpos+i];
      this.leftover += bytes;
    }
  };

  function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
    var s = new poly1305(k);
    s.update(m, mpos, n);
    s.finish(out, outpos);
    return 0;
  }

  function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
    var x = new Uint8Array(16);
    crypto_onetimeauth(x,0,m,mpos,n,k);
    return crypto_verify_16(h,hpos,x,0);
  }

  function crypto_secretbox(c,m,d,n,k) {
    var i;
    if (d < 32) return -1;
    crypto_stream_xor(c,0,m,0,d,n,k);
    crypto_onetimeauth(c, 16, c, 32, d - 32, c);
    for (i = 0; i < 16; i++) c[i] = 0;
    return 0;
  }

  function crypto_secretbox_open(m,c,d,n,k) {
    var i;
    var x = new Uint8Array(32);
    if (d < 32) return -1;
    crypto_stream(x,0,32,n,k);
    if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
    crypto_stream_xor(m,0,c,0,d,n,k);
    for (i = 0; i < 32; i++) m[i] = 0;
    return 0;
  }

  function set25519(r, a) {
    var i;
    for (i = 0; i < 16; i++) r[i] = a[i]|0;
  }

  function car25519(o) {
    var i, v, c = 1;
    for (i = 0; i < 16; i++) {
      v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c-1 + 37 * (c-1);
  }

  function sel25519(p, q, b) {
    var t, c = ~(b-1);
    for (var i = 0; i < 16; i++) {
      t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }

  function pack25519(o, n) {
    var i, j, b;
    var m = gf(), t = gf();
    for (i = 0; i < 16; i++) t[i] = n[i];
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; j++) {
      m[0] = t[0] - 0xffed;
      for (i = 1; i < 15; i++) {
        m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
        m[i-1] &= 0xffff;
      }
      m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
      b = (m[15]>>16) & 1;
      m[14] &= 0xffff;
      sel25519(t, m, 1-b);
    }
    for (i = 0; i < 16; i++) {
      o[2*i] = t[i] & 0xff;
      o[2*i+1] = t[i]>>8;
    }
  }

  function neq25519(a, b) {
    var c = new Uint8Array(32), d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return crypto_verify_32(c, 0, d, 0);
  }

  function par25519(a) {
    var d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
  }

  function unpack25519(o, n) {
    var i;
    for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
    o[15] &= 0x7fff;
  }

  function A(o, a, b) {
    for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
  }

  function Z(o, a, b) {
    for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
  }

  function M(o, a, b) {
    var v, c,
       t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
       t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
      t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
      t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
      b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11],
      b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;

    t0  += 38 * t16;
    t1  += 38 * t17;
    t2  += 38 * t18;
    t3  += 38 * t19;
    t4  += 38 * t20;
    t5  += 38 * t21;
    t6  += 38 * t22;
    t7  += 38 * t23;
    t8  += 38 * t24;
    t9  += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is

    // first car
    c = 1;
    v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
    v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
    v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
    v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
    v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
    v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
    v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
    v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
    v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
    v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
    v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
    v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
    v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
    v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
    v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
    v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
    t0 += c-1 + 37 * (c-1);

    // second car
    c = 1;
    v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
    v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
    v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
    v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
    v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
    v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
    v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
    v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
    v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
    v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
    v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
    v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
    v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
    v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
    v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
    v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
    t0 += c-1 + 37 * (c-1);

    o[ 0] = t0;
    o[ 1] = t1;
    o[ 2] = t2;
    o[ 3] = t3;
    o[ 4] = t4;
    o[ 5] = t5;
    o[ 6] = t6;
    o[ 7] = t7;
    o[ 8] = t8;
    o[ 9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }

  function S(o, a) {
    M(o, a, a);
  }

  function inv25519(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++) c[a] = i[a];
    for (a = 253; a >= 0; a--) {
      S(c, c);
      if(a !== 2 && a !== 4) M(c, c, i);
    }
    for (a = 0; a < 16; a++) o[a] = c[a];
  }

  function pow2523(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; a++) c[a] = i[a];
    for (a = 250; a >= 0; a--) {
        S(c, c);
        if(a !== 1) M(c, c, i);
    }
    for (a = 0; a < 16; a++) o[a] = c[a];
  }

  function crypto_scalarmult(q, n, p) {
    var z = new Uint8Array(32);
    var x = new Float64Array(80), r, i;
    var a = gf(), b = gf(), c = gf(),
        d = gf(), e = gf(), f = gf();
    for (i = 0; i < 31; i++) z[i] = n[i];
    z[31]=(n[31]&127)|64;
    z[0]&=248;
    unpack25519(x,p);
    for (i = 0; i < 16; i++) {
      b[i]=x[i];
      d[i]=a[i]=c[i]=0;
    }
    a[0]=d[0]=1;
    for (i=254; i>=0; --i) {
      r=(z[i>>>3]>>>(i&7))&1;
      sel25519(a,b,r);
      sel25519(c,d,r);
      A(e,a,c);
      Z(a,a,c);
      A(c,b,d);
      Z(b,b,d);
      S(d,e);
      S(f,a);
      M(a,c,a);
      M(c,b,e);
      A(e,a,c);
      Z(a,a,c);
      S(b,a);
      Z(c,d,f);
      M(a,c,_121665);
      A(a,a,d);
      M(c,c,a);
      M(a,d,f);
      M(d,b,x);
      S(b,e);
      sel25519(a,b,r);
      sel25519(c,d,r);
    }
    for (i = 0; i < 16; i++) {
      x[i+16]=a[i];
      x[i+32]=c[i];
      x[i+48]=b[i];
      x[i+64]=d[i];
    }
    var x32 = x.subarray(32);
    var x16 = x.subarray(16);
    inv25519(x32,x32);
    M(x16,x16,x32);
    pack25519(q,x16);
    return 0;
  }

  function crypto_scalarmult_base(q, n) {
    return crypto_scalarmult(q, n, _9);
  }

  function crypto_box_keypair(y, x) {
    randombytes(x, 32);
    return crypto_scalarmult_base(y, x);
  }

  function crypto_box_beforenm(k, y, x) {
    var s = new Uint8Array(32);
    crypto_scalarmult(s, x, y);
    return crypto_core_hsalsa20(k, _0, s, sigma);
  }

  var crypto_box_afternm = crypto_secretbox;
  var crypto_box_open_afternm = crypto_secretbox_open;

  function crypto_box(c, m, d, n, y, x) {
    var k = new Uint8Array(32);
    crypto_box_beforenm(k, y, x);
    return crypto_box_afternm(c, m, d, n, k);
  }

  function crypto_box_open(m, c, d, n, y, x) {
    var k = new Uint8Array(32);
    crypto_box_beforenm(k, y, x);
    return crypto_box_open_afternm(m, c, d, n, k);
  }

  var K = [
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  ];

  function crypto_hashblocks_hl(hh, hl, m, n) {
    var wh = new Int32Array(16), wl = new Int32Array(16),
        bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
        bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
        th, tl, i, j, h, l, a, b, c, d;

    var ah0 = hh[0],
        ah1 = hh[1],
        ah2 = hh[2],
        ah3 = hh[3],
        ah4 = hh[4],
        ah5 = hh[5],
        ah6 = hh[6],
        ah7 = hh[7],

        al0 = hl[0],
        al1 = hl[1],
        al2 = hl[2],
        al3 = hl[3],
        al4 = hl[4],
        al5 = hl[5],
        al6 = hl[6],
        al7 = hl[7];

    var pos = 0;
    while (n >= 128) {
      for (i = 0; i < 16; i++) {
        j = 8 * i + pos;
        wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
        wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
      }
      for (i = 0; i < 80; i++) {
        bh0 = ah0;
        bh1 = ah1;
        bh2 = ah2;
        bh3 = ah3;
        bh4 = ah4;
        bh5 = ah5;
        bh6 = ah6;
        bh7 = ah7;

        bl0 = al0;
        bl1 = al1;
        bl2 = al2;
        bl3 = al3;
        bl4 = al4;
        bl5 = al5;
        bl6 = al6;
        bl7 = al7;

        // add
        h = ah7;
        l = al7;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        // Sigma1
        h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
        l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        // Ch
        h = (ah4 & ah5) ^ (~ah4 & ah6);
        l = (al4 & al5) ^ (~al4 & al6);

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        // K
        h = K[i*2];
        l = K[i*2+1];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        // w
        h = wh[i%16];
        l = wl[i%16];

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        th = c & 0xffff | d << 16;
        tl = a & 0xffff | b << 16;

        // add
        h = th;
        l = tl;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        // Sigma0
        h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
        l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        // Maj
        h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
        l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        bh7 = (c & 0xffff) | (d << 16);
        bl7 = (a & 0xffff) | (b << 16);

        // add
        h = bh3;
        l = bl3;

        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;

        h = th;
        l = tl;

        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;

        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;

        bh3 = (c & 0xffff) | (d << 16);
        bl3 = (a & 0xffff) | (b << 16);

        ah1 = bh0;
        ah2 = bh1;
        ah3 = bh2;
        ah4 = bh3;
        ah5 = bh4;
        ah6 = bh5;
        ah7 = bh6;
        ah0 = bh7;

        al1 = bl0;
        al2 = bl1;
        al3 = bl2;
        al4 = bl3;
        al5 = bl4;
        al6 = bl5;
        al7 = bl6;
        al0 = bl7;

        if (i%16 === 15) {
          for (j = 0; j < 16; j++) {
            // add
            h = wh[j];
            l = wl[j];

            a = l & 0xffff; b = l >>> 16;
            c = h & 0xffff; d = h >>> 16;

            h = wh[(j+9)%16];
            l = wl[(j+9)%16];

            a += l & 0xffff; b += l >>> 16;
            c += h & 0xffff; d += h >>> 16;

            // sigma0
            th = wh[(j+1)%16];
            tl = wl[(j+1)%16];
            h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
            l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

            a += l & 0xffff; b += l >>> 16;
            c += h & 0xffff; d += h >>> 16;

            // sigma1
            th = wh[(j+14)%16];
            tl = wl[(j+14)%16];
            h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
            l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

            a += l & 0xffff; b += l >>> 16;
            c += h & 0xffff; d += h >>> 16;

            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;

            wh[j] = (c & 0xffff) | (d << 16);
            wl[j] = (a & 0xffff) | (b << 16);
          }
        }
      }

      // add
      h = ah0;
      l = al0;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[0];
      l = hl[0];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[0] = ah0 = (c & 0xffff) | (d << 16);
      hl[0] = al0 = (a & 0xffff) | (b << 16);

      h = ah1;
      l = al1;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[1];
      l = hl[1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[1] = ah1 = (c & 0xffff) | (d << 16);
      hl[1] = al1 = (a & 0xffff) | (b << 16);

      h = ah2;
      l = al2;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[2];
      l = hl[2];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[2] = ah2 = (c & 0xffff) | (d << 16);
      hl[2] = al2 = (a & 0xffff) | (b << 16);

      h = ah3;
      l = al3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[3];
      l = hl[3];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[3] = ah3 = (c & 0xffff) | (d << 16);
      hl[3] = al3 = (a & 0xffff) | (b << 16);

      h = ah4;
      l = al4;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[4];
      l = hl[4];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[4] = ah4 = (c & 0xffff) | (d << 16);
      hl[4] = al4 = (a & 0xffff) | (b << 16);

      h = ah5;
      l = al5;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[5];
      l = hl[5];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[5] = ah5 = (c & 0xffff) | (d << 16);
      hl[5] = al5 = (a & 0xffff) | (b << 16);

      h = ah6;
      l = al6;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[6];
      l = hl[6];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[6] = ah6 = (c & 0xffff) | (d << 16);
      hl[6] = al6 = (a & 0xffff) | (b << 16);

      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = hh[7];
      l = hl[7];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      hh[7] = ah7 = (c & 0xffff) | (d << 16);
      hl[7] = al7 = (a & 0xffff) | (b << 16);

      pos += 128;
      n -= 128;
    }

    return n;
  }

  function crypto_hash(out, m, n) {
    var hh = new Int32Array(8),
        hl = new Int32Array(8),
        x = new Uint8Array(256),
        i, b = n;

    hh[0] = 0x6a09e667;
    hh[1] = 0xbb67ae85;
    hh[2] = 0x3c6ef372;
    hh[3] = 0xa54ff53a;
    hh[4] = 0x510e527f;
    hh[5] = 0x9b05688c;
    hh[6] = 0x1f83d9ab;
    hh[7] = 0x5be0cd19;

    hl[0] = 0xf3bcc908;
    hl[1] = 0x84caa73b;
    hl[2] = 0xfe94f82b;
    hl[3] = 0x5f1d36f1;
    hl[4] = 0xade682d1;
    hl[5] = 0x2b3e6c1f;
    hl[6] = 0xfb41bd6b;
    hl[7] = 0x137e2179;

    crypto_hashblocks_hl(hh, hl, m, n);
    n %= 128;

    for (i = 0; i < n; i++) x[i] = m[b-n+i];
    x[n] = 128;

    n = 256-128*(n<112?1:0);
    x[n-9] = 0;
    ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
    crypto_hashblocks_hl(hh, hl, x, n);

    for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

    return 0;
  }

  function add(p, q) {
    var a = gf(), b = gf(), c = gf(),
        d = gf(), e = gf(), f = gf(),
        g = gf(), h = gf(), t = gf();

    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);

    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
  }

  function cswap(p, q, b) {
    var i;
    for (i = 0; i < 4; i++) {
      sel25519(p[i], q[i], b);
    }
  }

  function pack(r, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
  }

  function scalarmult(p, q, s) {
    var b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
      b = (s[(i/8)|0] >> (i&7)) & 1;
      cswap(p, q, b);
      add(q, p);
      add(p, p);
      cswap(p, q, b);
    }
  }

  function scalarbase(p, s) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
  }

  function crypto_sign_keypair(pk, sk, seeded) {
    var d = new Uint8Array(64);
    var p = [gf(), gf(), gf(), gf()];
    var i;

    if (!seeded) randombytes(sk, 32);
    crypto_hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;

    scalarbase(p, d);
    pack(pk, p);

    for (i = 0; i < 32; i++) sk[i+32] = pk[i];
    return 0;
  }

  var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

  function modL(r, x) {
    var carry, i, j, k;
    for (i = 63; i >= 32; --i) {
      carry = 0;
      for (j = i - 32, k = i - 12; j < k; ++j) {
        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
        carry = Math.floor((x[j] + 128) / 256);
        x[j] -= carry * 256;
      }
      x[j] += carry;
      x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; j++) {
      x[j] += carry - (x[31] >> 4) * L[j];
      carry = x[j] >> 8;
      x[j] &= 255;
    }
    for (j = 0; j < 32; j++) x[j] -= carry * L[j];
    for (i = 0; i < 32; i++) {
      x[i+1] += x[i] >> 8;
      r[i] = x[i] & 255;
    }
  }

  function reduce(r) {
    var x = new Float64Array(64), i;
    for (i = 0; i < 64; i++) x[i] = r[i];
    for (i = 0; i < 64; i++) r[i] = 0;
    modL(r, x);
  }

  // Note: difference from C - smlen returned, not passed as argument.
  function crypto_sign(sm, m, n, sk) {
    var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
    var i, j, x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];

    crypto_hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;

    var smlen = n + 64;
    for (i = 0; i < n; i++) sm[64 + i] = m[i];
    for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

    crypto_hash(r, sm.subarray(32), n+32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);

    for (i = 32; i < 64; i++) sm[i] = sk[i];
    crypto_hash(h, sm, n + 64);
    reduce(h);

    for (i = 0; i < 64; i++) x[i] = 0;
    for (i = 0; i < 32; i++) x[i] = r[i];
    for (i = 0; i < 32; i++) {
      for (j = 0; j < 32; j++) {
        x[i+j] += h[i] * d[j];
      }
    }

    modL(sm.subarray(32), x);
    return smlen;
  }

  function unpackneg(r, p) {
    var t = gf(), chk = gf(), num = gf(),
        den = gf(), den2 = gf(), den4 = gf(),
        den6 = gf();

    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);

    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);

    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);

    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) M(r[0], r[0], I);

    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) return -1;

    if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

    M(r[3], r[0], r[1]);
    return 0;
  }

  function crypto_sign_open(m, sm, n, pk) {
    var i;
    var t = new Uint8Array(32), h = new Uint8Array(64);
    var p = [gf(), gf(), gf(), gf()],
        q = [gf(), gf(), gf(), gf()];

    if (n < 64) return -1;

    if (unpackneg(q, pk)) return -1;

    for (i = 0; i < n; i++) m[i] = sm[i];
    for (i = 0; i < 32; i++) m[i+32] = pk[i];
    crypto_hash(h, m, n);
    reduce(h);
    scalarmult(p, q, h);

    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);

    n -= 64;
    if (crypto_verify_32(sm, 0, t, 0)) {
      for (i = 0; i < n; i++) m[i] = 0;
      return -1;
    }

    for (i = 0; i < n; i++) m[i] = sm[i + 64];
    return n;
  }

  var crypto_secretbox_KEYBYTES = 32,
      crypto_secretbox_NONCEBYTES = 24,
      crypto_secretbox_ZEROBYTES = 32,
      crypto_secretbox_BOXZEROBYTES = 16,
      crypto_scalarmult_BYTES = 32,
      crypto_scalarmult_SCALARBYTES = 32,
      crypto_box_PUBLICKEYBYTES = 32,
      crypto_box_SECRETKEYBYTES = 32,
      crypto_box_BEFORENMBYTES = 32,
      crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
      crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
      crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
      crypto_sign_BYTES = 64,
      crypto_sign_PUBLICKEYBYTES = 32,
      crypto_sign_SECRETKEYBYTES = 64,
      crypto_sign_SEEDBYTES = 32,
      crypto_hash_BYTES = 64;

  nacl.lowlevel = {
    crypto_core_hsalsa20: crypto_core_hsalsa20,
    crypto_stream_xor: crypto_stream_xor,
    crypto_stream: crypto_stream,
    crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
    crypto_stream_salsa20: crypto_stream_salsa20,
    crypto_onetimeauth: crypto_onetimeauth,
    crypto_onetimeauth_verify: crypto_onetimeauth_verify,
    crypto_verify_16: crypto_verify_16,
    crypto_verify_32: crypto_verify_32,
    crypto_secretbox: crypto_secretbox,
    crypto_secretbox_open: crypto_secretbox_open,
    crypto_scalarmult: crypto_scalarmult,
    crypto_scalarmult_base: crypto_scalarmult_base,
    crypto_box_beforenm: crypto_box_beforenm,
    crypto_box_afternm: crypto_box_afternm,
    crypto_box: crypto_box,
    crypto_box_open: crypto_box_open,
    crypto_box_keypair: crypto_box_keypair,
    crypto_hash: crypto_hash,
    crypto_sign: crypto_sign,
    crypto_sign_keypair: crypto_sign_keypair,
    crypto_sign_open: crypto_sign_open,

    crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
    crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
    crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
    crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
    crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
    crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
    crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
    crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
    crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
    crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
    crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
    crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
    crypto_sign_BYTES: crypto_sign_BYTES,
    crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
    crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
    crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
    crypto_hash_BYTES: crypto_hash_BYTES,

    gf: gf,
    D: D,
    L: L,
    pack25519: pack25519,
    unpack25519: unpack25519,
    M: M,
    A: A,
    S: S,
    Z: Z,
    pow2523: pow2523,
    add: add,
    set25519: set25519,
    modL: modL,
    scalarmult: scalarmult,
    scalarbase: scalarbase,
  };

  /* High-level API */

  function checkLengths(k, n) {
    if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
    if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
  }

  function checkBoxLengths(pk, sk) {
    if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
    if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
  }

  function checkArrayTypes() {
    for (var i = 0; i < arguments.length; i++) {
      if (!(arguments[i] instanceof Uint8Array))
        throw new TypeError('unexpected type, use Uint8Array');
    }
  }

  function cleanup(arr) {
    for (var i = 0; i < arr.length; i++) arr[i] = 0;
  }

  nacl.randomBytes = function(n) {
    var b = new Uint8Array(n);
    randombytes(b, n);
    return b;
  };

  nacl.secretbox = function(msg, nonce, key) {
    checkArrayTypes(msg, nonce, key);
    checkLengths(key, nonce);
    var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
    var c = new Uint8Array(m.length);
    for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
    crypto_secretbox(c, m, m.length, nonce, key);
    return c.subarray(crypto_secretbox_BOXZEROBYTES);
  };

  nacl.secretbox.open = function(box, nonce, key) {
    checkArrayTypes(box, nonce, key);
    checkLengths(key, nonce);
    var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
    var m = new Uint8Array(c.length);
    for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
    if (c.length < 32) return null;
    if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
    return m.subarray(crypto_secretbox_ZEROBYTES);
  };

  nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
  nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
  nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

  nacl.scalarMult = function(n, p) {
    checkArrayTypes(n, p);
    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
    var q = new Uint8Array(crypto_scalarmult_BYTES);
    crypto_scalarmult(q, n, p);
    return q;
  };

  nacl.scalarMult.base = function(n) {
    checkArrayTypes(n);
    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    var q = new Uint8Array(crypto_scalarmult_BYTES);
    crypto_scalarmult_base(q, n);
    return q;
  };

  nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
  nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

  nacl.box = function(msg, nonce, publicKey, secretKey) {
    var k = nacl.box.before(publicKey, secretKey);
    return nacl.secretbox(msg, nonce, k);
  };

  nacl.box.before = function(publicKey, secretKey) {
    checkArrayTypes(publicKey, secretKey);
    checkBoxLengths(publicKey, secretKey);
    var k = new Uint8Array(crypto_box_BEFORENMBYTES);
    crypto_box_beforenm(k, publicKey, secretKey);
    return k;
  };

  nacl.box.after = nacl.secretbox;

  nacl.box.open = function(msg, nonce, publicKey, secretKey) {
    var k = nacl.box.before(publicKey, secretKey);
    return nacl.secretbox.open(msg, nonce, k);
  };

  nacl.box.open.after = nacl.secretbox.open;

  nacl.box.keyPair = function() {
    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
    crypto_box_keypair(pk, sk);
    return {publicKey: pk, secretKey: sk};
  };

  nacl.box.keyPair.fromSecretKey = function(secretKey) {
    checkArrayTypes(secretKey);
    if (secretKey.length !== crypto_box_SECRETKEYBYTES)
      throw new Error('bad secret key size');
    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    crypto_scalarmult_base(pk, secretKey);
    return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
  };

  nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
  nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
  nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
  nacl.box.nonceLength = crypto_box_NONCEBYTES;
  nacl.box.overheadLength = nacl.secretbox.overheadLength;

  nacl.sign = function(msg, secretKey) {
    checkArrayTypes(msg, secretKey);
    if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
      throw new Error('bad secret key size');
    var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
    crypto_sign(signedMsg, msg, msg.length, secretKey);
    return signedMsg;
  };

  nacl.sign.open = function(signedMsg, publicKey) {
    checkArrayTypes(signedMsg, publicKey);
    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
      throw new Error('bad public key size');
    var tmp = new Uint8Array(signedMsg.length);
    var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
    if (mlen < 0) return null;
    var m = new Uint8Array(mlen);
    for (var i = 0; i < m.length; i++) m[i] = tmp[i];
    return m;
  };

  nacl.sign.detached = function(msg, secretKey) {
    var signedMsg = nacl.sign(msg, secretKey);
    var sig = new Uint8Array(crypto_sign_BYTES);
    for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
    return sig;
  };

  nacl.sign.detached.verify = function(msg, sig, publicKey) {
    checkArrayTypes(msg, sig, publicKey);
    if (sig.length !== crypto_sign_BYTES)
      throw new Error('bad signature size');
    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
      throw new Error('bad public key size');
    var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
    var m = new Uint8Array(crypto_sign_BYTES + msg.length);
    var i;
    for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
    for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
    return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
  };

  nacl.sign.keyPair = function() {
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    crypto_sign_keypair(pk, sk);
    return {publicKey: pk, secretKey: sk};
  };

  nacl.sign.keyPair.fromSecretKey = function(secretKey) {
    checkArrayTypes(secretKey);
    if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
      throw new Error('bad secret key size');
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
    return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
  };

  nacl.sign.keyPair.fromSeed = function(seed) {
    checkArrayTypes(seed);
    if (seed.length !== crypto_sign_SEEDBYTES)
      throw new Error('bad seed size');
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    for (var i = 0; i < 32; i++) sk[i] = seed[i];
    crypto_sign_keypair(pk, sk, true);
    return {publicKey: pk, secretKey: sk};
  };

  nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
  nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
  nacl.sign.seedLength = crypto_sign_SEEDBYTES;
  nacl.sign.signatureLength = crypto_sign_BYTES;

  nacl.hash = function(msg) {
    checkArrayTypes(msg);
    var h = new Uint8Array(crypto_hash_BYTES);
    crypto_hash(h, msg, msg.length);
    return h;
  };

  nacl.hash.hashLength = crypto_hash_BYTES;

  nacl.verify = function(x, y) {
    checkArrayTypes(x, y);
    // Zero length arguments are considered not equal.
    if (x.length === 0 || y.length === 0) return false;
    if (x.length !== y.length) return false;
    return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
  };

  nacl.setPRNG = function(fn) {
    randombytes = fn;
  };

  (function() {
    // Initialize PRNG if environment provides CSPRNG.
    // If not, methods calling randombytes will throw.
    var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
    if (crypto && crypto.getRandomValues) {
      // Browsers.
      var QUOTA = 65536;
      nacl.setPRNG(function(x, n) {
        var i, v = new Uint8Array(n);
        for (i = 0; i < n; i += QUOTA) {
          crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
        }
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    } else if (typeof commonjsRequire !== 'undefined') {
      // Node.js.
      crypto = require$$0;
      if (crypto && crypto.randomBytes) {
        nacl.setPRNG(function(x, n) {
          var i, v = crypto.randomBytes(n);
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      }
    }
  })();

  })(module.exports ? module.exports : (self.nacl = self.nacl || {}));
  }(naclFast));

  const nacl = naclFast.exports;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclKeypairFromSeed
   * @summary Creates a new public/secret keypair from a seed.
   * @description
   * Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclKeypairFromSeed } from '@polkadot/util-crypto';
   *
   * naclKeypairFromSeed(...); // => { secretKey: [...], publicKey: [...] }
   * ```
   */

  function naclKeypairFromSeed(seed, onlyJs = false) {
    if (!onlyJs && isReady()) {
      const full = ed25519KeypairFromSeed(seed);
      return {
        publicKey: full.slice(32),
        secretKey: full.slice(0, 64)
      };
    }

    return nacl.sign.keyPair.fromSeed(seed);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const keyHdkdEd25519 = createSeedDeriveFn(naclKeypairFromSeed, naclDeriveHard);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const SEC_LEN = 64;
  const PUB_LEN = 32;
  const TOT_LEN = SEC_LEN + PUB_LEN;
  function schnorrkelKeypairFromU8a(full) {
    const fullU8a = require$$0$3.u8aToU8a(full);
    require$$0$3.assert(fullU8a.length === TOT_LEN, () => `Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
    return {
      publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
      secretKey: fullU8a.slice(0, SEC_LEN)
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function schnorrkelKeypairToU8a({
    publicKey,
    secretKey
  }) {
    return require$$0$3.u8aConcat(secretKey, publicKey).slice();
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function createDeriveFn(derive) {
    return (keypair, chainCode) => schnorrkelKeypairFromU8a(derive(schnorrkelKeypairToU8a(keypair), require$$0$3.u8aToU8a(chainCode)));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const schnorrkelDeriveHard = createDeriveFn(sr25519DeriveKeypairHard);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const schnorrkelDeriveSoft = createDeriveFn(sr25519DeriveKeypairSoft);

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function keyHdkdSr25519(keypair, {
    chainCode,
    isSoft
  }) {
    return isSoft ? schnorrkelDeriveSoft(keypair, chainCode) : schnorrkelDeriveHard(keypair, chainCode);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const generators = {
    ecdsa: keyHdkdEcdsa,
    ed25519: keyHdkdEd25519,
    // FIXME This is Substrate-compatible, not Ethereum-compatible
    ethereum: keyHdkdEcdsa,
    sr25519: keyHdkdSr25519
  };
  function keyFromPath(pair, path, type) {
    const keyHdkd = generators[type];
    return path.reduce((pair, junction) => {
      return keyHdkd(pair, junction);
    }, pair);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name schnorrkelAgreement
   * @description Key agreement between other's public key and self secret key
   */

  function schnorrkelAgreement(secretKey, publicKey) {
    const secretKeyU8a = require$$0$3.u8aToU8a(secretKey);
    const publicKeyU8a = require$$0$3.u8aToU8a(publicKey);
    require$$0$3.assert(publicKeyU8a.length === 32, () => `Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    require$$0$3.assert(secretKeyU8a.length === 64, () => `Invalid secretKey, received ${secretKeyU8a.length} bytes, expected 64`);
    return sr25519Agree(publicKeyU8a, secretKeyU8a);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function schnorrkelDerivePublic(publicKey, chainCode) {
    const publicKeyU8a = require$$0$3.u8aToU8a(publicKey);
    require$$0$3.assert(publicKeyU8a.length === 32, () => `Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    return sr25519DerivePublicSoft(publicKeyU8a, require$$0$3.u8aToU8a(chainCode));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name schnorrkelKeypairFromSeed
   * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.
   */

  function schnorrkelKeypairFromSeed(seed) {
    const seedU8a = require$$0$3.u8aToU8a(seed);
    require$$0$3.assert(seedU8a.length === 32, () => `Expected a seed matching 32 bytes, found ${seedU8a.length}`);
    return schnorrkelKeypairFromU8a(sr25519KeypairFromSeed(seedU8a));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name schnorrkelSign
   * @description Returns message signature of `message`, using the supplied pair
   */

  function schnorrkelSign(message, {
    publicKey,
    secretKey
  }) {
    require$$0$3.assert((publicKey === null || publicKey === void 0 ? void 0 : publicKey.length) === 32, 'Expected a valid publicKey, 32-bytes');
    require$$0$3.assert((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) === 64, 'Expected a valid secretKey, 64-bytes');
    return sr25519Sign(publicKey, secretKey, require$$0$3.u8aToU8a(message));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name schnorrkelVerify
   * @description Verifies the signature of `message`, using the supplied pair
   */

  function schnorrkelVerify(message, signature, publicKey) {
    const publicKeyU8a = require$$0$3.u8aToU8a(publicKey);
    const signatureU8a = require$$0$3.u8aToU8a(signature);
    require$$0$3.assert(publicKeyU8a.length === 32, () => `Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
    require$$0$3.assert(signatureU8a.length === 64, () => `Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
    return sr25519Verify(signatureU8a, require$$0$3.u8aToU8a(message), publicKeyU8a);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const EMPTY_U8A$1 = new Uint8Array();
  /**
   * @name schnorrkelVrfSign
   * @description Sign with sr25519 vrf signing (deterministic)
   */

  function schnorrkelVrfSign(message, {
    secretKey
  }, context = EMPTY_U8A$1, extra = EMPTY_U8A$1) {
    require$$0$3.assert((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) === 64, 'Invalid secretKey, expected 64-bytes');
    return vrfSign(secretKey, require$$0$3.u8aToU8a(context), require$$0$3.u8aToU8a(message), require$$0$3.u8aToU8a(extra));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const EMPTY_U8A = new Uint8Array();
  /**
   * @name schnorrkelVrfVerify
   * @description Verify with sr25519 vrf verification
   */

  function schnorrkelVrfVerify(message, signOutput, publicKey, context = EMPTY_U8A, extra = EMPTY_U8A) {
    const publicKeyU8a = require$$0$3.u8aToU8a(publicKey);
    const proofU8a = require$$0$3.u8aToU8a(signOutput);
    require$$0$3.assert(publicKeyU8a.length === 32, 'Invalid publicKey, expected 32-bytes');
    require$$0$3.assert(proofU8a.length === 96, 'Invalid vrfSign output, expected 96 bytes');
    return vrfVerify(publicKeyU8a, require$$0$3.u8aToU8a(context), require$$0$3.u8aToU8a(message), require$$0$3.u8aToU8a(extra), proofU8a);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base58Encode
   * @summary Creates a base58 value.
   * @description
   * From the provided input, create the base58 and return the result as a string.
   */

  function base58Encode(value, ipfsCompat) {
    const out = bs58.encode(require$$0$3.u8aToU8a(value));
    return ipfsCompat ? `z${out}` : out;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function encodeAddress(key, ss58Format = defaults.prefix) {
    // decode it, this means we can re-encode an address
    const u8a = decodeAddress(key);
    require$$0$3.assert(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');
    require$$0$3.assert(defaults.allowedDecodedLengths.includes(u8a.length), () => `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);
    const input = require$$0$3.u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6], u8a);
    return base58Encode(require$$0$3.u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name deriveAddress
   * @summary Creates a sr25519 derived address from the supplied and path.
   * @description
   * Creates a sr25519 derived address based on the input address/publicKey and the uri supplied.
   */

  function deriveAddress(who, suri, ss58Format) {
    const {
      path
    } = keyExtractPath(suri);
    require$$0$3.assert(path.length && !path.some(path => path.isHard), 'Expected suri to contain a combination of non-hard paths');
    return encodeAddress(path.reduce((publicKey, path) => {
      return schnorrkelDerivePublic(publicKey, path.chainCode);
    }, decodeAddress(who)), ss58Format);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name encodeDerivedAddress
   * @summary Creates a derived address as used in Substrate utility.
   * @description
   * Creates a Substrate derived address based on the input address/publicKey and the index supplied.
   */

  function encodeDerivedAddress(who, index, ss58Format) {
    return encodeAddress(createKeyDerived(decodeAddress(who), index), ss58Format);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name encodeMultiAddress
   * @summary Creates a multisig address.
   * @description
   * Creates a Substrate multisig address based on the input address and the required threshold.
   */

  function encodeMultiAddress(who, threshold, ss58Format) {
    return encodeAddress(createKeyMulti(who, threshold), ss58Format);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name blake2AsHex
   * @summary Creates a blake2b hex from the input.
   * @description
   * From a `Uint8Array` input, create the blake2b and return the result as a hex string with the specified `bitLength`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { blake2AsHex } from '@polkadot/util-crypto';
   *
   * blake2AsHex('abc'); // => 0xba80a53f981c4d0d
   * ```
   */

  function blake2AsHex(data, bitLength = 256, key, onlyJs = false) {
    return require$$0$3.u8aToHex(blake2AsU8a(data, bitLength, key, onlyJs));
  }

  var sha3 = {exports: {}};

  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */

  (function (module) {
  /*jslint bitwise: true */
  (function () {

    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
      0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
      2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
      2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
      2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
    var CSHAKE_BYTEPAD = {
      '128': 168,
      '256': 136
    };

    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      };
    }

    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function (obj) {
        return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }

    var createOutputMethod = function (bits, padding, outputType) {
      return function (message) {
        return new Keccak(bits, padding, bits).update(message)[outputType]();
      };
    };

    var createShakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits) {
        return new Keccak(bits, padding, outputBits).update(message)[outputType]();
      };
    };

    var createCshakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits, n, s) {
        return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
      };
    };

    var createKmacOutputMethod = function (bits, padding, outputType) {
      return function (key, message, outputBits, s) {
        return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
      };
    };

    var createOutputMethods = function (method, createMethod, bits, padding) {
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createMethod(bits, padding, type);
      }
      return method;
    };

    var createMethod = function (bits, padding) {
      var method = createOutputMethod(bits, padding, 'hex');
      method.create = function () {
        return new Keccak(bits, padding, bits);
      };
      method.update = function (message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits, padding);
    };

    var createShakeMethod = function (bits, padding) {
      var method = createShakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits) {
        return new Keccak(bits, padding, outputBits);
      };
      method.update = function (message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };

    var createCshakeMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createCshakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits, n, s) {
        if (!n && !s) {
          return methods['shake' + bits].create(outputBits);
        } else {
          return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
        }
      };
      method.update = function (message, outputBits, n, s) {
        return method.create(outputBits, n, s).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };

    var createKmacMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createKmacOutputMethod(bits, padding, 'hex');
      method.create = function (key, outputBits, s) {
        return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
      };
      method.update = function (key, message, outputBits, s) {
        return method.create(key, outputBits, s).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };

    var algorithms = [
      { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
      { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
      { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];

    var methods = {}, methodNames = [];

    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + '_' + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== 'sha3') {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }

    function Keccak(bits, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = (1600 - (bits << 1)) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;

      for (var i = 0; i < 50; ++i) {
        this.s[i] = 0;
      }
    }

    Keccak.prototype.update = function (message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== 'string') {
        if (type === 'object') {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
        blockCount = this.blockCount, index = 0, s = this.s, i, code;

      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }
        if (notString) {
          for (i = this.start; index < length && i < byteCount; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index < length && i < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        if (i >= byteCount) {
          this.start = i - byteCount;
          this.block = blocks[blockCount];
          for (i = 0; i < blockCount; ++i) {
            s[i] ^= blocks[i];
          }
          f(s);
          this.reset = true;
        } else {
          this.start = i;
        }
      }
      return this;
    };

    Keccak.prototype.encode = function (x, right) {
      var o = x & 255, n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };

    Keccak.prototype.encodeString = function (str) {
      var notString, type = typeof str;
      if (type !== 'string') {
        if (type === 'object') {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i = 0; i < str.length; ++i) {
          var code = str.charCodeAt(i);
          if (code < 0x80) {
            bytes += 1;
          } else if (code < 0x800) {
            bytes += 2;
          } else if (code < 0xd800 || code >= 0xe000) {
            bytes += 3;
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };

    Keccak.prototype.bytepad = function (strs, w) {
      var bytes = this.encode(w);
      for (var i = 0; i < strs.length; ++i) {
        bytes += this.encodeString(strs[i]);
      }
      var paddingBytes = w - bytes % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };

    Keccak.prototype.finalize = function () {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
      blocks[i >> 2] |= this.padding[i & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      blocks[blockCount - 1] |= 0x80000000;
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
    };

    Keccak.prototype.toString = Keccak.prototype.hex = function () {
      this.finalize();

      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var hex = '', block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          block = s[i];
          hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
            HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
            HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
            HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
        }
        if (j % blockCount === 0) {
          f(s);
          i = 0;
        }
      }
      if (extraBytes) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
        if (extraBytes > 1) {
          hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
        }
      }
      return hex;
    };

    Keccak.prototype.arrayBuffer = function () {
      this.finalize();

      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer((outputBlocks + 1) << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          array[j] = s[i];
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        array[i] = s[i];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };

    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

    Keccak.prototype.digest = Keccak.prototype.array = function () {
      this.finalize();

      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var array = [], offset, block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          offset = j << 2;
          block = s[i];
          array[offset] = block & 0xFF;
          array[offset + 1] = (block >> 8) & 0xFF;
          array[offset + 2] = (block >> 16) & 0xFF;
          array[offset + 3] = (block >> 24) & 0xFF;
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        if (extraBytes > 1) {
          array[offset + 1] = (block >> 8) & 0xFF;
        }
        if (extraBytes > 2) {
          array[offset + 2] = (block >> 16) & 0xFF;
        }
      }
      return array;
    };

    function Kmac(bits, padding, outputBits) {
      Keccak.call(this, bits, padding, outputBits);
    }

    Kmac.prototype = new Keccak();

    Kmac.prototype.finalize = function () {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };

    var f = function (s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;

        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);

        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);

        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };

    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
  }(sha3));

  const js = sha3.exports;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name keccakAsU8a
   * @summary Creates a keccak Uint8Array from the input.
   * @description
   * From either a `string` or a `Buffer` input, create the keccak and return the result as a `Uint8Array`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { keccakAsU8a } from '@polkadot/util-crypto';
   *
   * keccakAsU8a('123'); // => Uint8Array
   * ```
   */

  function keccakAsU8a(value, bitLength = 256, onlyJs = false) {
    const is256 = bitLength === 256;
    return isReady() && is256 && !onlyJs ? keccak256(require$$0$3.u8aToU8a(value)) : new Uint8Array((is256 ? js.keccak256 : js.keccak512).update(require$$0$3.u8aToU8a(value)).arrayBuffer());
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name keccakAsHex
   * @summary Creates a keccak hex string from the input.
   * @description
   * From either a `string` or a `Buffer` input, create the keccak and return the result as a `0x` prefixed hex string.
   * @example
   * <BR>
   *
   * ```javascript
   * import { keccakAsHex } from '@polkadot/util-crypto';
   *
   * keccakAsHex('123'); // => 0x...
   * ```
   */

  function keccakAsHex(value, bitLength) {
    return require$$0$3.u8aToHex(keccakAsU8a(value, bitLength));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const HASH_TYPES = ['blake2', 'keccak'];
  function secp256k1Hasher(hashType, data) {
    if (hashType === 'blake2') {
      return blake2AsU8a(data);
    } else if (hashType === 'keccak') {
      return keccakAsU8a(data);
    }

    throw new Error(`Unsupported secp256k1 hasher '${hashType}', expected one of ${HASH_TYPES.join(', ')}`);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name evmToAddress
   * @summary Converts an EVM address to its corresponding SS58 address.
   */

  function evmToAddress(evmAddress, ss58Format, hashType = 'blake2') {
    const wrapError = message => `Converting ${evmAddress}: ${message}`;

    const message = require$$0$3.u8aConcat('evm:', evmAddress);

    if (message.length !== 24) {
      throw new Error(wrapError('Invalid evm address length'));
    }

    const address = secp256k1Hasher(hashType, message);
    return encodeAddress(address, ss58Format);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name addressEq
   * @summary Compares two addresses, either in ss58, Uint8Array or hex format.
   * @description
   * For the input values, return true is the underlying public keys do match.
   * @example
   * <BR>
   *
   * ```javascript
   * import { u8aEq } from '@polkadot/util';
   *
   * u8aEq(new Uint8Array([0x68, 0x65]), new Uint8Array([0x68, 0x65])); // true
   * ```
   */

  function addressEq(a, b) {
    return require$$0$3.u8aEq(decodeAddress(a), decodeAddress(b));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function validateAddress(encoded, ignoreChecksum, ss58Format) {
    return !!decodeAddress(encoded, ignoreChecksum, ss58Format);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function isAddress(address, ignoreChecksum, ss58Format) {
    try {
      return validateAddress(address, ignoreChecksum, ss58Format);
    } catch (error) {
      return false;
    }
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const l = require$$0$3.logger('setSS58Format');
  /**
   * @description Sets the global SS58 format to use for address encoding
   * @deprecated Use keyring.setSS58Format
   */

  function setSS58Format(prefix) {
    l.warn('Global setting of the ss58Format is deprecated and not recommended. Set format on the keyring (if used) or as pat of the address encode function');
    defaults.prefix = prefix;
  }

  // Copyright 2017-2021 @polkadot/util authors & contributors
  function sortAddresses(addresses, ss58Format) {
    return require$$0$3.u8aSorted(addresses.map(who => decodeAddress(who))).map(u8a => encodeAddress(u8a, ss58Format));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // https://github.com/multiformats/js-multibase/blob/master/src/constants.js
  const BASE32_ALPHABET = 'abcdefghijklmnopqrstuvwxyz234567';
  const BITS_PER_CHAR = 5;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base32Validate
   * @summary Validates a base32 value.
   * @description
   * Validates that the supplied value is valid base32
   */

  const base32Validate = createValidateFn({
    alphabet: BASE32_ALPHABET,
    ipfsChar: 'b',
    type: 'base32'
  });

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  const LOOKUP = BASE32_ALPHABET.split('').reduce((lookup, char, index) => {
    lookup[char] = index;
    return lookup;
  }, {});
  /** @internal */

  function decode(output, input, offset) {
    let bits = 0;
    let buffer = 0;
    let written = 0;

    for (let i = offset; i < input.length; i++) {
      buffer = buffer << BITS_PER_CHAR | LOOKUP[input[i]];
      bits += BITS_PER_CHAR;

      if (bits >= 8) {
        bits -= 8;
        output[written++] = 0xff & buffer >> bits;
      }
    }

    return [output, bits, buffer];
  }
  /**
   * @name base32Decode
   * @summary Delookup a base32 value.
   * @description
   * From the provided input, decode the base32 and return the result as an `Uint8Array`.
   */


  function base32Decode(value, ipfsCompat = false) {
    base32Validate(value, ipfsCompat);
    const offset = ipfsCompat ? 1 : 0;
    const [output, bits, buffer] = decode(new Uint8Array((value.length - offset) * BITS_PER_CHAR / 8 | 0), value, offset);
    require$$0$3.assert(!(bits >= BITS_PER_CHAR || 0xff & buffer << 8 - bits), 'Unexpected end of data');
    return output;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const MASK = (1 << BITS_PER_CHAR) - 1;
  /**
   * @name base32Encode
   * @summary Creates a base32 value.
   * @description
   * From the provided input, create the base32 and return the result as a string.
   */

  function base32Encode(value, ipfsCompat = false) {
    const u8a = require$$0$3.u8aToU8a(value);
    let out = '';
    let bits = 0;
    let buffer = 0;

    for (let i = 0; i < u8a.length; ++i) {
      buffer = buffer << 8 | u8a[i];
      bits += 8;

      while (bits > BITS_PER_CHAR) {
        bits -= BITS_PER_CHAR;
        out += BASE32_ALPHABET[MASK & buffer >> bits];
      }
    }

    if (bits) {
      out += BASE32_ALPHABET[MASK & buffer << BITS_PER_CHAR - bits];
    }

    return ipfsCompat ? `b${out}` : out;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function testValidator(validate, value, ipfsCompat) {
    try {
      return validate(value, ipfsCompat);
    } catch (error) {
      return false;
    }
  }
  function isBase32(value, ipfsCompat) {
    return testValidator(base32Validate, value, ipfsCompat);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function isBase58(value, ipfsCompat) {
    return testValidator(base58Validate, value, ipfsCompat);
  }

  var base64Js = {};

  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens (b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;

    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4);

    return [validLen, placeHoldersLen]
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength (b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function toByteArray (b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];

    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen;

    var i;
    for (i = 0; i < len; i += 4) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = (tmp >> 16) & 0xFF;
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] +
      lookup[num >> 12 & 0x3F] +
      lookup[num >> 6 & 0x3F] +
      lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup[tmp >> 2] +
        lookup[(tmp << 4) & 0x3F] +
        '=='
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] +
        lookup[(tmp >> 4) & 0x3F] +
        lookup[(tmp << 2) & 0x3F] +
        '='
      );
    }

    return parts.join('')
  }

  const base64 = base64Js;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base64Validate
   * @summary Validates a base64 value.
   * @description
   * Validates that the supplied value is valid base64
   */

  function base64Validate(value) {
    require$$0$3.assert(value && typeof value === 'string', 'Expected non-null, non-empty base64 string input');
    require$$0$3.assert(/^(?:[A-Za-z0-9+/]{2}[A-Za-z0-9+/]{2})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value), 'Invalid base64 encoding');
    return true;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base64Decode
   * @summary Decodes a base64 value.
   * @description
   * From the provided input, decode the base64 and return the result as an `Uint8Array`.
   */

  function base64Decode(value) {
    base64Validate(value);
    return base64.toByteArray(value);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name base64Encode
   * @summary Creates a base64 value.
   * @description
   * From the provided input, create the base64 and return the result as a string.
   */

  function base64Encode(value) {
    return base64.fromByteArray(require$$0$3.u8aToU8a(value));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  function base64Pad(value) {
    return value.padEnd(value.length + value.length % 4, '=');
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  function base64Trim(value) {
    while (value.length && value[value.length - 1] === '=') {
      value = value.slice(0, -1);
    }

    return value;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function isBase64(value) {
    try {
      return base64Validate(value);
    } catch (error) {
      return false;
    }
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function secp256k1Compress(publicKey) {
    require$$0$3.assert([33, 65].includes(publicKey.length), 'Invalid publicKey provided');
    return new Uint8Array(secp256k1.keyFromPublic(publicKey).getPublic().encodeCompressed());
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function secp256k1Expand(publicKey) {
    require$$0$3.assert([33, 65].includes(publicKey.length), 'Invalid publicKey provided');
    const expanded = secp256k1.keyFromPublic(publicKey).getPublic();
    return require$$0$3.u8aConcat(require$$0$3.bnToU8a(expanded.getX(), EXPAND_OPT), require$$0$3.bnToU8a(expanded.getY(), EXPAND_OPT));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name secp256k1Recover
   * @description Recovers a publicKey from the supplied signature
   */

  function secp256k1Recover(message, signature, recovery) {
    return new Uint8Array( // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument
    secp256k1.recoverPubKey(message, {
      r: signature.slice(0, 32),
      s: signature.slice(32, 64)
    }, recovery).encode(null, true));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name secp256k1Sign
   * @description Returns message signature of `message`, using the supplied pair
   */

  function secp256k1Sign(message, {
    secretKey
  }, hashType = 'blake2') {
    require$$0$3.assert((secretKey === null || secretKey === void 0 ? void 0 : secretKey.length) === 32, 'Expected valid secp256k1 secretKey, 32-bytes');
    const key = secp256k1.keyFromPrivate(secretKey);
    const ecsig = key.sign(secp256k1Hasher(hashType, message));
    return require$$0$3.u8aConcat(require$$0$3.bnToU8a(ecsig.r, EXPAND_OPT), require$$0$3.bnToU8a(ecsig.s, EXPAND_OPT), new Uint8Array([ecsig.recoveryParam || 0]));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const ecparams = secp256k1.curve;
  function secp256k1PrivateKeyTweakAdd(seckey, tweak) {
    require$$0$3.assert(require$$0$3.isU8a(seckey) && seckey.length === 32, 'Expected seckey to be an Uint8Array with length 32');
    require$$0$3.assert(require$$0$3.isU8a(tweak) && tweak.length === 32, 'Expected tweak to be an Uint8Array with length 32');
    const bn = new require$$0$3.BN(tweak);
    require$$0$3.assert(bn.cmp(ecparams.n) < 0, 'Tweak parameter is out of range');
    bn.iadd(new require$$0$3.BN(seckey));

    if (bn.cmp(ecparams.n) >= 0) {
      bn.isub(ecparams.n);
    }

    require$$0$3.assert(!bn.isZero(), 'Invalid resulting private key');
    return require$$0$3.bnToU8a(bn, {
      bitLength: 256,
      isLe: false
    });
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name secp256k1Verify
   * @description Verifies the signature of `message`, using the supplied pair
   */

  function secp256k1Verify(message, signature, address, hashType = 'blake2') {
    const isEthereum = hashType === 'keccak';
    const u8a = require$$0$3.u8aToU8a(signature);
    require$$0$3.assert(u8a.length === 65, `Expected signature with 65 bytes, ${u8a.length} found instead`);
    const publicKey = new Uint8Array( // eslint-disable-next-line @typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-argument
    secp256k1.recoverPubKey(secp256k1Hasher(hashType, message), {
      r: u8a.slice(0, 32),
      s: u8a.slice(32, 64)
    }, u8a[64]).encodeCompressed());
    const signingAddress = secp256k1Hasher(hashType, isEthereum ? secp256k1Expand(publicKey) : publicKey);
    const inputAddress = require$$0$3.u8aToU8a(address); // for Ethereum (keccak) the last 20 bytes is the address

    return isEthereum ? require$$0$3.u8aEq(signingAddress.slice(-20), inputAddress.slice(-20)) : require$$0$3.u8aEq(signingAddress, inputAddress);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  function getH160(u8a) {
    if ([33, 65].includes(u8a.length)) {
      u8a = keccakAsU8a(secp256k1Expand(u8a));
    }

    return u8a.slice(-20);
  }

  function ethereumEncode(addressOrPublic) {
    if (!addressOrPublic) {
      return '0x';
    }

    const u8aAddress = require$$0$3.u8aToU8a(addressOrPublic);
    require$$0$3.assert([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');
    const address = require$$0$3.u8aToHex(getH160(u8aAddress), -1, false);
    const hash = require$$0$3.u8aToHex(keccakAsU8a(address), -1, false);
    let result = '';

    for (let index = 0; index < 40; index++) {
      result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;
    }

    return `0x${result}`;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  function isInvalidChar(char, byte) {
    return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
  }

  function isEthereumChecksum(_address) {
    const address = _address.replace('0x', '');

    const hash = require$$0$3.u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);

    for (let index = 0; index < 40; index++) {
      if (isInvalidChar(address[index], parseInt(hash[index], 16))) {
        return false;
      }
    }

    return true;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function isEthereumAddress(address) {
    if (!address || address.length !== 42 || !require$$0$3.isHex(address)) {
      return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
      return true;
    }

    return isEthereumChecksum(address);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function hmacSha(key, data, is512) {
    return Uint8Array.from(hash$2 // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    .hmac(is512 ? hash$2.sha512 : hash$2.sha256, key).update(data).digest());
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function hmacSha256(key, data) {
    return hmacSha(key, data, false);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function hmacSha512(key, data) {
    return hmacSha(key, data, true);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const HARDENED = 0x80000000;
  function hdValidatePath(path) {
    if (!path.startsWith('m/')) {
      return false;
    }

    const parts = path.split('/').slice(1);
    return parts.every(n => /^\d+'?$/.test(n)) && !parts.map(n => parseInt(n.replace(/'$/, ''), 10)).some(n => isNaN(n) || n >= HARDENED || n < 0);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const MASTER_SECRET = require$$0$3.stringToU8a('Bitcoin seed');

  function createCoded(secretKey, chainCode) {
    return {
      chainCode,
      publicKey: secp256k1KeypairFromSeed(secretKey).publicKey,
      secretKey
    };
  }

  function deriveChild(hd, index) {
    const indexBuffer = require$$0$3.bnToU8a(index, {
      bitLength: 32,
      isLe: false
    });
    const data = index >= HARDENED ? require$$0$3.u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : require$$0$3.u8aConcat(hd.publicKey, indexBuffer);

    try {
      const I = hmacSha512(hd.chainCode, data);
      return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, proceed with the next value for i
      return deriveChild(hd, index + 1);
    }
  }

  function hdEthereum(seed, path = '') {
    const I = hmacSha512(MASTER_SECRET, seed);
    const hd = createCoded(I.slice(0, 32), I.slice(32));

    if (!path || path === 'm' || path === 'M' || path === "m'" || path === "M'") {
      return hd;
    }

    require$$0$3.assert(hdValidatePath(path), 'Invalid derivation path');
    return path.split('/').slice(1).reduce((hd, c) => deriveChild(hd, parseInt(c, 10) + (c.length > 1 && c.endsWith("'") ? HARDENED : 0)), hd);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name randomAsU8a
   * @summary Creates a Uint8Array filled with random bytes.
   * @description
   * Returns a `Uint8Array` with the specified (optional) length filled with random bytes.
   * @example
   * <BR>
   *
   * ```javascript
   * import { randomAsU8a } from '@polkadot/util-crypto';
   *
   * randomAsU8a(); // => Uint8Array([...])
   * ```
   */

  function randomAsU8a(length = 32) {
    return getRandomValues(new Uint8Array(length));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function pbkdf2Sync(password, salt, rounds, len = 64) {
    let out = new Uint8Array();
    let num = 0;
    const block = require$$0$3.u8aConcat(salt, new Uint8Array(4));

    while (out.length < len) {
      num++;
      block.set(require$$0$3.bnToU8a(num, {
        bitLength: 32,
        isLe: false
      }), salt.length);
      let prev = hmacSha512(password, block);
      const md = prev;
      let i = 0;

      while (++i < rounds) {
        prev = hmacSha512(password, prev);
        let j = -1;

        while (++j < prev.length) {
          md[j] ^= prev[j];
        }
      }

      out = require$$0$3.u8aConcat(out, md);
    }

    return out.slice(0, len);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function pbkdf2Encode(passphrase, salt = randomAsU8a(), rounds = 2048, onlyJs = false) {
    const u8aPass = require$$0$3.u8aToU8a(passphrase);
    const u8aSalt = require$$0$3.u8aToU8a(salt);
    const password = isReady() && !onlyJs ? pbkdf2(u8aPass, u8aSalt, rounds) : pbkdf2Sync(u8aPass, u8aSalt, rounds);
    return {
      password,
      rounds,
      salt
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  // Adapted from the bitcoinjs/bip39 source
  // https://github.com/bitcoinjs/bip39/blob/1d063b6a6aee4145b34d701037cd3e67f5446ff9/ts_src/
  const DEFAULT_WORDLIST = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const INVALID_MNEMONIC = 'Invalid mnemonic';
  const INVALID_ENTROPY = 'Invalid entropy';
  const INVALID_CHECKSUM = 'Invalid mnemonic checksum';

  function normalize(str) {
    return (str || '').normalize('NFKD');
  }

  function binaryToByte(bin) {
    return parseInt(bin, 2);
  }

  function bytesToBinary(bytes) {
    return bytes.map(x => x.toString(2).padStart(8, '0')).join('');
  }

  function deriveChecksumBits(entropyBuffer) {
    const ENT = entropyBuffer.length * 8;
    const CS = ENT / 32;
    const result = hash$2.sha256().update(entropyBuffer).digest();
    return bytesToBinary(Array.from(result)).slice(0, CS);
  }

  function mnemonicToSeedSync(mnemonic, password) {
    const mnemonicBuffer = require$$0$3.stringToU8a(normalize(mnemonic));
    const saltBuffer = require$$0$3.stringToU8a(`mnemonic${normalize(password)}`);
    return pbkdf2Encode(mnemonicBuffer, saltBuffer).password;
  }
  function mnemonicToEntropy$1(mnemonic) {
    var _entropyBits$match;

    const words = normalize(mnemonic).split(' ');
    require$$0$3.assert(words.length % 3 === 0, INVALID_MNEMONIC); // convert word indices to 11 bit binary strings

    const bits = words.map(word => {
      const index = DEFAULT_WORDLIST.indexOf(word);
      require$$0$3.assert(index !== -1, INVALID_MNEMONIC);
      return index.toString(2).padStart(11, '0');
    }).join(''); // split the binary string into ENT/CS

    const dividerIndex = Math.floor(bits.length / 33) * 32;
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare

    const entropyBytes = (_entropyBits$match = entropyBits.match(/(.{1,8})/g)) === null || _entropyBits$match === void 0 ? void 0 : _entropyBits$match.map(binaryToByte);
    require$$0$3.assert(entropyBytes && entropyBytes.length % 4 === 0 && entropyBytes.length >= 16 && entropyBytes.length <= 32, INVALID_ENTROPY);
    const entropy = require$$0$3.u8aToU8a(entropyBytes);
    const newChecksum = deriveChecksumBits(entropy);
    require$$0$3.assert(newChecksum === checksumBits, INVALID_CHECKSUM);
    return entropy;
  }
  function entropyToMnemonic(entropy) {
    // 128 <= ENT <= 256
    require$$0$3.assert(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, INVALID_ENTROPY);
    const entropyBits = bytesToBinary(Array.from(entropy));
    const checksumBits = deriveChecksumBits(entropy); // we just set it prior, so this is a safe check
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    return (entropyBits + checksumBits).match(/(.{1,11})/g).map(binary => DEFAULT_WORDLIST[binaryToByte(binary)]).join(' ');
  }
  function generateMnemonic(strength) {
    strength = strength || 128;
    require$$0$3.assert(strength % 32 === 0, INVALID_ENTROPY);
    return entropyToMnemonic(randomAsU8a(strength / 8));
  }
  function validateMnemonic(mnemonic) {
    try {
      mnemonicToEntropy$1(mnemonic);
    } catch (e) {
      return false;
    }

    return true;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // mapping of words to the actual strength (as expected)
  const STRENGTH_MAP = {
    12: 16 * 8,
    15: 20 * 8,
    18: 24 * 8,
    21: 28 * 8,
    24: 32 * 8
  };
  /**
   * @name mnemonicGenerate
   * @summary Creates a valid mnemonic string using using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
   * @example
   * <BR>
   *
   * ```javascript
   * import { mnemonicGenerate } from '@polkadot/util-crypto';
   *
   * const mnemonic = mnemonicGenerate(); // => string
   * ```
   */

  function mnemonicGenerate(numWords = 12, onlyJs = false) {
    return isReady() && !onlyJs ? bip39Generate(numWords) : generateMnemonic(STRENGTH_MAP[numWords]);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function mnemonicToEntropy(mnemonic, onlyJs = false) {
    return isReady() && !onlyJs ? bip39ToEntropy(mnemonic) : mnemonicToEntropy$1(mnemonic);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name mnemonicValidate
   * @summary Validates a mnemonic input using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
   * @example
   * <BR>
   *
   * ```javascript
   * import { mnemonicGenerate, mnemonicValidate } from '@polkadot/util-crypto';
   *
   * const mnemonic = mnemonicGenerate(); // => string
   * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean
   * ```
   */

  function mnemonicValidate(mnemonic, onlyJs = false) {
    return isReady() && !onlyJs ? bip39Validate(mnemonic) : validateMnemonic(mnemonic);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name mnemonicToLegacySeed
   * @summary Creates a valid Ethereum/Bitcoin-compatible seed from a mnemonic input
   * @example
   * <BR>
   *
   * ```javascript
   * import { mnemonicGenerate, mnemonicToLegacySeed, mnemonicValidate } from '@polkadot/util-crypto';
   *
   * const mnemonic = mnemonicGenerate(); // => string
   * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean
   *
   * if (isValidMnemonic) {
   *   console.log(`Seed generated from mnemonic: ${mnemonicToLegacySeed(mnemonic)}`); => u8a
   * }
   * ```
   */

  function mnemonicToLegacySeed(mnemonic, password = '', onlyJs = false, byteLength = 32) {
    require$$0$3.assert(mnemonicValidate(mnemonic), 'Invalid bip39 mnemonic specified');
    require$$0$3.assert([32, 64].includes(byteLength), () => `Invalid seed length ${byteLength}, expected 32 or 64`);

    if (byteLength === 32) {
      return isReady() && !onlyJs ? bip39ToSeed(mnemonic, password) : mnemonicToSeedSync(mnemonic, password).subarray(0, 32);
    } else if (byteLength === 64) {
      return mnemonicToSeedSync(mnemonic, password);
    }

    return new Uint8Array();
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function mnemonicToMiniSecret(mnemonic, password = '', onlyJs = false) {
    require$$0$3.assert(mnemonicValidate(mnemonic), 'Invalid bip39 mnemonic specified');

    if (isReady() && !onlyJs) {
      return bip39ToMiniSecret(mnemonic, password);
    }

    const entropy = mnemonicToEntropy(mnemonic);
    const salt = require$$0$3.stringToU8a(`mnemonic${password}`); // return the first 32 bytes as the seed

    return pbkdf2Encode(entropy, salt).password.slice(0, 32);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclDecrypt
   * @summary Decrypts a message using the supplied secretKey and nonce
   * @description
   * Returns an decrypted message, using the `secret` and `nonce`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclDecrypt } from '@polkadot/util-crypto';
   *
   * naclDecrypt([...], [...], [...]); // => [...]
   * ```
   */

  function naclDecrypt(encrypted, nonce, secret) {
    return nacl.secretbox.open(encrypted, nonce, secret) || null;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  /**
   * @name naclEncrypt
   * @summary Encrypts a message using the supplied secretKey and nonce
   * @description
   * Returns an encrypted message, using the `secretKey` and `nonce`. If the `nonce` was not supplied, a random value is generated.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclEncrypt } from '@polkadot/util-crypto';
   *
   * naclEncrypt([...], [...]); // => [...]
   * ```
   */
  function naclEncrypt(message, secret, nonce = randomAsU8a(24)) {
    return {
      encrypted: nacl.secretbox(message, nonce, secret),
      nonce
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclKeypairFromRandom
   * @summary Creates a new public/secret keypair.
   * @description
   * Returns a new generate object containing a `publicKey` & `secretKey`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclKeypairFromRandom } from '@polkadot/util-crypto';
   *
   * naclKeypairFromRandom(); // => { secretKey: [...], publicKey: [...] }
   * ```
   */

  function naclKeypairFromRandom() {
    return nacl.sign.keyPair();
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclKeypairFromSecret
   * @summary Creates a new public/secret keypair from a secret.
   * @description
   * Returns a object containing a `publicKey` & `secretKey` generated from the supplied secret.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclKeypairFromSecret } from '@polkadot/util-crypto';
   *
   * naclKeypairFromSecret(...); // => { secretKey: [...], publicKey: [...] }
   * ```
   */

  function naclKeypairFromSecret(secret) {
    return nacl.sign.keyPair.fromSecretKey(secret);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclKeypairFromString
   * @summary Creates a new public/secret keypair from a string.
   * @description
   * Returns a object containing a `publicKey` & `secretKey` generated from the supplied string. The string is hashed and the value used as the input seed.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclKeypairFromString } from '@polkadot/util-crypto';
   *
   * naclKeypairFromString('test'); // => { secretKey: [...], publicKey: [...] }
   * ```
   */

  function naclKeypairFromString(value) {
    return naclKeypairFromSeed(blake2AsU8a(require$$0$3.stringToU8a(value), 256));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclSign
   * @summary Signs a message using the supplied secretKey
   * @description
   * Returns message signature of `message`, using the `secretKey`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclSign } from '@polkadot/util-crypto';
   *
   * naclSign([...], [...]); // => [...]
   * ```
   */

  function naclSign(message, {
    publicKey,
    secretKey
  }, onlyJs = false) {
    require$$0$3.assert(secretKey, 'Expected a valid secretKey');
    const messageU8a = require$$0$3.u8aToU8a(message);
    return isReady() && !onlyJs ? ed25519Sign(publicKey, secretKey.subarray(0, 32), messageU8a) : nacl.sign.detached(messageU8a, secretKey);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclSign
   * @summary Verifies the signature on the supplied message.
   * @description
   * Verifies the `signature` on `message` with the supplied `publicKey`. Returns `true` on sucess, `false` otherwise.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclVerify } from '@polkadot/util-crypto';
   *
   * naclVerify([...], [...], [...]); // => true/false
   * ```
   */

  function naclVerify(message, signature, publicKey, onlyJs = false) {
    const messageU8a = require$$0$3.u8aToU8a(message);
    const publicKeyU8a = require$$0$3.u8aToU8a(publicKey);
    const signatureU8a = require$$0$3.u8aToU8a(signature);
    require$$0$3.assert(publicKeyU8a.length === 32, () => `Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
    require$$0$3.assert(signatureU8a.length === 64, () => `Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
    return isReady() && !onlyJs ? ed25519Verify(signatureU8a, messageU8a, publicKeyU8a) : nacl.sign.detached.verify(messageU8a, signatureU8a, publicKeyU8a);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclBoxKeypairFromSecret
   * @summary Creates a new public/secret box keypair from a secret.
   * @description
   * Returns a object containing a box `publicKey` & `secretKey` generated from the supplied secret.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclBoxKeypairFromSecret } from '@polkadot/util-crypto';
   *
   * naclBoxKeypairFromSecret(...); // => { secretKey: [...], publicKey: [...] }
   * ```
   */

  function naclBoxKeypairFromSecret(secret) {
    return nacl.box.keyPair.fromSecretKey(secret.slice(0, 32));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name naclOpen
   * @summary Opens a message using the receiver's secretKey and nonce
   * @description
   * Returns a message sealed by the sender, using the receiver's `secret` and `nonce`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclOpen } from '@polkadot/util-crypto';
   *
   * naclOpen([...], [...], [...]); // => [...]
   * ```
   */

  function naclOpen(sealed, nonce, senderBoxPublic, receiverBoxSecret) {
    return nacl.box.open(sealed, nonce, senderBoxPublic, receiverBoxSecret) || null;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  /**
   * @name naclSeal
   * @summary Seals a message using the sender's encrypting secretKey, receiver's public key, and nonce
   * @description
   * Returns an encrypted message which can be open only by receiver's secretKey. If the `nonce` was not supplied, a random value is generated.
   * @example
   * <BR>
   *
   * ```javascript
   * import { naclSeal } from '@polkadot/util-crypto';
   *
   * naclSeal([...], [...], [...], [...]); // => [...]
   * ```
   */
  function naclSeal(message, senderBoxSecret, receiverBoxPublic, nonce = randomAsU8a(24)) {
    return {
      nonce,
      sealed: nacl.box(message, nonce, receiverBoxPublic, senderBoxSecret)
    };
  }

  var ed2curve$1 = {exports: {}};

  /*
   * ed2curve: convert Ed25519 signing key pair into Curve25519
   * key pair suitable for Diffie-Hellman key exchange.
   *
   * Written by Dmitry Chestnykh in 2014. Public domain.
   */

  (function (module) {
  /* jshint newcap: false */
  (function(root, f) {
    if (module.exports) module.exports = f(naclFast.exports);
    else root.ed2curve = f(root.nacl);
  }(commonjsGlobal, function(nacl) {
    if (!nacl) throw new Error('tweetnacl not loaded');

    // -- Operations copied from TweetNaCl.js. --

    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };

    var gf0 = gf(),
        gf1 = gf([1]),
        D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
        I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

    function car25519(o) {
      var c;
      var i;
      for (i = 0; i < 16; i++) {
        o[i] += 65536;
        c = Math.floor(o[i] / 65536);
        o[(i+1)*(i<15?1:0)] += c - 1 + 37 * (c-1) * (i===15?1:0);
        o[i] -= (c * 65536);
      }
    }

    function sel25519(p, q, b) {
      var t, c = ~(b-1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
      o[15] &= 0x7fff;
    }

    // addition
    function A(o, a, b) {
      var i;
      for (i = 0; i < 16; i++) o[i] = (a[i] + b[i])|0;
    }

    // subtraction
    function Z(o, a, b) {
      var i;
      for (i = 0; i < 16; i++) o[i] = (a[i] - b[i])|0;
    }

    // multiplication
    function M(o, a, b) {
      var i, j, t = new Float64Array(31);
      for (i = 0; i < 31; i++) t[i] = 0;
      for (i = 0; i < 16; i++) {
        for (j = 0; j < 16; j++) {
          t[i+j] += a[i] * b[j];
        }
      }
      for (i = 0; i < 15; i++) {
        t[i] += 38 * t[i+16];
      }
      for (i = 0; i < 16; i++) o[i] = t[i];
      car25519(o);
      car25519(o);
    }

    // squaring
    function S(o, a) {
      M(o, a, a);
    }

    // inversion
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if(a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
          m[i-1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
        b = (m[15]>>16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1-b);
      }
      for (i = 0; i < 16; i++) {
        o[2*i] = t[i] & 0xff;
        o[2*i+1] = t[i] >> 8;
      }
    }

    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }

    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
      return (1 & ((d - 1) >>> 8)) - 1;
    }

    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }

    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }

    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }

    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i] | 0;
    }

    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(),
        den = gf(), den2 = gf(), den4 = gf(),
        den6 = gf();

      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);

      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);

      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);

      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;

      if (par25519(r[0]) === (p[31] >> 7)) Z(r[0], gf0, r[0]);

      M(r[3], r[0], r[1]);
      return 0;
    }

    // ----

    // Converts Ed25519 public key to Curve25519 public key.
    // montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p
    function convertPublicKey(pk) {
      var z = new Uint8Array(32),
        q = [gf(), gf(), gf(), gf()],
        a = gf(), b = gf();

      if (unpackneg(q, pk)) return null; // reject invalid key

      var y = q[1];

      A(a, gf1, y);
      Z(b, gf1, y);
      inv25519(b, b);
      M(a, a, b);

      pack25519(z, a);
      return z;
    }

    // Converts Ed25519 secret key to Curve25519 secret key.
    function convertSecretKey(sk) {
      var d = new Uint8Array(64), o = new Uint8Array(32), i;
      nacl.lowlevel.crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      for (i = 0; i < 32; i++) o[i] = d[i];
      for (i = 0; i < 64; i++) d[i] = 0;
      return o;
    }

    function convertKeyPair(edKeyPair) {
      var publicKey = convertPublicKey(edKeyPair.publicKey);
      if (!publicKey) return null;
      return {
        publicKey: publicKey,
        secretKey: convertSecretKey(edKeyPair.secretKey)
      };
    }

    return {
      convertPublicKey: convertPublicKey,
      convertSecretKey: convertSecretKey,
      convertKeyPair: convertKeyPair,
    };

  }));
  }(ed2curve$1));

  const ed2curve = ed2curve$1.exports;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function convertSecretKeyToCurve25519(secretKey) {
    return ed2curve.convertSecretKey(secretKey);
  }
  function convertPublicKeyToCurve25519(publicKey) {
    return ed2curve.convertPublicKey(publicKey);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  function ledgerDerivePrivate(xprv, index) {
    const kl = xprv.subarray(0, 32);
    const kr = xprv.subarray(32, 64);
    const cc = xprv.subarray(64, 96);
    const data = require$$0$3.u8aConcat([0], kl, kr, require$$0$3.bnToU8a(index, {
      bitLength: 32,
      isLe: true
    }));
    const z = hmacSha512(cc, data);
    data[0] = 0x01;
    return require$$0$3.u8aConcat(require$$0$3.bnToU8a(require$$0$3.u8aToBn(kl, {
      isLe: true
    }).iadd(require$$0$3.u8aToBn(z.subarray(0, 28), {
      isLe: true
    }).imul(require$$0$3.BN_EIGHT)), {
      bitLength: 512,
      isLe: true
    }).subarray(0, 32), require$$0$3.bnToU8a(require$$0$3.u8aToBn(kr, {
      isLe: true
    }).iadd(require$$0$3.u8aToBn(z.subarray(32, 64), {
      isLe: true
    })), {
      bitLength: 512,
      isLe: true
    }).subarray(0, 32), hmacSha512(cc, data).subarray(32, 64));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const ED25519_CRYPTO = 'ed25519 seed'; // gets an xprv from a mnemonic

  function ledgerMaster(mnemonic, password) {
    const seed = mnemonicToSeedSync(mnemonic, password);
    const chainCode = hmacSha256(ED25519_CRYPTO, new Uint8Array([1, ...seed]));
    let priv;

    while (!priv || priv[31] & 0b00100000) {
      priv = hmacSha512(ED25519_CRYPTO, priv || seed);
    }

    priv[0] &= 0b11111000;
    priv[31] &= 0b01111111;
    priv[31] |= 0b01000000;
    return require$$0$3.u8aConcat(priv, chainCode);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function hdLedger(_mnemonic, path) {
    const parts = _mnemonic.split(' ').map(s => s.trim()).filter(s => s);

    require$$0$3.assert([12, 24, 25].includes(parts.length), 'Expected a mnemonic with 24 words (or 25 including a password)');
    const [mnemonic, password] = parts.length === 25 ? [parts.slice(0, 24).join(' '), parts[24]] : [parts.join(' '), ''];
    require$$0$3.assert(mnemonicValidate(mnemonic), 'Invalid mnemonic passed to ledger derivation');
    require$$0$3.assert(hdValidatePath(path), 'Invalid derivation path');
    return naclKeypairFromSeed(path.split('/').slice(1).map(n => parseInt(n.replace(/'$/, ''), 10)).map(n => n < HARDENED ? n + HARDENED : n).reduce((x, n) => ledgerDerivePrivate(x, n), ledgerMaster(mnemonic, password)).slice(0, 32));
  }

  const crypto$2 = require$$0;
  const MAX_VALUE = 0x7fffffff;
  const DEFAULT_PROMISE_INTERVAL = 5000;
  /* eslint-disable camelcase */

  function checkAndInit$2 (key, salt, N, r, p, dkLen, progressCallback) {
    if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

    if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
    if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

    let XY = Buffer.alloc(256 * r);
    let V = Buffer.alloc(128 * r * N);

    // pseudo global
    let B32 = new Int32Array(16); // salsa20_8
    let x = new Int32Array(16); // salsa20_8
    let _X = Buffer.alloc(64); // blockmix_salsa8

    // pseudo global
    let B = crypto$2.pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256');

    let tickCallback;
    if (progressCallback) {
      let totalOps = p * N * 2;
      let currentOp = 0;

      tickCallback = function () {
        ++currentOp;

        // send progress notifications once every 1,000 ops
        if (currentOp % 1000 === 0) {
          progressCallback({
            current: currentOp,
            total: totalOps,
            percent: (currentOp / totalOps) * 100.0
          });
        }
      };
    }
    return {
      XY,
      V,
      B32,
      x,
      _X,
      B,
      tickCallback
    }
  }

  async function smix$1 (B, Bi, r, N, V, XY, _X, B32, x, tickCallback, promiseInterval) {
    promiseInterval = promiseInterval || DEFAULT_PROMISE_INTERVAL;
    let Xi = 0;
    let Yi = 128 * r;
    let i;

    B.copy(XY, Xi, Bi, Bi + Yi);

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi);
      if (i % promiseInterval === 0) {
        await new Promise(resolve => setImmediate(resolve));
      }
      blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x);

      if (tickCallback) tickCallback();
    }

    for (i = 0; i < N; i++) {
      let offset = Xi + (2 * r - 1) * 64;
      let j = XY.readUInt32LE(offset) & (N - 1);
      blockxor(V, j * Yi, XY, Xi, Yi);
      if (i % promiseInterval === 0) {
        await new Promise(resolve => setImmediate(resolve));
      }
      blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x);

      if (tickCallback) tickCallback();
    }

    XY.copy(B, Bi, Xi, Xi + Yi);
  }

  function smixSync$1 (B, Bi, r, N, V, XY, _X, B32, x, tickCallback) {
    let Xi = 0;
    let Yi = 128 * r;
    let i;

    B.copy(XY, Xi, Bi, Bi + Yi);

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi);
      blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x);

      if (tickCallback) tickCallback();
    }

    for (i = 0; i < N; i++) {
      let offset = Xi + (2 * r - 1) * 64;
      let j = XY.readUInt32LE(offset) & (N - 1);
      blockxor(V, j * Yi, XY, Xi, Yi);
      blockmix_salsa8(XY, Xi, Yi, r, _X, B32, x);

      if (tickCallback) tickCallback();
    }

    XY.copy(B, Bi, Xi, Xi + Yi);
  }

  function blockmix_salsa8 (BY, Bi, Yi, r, _X, B32, x) {
    let i;

    arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64);

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64);
      salsa20_8(_X, B32, x);
      arraycopy(_X, 0, BY, Yi + (i * 64), 64);
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64);
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64);
    }
  }

  function R (a, b) {
    return (a << b) | (a >>> (32 - b))
  }

  function salsa20_8 (B, B32, x) {
    let i;

    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 0xff) << 0;
      B32[i] |= (B[i * 4 + 1] & 0xff) << 8;
      B32[i] |= (B[i * 4 + 2] & 0xff) << 16;
      B32[i] |= (B[i * 4 + 3] & 0xff) << 24;
      // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
    }

    arraycopy(B32, 0, x, 0, 16);

    for (i = 8; i > 0; i -= 2) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }

    for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i];

    for (i = 0; i < 16; i++) {
      let bi = i * 4;
      B[bi + 0] = (B32[i] >> 0 & 0xff);
      B[bi + 1] = (B32[i] >> 8 & 0xff);
      B[bi + 2] = (B32[i] >> 16 & 0xff);
      B[bi + 3] = (B32[i] >> 24 & 0xff);
      // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor (S, Si, D, Di, len) {
    for (let i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i];
    }
  }

  function arraycopy (src, srcPos, dest, destPos, length) {
    if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
      src.copy(dest, destPos, srcPos, srcPos + length);
    } else {
      while (length--) {
        dest[destPos++] = src[srcPos++];
      }
    }
  }

  var utils = {
    checkAndInit: checkAndInit$2,
    smix: smix$1,
    smixSync: smixSync$1
  };

  const crypto$1 = require$$0;
  const {
    checkAndInit: checkAndInit$1,
    smixSync
  } = utils;

  // N = Cpu cost, r = Memory cost, p = parallelization cost
  function scrypt$2 (key, salt, N, r, p, dkLen, progressCallback) {
    const {
      XY,
      V,
      B32,
      x,
      _X,
      B,
      tickCallback
    } = checkAndInit$1(key, salt, N, r, p, dkLen, progressCallback);

    for (var i = 0; i < p; i++) {
      smixSync(B, i * 128 * r, r, N, V, XY, _X, B32, x, tickCallback);
    }

    return crypto$1.pbkdf2Sync(key, B, 1, dkLen, 'sha256')
  }

  var scryptSync = scrypt$2;

  const crypto = require$$0;
  const {
    checkAndInit,
    smix
  } = utils;

  // N = Cpu cost, r = Memory cost, p = parallelization cost
  async function scrypt$1 (key, salt, N, r, p, dkLen, progressCallback, promiseInterval) {
    const {
      XY,
      V,
      B32,
      x,
      _X,
      B,
      tickCallback
    } = checkAndInit(key, salt, N, r, p, dkLen, progressCallback);

    for (var i = 0; i < p; i++) {
      await smix(B, i * 128 * r, r, N, V, XY, _X, B32, x, tickCallback, promiseInterval);
    }

    return crypto.pbkdf2Sync(key, B, 1, dkLen, 'sha256')
  }

  var scrypt_1 = scrypt$1;

  const scrypt = scryptSync;
  scrypt.async = scrypt_1;
  var lib$1 = scrypt;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const DEFAULT_PARAMS = {
    N: 1 << 15,
    p: 1,
    r: 8
  };

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function scryptEncode(passphrase, salt = randomAsU8a(), params = DEFAULT_PARAMS) {
    const password = isReady() ? scrypt$3(require$$0$3.u8aToU8a(passphrase), salt, Math.log2(params.N), params.r, params.p) : require$$0$3.bufferToU8a(lib$1(require$$0$3.u8aToBuffer(require$$0$3.u8aToU8a(passphrase)), require$$0$3.u8aToBuffer(salt), params.N, params.r, params.p, 64));
    return {
      params,
      password,
      salt
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function scryptFromU8a(data) {
    const salt = data.subarray(0, 32);
    const N = require$$0$3.u8aToBn(data.subarray(32 + 0, 32 + 4), {
      isLe: true
    }).toNumber();
    const p = require$$0$3.u8aToBn(data.subarray(32 + 4, 32 + 8), {
      isLe: true
    }).toNumber();
    const r = require$$0$3.u8aToBn(data.subarray(32 + 8, 32 + 12), {
      isLe: true
    }).toNumber(); // FIXME At this moment we assume these to be fixed params, this is not a great idea since we lose flexibility
    // and updates for greater security. However we need some protection against carefully-crafted params that can
    // eat up CPU since these are user inputs. So we need to get very clever here, but atm we only allow the defaults
    // and if no match, bail out

    require$$0$3.assert(N === DEFAULT_PARAMS.N && p === DEFAULT_PARAMS.p && r === DEFAULT_PARAMS.r, 'Invalid injected scrypt params found');
    return {
      params: {
        N,
        p,
        r
      },
      salt
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function scryptToU8a(salt, {
    N,
    p,
    r
  }) {
    return require$$0$3.u8aConcat(salt, require$$0$3.bnToU8a(N, {
      bitLength: 32,
      isLe: true
    }), require$$0$3.bnToU8a(p, {
      bitLength: 32,
      isLe: true
    }), require$$0$3.bnToU8a(r, {
      bitLength: 32,
      isLe: true
    }));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const ENCODING = ['scrypt', 'xsalsa20-poly1305'];
  const ENCODING_NONE = ['none'];
  const ENCODING_VERSION = '3';
  const NONCE_LENGTH = 24;
  const SCRYPT_LENGTH = 32 + 3 * 4;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {
    require$$0$3.assert(encrypted, 'No encrypted data available to decode');
    require$$0$3.assert(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encrypted data');
    let encoded = encrypted;

    if (passphrase) {
      let password;

      if (encType.includes('scrypt')) {
        const {
          params,
          salt
        } = scryptFromU8a(encrypted);
        password = scryptEncode(passphrase, salt, params).password;
        encrypted = encrypted.subarray(SCRYPT_LENGTH);
      } else {
        password = require$$0$3.stringToU8a(passphrase);
      }

      encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), require$$0$3.u8aFixLength(password, 256, true));
    }

    require$$0$3.assert(encoded, 'Unable to decode using the supplied passphrase');
    return encoded;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function jsonDecrypt({
    encoded,
    encoding
  }, passphrase) {
    require$$0$3.assert(encoded, 'No encrypted data available to decode');
    return jsonDecryptData(require$$0$3.isHex(encoded) ? require$$0$3.hexToU8a(encoded) : base64Decode(encoded), passphrase, Array.isArray(encoding.type) ? encoding.type : [encoding.type]);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function jsonEncryptFormat(encoded, contentType, isEncrypted) {
    return {
      encoded: base64Encode(encoded),
      encoding: {
        content: contentType,
        type: isEncrypted ? ENCODING : ENCODING_NONE,
        version: ENCODING_VERSION
      }
    };
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function jsonEncrypt(data, contentType, passphrase) {
    let isEncrypted = false;
    let encoded = data;

    if (passphrase) {
      const {
        params,
        password,
        salt
      } = scryptEncode(passphrase);
      const {
        encrypted,
        nonce
      } = naclEncrypt(encoded, password.subarray(0, 32));
      isEncrypted = true;
      encoded = require$$0$3.u8aConcat(scryptToU8a(salt, params), nonce, encrypted);
    }

    return jsonEncryptFormat(encoded, contentType, isEncrypted);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name randomAsHex
   * @summary Creates a hex string filled with random bytes.
   * @description
   * Returns a hex string with the specified (optional) length filled with random bytes.
   * @example
   * <BR>
   *
   * ```javascript
   * import { randomAsHex } from '@polkadot/util-crypto';
   *
   * randomAsHex(); // => 0x...
   * ```
   */

  function randomAsHex(length = 32) {
    return require$$0$3.u8aToHex(randomAsU8a(length));
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  const BN_53 = new require$$0$3.BN(0b11111111111111111111111111111111111111111111111111111);
  /**
   * @name randomAsNumber
   * @summary Creates a random number from random bytes.
   * @description
   * Returns a random number generated from the secure bytes.
   * @example
   * <BR>
   *
   * ```javascript
   * import { randomAsNumber } from '@polkadot/util-crypto';
   *
   * randomAsNumber(); // => <random number>
   * ```
   */

  function randomAsNumber() {
    return require$$0$3.hexToBn(randomAsHex(8)).and(BN_53).toNumber();
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name sha512AsU8a
   * @summary Creates sha-512 hash of the input.
   * @description
   * Returns a sha-512 `Uint8Array` from the supplied data.
   * @example
   * <BR>
   *
   * ```javascript
   * import { sha512AsU8a } from '@polkadot/util-crypto';
   *
   * sha512AsU8a(Uint8Array.from([...])); // => Uint8Array([...])
   * ```
   */

  function sha512AsU8a(data, onlyJs = false) {
    return isReady() && !onlyJs ? sha512(data) : nacl.hash(data);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors

  const secp256k1VerifyHasher = hashType => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType);

  const VERIFIERS_ECDSA = [['ecdsa', secp256k1VerifyHasher('blake2')], ['ethereum', secp256k1VerifyHasher('keccak')]];
  const VERIFIERS = [['ed25519', naclVerify], ['sr25519', schnorrkelVerify], ...VERIFIERS_ECDSA];
  const CRYPTO_TYPES = ['ed25519', 'sr25519', 'ecdsa'];

  function verifyDetect(result, {
    message,
    publicKey,
    signature
  }, verifiers = VERIFIERS) {
    result.isValid = verifiers.some(([crypto, verify]) => {
      try {
        if (verify(message, signature, publicKey)) {
          result.crypto = crypto;
          return true;
        }
      } catch (error) {// do nothing, result.isValid still set to false
      }

      return false;
    });
    return result;
  }

  function verifyMultisig(result, {
    message,
    publicKey,
    signature
  }) {
    require$$0$3.assert([0, 1, 2].includes(signature[0]), () => `Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
    const type = CRYPTO_TYPES[signature[0]] || 'none';
    result.crypto = type;

    try {
      result.isValid = {
        ecdsa: () => verifyDetect(result, {
          message,
          publicKey,
          signature: signature.subarray(1)
        }, VERIFIERS_ECDSA).isValid,
        ed25519: () => naclVerify(message, signature.subarray(1), publicKey),
        none: () => {
          throw Error('no verify for `none` crypto type');
        },
        sr25519: () => schnorrkelVerify(message, signature.subarray(1), publicKey)
      }[type]();
    } catch (error) {// ignore, result.isValid still set to false
    }

    return result;
  }

  function getVerifyFn(signature) {
    return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;
  }

  function signatureVerify(message, signature, addressOrPublicKey) {
    const signatureU8a = require$$0$3.u8aToU8a(signature);
    require$$0$3.assert([64, 65, 66].includes(signatureU8a.length), () => `Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
    const publicKey = decodeAddress(addressOrPublicKey);
    const input = {
      message: require$$0$3.u8aToU8a(message),
      publicKey,
      signature: signatureU8a
    };
    const result = {
      crypto: 'none',
      isValid: false,
      isWrapped: require$$0$3.u8aIsWrapped(input.message, true),
      publicKey
    };
    const isWrappedBytes = require$$0$3.u8aIsWrapped(input.message, false);
    const verifyFn = getVerifyFn(signatureU8a);
    verifyFn(result, input);

    if (result.crypto !== 'none' || result.isWrapped && !isWrappedBytes) {
      return result;
    }

    input.message = isWrappedBytes ? require$$0$3.u8aUnwrapBytes(input.message) : require$$0$3.u8aWrapBytes(input.message);
    return verifyFn(result, input);
  }

  var cuint = {};

  var uint32 = {exports: {}};

  /**
  	C-like unsigned 32 bits integers in Javascript
  	Copyright (C) 2013, Pierre Curto
  	MIT license
   */

  (function (module) {
  (function (root) {

  	// Local cache for typical radices
  	({
  		36: UINT32( Math.pow(36, 5) )
  	,	16: UINT32( Math.pow(16, 7) )
  	,	10: UINT32( Math.pow(10, 9) )
  	,	2:  UINT32( Math.pow(2, 30) )
  	});
  	({
  		36: UINT32(36)
  	,	16: UINT32(16)
  	,	10: UINT32(10)
  	,	2:  UINT32(2)
  	});

  	/**
  	 *	Represents an unsigned 32 bits integer
  	 * @constructor
  	 * @param {Number|String|Number} low bits     | integer as a string 		 | integer as a number
  	 * @param {Number|Number|Undefined} high bits | radix (optional, default=10)
  	 * @return 
  	 */
  	function UINT32 (l, h) {
  		if ( !(this instanceof UINT32) )
  			return new UINT32(l, h)

  		this._low = 0;
  		this._high = 0;
  		this.remainder = null;
  		if (typeof h == 'undefined')
  			return fromNumber.call(this, l)

  		if (typeof l == 'string')
  			return fromString.call(this, l, h)

  		fromBits.call(this, l, h);
  	}

  	/**
  	 * Set the current _UINT32_ object with its low and high bits
  	 * @method fromBits
  	 * @param {Number} low bits
  	 * @param {Number} high bits
  	 * @return ThisExpression
  	 */
  	function fromBits (l, h) {
  		this._low = l | 0;
  		this._high = h | 0;

  		return this
  	}
  	UINT32.prototype.fromBits = fromBits;

  	/**
  	 * Set the current _UINT32_ object from a number
  	 * @method fromNumber
  	 * @param {Number} number
  	 * @return ThisExpression
  	 */
  	function fromNumber (value) {
  		this._low = value & 0xFFFF;
  		this._high = value >>> 16;

  		return this
  	}
  	UINT32.prototype.fromNumber = fromNumber;

  	/**
  	 * Set the current _UINT32_ object from a string
  	 * @method fromString
  	 * @param {String} integer as a string
  	 * @param {Number} radix (optional, default=10)
  	 * @return ThisExpression
  	 */
  	function fromString (s, radix) {
  		var value = parseInt(s, radix || 10);

  		this._low = value & 0xFFFF;
  		this._high = value >>> 16;

  		return this
  	}
  	UINT32.prototype.fromString = fromString;

  	/**
  	 * Convert this _UINT32_ to a number
  	 * @method toNumber
  	 * @return {Number} the converted UINT32
  	 */
  	UINT32.prototype.toNumber = function () {
  		return (this._high * 65536) + this._low
  	};

  	/**
  	 * Convert this _UINT32_ to a string
  	 * @method toString
  	 * @param {Number} radix (optional, default=10)
  	 * @return {String} the converted UINT32
  	 */
  	UINT32.prototype.toString = function (radix) {
  		return this.toNumber().toString(radix || 10)
  	};

  	/**
  	 * Add two _UINT32_. The current _UINT32_ stores the result
  	 * @method add
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.add = function (other) {
  		var a00 = this._low + other._low;
  		var a16 = a00 >>> 16;

  		a16 += this._high + other._high;

  		this._low = a00 & 0xFFFF;
  		this._high = a16 & 0xFFFF;

  		return this
  	};

  	/**
  	 * Subtract two _UINT32_. The current _UINT32_ stores the result
  	 * @method subtract
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.subtract = function (other) {
  		//TODO inline
  		return this.add( other.clone().negate() )
  	};

  	/**
  	 * Multiply two _UINT32_. The current _UINT32_ stores the result
  	 * @method multiply
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.multiply = function (other) {
  		/*
  			a = a00 + a16
  			b = b00 + b16
  			a*b = (a00 + a16)(b00 + b16)
  				= a00b00 + a00b16 + a16b00 + a16b16

  			a16b16 overflows the 32bits
  		 */
  		var a16 = this._high;
  		var a00 = this._low;
  		var b16 = other._high;
  		var b00 = other._low;

  /* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)
  		// this == 0 or other == 1: nothing to do
  		if ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this

  		// other == 0 or this == 1: this = other
  		if ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {
  			this._low = other._low
  			this._high = other._high
  			return this
  		}
  */

  		var c16, c00;
  		c00 = a00 * b00;
  		c16 = c00 >>> 16;

  		c16 += a16 * b00;
  		c16 &= 0xFFFF;		// Not required but improves performance
  		c16 += a00 * b16;

  		this._low = c00 & 0xFFFF;
  		this._high = c16 & 0xFFFF;

  		return this
  	};

  	/**
  	 * Divide two _UINT32_. The current _UINT32_ stores the result.
  	 * The remainder is made available as the _remainder_ property on
  	 * the _UINT32_ object. It can be null, meaning there are no remainder.
  	 * @method div
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.div = function (other) {
  		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')

  		// other == 1
  		if (other._high == 0 && other._low == 1) {
  			this.remainder = new UINT32(0);
  			return this
  		}

  		// other > this: 0
  		if ( other.gt(this) ) {
  			this.remainder = this.clone();
  			this._low = 0;
  			this._high = 0;
  			return this
  		}
  		// other == this: 1
  		if ( this.eq(other) ) {
  			this.remainder = new UINT32(0);
  			this._low = 1;
  			this._high = 0;
  			return this
  		}

  		// Shift the divisor left until it is higher than the dividend
  		var _other = other.clone();
  		var i = -1;
  		while ( !this.lt(_other) ) {
  			// High bit can overflow the default 16bits
  			// Its ok since we right shift after this loop
  			// The overflown bit must be kept though
  			_other.shiftLeft(1, true);
  			i++;
  		}

  		// Set the remainder
  		this.remainder = this.clone();
  		// Initialize the current result to 0
  		this._low = 0;
  		this._high = 0;
  		for (; i >= 0; i--) {
  			_other.shiftRight(1);
  			// If shifted divisor is smaller than the dividend
  			// then subtract it from the dividend
  			if ( !this.remainder.lt(_other) ) {
  				this.remainder.subtract(_other);
  				// Update the current result
  				if (i >= 16) {
  					this._high |= 1 << (i - 16);
  				} else {
  					this._low |= 1 << i;
  				}
  			}
  		}

  		return this
  	};

  	/**
  	 * Negate the current _UINT32_
  	 * @method negate
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.negate = function () {
  		var v = ( ~this._low & 0xFFFF ) + 1;
  		this._low = v & 0xFFFF;
  		this._high = (~this._high + (v >>> 16)) & 0xFFFF;

  		return this
  	};

  	/**
  	 * Equals
  	 * @method eq
  	 * @param {Object} other UINT32
  	 * @return {Boolean}
  	 */
  	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
  		return (this._low == other._low) && (this._high == other._high)
  	};

  	/**
  	 * Greater than (strict)
  	 * @method gt
  	 * @param {Object} other UINT32
  	 * @return {Boolean}
  	 */
  	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
  		if (this._high > other._high) return true
  		if (this._high < other._high) return false
  		return this._low > other._low
  	};

  	/**
  	 * Less than (strict)
  	 * @method lt
  	 * @param {Object} other UINT32
  	 * @return {Boolean}
  	 */
  	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
  		if (this._high < other._high) return true
  		if (this._high > other._high) return false
  		return this._low < other._low
  	};

  	/**
  	 * Bitwise OR
  	 * @method or
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.or = function (other) {
  		this._low |= other._low;
  		this._high |= other._high;

  		return this
  	};

  	/**
  	 * Bitwise AND
  	 * @method and
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.and = function (other) {
  		this._low &= other._low;
  		this._high &= other._high;

  		return this
  	};

  	/**
  	 * Bitwise NOT
  	 * @method not
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.not = function() {
  		this._low = ~this._low & 0xFFFF;
  		this._high = ~this._high & 0xFFFF;

  		return this
  	};

  	/**
  	 * Bitwise XOR
  	 * @method xor
  	 * @param {Object} other UINT32
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.xor = function (other) {
  		this._low ^= other._low;
  		this._high ^= other._high;

  		return this
  	};

  	/**
  	 * Bitwise shift right
  	 * @method shiftRight
  	 * @param {Number} number of bits to shift
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
  		if (n > 16) {
  			this._low = this._high >> (n - 16);
  			this._high = 0;
  		} else if (n == 16) {
  			this._low = this._high;
  			this._high = 0;
  		} else {
  			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF );
  			this._high >>= n;
  		}

  		return this
  	};

  	/**
  	 * Bitwise shift left
  	 * @method shiftLeft
  	 * @param {Number} number of bits to shift
  	 * @param {Boolean} allow overflow
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
  		if (n > 16) {
  			this._high = this._low << (n - 16);
  			this._low = 0;
  			if (!allowOverflow) {
  				this._high &= 0xFFFF;
  			}
  		} else if (n == 16) {
  			this._high = this._low;
  			this._low = 0;
  		} else {
  			this._high = (this._high << n) | (this._low >> (16-n));
  			this._low = (this._low << n) & 0xFFFF;
  			if (!allowOverflow) {
  				// Overflow only allowed on the high bits...
  				this._high &= 0xFFFF;
  			}
  		}

  		return this
  	};

  	/**
  	 * Bitwise rotate left
  	 * @method rotl
  	 * @param {Number} number of bits to rotate
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
  		var v = (this._high << 16) | this._low;
  		v = (v << n) | (v >>> (32 - n));
  		this._low = v & 0xFFFF;
  		this._high = v >>> 16;

  		return this
  	};

  	/**
  	 * Bitwise rotate right
  	 * @method rotr
  	 * @param {Number} number of bits to rotate
  	 * @return ThisExpression
  	 */
  	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
  		var v = (this._high << 16) | this._low;
  		v = (v >>> n) | (v << (32 - n));
  		this._low = v & 0xFFFF;
  		this._high = v >>> 16;

  		return this
  	};

  	/**
  	 * Clone the current _UINT32_
  	 * @method clone
  	 * @return {Object} cloned UINT32
  	 */
  	UINT32.prototype.clone = function () {
  		return new UINT32(this._low, this._high)
  	};

  	if (module.exports) {
  		// Node.js
  		module.exports = UINT32;
  	} else {
  		// Browser
  		root['UINT32'] = UINT32;
  	}

  })(commonjsGlobal);
  }(uint32));

  var uint64 = {exports: {}};

  /**
  	C-like unsigned 64 bits integers in Javascript
  	Copyright (C) 2013, Pierre Curto
  	MIT license
   */

  (function (module) {
  (function (root) {

  	// Local cache for typical radices
  	var radixPowerCache = {
  		16: UINT64( Math.pow(16, 5) )
  	,	10: UINT64( Math.pow(10, 5) )
  	,	2:  UINT64( Math.pow(2, 5) )
  	};
  	var radixCache = {
  		16: UINT64(16)
  	,	10: UINT64(10)
  	,	2:  UINT64(2)
  	};

  	/**
  	 *	Represents an unsigned 64 bits integer
  	 * @constructor
  	 * @param {Number} first low bits (8)
  	 * @param {Number} second low bits (8)
  	 * @param {Number} first high bits (8)
  	 * @param {Number} second high bits (8)
  	 * or
  	 * @param {Number} low bits (32)
  	 * @param {Number} high bits (32)
  	 * or
  	 * @param {String|Number} integer as a string 		 | integer as a number
  	 * @param {Number|Undefined} radix (optional, default=10)
  	 * @return 
  	 */
  	function UINT64 (a00, a16, a32, a48) {
  		if ( !(this instanceof UINT64) )
  			return new UINT64(a00, a16, a32, a48)

  		this.remainder = null;
  		if (typeof a00 == 'string')
  			return fromString.call(this, a00, a16)

  		if (typeof a16 == 'undefined')
  			return fromNumber.call(this, a00)

  		fromBits.apply(this, arguments);
  	}

  	/**
  	 * Set the current _UINT64_ object with its low and high bits
  	 * @method fromBits
  	 * @param {Number} first low bits (8)
  	 * @param {Number} second low bits (8)
  	 * @param {Number} first high bits (8)
  	 * @param {Number} second high bits (8)
  	 * or
  	 * @param {Number} low bits (32)
  	 * @param {Number} high bits (32)
  	 * @return ThisExpression
  	 */
  	function fromBits (a00, a16, a32, a48) {
  		if (typeof a32 == 'undefined') {
  			this._a00 = a00 & 0xFFFF;
  			this._a16 = a00 >>> 16;
  			this._a32 = a16 & 0xFFFF;
  			this._a48 = a16 >>> 16;
  			return this
  		}

  		this._a00 = a00 | 0;
  		this._a16 = a16 | 0;
  		this._a32 = a32 | 0;
  		this._a48 = a48 | 0;

  		return this
  	}
  	UINT64.prototype.fromBits = fromBits;

  	/**
  	 * Set the current _UINT64_ object from a number
  	 * @method fromNumber
  	 * @param {Number} number
  	 * @return ThisExpression
  	 */
  	function fromNumber (value) {
  		this._a00 = value & 0xFFFF;
  		this._a16 = value >>> 16;
  		this._a32 = 0;
  		this._a48 = 0;

  		return this
  	}
  	UINT64.prototype.fromNumber = fromNumber;

  	/**
  	 * Set the current _UINT64_ object from a string
  	 * @method fromString
  	 * @param {String} integer as a string
  	 * @param {Number} radix (optional, default=10)
  	 * @return ThisExpression
  	 */
  	function fromString (s, radix) {
  		radix = radix || 10;

  		this._a00 = 0;
  		this._a16 = 0;
  		this._a32 = 0;
  		this._a48 = 0;

  		/*
  			In Javascript, bitwise operators only operate on the first 32 bits 
  			of a number, even though parseInt() encodes numbers with a 53 bits 
  			mantissa.
  			Therefore UINT64(<Number>) can only work on 32 bits.
  			The radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)
  			maximum input value is m = 32bits as 1 = 2^32 - 1
  			So the maximum substring length n is:
  			36^(n+1) - 1 = 2^32 - 1
  			36^(n+1) = 2^32
  			(n+1)ln(36) = 32ln(2)
  			n = 32ln(2)/ln(36) - 1
  			n = 5.189644915687692
  			n = 5
  		 */
  		var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) );

  		for (var i = 0, len = s.length; i < len; i += 5) {
  			var size = Math.min(5, len - i);
  			var value = parseInt( s.slice(i, i + size), radix );
  			this.multiply(
  					size < 5
  						? new UINT64( Math.pow(radix, size) )
  						: radixUint
  				)
  				.add( new UINT64(value) );
  		}

  		return this
  	}
  	UINT64.prototype.fromString = fromString;

  	/**
  	 * Convert this _UINT64_ to a number (last 32 bits are dropped)
  	 * @method toNumber
  	 * @return {Number} the converted UINT64
  	 */
  	UINT64.prototype.toNumber = function () {
  		return (this._a16 * 65536) + this._a00
  	};

  	/**
  	 * Convert this _UINT64_ to a string
  	 * @method toString
  	 * @param {Number} radix (optional, default=10)
  	 * @return {String} the converted UINT64
  	 */
  	UINT64.prototype.toString = function (radix) {
  		radix = radix || 10;
  		var radixUint = radixCache[radix] || new UINT64(radix);

  		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)

  		var self = this.clone();
  		var res = new Array(64);
  		for (var i = 63; i >= 0; i--) {
  			self.div(radixUint);
  			res[i] = self.remainder.toNumber().toString(radix);
  			if ( !self.gt(radixUint) ) break
  		}
  		res[i-1] = self.toNumber().toString(radix);

  		return res.join('')
  	};

  	/**
  	 * Add two _UINT64_. The current _UINT64_ stores the result
  	 * @method add
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.add = function (other) {
  		var a00 = this._a00 + other._a00;

  		var a16 = a00 >>> 16;
  		a16 += this._a16 + other._a16;

  		var a32 = a16 >>> 16;
  		a32 += this._a32 + other._a32;

  		var a48 = a32 >>> 16;
  		a48 += this._a48 + other._a48;

  		this._a00 = a00 & 0xFFFF;
  		this._a16 = a16 & 0xFFFF;
  		this._a32 = a32 & 0xFFFF;
  		this._a48 = a48 & 0xFFFF;

  		return this
  	};

  	/**
  	 * Subtract two _UINT64_. The current _UINT64_ stores the result
  	 * @method subtract
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.subtract = function (other) {
  		return this.add( other.clone().negate() )
  	};

  	/**
  	 * Multiply two _UINT64_. The current _UINT64_ stores the result
  	 * @method multiply
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.multiply = function (other) {
  		/*
  			a = a00 + a16 + a32 + a48
  			b = b00 + b16 + b32 + b48
  			a*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)
  				= a00b00 + a00b16 + a00b32 + a00b48
  				+ a16b00 + a16b16 + a16b32 + a16b48
  				+ a32b00 + a32b16 + a32b32 + a32b48
  				+ a48b00 + a48b16 + a48b32 + a48b48

  			a16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits
  			so it comes down to:
  			a*b	= a00b00 + a00b16 + a00b32 + a00b48
  				+ a16b00 + a16b16 + a16b32
  				+ a32b00 + a32b16
  				+ a48b00
  				= a00b00
  				+ a00b16 + a16b00
  				+ a00b32 + a16b16 + a32b00
  				+ a00b48 + a16b32 + a32b16 + a48b00
  		 */
  		var a00 = this._a00;
  		var a16 = this._a16;
  		var a32 = this._a32;
  		var a48 = this._a48;
  		var b00 = other._a00;
  		var b16 = other._a16;
  		var b32 = other._a32;
  		var b48 = other._a48;

  		var c00 = a00 * b00;

  		var c16 = c00 >>> 16;
  		c16 += a00 * b16;
  		var c32 = c16 >>> 16;
  		c16 &= 0xFFFF;
  		c16 += a16 * b00;

  		c32 += c16 >>> 16;
  		c32 += a00 * b32;
  		var c48 = c32 >>> 16;
  		c32 &= 0xFFFF;
  		c32 += a16 * b16;
  		c48 += c32 >>> 16;
  		c32 &= 0xFFFF;
  		c32 += a32 * b00;

  		c48 += c32 >>> 16;
  		c48 += a00 * b48;
  		c48 &= 0xFFFF;
  		c48 += a16 * b32;
  		c48 &= 0xFFFF;
  		c48 += a32 * b16;
  		c48 &= 0xFFFF;
  		c48 += a48 * b00;

  		this._a00 = c00 & 0xFFFF;
  		this._a16 = c16 & 0xFFFF;
  		this._a32 = c32 & 0xFFFF;
  		this._a48 = c48 & 0xFFFF;

  		return this
  	};

  	/**
  	 * Divide two _UINT64_. The current _UINT64_ stores the result.
  	 * The remainder is made available as the _remainder_ property on
  	 * the _UINT64_ object. It can be null, meaning there are no remainder.
  	 * @method div
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.div = function (other) {
  		if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
  			if (other._a00 == 0) throw Error('division by zero')

  			// other == 1: this
  			if (other._a00 == 1) {
  				this.remainder = new UINT64(0);
  				return this
  			}
  		}

  		// other > this: 0
  		if ( other.gt(this) ) {
  			this.remainder = this.clone();
  			this._a00 = 0;
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  			return this
  		}
  		// other == this: 1
  		if ( this.eq(other) ) {
  			this.remainder = new UINT64(0);
  			this._a00 = 1;
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  			return this
  		}

  		// Shift the divisor left until it is higher than the dividend
  		var _other = other.clone();
  		var i = -1;
  		while ( !this.lt(_other) ) {
  			// High bit can overflow the default 16bits
  			// Its ok since we right shift after this loop
  			// The overflown bit must be kept though
  			_other.shiftLeft(1, true);
  			i++;
  		}

  		// Set the remainder
  		this.remainder = this.clone();
  		// Initialize the current result to 0
  		this._a00 = 0;
  		this._a16 = 0;
  		this._a32 = 0;
  		this._a48 = 0;
  		for (; i >= 0; i--) {
  			_other.shiftRight(1);
  			// If shifted divisor is smaller than the dividend
  			// then subtract it from the dividend
  			if ( !this.remainder.lt(_other) ) {
  				this.remainder.subtract(_other);
  				// Update the current result
  				if (i >= 48) {
  					this._a48 |= 1 << (i - 48);
  				} else if (i >= 32) {
  					this._a32 |= 1 << (i - 32);
  				} else if (i >= 16) {
  					this._a16 |= 1 << (i - 16);
  				} else {
  					this._a00 |= 1 << i;
  				}
  			}
  		}

  		return this
  	};

  	/**
  	 * Negate the current _UINT64_
  	 * @method negate
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.negate = function () {
  		var v = ( ~this._a00 & 0xFFFF ) + 1;
  		this._a00 = v & 0xFFFF;
  		v = (~this._a16 & 0xFFFF) + (v >>> 16);
  		this._a16 = v & 0xFFFF;
  		v = (~this._a32 & 0xFFFF) + (v >>> 16);
  		this._a32 = v & 0xFFFF;
  		this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF;

  		return this
  	};

  	/**

  	 * @method eq
  	 * @param {Object} other UINT64
  	 * @return {Boolean}
  	 */
  	UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
  		return (this._a48 == other._a48) && (this._a00 == other._a00)
  			 && (this._a32 == other._a32) && (this._a16 == other._a16)
  	};

  	/**
  	 * Greater than (strict)
  	 * @method gt
  	 * @param {Object} other UINT64
  	 * @return {Boolean}
  	 */
  	UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
  		if (this._a48 > other._a48) return true
  		if (this._a48 < other._a48) return false
  		if (this._a32 > other._a32) return true
  		if (this._a32 < other._a32) return false
  		if (this._a16 > other._a16) return true
  		if (this._a16 < other._a16) return false
  		return this._a00 > other._a00
  	};

  	/**
  	 * Less than (strict)
  	 * @method lt
  	 * @param {Object} other UINT64
  	 * @return {Boolean}
  	 */
  	UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
  		if (this._a48 < other._a48) return true
  		if (this._a48 > other._a48) return false
  		if (this._a32 < other._a32) return true
  		if (this._a32 > other._a32) return false
  		if (this._a16 < other._a16) return true
  		if (this._a16 > other._a16) return false
  		return this._a00 < other._a00
  	};

  	/**
  	 * Bitwise OR
  	 * @method or
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.or = function (other) {
  		this._a00 |= other._a00;
  		this._a16 |= other._a16;
  		this._a32 |= other._a32;
  		this._a48 |= other._a48;

  		return this
  	};

  	/**
  	 * Bitwise AND
  	 * @method and
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.and = function (other) {
  		this._a00 &= other._a00;
  		this._a16 &= other._a16;
  		this._a32 &= other._a32;
  		this._a48 &= other._a48;

  		return this
  	};

  	/**
  	 * Bitwise XOR
  	 * @method xor
  	 * @param {Object} other UINT64
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.xor = function (other) {
  		this._a00 ^= other._a00;
  		this._a16 ^= other._a16;
  		this._a32 ^= other._a32;
  		this._a48 ^= other._a48;

  		return this
  	};

  	/**
  	 * Bitwise NOT
  	 * @method not
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.not = function() {
  		this._a00 = ~this._a00 & 0xFFFF;
  		this._a16 = ~this._a16 & 0xFFFF;
  		this._a32 = ~this._a32 & 0xFFFF;
  		this._a48 = ~this._a48 & 0xFFFF;

  		return this
  	};

  	/**
  	 * Bitwise shift right
  	 * @method shiftRight
  	 * @param {Number} number of bits to shift
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
  		n %= 64;
  		if (n >= 48) {
  			this._a00 = this._a48 >> (n - 48);
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  		} else if (n >= 32) {
  			n -= 32;
  			this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a16 = (this._a48 >> n) & 0xFFFF;
  			this._a32 = 0;
  			this._a48 = 0;
  		} else if (n >= 16) {
  			n -= 16;
  			this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a32 = (this._a48 >> n) & 0xFFFF;
  			this._a48 = 0;
  		} else {
  			this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF;
  			this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a48 = (this._a48 >> n) & 0xFFFF;
  		}

  		return this
  	};

  	/**
  	 * Bitwise shift left
  	 * @method shiftLeft
  	 * @param {Number} number of bits to shift
  	 * @param {Boolean} allow overflow
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
  		n %= 64;
  		if (n >= 48) {
  			this._a48 = this._a00 << (n - 48);
  			this._a32 = 0;
  			this._a16 = 0;
  			this._a00 = 0;
  		} else if (n >= 32) {
  			n -= 32;
  			this._a48 = (this._a16 << n) | (this._a00 >> (16-n));
  			this._a32 = (this._a00 << n) & 0xFFFF;
  			this._a16 = 0;
  			this._a00 = 0;
  		} else if (n >= 16) {
  			n -= 16;
  			this._a48 = (this._a32 << n) | (this._a16 >> (16-n));
  			this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF;
  			this._a16 = (this._a00 << n) & 0xFFFF;
  			this._a00 = 0;
  		} else {
  			this._a48 = (this._a48 << n) | (this._a32 >> (16-n));
  			this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF;
  			this._a00 = (this._a00 << n) & 0xFFFF;
  		}
  		if (!allowOverflow) {
  			this._a48 &= 0xFFFF;
  		}

  		return this
  	};

  	/**
  	 * Bitwise rotate left
  	 * @method rotl
  	 * @param {Number} number of bits to rotate
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
  		n %= 64;
  		if (n == 0) return this
  		if (n >= 32) {
  			// A.B.C.D
  			// B.C.D.A rotl(16)
  			// C.D.A.B rotl(32)
  			var v = this._a00;
  			this._a00 = this._a32;
  			this._a32 = v;
  			v = this._a48;
  			this._a48 = this._a16;
  			this._a16 = v;
  			if (n == 32) return this
  			n -= 32;
  		}

  		var high = (this._a48 << 16) | this._a32;
  		var low = (this._a16 << 16) | this._a00;

  		var _high = (high << n) | (low >>> (32 - n));
  		var _low = (low << n) | (high >>> (32 - n));

  		this._a00 = _low & 0xFFFF;
  		this._a16 = _low >>> 16;
  		this._a32 = _high & 0xFFFF;
  		this._a48 = _high >>> 16;

  		return this
  	};

  	/**
  	 * Bitwise rotate right
  	 * @method rotr
  	 * @param {Number} number of bits to rotate
  	 * @return ThisExpression
  	 */
  	UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
  		n %= 64;
  		if (n == 0) return this
  		if (n >= 32) {
  			// A.B.C.D
  			// D.A.B.C rotr(16)
  			// C.D.A.B rotr(32)
  			var v = this._a00;
  			this._a00 = this._a32;
  			this._a32 = v;
  			v = this._a48;
  			this._a48 = this._a16;
  			this._a16 = v;
  			if (n == 32) return this
  			n -= 32;
  		}

  		var high = (this._a48 << 16) | this._a32;
  		var low = (this._a16 << 16) | this._a00;

  		var _high = (high >>> n) | (low << (32 - n));
  		var _low = (low >>> n) | (high << (32 - n));

  		this._a00 = _low & 0xFFFF;
  		this._a16 = _low >>> 16;
  		this._a32 = _high & 0xFFFF;
  		this._a48 = _high >>> 16;

  		return this
  	};

  	/**
  	 * Clone the current _UINT64_
  	 * @method clone
  	 * @return {Object} cloned UINT64
  	 */
  	UINT64.prototype.clone = function () {
  		return new UINT64(this._a00, this._a16, this._a32, this._a48)
  	};

  	if (module.exports) {
  		// Node.js
  		module.exports = UINT64;
  	} else {
  		// Browser
  		root['UINT64'] = UINT64;
  	}

  })(commonjsGlobal);
  }(uint64));

  cuint.UINT32 = uint32.exports;
  cuint.UINT64 = uint64.exports;

  var UINT32 = cuint.UINT32;

  /*
  	Merged this sequence of method calls as it speeds up
  	the calculations by a factor of 2
   */
  // this.v1.add( other.multiply(PRIME32_2) ).rotl(13).multiply(PRIME32_1);
  UINT32.prototype.xxh_update = function (low, high) {
  	var b00 = PRIME32_2._low;
  	var b16 = PRIME32_2._high;

  	var c16, c00;
  	c00 = low * b00;
  	c16 = c00 >>> 16;

  	c16 += high * b00;
  	c16 &= 0xFFFF;		// Not required but improves performance
  	c16 += low * b16;

  	var a00 = this._low + (c00 & 0xFFFF);
  	var a16 = a00 >>> 16;

  	a16 += this._high + (c16 & 0xFFFF);

  	var v = (a16 << 16) | (a00 & 0xFFFF);
  	v = (v << 13) | (v >>> 19);

  	a00 = v & 0xFFFF;
  	a16 = v >>> 16;

  	b00 = PRIME32_1._low;
  	b16 = PRIME32_1._high;

  	c00 = a00 * b00;
  	c16 = c00 >>> 16;

  	c16 += a16 * b00;
  	c16 &= 0xFFFF;		// Not required but improves performance
  	c16 += a00 * b16;

  	this._low = c00 & 0xFFFF;
  	this._high = c16 & 0xFFFF;
  };

  /*
   * Constants
   */
  var PRIME32_1 = UINT32( '2654435761' );
  var PRIME32_2 = UINT32( '2246822519' );
  var PRIME32_3 = UINT32( '3266489917' );
  var PRIME32_4 = UINT32(  '668265263' );
  var PRIME32_5 = UINT32(  '374761393' );

  /**
  * Convert string to proper UTF-8 array
  * @param str Input string
  * @returns {Uint8Array} UTF8 array is returned as uint8 array
  */
  function toUTF8Array$1 (str) {
  	var utf8 = [];
  	for (var i=0, n=str.length; i < n; i++) {
  		var charcode = str.charCodeAt(i);
  		if (charcode < 0x80) utf8.push(charcode);
  		else if (charcode < 0x800) {
  			utf8.push(0xc0 | (charcode >> 6),
  			0x80 | (charcode & 0x3f));
  		}
  		else if (charcode < 0xd800 || charcode >= 0xe000) {
  			utf8.push(0xe0 | (charcode >> 12),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  		// surrogate pair
  		else {
  			i++;
  			// UTF-16 encodes 0x10000-0x10FFFF by
  			// subtracting 0x10000 and splitting the
  			// 20 bits of 0x0-0xFFFFF into two halves
  			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
  			| (str.charCodeAt(i) & 0x3ff));
  			utf8.push(0xf0 | (charcode >>18),
  			0x80 | ((charcode>>12) & 0x3f),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  	}

  	return new Uint8Array(utf8)
  }

  /**
   * XXH object used as a constructor or a function
   * @constructor
   * or
   * @param {Object|String} input data
   * @param {Number|UINT32} seed
   * @return ThisExpression
   * or
   * @return {UINT32} xxHash
   */
  function XXH () {
  	if (arguments.length == 2)
  		return new XXH( arguments[1] ).update( arguments[0] ).digest()

  	if (!(this instanceof XXH))
  		return new XXH( arguments[0] )

  	init$1.call(this, arguments[0]);
  }

  /**
   * Initialize the XXH instance with the given seed
   * @method init
   * @param {Number|Object} seed as a number or an unsigned 32 bits integer
   * @return ThisExpression
   */
   function init$1 (seed) {
  	this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
  	this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
  	this.v2 = this.seed.clone().add(PRIME32_2);
  	this.v3 = this.seed.clone();
  	this.v4 = this.seed.clone().subtract(PRIME32_1);
  	this.total_len = 0;
  	this.memsize = 0;
  	this.memory = null;

  	return this
  }
  XXH.prototype.init = init$1;

  /**
   * Add data to be computed for the XXH hash
   * @method update
   * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
   * @return ThisExpression
   */
  XXH.prototype.update = function (input) {
  	var isString = typeof input == 'string';
  	var isArrayBuffer;

  	// Convert all strings to utf-8 first (issue #5)
  	if (isString) {
  		input = toUTF8Array$1(input);
  		isString = false;
  		isArrayBuffer = true;
  	}

  	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
  	{
  		isArrayBuffer = true;
  		input = new Uint8Array(input);
  	}

  	var p = 0;
  	var len = input.length;
  	var bEnd = p + len;

  	if (len == 0) return this

  	this.total_len += len;

  	if (this.memsize == 0)
  	{
  		if (isString) {
  			this.memory = '';
  		} else if (isArrayBuffer) {
  			this.memory = new Uint8Array(16);
  		} else {
  			this.memory = new Buffer(16);
  		}
  	}

  	if (this.memsize + len < 16)   // fill in tmp buffer
  	{
  		// XXH_memcpy(this.memory + this.memsize, input, len)
  		if (isString) {
  			this.memory += input;
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, len), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, len );
  		}

  		this.memsize += len;
  		return this
  	}

  	if (this.memsize > 0)   // some data left from previous update
  	{
  		// XXH_memcpy(this.memory + this.memsize, input, 16-this.memsize);
  		if (isString) {
  			this.memory += input.slice(0, 16 - this.memsize);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, 16 - this.memsize );
  		}

  		var p32 = 0;
  		if (isString) {
  			this.v1.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v2.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v3.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v4.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  		} else {
  			this.v1.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v2.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v3.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v4.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  		}

  		p += 16 - this.memsize;
  		this.memsize = 0;
  		if (isString) this.memory = '';
  	}

  	if (p <= bEnd - 16)
  	{
  		var limit = bEnd - 16;

  		do
  		{
  			if (isString) {
  				this.v1.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v2.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v3.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v4.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  			} else {
  				this.v1.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v2.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v3.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v4.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  			}
  			p += 4;
  		} while (p <= limit)
  	}

  	if (p < bEnd)
  	{
  		// XXH_memcpy(this.memory, p, bEnd-p);
  		if (isString) {
  			this.memory += input.slice(p);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(p, bEnd), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, p, bEnd );
  		}

  		this.memsize = bEnd - p;
  	}

  	return this
  };

  /**
   * Finalize the XXH computation. The XXH instance is ready for reuse for the given seed
   * @method digest
   * @return {UINT32} xxHash
   */
  XXH.prototype.digest = function () {
  	var input = this.memory;
  	var isString = typeof input == 'string';
  	var p = 0;
  	var bEnd = this.memsize;
  	var h32, h;
  	var u = new UINT32;

  	if (this.total_len >= 16)
  	{
  		h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) );
  	}
  	else
  	{
  		h32  = this.seed.clone().add( PRIME32_5 );
  	}

  	h32.add( u.fromNumber(this.total_len) );

  	while (p <= bEnd - 4)
  	{
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			);
  		}
  		h32
  			.add( u.multiply(PRIME32_3) )
  			.rotl(17)
  			.multiply( PRIME32_4 );
  		p += 4;
  	}

  	while (p < bEnd)
  	{
  		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 );
  		h32
  			.add( u.multiply(PRIME32_5) )
  			.rotl(11)
  			.multiply(PRIME32_1);
  	}

  	h = h32.clone().shiftRight(15);
  	h32.xor(h).multiply(PRIME32_2);

  	h = h32.clone().shiftRight(13);
  	h32.xor(h).multiply(PRIME32_3);

  	h = h32.clone().shiftRight(16);
  	h32.xor(h);

  	// Reset the state
  	this.init( this.seed );

  	return h32
  };

  var xxhash = XXH;

  var UINT64 = cuint.UINT64;

  /*
   * Constants
   */
  var PRIME64_1 = UINT64( '11400714785074694791' );
  var PRIME64_2 = UINT64( '14029467366897019727' );
  var PRIME64_3 = UINT64(  '1609587929392839161' );
  var PRIME64_4 = UINT64(  '9650029242287828579' );
  var PRIME64_5 = UINT64(  '2870177450012600261' );

  /**
  * Convert string to proper UTF-8 array
  * @param str Input string
  * @returns {Uint8Array} UTF8 array is returned as uint8 array
  */
  function toUTF8Array (str) {
  	var utf8 = [];
  	for (var i=0, n=str.length; i < n; i++) {
  		var charcode = str.charCodeAt(i);
  		if (charcode < 0x80) utf8.push(charcode);
  		else if (charcode < 0x800) {
  			utf8.push(0xc0 | (charcode >> 6),
  			0x80 | (charcode & 0x3f));
  		}
  		else if (charcode < 0xd800 || charcode >= 0xe000) {
  			utf8.push(0xe0 | (charcode >> 12),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  		// surrogate pair
  		else {
  			i++;
  			// UTF-16 encodes 0x10000-0x10FFFF by
  			// subtracting 0x10000 and splitting the
  			// 20 bits of 0x0-0xFFFFF into two halves
  			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
  			| (str.charCodeAt(i) & 0x3ff));
  			utf8.push(0xf0 | (charcode >>18),
  			0x80 | ((charcode>>12) & 0x3f),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  	}

  	return new Uint8Array(utf8)
  }

  /**
   * XXH64 object used as a constructor or a function
   * @constructor
   * or
   * @param {Object|String} input data
   * @param {Number|UINT64} seed
   * @return ThisExpression
   * or
   * @return {UINT64} xxHash
   */
  function XXH64 () {
  	if (arguments.length == 2)
  		return new XXH64( arguments[1] ).update( arguments[0] ).digest()

  	if (!(this instanceof XXH64))
  		return new XXH64( arguments[0] )

  	init.call(this, arguments[0]);
  }

  /**
   * Initialize the XXH64 instance with the given seed
   * @method init
   * @param {Number|Object} seed as a number or an unsigned 32 bits integer
   * @return ThisExpression
   */
   function init (seed) {
  	this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
  	this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
  	this.v2 = this.seed.clone().add(PRIME64_2);
  	this.v3 = this.seed.clone();
  	this.v4 = this.seed.clone().subtract(PRIME64_1);
  	this.total_len = 0;
  	this.memsize = 0;
  	this.memory = null;

  	return this
  }
  XXH64.prototype.init = init;

  /**
   * Add data to be computed for the XXH64 hash
   * @method update
   * @param {String|Buffer|ArrayBuffer} input as a string or nodejs Buffer or ArrayBuffer
   * @return ThisExpression
   */
  XXH64.prototype.update = function (input) {
  	var isString = typeof input == 'string';
  	var isArrayBuffer;

  	// Convert all strings to utf-8 first (issue #5)
  	if (isString) {
  		input = toUTF8Array(input);
  		isString = false;
  		isArrayBuffer = true;
  	}

  	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
  	{
  		isArrayBuffer = true;
  		input = new Uint8Array(input);
  	}

  	var p = 0;
  	var len = input.length;
  	var bEnd = p + len;

  	if (len == 0) return this

  	this.total_len += len;

  	if (this.memsize == 0)
  	{
  		if (isString) {
  			this.memory = '';
  		} else if (isArrayBuffer) {
  			this.memory = new Uint8Array(32);
  		} else {
  			this.memory = new Buffer(32);
  		}
  	}

  	if (this.memsize + len < 32)   // fill in tmp buffer
  	{
  		// XXH64_memcpy(this.memory + this.memsize, input, len)
  		if (isString) {
  			this.memory += input;
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, len), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, len );
  		}

  		this.memsize += len;
  		return this
  	}

  	if (this.memsize > 0)   // some data left from previous update
  	{
  		// XXH64_memcpy(this.memory + this.memsize, input, 16-this.memsize);
  		if (isString) {
  			this.memory += input.slice(0, 32 - this.memsize);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, 32 - this.memsize );
  		}

  		var p64 = 0;
  		if (isString) {
  			var other;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  		} else {
  			var other;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  		}

  		p += 32 - this.memsize;
  		this.memsize = 0;
  		if (isString) this.memory = '';
  	}

  	if (p <= bEnd - 32)
  	{
  		var limit = bEnd - 32;

  		do
  		{
  			if (isString) {
  				var other;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			} else {
  				var other;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			}
  			p += 8;
  		} while (p <= limit)
  	}

  	if (p < bEnd)
  	{
  		// XXH64_memcpy(this.memory, p, bEnd-p);
  		if (isString) {
  			this.memory += input.slice(p);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(p, bEnd), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, p, bEnd );
  		}

  		this.memsize = bEnd - p;
  	}

  	return this
  };

  /**
   * Finalize the XXH64 computation. The XXH64 instance is ready for reuse for the given seed
   * @method digest
   * @return {UINT64} xxHash
   */
  XXH64.prototype.digest = function () {
  	var input = this.memory;
  	var isString = typeof input == 'string';
  	var p = 0;
  	var bEnd = this.memsize;
  	var h64, h;
  	var u = new UINT64;

  	if (this.total_len >= 32)
  	{
  		h64 = this.v1.clone().rotl(1);
  		h64.add( this.v2.clone().rotl(7) );
  		h64.add( this.v3.clone().rotl(12) );
  		h64.add( this.v4.clone().rotl(18) );

  		h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);

  		h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);

  		h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);

  		h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);
  	}
  	else
  	{
  		h64  = this.seed.clone().add( PRIME64_5 );
  	}

  	h64.add( u.fromNumber(this.total_len) );

  	while (p <= bEnd - 8)
  	{
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  			,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			,	(input[p+5] << 8) | input[p+4]
  			,	(input[p+7] << 8) | input[p+6]
  			);
  		}
  		u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
  		h64
  			.xor(u)
  			.rotl(27)
  			.multiply( PRIME64_1 )
  			.add( PRIME64_4 );
  		p += 8;
  	}

  	if (p + 4 <= bEnd) {
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			,	0
  			,	0
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			,	0
  			,	0
  			);
  		}
  		h64
  			.xor( u.multiply(PRIME64_1) )
  			.rotl(23)
  			.multiply( PRIME64_2 )
  			.add( PRIME64_3 );
  		p += 4;
  	}

  	while (p < bEnd)
  	{
  		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 );
  		h64
  			.xor( u.multiply(PRIME64_5) )
  			.rotl(11)
  			.multiply(PRIME64_1);
  	}

  	h = h64.clone().shiftRight(33);
  	h64.xor(h).multiply(PRIME64_2);

  	h = h64.clone().shiftRight(29);
  	h64.xor(h).multiply(PRIME64_3);

  	h = h64.clone().shiftRight(32);
  	h64.xor(h);

  	// Reset the state
  	this.init( this.seed );

  	return h64
  };

  var xxhash64 = XXH64;

  var lib = {
  	h32: xxhash
  ,	h64: xxhash64
  };

  const xx = lib;

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function xxhash64AsValue(data, seed) {
    return xx.h64(require$$0$3.u8aToU8a(data).buffer, seed);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function xxhash64AsRaw(data, seed) {
    return xxhash64AsValue(data, seed).toString(16);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  function xxhash64AsBn(data, seed) {
    return new require$$0$3.BN(xxhash64AsRaw(data, seed), 16);
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name xxhashAsU8a
   * @summary Creates a xxhash64 u8a from the input.
   * @description
   * From either a `string`, `Uint8Array` or a `Buffer` input, create the xxhash64 and return the result as a `Uint8Array` with the specified `bitLength`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { xxhashAsU8a } from '@polkadot/util-crypto';
   *
   * xxhashAsU8a('abc'); // => 0x44bc2cf5ad770999
   * ```
   */

  function xxhashAsU8a(data, bitLength = 64, onlyJs = false) {
    const iterations = Math.ceil(bitLength / 64);
    const u8a = require$$0$3.u8aToU8a(data);

    if (isReady() && !onlyJs) {
      return twox(u8a, iterations);
    }

    const result = new Uint8Array(Math.ceil(bitLength / 8));

    for (let seed = 0; seed < iterations; seed++) {
      result.set(xxhash64AsBn(u8a, seed).toArray('le', 8), seed * 8);
    }

    return result;
  }

  // Copyright 2017-2021 @polkadot/util-crypto authors & contributors
  /**
   * @name xxhashAsHex
   * @summary Creates a xxhash64 hex from the input.
   * @description
   * From either a `string`, `Uint8Array` or a `Buffer` input, create the xxhash64 and return the result as a hex string with the specified `bitLength`.
   * @example
   * <BR>
   *
   * ```javascript
   * import { xxhashAsHex } from '@polkadot/util-crypto';
   *
   * xxhashAsHex('abc'); // => 0x44bc2cf5ad770999
   * ```
   */

  function xxhashAsHex(data, bitLength = 64) {
    return require$$0$3.u8aToHex(xxhashAsU8a(data, bitLength));
  }

  exports.addressEq = addressEq;
  exports.addressToEvm = addressToEvm;
  exports.allNetworks = allNetworks;
  exports.availableNetworks = availableNetworks;
  exports.base32Decode = base32Decode;
  exports.base32Encode = base32Encode;
  exports.base32Validate = base32Validate;
  exports.base58Decode = base58Decode;
  exports.base58Encode = base58Encode;
  exports.base58Validate = base58Validate;
  exports.base64Decode = base64Decode;
  exports.base64Encode = base64Encode;
  exports.base64Pad = base64Pad;
  exports.base64Trim = base64Trim;
  exports.base64Validate = base64Validate;
  exports.blake2AsHex = blake2AsHex;
  exports.blake2AsU8a = blake2AsU8a;
  exports.checkAddress = checkAddress;
  exports.checkAddressChecksum = checkAddressChecksum;
  exports.convertPublicKeyToCurve25519 = convertPublicKeyToCurve25519;
  exports.convertSecretKeyToCurve25519 = convertSecretKeyToCurve25519;
  exports.createKeyDerived = createKeyDerived;
  exports.createKeyMulti = createKeyMulti;
  exports.cryptoIsReady = cryptoIsReady;
  exports.cryptoWaitReady = cryptoWaitReady;
  exports.decodeAddress = decodeAddress;
  exports.deriveAddress = deriveAddress;
  exports.encodeAddress = encodeAddress;
  exports.encodeDerivedAddress = encodeDerivedAddress;
  exports.encodeMultiAddress = encodeMultiAddress;
  exports.ethereumEncode = ethereumEncode;
  exports.evmToAddress = evmToAddress;
  exports.hdEthereum = hdEthereum;
  exports.hdLedger = hdLedger;
  exports.hdValidatePath = hdValidatePath;
  exports.hmacSha256 = hmacSha256;
  exports.hmacSha512 = hmacSha512;
  exports.isAddress = isAddress;
  exports.isBase32 = isBase32;
  exports.isBase58 = isBase58;
  exports.isBase64 = isBase64;
  exports.isEthereumAddress = isEthereumAddress;
  exports.isEthereumChecksum = isEthereumChecksum;
  exports.jsonDecrypt = jsonDecrypt;
  exports.jsonDecryptData = jsonDecryptData;
  exports.jsonEncrypt = jsonEncrypt;
  exports.jsonEncryptFormat = jsonEncryptFormat;
  exports.keccakAsHex = keccakAsHex;
  exports.keccakAsU8a = keccakAsU8a;
  exports.keyExtractPath = keyExtractPath;
  exports.keyExtractSuri = keyExtractSuri;
  exports.keyFromPath = keyFromPath;
  exports.keyHdkdEcdsa = keyHdkdEcdsa;
  exports.keyHdkdEd25519 = keyHdkdEd25519;
  exports.keyHdkdSr25519 = keyHdkdSr25519;
  exports.mnemonicGenerate = mnemonicGenerate;
  exports.mnemonicToEntropy = mnemonicToEntropy;
  exports.mnemonicToLegacySeed = mnemonicToLegacySeed;
  exports.mnemonicToMiniSecret = mnemonicToMiniSecret;
  exports.mnemonicValidate = mnemonicValidate;
  exports.naclBoxKeypairFromSecret = naclBoxKeypairFromSecret;
  exports.naclDecrypt = naclDecrypt;
  exports.naclEncrypt = naclEncrypt;
  exports.naclKeypairFromRandom = naclKeypairFromRandom;
  exports.naclKeypairFromSecret = naclKeypairFromSecret;
  exports.naclKeypairFromSeed = naclKeypairFromSeed;
  exports.naclKeypairFromString = naclKeypairFromString;
  exports.naclOpen = naclOpen;
  exports.naclSeal = naclSeal;
  exports.naclSign = naclSign;
  exports.naclVerify = naclVerify;
  exports.packageInfo = packageInfo;
  exports.pbkdf2Encode = pbkdf2Encode;
  exports.randomAsHex = randomAsHex;
  exports.randomAsNumber = randomAsNumber;
  exports.randomAsU8a = randomAsU8a;
  exports.schnorrkelAgreement = schnorrkelAgreement;
  exports.schnorrkelDeriveHard = schnorrkelDeriveHard;
  exports.schnorrkelDerivePublic = schnorrkelDerivePublic;
  exports.schnorrkelDeriveSoft = schnorrkelDeriveSoft;
  exports.schnorrkelKeypairFromSeed = schnorrkelKeypairFromSeed;
  exports.schnorrkelSign = schnorrkelSign;
  exports.schnorrkelVerify = schnorrkelVerify;
  exports.schnorrkelVrfSign = schnorrkelVrfSign;
  exports.schnorrkelVrfVerify = schnorrkelVrfVerify;
  exports.scryptEncode = scryptEncode;
  exports.scryptFromU8a = scryptFromU8a;
  exports.scryptToU8a = scryptToU8a;
  exports.secp256k1Compress = secp256k1Compress;
  exports.secp256k1Expand = secp256k1Expand;
  exports.secp256k1KeypairFromSeed = secp256k1KeypairFromSeed;
  exports.secp256k1PrivateKeyTweakAdd = secp256k1PrivateKeyTweakAdd;
  exports.secp256k1Recover = secp256k1Recover;
  exports.secp256k1Sign = secp256k1Sign;
  exports.secp256k1Verify = secp256k1Verify;
  exports.selectableNetworks = selectableNetworks;
  exports.setSS58Format = setSS58Format;
  exports.sha512AsU8a = sha512AsU8a;
  exports.signatureVerify = signatureVerify;
  exports.sortAddresses = sortAddresses;
  exports.validateAddress = validateAddress;
  exports.xxhashAsHex = xxhashAsHex;
  exports.xxhashAsU8a = xxhashAsU8a;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, polkadotUtil);
