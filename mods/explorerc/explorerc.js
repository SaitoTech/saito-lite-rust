const ModTemplate = require('../../lib/templates/modtemplate');
const path = require('path');
const ExplorerHomePage = require('./index'); // Require the HTML generation function
const JSON = require('json-bigint'); // Add require for json-bigint

// Restore requires for direct rendering in render()
const React = require('react'); 
const { createRoot } = require('react-dom/client'); 
const App = require('./react-components/App').default; // Require the main React component - Added .default

class Explorerc extends ModTemplate {

  constructor(app) {
    super(app);
    this.app = app;
    this.name = "explorerc"; // Use lowercase slug for consistency
    this.description = "Saito Block Explorer (React Version)";
    this.categories = "Utilities Information";

    // Define the style bundle
    this.styles = [`/${this.name}/style.css`]; 
    // bundle.js is NOT included here - rendering happens directly in render()
    this.scripts = []; 

    this.rendered = false; // Track if render has been called

    return this;
  }

  async initialize(app) {
    await super.initialize(app);
    console.log(`${this.returnName()} Initialized (React rendering handled directly in render())`);
  }

  //
  // RENDER (CLIENT)
  // This method now directly handles rendering the main React component into the DOM
  // mimicking the approach in mods/react/react.js
  //
  async render() {
    console.log(`${this.returnName()} render() method called.`);
    // Ensure styles are attached first by calling super.render()
    try {
      await super.render(); 
      console.log(`${this.returnName()} super.render() completed.`);
    } catch (err) {
        console.error(`${this.returnName()} error during super.render():`, err);
        return; // Don't proceed if super.render fails
    }

    // Prevent re-rendering
    if (this.rendered) {
      console.log(`${this.returnName()} render() aborted: Already rendered.`);
      return;
    }

    console.log(`${this.returnName()} looking for root element #saito-react-app...`);
    // Find the mount point defined in mods/explorerc/index.js
    const rootElement = document.getElementById('saito-react-app');

    if (rootElement) {
      console.log(`${this.returnName()} found root element #saito-react-app.`);
      try {
        // Use react-dom/client to render the App component
        console.log(`${this.returnName()} attempting to render React component...`);
        // Verify App component is loaded
        if (!App) {
            console.error(`${this.returnName()} Error: App component is undefined or null. Check require statement.`);
            return;
        }
        const root = createRoot(rootElement);
        root.render(<App app={this.app} mod={this} />);
        this.rendered = true;
        console.log(`${this.returnName()} React component rendered successfully.`);
      } catch (err) {
        console.error(`${this.returnName()} Error rendering React component in render():`, err);
      }
    } else {
      console.error(`${this.returnName()} Error: Could not find root element #saito-react-app for React rendering in render(). Check HTML shell.`);
    }
  }


  //
  // WEBSERVER (SERVER)
  // Serves the HTML shell and API endpoints.
  // It does NOT rely on a bundle.js being loaded by the shell.
  //
  webServer(app, expressapp, express) {

    const explorerc_self = this;

    // Serve Static Files from the 'web' directory (for CSS, images, etc.)
    expressapp.use(`/${explorerc_self.name}/`, express.static(path.join(__dirname, 'web')));

    // Main Application Route - Serves the HTML Shell generated by ExplorerHomePage
    expressapp.get(`/${explorerc_self.name}/`, (req, res) => {
      res.setHeader('Content-type', 'text/html');
      res.charset = 'UTF-8';
      // Call the function from ./index.js to get the HTML
      res.send(ExplorerHomePage(app, explorerc_self, app.build_number)); 
    });

    // --- API Endpoints (Placeholders - return JSON) ---
    // It's good practice to prefix API routes, e.g., with /api/

    // Block Information
    expressapp.get(`/${explorerc_self.name}/api/block`, async (req, res) => {
      const hash = req.query.hash;
      if (!hash) {
        return res.status(400).json({ status: "error", message: "Missing block hash parameter" });
      }
      try {
        const block = await app.blockchain.getBlock(hash);
        if (block && typeof block.toJson === 'function') {
          const blockJsonString = block.toJson();
          try {
             const blockData = JSON.parse(blockJsonString); // Use json-bigint parser
             res.json({ status: "success", hash: hash, blockData: blockData });
          } catch (jsonError) {
            console.error(`Error parsing block JSON for hash ${hash}:`, jsonError);
            // Optionally return the raw string if parsing fails but block was found
            res.status(500).json({ status: "error", message: "Error parsing block JSON", hash: hash }); 
          }
        } else {
          res.status(404).json({ status: "error", message: "Block not found", hash: hash });
        }
      } catch (error) {
        console.error(`Error fetching block ${hash}:`, error);
        res.status(500).json({ status: "error", message: "Internal server error fetching block", hash: hash });
      }
    });

    expressapp.get(`/${explorerc_self.name}/api/blocksource`, async (req, res) => {
        const hash = req.query.hash;
        if (!hash) {
            return res.status(400).json({ status: "error", message: "Missing block hash parameter" });
        }
        try {
            const block = await app.blockchain.getBlock(hash);
            if (block && typeof block.toJson === 'function') {
                const blockSource = block.toJson(); // Get raw JSON string
                res.json({ status: "success", hash: hash, blockSource: blockSource });
            } else {
                res.status(404).json({ status: "error", message: "Block not found", hash: hash });
            }
        } catch (error) {
            console.error(`Error fetching block source for ${hash}:`, error);
            res.status(500).json({ status: "error", message: "Internal server error fetching block source", hash: hash });
        }
    });

    expressapp.get(`/${explorerc_self.name}/api/json-block/:bhash`, async (req, res) => {
      const bhash = req.params.bhash;
      if (!bhash) {
        return res.status(400).json({ status: "error", message: "Missing block hash parameter" });
      }
       try {
        const block = await app.blockchain.getBlock(bhash);
        if (block && typeof block.toJson === 'function') {
          const blockJsonString = block.toJson();
          try {
             const blockData = JSON.parse(blockJsonString); // Use json-bigint parser
             // Send the parsed JSON object directly
             res.setHeader('Content-Type', 'application/json');
             res.charset = 'UTF-8';
             res.send(JSON.stringify(blockData, null, 2)); // Pretty print might be nice
          } catch (jsonError) {
            console.error(`Error parsing block JSON for hash ${bhash}:`, jsonError);
            res.status(500).json({ status: "error", message: "Error parsing block JSON", bhash: bhash });
          }
        } else {
          res.status(404).json({ status: "error", message: "Block not found", bhash: bhash });
        }
      } catch (error) {
        console.error(`Error fetching block ${bhash}:`, error);
        res.status(500).json({ status: "error", message: "Internal server error fetching block", bhash: bhash });
      }
    });

    // Balance Information
    expressapp.get(`/${explorerc_self.name}/api/balance`, async (req, res) => {
      const pubkey = req.query.pubkey;
      // TODO: Implement logic to fetch balance data from app.wallet or blockchain
      // Example: const balance = await app.wallet.getBalance(pubkey);
      res.json({ status: "success", message: "API: Balance endpoint not yet implemented", pubkey: pubkey /*, balance: balance */ });
    });

    expressapp.get(`/${explorerc_self.name}/api/balance/all`, async (req, res) => {
      // TODO: Implement logic to fetch all balances data
      res.json({ status: "success", message: "API: All Balances endpoint not yet implemented" });
    });

    // Mempool Information
    expressapp.get(`/${explorerc_self.name}/api/mempool`, async (req, res) => {
      // TODO: Implement logic to fetch mempool data from app.mempool
      // Example: const mempoolTxs = app.mempool.returnTransactions();
      res.json({ status: "success", message: "API: Mempool endpoint not yet implemented" /*, transactions: mempoolTxs */ });
    });

    // NEW: Get Blocks by ID Range
    expressapp.get(`/${explorerc_self.name}/api/blocks/:start_id/:end_id`, async (req, res) => {
      try {
        const start_id_str = req.params.start_id;
        const end_id_str = req.params.end_id;

        let start_id;
        let end_id;

        // Validate and convert IDs to BigInt
        try {
          start_id = BigInt(start_id_str);
          end_id = BigInt(end_id_str);
        } catch (e) {
          return res.status(400).json({ error: "Invalid block ID format. IDs must be integers." });
        }

        if (start_id < end_id || end_id < BigInt(0)) {
            return res.status(400).json({ error: "Invalid block range. start_id must be >= end_id, and end_id must be >= 0." });
        }

        // Limit the number of blocks fetched in one request to prevent overload
        const MAX_BLOCKS_PER_REQUEST = 200; // Adjust as needed
        if (start_id - end_id + BigInt(1) > BigInt(MAX_BLOCKS_PER_REQUEST)) {
            return res.status(400).json({ error: `Request exceeds maximum block limit (${MAX_BLOCKS_PER_REQUEST}). Please request a smaller range.` });
        }

        const blocksData = [];
        console.log(`Fetching blocks from ${start_id} down to ${end_id}`);

        // Loop from the higher ID down to the lower ID
        for (let current_id = start_id; current_id >= end_id; current_id--) {
            try {
                // Get the hash of the block on the longest chain at this ID
                const longest_chain_hash = await app.blockchain.getLongestChainHashAtId(current_id);

                if (longest_chain_hash) {
                    const block = await app.blockchain.getBlock(longest_chain_hash);

                    // Log the raw block object (optional, can be removed later)
                    console.log(`API Endpoint: Raw block data for ID ${current_id}, Hash ${longest_chain_hash}:`, block);

                    if (block && typeof block.toJson === 'function') {
                        // Parse the JSON representation to get creator and timestamp
                        let blockJson = {};
                        try {
                             blockJson = JSON.parse(block.toJson());
                        } catch (jsonError) {
                            console.error(`Error parsing block JSON for ID ${current_id}:`, jsonError);
                            // Skip this block or handle error appropriately
                            continue; 
                        }

                        // Extract additional block properties (access as properties, not functions)
                        const goldenTicket = !!block.hasGoldenTicket; // Check truthiness of property
                        const longestChain = !!block.inLongestChain; // Check truthiness of property
                        let burnFee = 0;
                        let difficulty = 0;
                        // Assuming burnFee and difficulty are still functions returning BigInt based on previous context
                        try { burnFee = block.burnFee ? Number(block.burnFee()) : 0; } catch (e) { console.error(`Error getting burnFee for block ${block.id}:`, e); }
                        try { difficulty = block.difficulty ? Number(block.difficulty()) : 0; } catch (e) { console.error(`Error getting difficulty for block ${block.id}:`, e); }

                        // Log specific fields after parsing JSON and getting extra props
                        console.log(`API Endpoint: Parsed - ID=${block.id}, Creator=${blockJson.creator}, Timestamp=${blockJson.timestamp}, GT=${goldenTicket}, LC=${longestChain}, BF=${burnFee}, Diff=${difficulty}`);

                        // Construct the response object using parsed data
                        blocksData.push({
                            id: block.id,
                            hash: block.hash,
                            previousBlockHash: block.previousBlockHash,
                            creator: blockJson.creator, 
                            timestamp: blockJson.timestamp, 
                            transactionCount: block.transactions.length,
                            // Add new properties
                            goldenTicket: goldenTicket,
                            longestChain: longestChain,
                            burnFee: burnFee, // Send as number
                            difficulty: difficulty // Send as number
                        });
                    } else {
                         console.warn(`Block not found or block.toJson is not a function for hash ${longest_chain_hash} at ID ${current_id}`);
                    }
                } else {
                     console.warn(`No longest chain hash found for block ID ${current_id}`);
                }
            } catch (err) {
                console.error(`Error fetching block data for ID ${current_id}:`, err);
                // Decide how to handle errors for individual blocks (e.g., skip, add error entry)
            }
        }

        console.log(`Returning ${blocksData.length} blocks.`);
        res.json({ status: "success", blocks: blocksData });

      } catch (error) {
        console.error("Error in /api/blocks/:start_id/:end_id endpoint:", error);
        res.status(500).json({ error: "Internal server error while fetching blocks." });
      }
    });

    // NEW: Get Node Information
    expressapp.get(`/${explorerc_self.name}/api/node-info`, async (req, res) => {
      try {
        const publicKey = app.wallet?.publicKey || 'N/A';
        let balance = 'N/A';
        let serverEndpoint = 'N/A';
        let mempoolTxCount = 0;
        let latestBlockId = 'N/A';

        try {
            balance = await app.wallet?.getBalance() || '0'; 
        } catch (e) { console.error("Error getting balance:", e); balance = 'Error'; }
        
        try {
             if (app.options?.server) {
                serverEndpoint = `${app.options.server.protocol}://${app.options.server.host}:${app.options.server.port}`;
            }
        } catch (e) { console.error("Error getting server endpoint:", e); }

        try {
            mempoolTxCount = app.mempool?.returnTransactions()?.length || 0;
        } catch (e) { console.error("Error getting mempool count:", e); }
        
        try {
            const latestIdBigInt = await app.blockchain?.getLatestBlockId();
            latestBlockId = latestIdBigInt !== undefined ? latestIdBigInt.toString() : 'N/A';
        } catch (e) { console.error("Error getting latest block ID:", e); }

        res.json({
          status: "success",
          nodeInfo: {
            publicKey: publicKey,
            balance: balance, // Saito balance (string)
            serverEndpoint: serverEndpoint,
            mempoolTxCount: mempoolTxCount,
            latestBlockId: latestBlockId // Latest block ID (string)
          }
        });

      } catch (error) {
        console.error("Error in /api/node-info endpoint:", error);
        res.status(500).json({ error: "Internal server error while fetching node information." });
      }
    });

    // NEW: Get Latest Block ID
    expressapp.get(`/${explorerc_self.name}/api/latest_block_id`, async (req, res) => {
      try {
        const latest_block_id = await app.blockchain.getLatestBlockId();
        res.json({ status: "success", latest_block_id: latest_block_id.toString() }); // Send as string for BigInt compatibility
      } catch (error) {
        console.error("Error in /api/latest_block_id endpoint:", error);
        res.status(500).json({ error: "Internal server error while fetching latest block ID." });
      }
    });

  }

  // Client-side method to fetch the latest block ID from the module's API
  async fetchLatestBlockId() {
    const API_BASE_PATH = `/${this.name}/api`; // Use module name dynamically
    try {
      const response = await fetch(`${API_BASE_PATH}/latest_block_id`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data.status !== 'success' || !data.latest_block_id) {
          throw new Error('Failed to fetch latest block ID: ' + (data.error || 'Unknown error'));
      }
      // Return as BigInt for internal use
      return BigInt(data.latest_block_id);
    } catch (error) {
      console.error("Error fetching latest block ID via mod method:", error);
      throw error; // Re-throw to allow caller handling
    }
  }

  // Client-side method to fetch blocks by ID range from the module's API
  async fetchBlocksByIdRange(startId, endId) {
    const API_BASE_PATH = `/${this.name}/api`; // Use module name dynamically
    const start_id_str = typeof startId === 'bigint' ? startId.toString() : startId;
    const end_id_str = typeof endId === 'bigint' ? endId.toString() : endId;
    const fetchUrl = `${API_BASE_PATH}/blocks/${start_id_str}/${end_id_str}`; // Construct the URL

    // *** Log the URL being fetched ***
    console.log(`Client-side fetchBlocksByIdRange: Attempting to fetch URL: ${fetchUrl}`);

    try {
      const response = await fetch(fetchUrl); // Use the constructed URL
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({})); // Try to get error message
        throw new Error(`HTTP error! status: ${response.status} - ${errorData.error || 'Failed to fetch block range'}`);
      }
      const data = await response.json();
      if (data.status !== 'success' || !data.blocks) {
        throw new Error('Failed to fetch blocks: ' + (data.error || 'Malformed response'));
      }
      // Convert IDs and timestamps
      return data.blocks.map(block => ({ 
        ...block,
        id: BigInt(block.id),
        timestamp: Number(block.timestamp),
        transactionCount: Number(block.transactionCount || 0),
        // Ensure new fields have correct types (mostly boolean/number)
        goldenTicket: Boolean(block.goldenTicket),
        longestChain: Boolean(block.longestChain),
        burnFee: Number(block.burnFee || 0),
        difficulty: Number(block.difficulty || 0)
      })); 
    } catch (error) {
      console.error(`Error fetching blocks from ${start_id_str} to ${end_id_str} via mod method:`, error);
      throw error; // Re-throw
    }
  }

  // Client-side method to fetch node info from the module's API
  async fetchNodeInfo() {
    const API_BASE_PATH = `/${this.name}/api`;
    try {
        const response = await fetch(`${API_BASE_PATH}/node-info`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(`HTTP error! status: ${response.status} - ${errorData.error || 'Failed to fetch node info'}`);
        }
        const data = await response.json();
        if (data.status !== 'success' || !data.nodeInfo) {
            throw new Error('Failed to fetch node info: ' + (data.error || 'Malformed response'));
        }
        // Return the nested nodeInfo object
        return data.nodeInfo; 
    } catch (error) {
        console.error("Error fetching node info via mod method:", error);
        throw error; // Re-throw
    }
  }

}

module.exports = Explorerc;