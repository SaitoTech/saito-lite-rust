const ModTemplate = require('../../lib/templates/modtemplate');
const path = require('path');
const ExplorerHomePage = require('./index'); // Require the HTML generation function
const JSON = require('json-bigint'); // Add require for json-bigint

// Restore requires for direct rendering in render()
const React = require('react'); 
const { createRoot } = require('react-dom/client'); 
const App = require('./react-components/App').default; // Require the main React component - Added .default

class Explorerc extends ModTemplate {

  constructor(app) {
    super(app);
    this.app = app;
    this.name = "explorerc"; // Use lowercase slug for consistency
    this.description = "Saito Block Explorer (React Version)";
    this.categories = "Utilities Information";

    // Define the style bundle
    this.styles = [`/${this.name}/style.css`]; 
    // bundle.js is NOT included here - rendering happens directly in render()
    this.scripts = []; 

    this.rendered = false; // Track if render has been called

    return this;
  }

  async initialize(app) {
    await super.initialize(app);
    console.log(`${this.returnName()} Initialized (React rendering handled directly in render())`);
  }

  //
  // RENDER (CLIENT)
  // This method now directly handles rendering the main React component into the DOM
  // mimicking the approach in mods/react/react.js
  //
  async render() {
    console.log(`${this.returnName()} render() method called.`);
    // Ensure styles are attached first by calling super.render()
    try {
      await super.render(); 
      console.log(`${this.returnName()} super.render() completed.`);
    } catch (err) {
        console.error(`${this.returnName()} error during super.render():`, err);
        return; // Don't proceed if super.render fails
    }

    // Prevent re-rendering
    if (this.rendered) {
      console.log(`${this.returnName()} render() aborted: Already rendered.`);
      return;
    }

    console.log(`${this.returnName()} looking for root element #saito-react-app...`);
    // Find the mount point defined in mods/explorerc/index.js
    const rootElement = document.getElementById('saito-react-app');

    if (rootElement) {
      console.log(`${this.returnName()} found root element #saito-react-app.`);
      try {
        // Use react-dom/client to render the App component
        console.log(`${this.returnName()} attempting to render React component...`);
        // Verify App component is loaded
        if (!App) {
            console.error(`${this.returnName()} Error: App component is undefined or null. Check require statement.`);
            return;
        }
        const root = createRoot(rootElement);
        root.render(<App app={this.app} mod={this} />);
        this.rendered = true;
        console.log(`${this.returnName()} React component rendered successfully.`);
      } catch (err) {
        console.error(`${this.returnName()} Error rendering React component in render():`, err);
      }
    } else {
      console.error(`${this.returnName()} Error: Could not find root element #saito-react-app for React rendering in render(). Check HTML shell.`);
    }
  }


  //
  // WEBSERVER (SERVER)
  // Serves the HTML shell and API endpoints.
  // It does NOT rely on a bundle.js being loaded by the shell.
  //
  webServer(app, expressapp, express) {

    const explorerc_self = this;

    // Serve Static Files from the 'web' directory (for CSS, images, etc.)
    expressapp.use(`/${explorerc_self.name}/`, express.static(path.join(__dirname, 'web')));

    // Main Application Route - Serves the HTML Shell generated by ExplorerHomePage
    expressapp.get(`/${explorerc_self.name}/`, (req, res) => {
      res.setHeader('Content-type', 'text/html');
      res.charset = 'UTF-8';
      // Call the function from ./index.js to get the HTML
      res.send(ExplorerHomePage(app, explorerc_self, app.build_number)); 
    });

    // --- API Endpoints (Placeholders - return JSON) ---
    // It's good practice to prefix API routes, e.g., with /api/

    // Block Information
    expressapp.get(`/${explorerc_self.name}/api/block`, async (req, res) => {
      const hash = req.query.hash;
      // TODO: Implement logic to fetch block data from app.blockchain
      // Example: const blockData = await app.blockchain.getBlock(hash);
      res.json({ status: "success", message: "API: Block endpoint not yet implemented", hash: hash /*, data: blockData */ });
    });

    expressapp.get(`/${explorerc_self.name}/api/blocksource`, async (req, res) => {
        const hash = req.query.hash;
        // TODO: Implement logic to fetch raw block data
        res.json({ status: "success", message: "API: Block source endpoint not yet implemented", hash: hash });
    });

    expressapp.get(`/${explorerc_self.name}/api/json-block/:bhash`, async (req, res) => {
      const bhash = req.params.bhash;
       // TODO: Implement logic to fetch block data from app.blockchain
       // Example: const blockData = await app.blockchain.getBlock(bhash);
      res.json({ status: "success", message: "API: JSON Block endpoint not yet implemented", bhash: bhash /*, data: blockData */ });
    });

    // Balance Information
    expressapp.get(`/${explorerc_self.name}/api/balance`, async (req, res) => {
      const pubkey = req.query.pubkey;
      // TODO: Implement logic to fetch balance data from app.wallet or blockchain
      // Example: const balance = await app.wallet.getBalance(pubkey);
      res.json({ status: "success", message: "API: Balance endpoint not yet implemented", pubkey: pubkey /*, balance: balance */ });
    });

    expressapp.get(`/${explorerc_self.name}/api/balance/all`, async (req, res) => {
      // TODO: Implement logic to fetch all balances data
      res.json({ status: "success", message: "API: All Balances endpoint not yet implemented" });
    });

    // Mempool Information
    expressapp.get(`/${explorerc_self.name}/api/mempool`, async (req, res) => {
      // TODO: Implement logic to fetch mempool data from app.mempool
      // Example: const mempoolTxs = app.mempool.returnTransactions();
      res.json({ status: "success", message: "API: Mempool endpoint not yet implemented" /*, transactions: mempoolTxs */ });
    });

    // NEW: Get Blocks by ID Range
    expressapp.get(`/${explorerc_self.name}/api/blocks/:start_id/:end_id`, async (req, res) => {
      try {
        const start_id_str = req.params.start_id;
        const end_id_str = req.params.end_id;

        let start_id;
        let end_id;

        // Validate and convert IDs to BigInt
        try {
          start_id = BigInt(start_id_str);
          end_id = BigInt(end_id_str);
        } catch (e) {
          return res.status(400).json({ error: "Invalid block ID format. IDs must be integers." });
        }

        if (start_id < end_id || end_id < BigInt(0)) {
            return res.status(400).json({ error: "Invalid block range. start_id must be >= end_id, and end_id must be >= 0." });
        }

        // Limit the number of blocks fetched in one request to prevent overload
        const MAX_BLOCKS_PER_REQUEST = 200; // Adjust as needed
        if (start_id - end_id + BigInt(1) > BigInt(MAX_BLOCKS_PER_REQUEST)) {
            return res.status(400).json({ error: `Request exceeds maximum block limit (${MAX_BLOCKS_PER_REQUEST}). Please request a smaller range.` });
        }

        const blocksData = [];
        console.log(`Fetching blocks from ${start_id} down to ${end_id}`);

        // Loop from the higher ID down to the lower ID
        for (let current_id = start_id; current_id >= end_id; current_id--) {
            try {
                // Get the hash of the block on the longest chain at this ID
                const longest_chain_hash = await app.blockchain.getLongestChainHashAtId(current_id);

                if (longest_chain_hash) {
                    const block = await app.blockchain.getBlock(longest_chain_hash);

                    // Log the raw block object (optional, can be removed later)
                    // console.log(`API Endpoint: Raw block data for ID ${current_id}, Hash ${longest_chain_hash}:`, block);

                    if (block && typeof block.toJson === 'function') {
                        // Parse the JSON representation to get creator and timestamp
                        let blockJson = {};
                        try {
                             blockJson = JSON.parse(block.toJson());
                        } catch (jsonError) {
                            console.error(`Error parsing block JSON for ID ${current_id}:`, jsonError);
                            // Skip this block or handle error appropriately
                            continue; 
                        }

                        // Log specific fields after parsing JSON
                        console.log(`API Endpoint: Parsed - ID=${block.id}, Creator=${blockJson.creator}, Timestamp=${blockJson.timestamp}`);

                        // Construct the response object using parsed data
                        blocksData.push({
                            id: block.id, // Use the direct block.id (already BigInt)
                            hash: block.hash,
                            previousBlockHash: block.previousBlockHash,
                            creator: blockJson.creator, // Get from parsed JSON
                            timestamp: blockJson.timestamp, // Get from parsed JSON
                            transactionCount: block.transactions.length 
                        });
                    } else {
                         console.warn(`Block not found or block.toJson is not a function for hash ${longest_chain_hash} at ID ${current_id}`);
                    }
                } else {
                     console.warn(`No longest chain hash found for block ID ${current_id}`);
                }
            } catch (err) {
                console.error(`Error fetching block data for ID ${current_id}:`, err);
                // Decide how to handle errors for individual blocks (e.g., skip, add error entry)
            }
        }

        console.log(`Returning ${blocksData.length} blocks.`);
        res.json({ status: "success", blocks: blocksData });

      } catch (error) {
        console.error("Error in /api/blocks/:start_id/:end_id endpoint:", error);
        res.status(500).json({ error: "Internal server error while fetching blocks." });
      }
    });

    // NEW: Get Latest Block ID
    expressapp.get(`/${explorerc_self.name}/api/latest_block_id`, async (req, res) => {
      try {
        const latest_block_id = await app.blockchain.getLatestBlockId();
        res.json({ status: "success", latest_block_id: latest_block_id.toString() }); // Send as string for BigInt compatibility
      } catch (error) {
        console.error("Error in /api/latest_block_id endpoint:", error);
        res.status(500).json({ error: "Internal server error while fetching latest block ID." });
      }
    });

  }

  // Client-side method to fetch the latest block ID from the module's API
  async fetchLatestBlockId() {
    const API_BASE_PATH = `/${this.name}/api`; // Use module name dynamically
    try {
      const response = await fetch(`${API_BASE_PATH}/latest_block_id`);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data.status !== 'success' || !data.latest_block_id) {
          throw new Error('Failed to fetch latest block ID: ' + (data.error || 'Unknown error'));
      }
      // Return as BigInt for internal use
      return BigInt(data.latest_block_id);
    } catch (error) {
      console.error("Error fetching latest block ID via mod method:", error);
      throw error; // Re-throw to allow caller handling
    }
  }

  // Client-side method to fetch blocks by ID range from the module's API
  async fetchBlocksByIdRange(startId, endId) {
    const API_BASE_PATH = `/${this.name}/api`; // Use module name dynamically
    const start_id_str = typeof startId === 'bigint' ? startId.toString() : startId;
    const end_id_str = typeof endId === 'bigint' ? endId.toString() : endId;
    const fetchUrl = `${API_BASE_PATH}/blocks/${start_id_str}/${end_id_str}`; // Construct the URL

    // *** Log the URL being fetched ***
    console.log(`Client-side fetchBlocksByIdRange: Attempting to fetch URL: ${fetchUrl}`);

    try {
      const response = await fetch(fetchUrl); // Use the constructed URL
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({})); // Try to get error message
        throw new Error(`HTTP error! status: ${response.status} - ${errorData.error || 'Failed to fetch block range'}`);
      }
      const data = await response.json();
      if (data.status !== 'success' || !data.blocks) {
        throw new Error('Failed to fetch blocks: ' + (data.error || 'Malformed response'));
      }
      // Convert IDs and timestamps
      return data.blocks.map(block => ({ 
        ...block,
        id: BigInt(block.id), // API sends string/number, ensure BigInt
        timestamp: Number(block.timestamp), // Ensure timestamp is number
        transactionCount: Number(block.transactionCount || 0) // Ensure count is number
      })); 
    } catch (error) {
      console.error(`Error fetching blocks from ${start_id_str} to ${end_id_str} via mod method:`, error);
      throw error; // Re-throw
    }
  }

}

module.exports = Explorerc;