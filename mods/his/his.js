const GameTemplate = require('../../lib/templates/gametemplate');
const DebateOverlay = require('./lib/ui/overlays/debate');
const ChateauxOverlay = require('./lib/ui/overlays/chateaux');
const PiracyOverlay = require('./lib/ui/overlays/piracy');
const VPOverlay = require('./lib/ui/overlays/vp');
const NewWorldOverlay = require('./lib/ui/overlays/newworld');
const TreatiseOverlay = require('./lib/ui/overlays/treatise');
const FactionOverlay = require('./lib/ui/overlays/faction');
const FactionBar = require('./lib/ui/factionbar');
const ReligiousOverlay = require('./lib/ui/overlays/religious');
const CouncilOfTrentOverlay = require('./lib/ui/overlays/council-of-trent');
const ReformationOverlay = require('./lib/ui/overlays/reformation');
const DiplomacyConfirmOverlay = require('./lib/ui/overlays/diplomacy-confirm');
const DiplomacyProposeOverlay = require('./lib/ui/overlays/diplomacy-propose');
const AvailableUnitsOverlay = require('./lib/ui/overlays/available-units');
const FortificationOverlay = require('./lib/ui/overlays/fortification');
const SpringDeploymentOverlay = require('./lib/ui/overlays/spring-deployment');
const BuildOverlay = require('./lib/ui/overlays/build');
const MovementOverlay = require('./lib/ui/overlays/movement');
const DietOfWormsOverlay = require('./lib/ui/overlays/diet-of-worms');
const FieldBattleOverlay = require('./lib/ui/overlays/field-battle');
const NavalBattleOverlay = require('./lib/ui/overlays/naval-battle');
const SchmalkaldicOverlay = require('./lib/ui/overlays/schmalkaldic');
const AssaultOverlay = require('./lib/ui/overlays/siege');
const WarOverlay = require('./lib/ui/overlays/war');
const ThesesOverlay = require('./lib/ui/overlays/theses');
const DebatersOverlay = require('./lib/ui/overlays/debaters');
const UnitsOverlay = require('./lib/ui/overlays/units');
const WelcomeOverlay = require('./lib/ui/overlays/welcome');
const WinterOverlay = require('./lib/ui/overlays/winter');
const DeckOverlay = require('./lib/ui/overlays/deck');
const MenuOverlay = require('./lib/ui/overlays/menu');
const LanguageZoneOverlay = require('./lib/ui/overlays/language-zone');

// Tutorial Overlays
const GameHelp = require('./lib/ui/game-help/game-help');
const TutorialTemplate = require('./lib/ui/overlays/tutorials/tutorial.template');

const HISRules = require('./lib/core/rules.template');
const HISOptions = require('./lib/core/advanced-options.template');
const HISingularOption = require('./lib/core/options.template');
const htmlTemplate = require('./lib/core/game-html.template');

const JSON = require('json-bigint');



//////////////////
// CONSTRUCTOR  //
//////////////////
class HereIStand extends GameTemplate {

  constructor(app) {

    super(app);

    this.app             = app;

    this.name  		 = "HereIStand";
    this.gamename        = "Here I Stand";
    this.slug		 = "his";
    this.description     = `Here I Stand is a boardgame based on the military, political and religious conflicts within Europe at the outbreak of the Protestant Reformation (1517-1555). Each player controls one or more major powers that dominated Europe: the Ottoman Empire, the Hapsburgs, England, France, the Papacy and the Protestant states.`;
    this.publisher_message = `Here I Stand is published by GMT Games. This module is made available under an open source license provided by GMT Games that permits usage provided that at least one player per game has purchased a copy of the game. Support GMT Games: <a href="https://www.gmtgames.com/p-917-here-i-stand-500th-anniversary-reprint-edition-2nd-printing.aspx">purchase</a>`;
    this.categories      = "Games Boardgame Strategy";

    this.interface = 1; // graphical interface

    //
    // ui components
    //
    this.debate_overlay = new DebateOverlay(this.app, this);      // theological debates
    this.treatise_overlay = new TreatiseOverlay(this.app, this);  // publish treatise
    this.religious_overlay = new ReligiousOverlay(this.app, this);  // religious conflict sheet
    this.faction_overlay = new FactionOverlay(this.app, this);  // faction sheet
    this.factionbar = new FactionBar(this.app, this); // shows you which factions you are in multiplayer
    this.diet_of_worms_overlay = new DietOfWormsOverlay(this.app, this);  // diet of worms
    this.diplomacy_confirm_overlay = new DiplomacyConfirmOverlay(this.app, this);
    this.diplomacy_propose_overlay = new DiplomacyProposeOverlay(this.app, this);
    this.council_of_trent_overlay = new CouncilOfTrentOverlay(this.app, this);  // council of trent
    this.chateaux_overlay = new ChateauxOverlay(this.app, this);  // build some fucking chateaux
    this.piracy_overlay = new PiracyOverlay(this.app, this);  // rape and pillage but mostly steal
    this.vp_overlay = new VPOverlay(this.app, this);  // end-of-turn points overlay
    this.newworld_overlay = new NewWorldOverlay(this.app, this);
    this.theses_overlay = new ThesesOverlay(this.app, this);  // 95 theses
    this.reformation_overlay = new ReformationOverlay(this.app, this);  // reformations and counter-reformations
    this.language_zone_overlay = new LanguageZoneOverlay(this.app, this);  // language zone selection
    this.debaters_overlay = new DebatersOverlay(this.app, this);  // language zone selection
    this.schmalkaldic_overlay = new SchmalkaldicOverlay(this.app, this);  // schmalkaldic league
    this.assault_overlay = new AssaultOverlay(this.app, this);  // siege
    this.war_overlay = new WarOverlay(this.app, this);  // naval battles
    this.naval_battle_overlay = new NavalBattleOverlay(this.app, this);  // naval battles
    this.field_battle_overlay = new FieldBattleOverlay(this.app, this);  // field battles
    this.spring_deployment_overlay = new SpringDeploymentOverlay(this.app, this);  // spring deployment
    this.build_overlay = new BuildOverlay(this.app, this);  // unit building
    this.available_units_overlay = new AvailableUnitsOverlay(this.app, this);  // unit movement
    this.movement_overlay = new MovementOverlay(this.app, this);  // unit movement
    this.fortification_overlay = new FortificationOverlay(this.app, this);  // unit movement
    this.welcome_overlay = new WelcomeOverlay(this.app, this);  // hello world
    this.deck_overlay = new DeckOverlay(this.app, this);  // overlay to show cards
    this.menu_overlay = new MenuOverlay(this.app, this);  // players doing stuff
    this.winter_overlay = new WinterOverlay(this.app, this);
    this.units_overlay = new UnitsOverlay(this.app, this);

    //
    // triangular help button
    //
    this.game_help = new GameHelp(this.app, this);

    //
    // this sets the ratio used for determining
    // the size of the original pieces
    //
    this.boardWidth  = 5100;

    //
    // newbie mode
    //
    this.confirm_moves = 1;
    this.faster_play = 1; // this speeds-up some responses at the cost of potentially
			  // leaking information on what response cards users have or
			  // do not have.

    //
    // "showcard" popups
    //
    this.useCardbox = 1;

    //
    //
    // players
    this.minPlayers 	 = 2;
    this.maxPlayers 	 = 6;

  }


  returnSingularGameOption(){
    return HISSingularOption();
  }

  returnAdvancedOptions() {
    return HISOptions();
  }

  returnGameRulesHTML(){
    return HISRules();
  }


  ////////////////
  // initialize //
  ////////////////
  initializeGame(game_id) {


    //this.realEndTurn = this.endTurn;
    //this.endTurn = () => {
    //  console.log("TESTING REAL END TURN");
    //  this.realEndTurn();
    //}

    //
    // check user preferences to update interface, if text
    //
    if (this.app?.options?.gameprefs) {
      if (this.app.options.gameprefs.his_expert_mode == 1) {
        this.confirm_moves = 0;
      } else {
        this.confirm_moves = 1;
      }
      if (this.app.options.gameprefs.his_faster_play == 1) {
        this.faster_play = 1;
      } else {
        this.faster_play = 0;
      }
    }

    //
    // re-fill status and log
    //
    if (this.game.status != "") { this.updateStatus(this.game.status); }

    //
    // initialize game objects
    //
    this.factions = {};

    this.units = {};
    this.army = {};
    this.navy = {};
    this.reformers = {};
    this.debaters = {};
    this.explorers = {};
    this.conquistadors = {};
    this.wives = {};

    this.deck = this.returnDeck();
    this.diplomatic_deck = this.returnDiplomaticDeck();



    this.importFaction('faction2', {
      id		:	"faction2" ,
      key		:	"england" ,
      name		: 	"England",
      nickname		: 	"England",
      img		:	"england.png",
      admin_rating	:	1,
      capitals		:	["london"],
      cards_bonus	:	1,
      marital_status    :       0,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.henry_viii == 1) { base += 1; }
        if (game_mod.game.state.leaders.edward_vi == 1) { base += 1; }
        if (game_mod.game.state.leaders.mary_i == 1) { base += 1; }
        if (game_mod.game.state.leaders.elizabeth_i == 1) { base += 2; }

        return base;

      },
      returnCardsDealt  :	function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = 0;

	switch (kc) {
	  case 1: { base = 1; break; }
	  case 2: { base = 1; break; }
	  case 3: { base = 2; break; }
	  case 4: { base = 2; break; }
	  case 5: { base = 3; break; }
	  case 6: { base = 3; break; }
	  case 7: { base = 4; break; }
	  case 8: { base = 4; break; }
	  case 9: { base = 5; break; }
	  case 10: { base = 5; break; }
	  case 11: { base = 6; break; }
	  case 12: { base = 6; break; }
	  default: { base = 1; break; }
	}

	// bonuses based on leaders
	if (game_mod.game.state.leaders.henry_viii == 1) { base += 1; }
	if (game_mod.game.state.leaders.edward_vi == 1) { base += 0; }
	if (game_mod.game.state.leaders.mary_i == 1) { base += 0; }
	if (game_mod.game.state.leaders.elizabeth_i == 1) { base += 2; }

        base += game_mod.game.state.england_card_bonus;

	// TODO - bonus for home spaces under protestant control
	return base;

      },
      calculateBonusVictoryPoints  :	function(game_mod) {
	let base = 0;
        return base;
      },
      calculateSpecialVictoryPoints  :	function(game_mod) {
        let base = 0;

	//
	// 5VP if 
	//
	if (game_mod.game.state.events.henry_viii_sickly_edward == 1 || game_mod.game.state.events.henry_viii_edward_added == 1 || game_mod.game.state.events.henry_viii_healthy_edward == 1) { 
	  base += 5;
        } else {
	  if (game_mod.game.state.events.henry_viii_elizabeth_added == 1) {
	    base += 2;
	  }
	}

	//
	// 1VP per every 2 protestant spaces
	//
	let eps = game_mod.returnNumberOfProtestantSpacesInLanguageZone("english", 1);
	while (eps > 1) { eps -= 2; base++; }

	return base;

      },
      calculateBaseVictoryPoints  :	function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = this.vp;

	switch (kc) {
	  case 1: { base += 3; break; }
	  case 2: { base += 5; break; }
	  case 3: { base += 7; break; }
	  case 4: { base += 9; break; }
	  case 5: { base += 11; break; }
	  case 6: { base += 13; break; }
	  case 7: { base += 15; break; }
	  case 8: { base += 17; break; }
	  default: { base += 17; break; }
	}

	return base;

      },
    });
 


    this.importFaction('faction3', {
      id		:	"faction3" ,
      key		: 	"france",
      name		: 	"France",
      nickname		: 	"France",
      capitals          :       ["paris"],
      admin_rating	:	1,
      img		:	"france.png",
      cards_bonus	:	1,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.francis_i == 1) { base += 1; }
        if (game_mod.game.state.leaders.henry_ii == 1) { base += 1; }

        return base;

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("france");
        let base = this.vp; 
       
        switch (kc) {
          case 1: { base = 1; break; }
          case 2: { base = 1; break; }
          case 3: { base = 1; break; }
          case 4: { base = 2; break; }
          case 5: { base = 2; break; }
          case 6: { base = 3; break; }
          case 7: { base = 3; break; }
          case 8: { base = 4; break; }
          case 9: { base = 4; break; }
          case 10: { base = 5; break; }
          case 11: { base = 6; break; }
          case 12: { base = 6; break; }
          default: { base = 0; break; }
        }

        // bonuses based on leaders
        if (game_mod.game.state.leaders.francis_i == 1) { base += 1; }        
        if (game_mod.game.state.leaders.henry_ii == 1) { base += 0; }        

        base += game_mod.game.state.france_card_bonus;

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("france");
        let base = 0;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
          case 7: { base += 14; break; }
          case 8: { base += 16; break; }
          case 9: { base += 18; break; }
          case 10: { base += 20; break; }
        } 
        
        return base;
        
      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
	let base = 0;
	if (game_mod.game.state.french_chateaux_vp) {
	  base += game_mod.game.state.french_chateaux_vp;
	}
	return base;
      },
    });
 



    this.importFaction('faction7', {
      id		:	"faction7" ,
      key		:	"genoa" ,
      name		: 	"Genoa",
      nickname		: 	"Genoa",
    });
 


    this.importFaction('faction1', {
      id		:	"faction1" ,
      key		: 	"hapsburg",
      name		: 	"Hapsburg",
      nickname		: 	"Hapsburg",
      capitals          :       ["valladolid","vienna"],
      img		:	"hapsburgs.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {
 
        let base = 0;

        if (game_mod.game.state.leaders.charles_v == 1) { base += 2; }

        return base;

        return base; 

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("hapsburg");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 1; break; }
          case 2: { base = 2; break; }
          case 3: { base = 2; break; }
          case 4: { base = 3; break; }
          case 5: { base = 3; break; }
          case 6: { base = 4; break; }
          case 7: { base = 4; break; }
          case 8: { base = 5; break; }
          case 9: { base = 5; break; }
          case 10: { base = 6; break; }
          case 11: { base = 6; break; }
          case 12: { base = 7; break; }
          case 13: { base = 7; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.charles_v == 1) { base += 0; }

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("hapsburg");
        let base = 0;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 3; break; }
          case 3: { base += 4; break; }
          case 4: { base += 5; break; }
          case 5: { base += 6; break; }
          case 6: { base += 7; break; }
          case 7: { base += 8; break; }
          case 8: { base += 9; break; }
          case 9: { base += 10; break; }
          case 10: { base += 11; break; }
          case 11: { base += 12; break; }
          case 12: { base += 13; break; }
          case 13: { base += 14; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
        let base = 0;
	if (game_mod.game.state.events.schmalkaldic_league == 1) {
	  if (game_mod.isSpaceControlled("mainz", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("wittenberg", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("augsburg", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("trier", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("cologne", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("brandenburg", "hapsburg")) { base += 1; }
	}
	return base;
      },
    });
 



    this.importFaction('faction8', {
      id                :       "faction8" ,
      key               :       "hungary" ,
      name              :       "Hungary",
      nickname          :       "Hungary",
    });



    this.importFaction('faction11', {
      id                :       "faction11" ,
      key               :       "independent" ,
      name              :       "Independent",
      nickname          :       "Independent",
    });



    this.importFaction('faction5', {
      id		:	"faction5" ,
      key		: 	"ottoman",
      name		: 	"Ottoman Empire",
      nickname		: 	"Ottoman",
      capitals          :       ["istanbul"],
      img		:	"ottoman.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.suleiman == 1) { base += 2; }

        return base;

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 2; break; }
          case 2: { base = 2; break; }
          case 3: { base = 3; break; }
          case 4: { base = 3; break; }
          case 5: { base = 4; break; }
          case 6: { base = 4; break; }
          case 7: { base = 5; break; }
          case 8: { base = 5; break; }
          case 9: { base = 6; break; }
          case 10: { base = 6; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.suleiman == 1) { base += 0; }        
 
        base += game_mod.game.state.ottoman_card_bonus;
      
        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("ottoman");
        let base = this.vp;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
          case 7: { base += 14; break; }
          case 8: { base += 16; break; }
          case 9: { base += 18; break; }
          case 10: { base += 20; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
        let base = 0;
	base += parseInt(game_mod.game.state.events.ottoman_piracy_vp);
        base += parseInt(game_mod.game.state.events.ottoman_julia_gonzaga_vp);
	return base;
      },
    });
 



    this.importFaction('faction4', {

      id		:	"faction4" ,
      key		: 	"papacy",
      name		: 	"Papacy",
      nickname		: 	"Papacy",
      capitals          :       ["rome"],
      img		:	"papacy.png",
      admin_rating	:	0,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {
 
        let base = 0;

        if (game_mod.game.state.leaders.leo_x == 1) { base += 0; }
        if (game_mod.game.state.leaders.clement_vii == 1) { base += 1; }
        if (game_mod.game.state.leaders.paul_iii == 1) { base += 1; }
        if (game_mod.game.state.leaders.julius_iii == 1) { base += 0; }

        return base; 

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 2; break; }
          case 2: { base = 3; break; }
          case 3: { base = 3; break; }
          case 4: { base = 4; break; }
          case 5: { base = 4; break; }
          case 6: { base = 4; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.leo_x == 1) { base += 0; }
        if (game_mod.game.state.leaders.clement_vii == 1) { base += 0; }
        if (game_mod.game.state.leaders.paul_iii == 1) { base += 1; }
        if (game_mod.game.state.leaders.julius_iii == 1) { base += 1; }       

        base += game_mod.game.state.papacy_card_bonus;

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("papacy");
        let base = this.vp;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {

	// protestant spaces track
	let base = game_mod.returnProtestantSpacesTrackVictoryPoints().papacy;

        // burned protestant debaters
        for (let i = 0; i < game_mod.game.state.burned.length; i++) {
          let bd = game_mod.game.state.burned[i];
          if (game_mod.debaters[bd]) {
            if (game_mod.debaters[bd].faction == "papacy") {
              base += game_mod.debaters[bd].power;
            }
          }
        }

	// saint peters cathedral
 	base += game_mod.game.state.saint_peters_cathedral['vp'];

        return base;

      },
    });
 



    this.importFaction('faction6', {
      id		:	"faction6" ,
      key		: 	"protestant",
      name		: 	"Protestants",
      nickname		: 	"Protestants",
      capitals		:	[] ,
      img		:	"protestant.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnCardsDealt  :       function(game_mod) {
	let base = 4; 
        let kc = game_mod.returnNumberOfElectoratesControlledByProtestants(1); // 1 = political control
        if (kc > 4) { base += 1; }
        if (game_mod.game.state.leaders.luther == 1) { base += 0; }
	base += game_mod.game.state.protestant_card_bonus;
	return base;
      },

      returnAdminRating  :       function(game_mod) {
	if (game_mod.game.state.leaders.luther == 1) { return 2; }
	return 0;
      },

      calculateBaseVictoryPoints  : function(game_mod) {
	// 2 VP for every electorate that is under Protesant religious + political control
        let base = 0;
        base += (2 * game_mod.returnNumberOfProtestantElectorates());        
        return base;
      },

      calculateBonusVictoryPoints  :    function(game_mod) {
	// + VP from disgraced papal debaters
	let bonus_vp_points = 0;
	bonus_vp_points += parseInt(game_mod.game.state.papal_debaters_disgraced_vp);
	bonus_vp_points += parseInt(game_mod.game.state.protestant_war_winner_vp);
        return bonus_vp_points;
      }
,
      calculateSpecialVictoryPoints  :  function(game_mod) {

	// protestant spaces track
        let base = game_mod.returnProtestantSpacesTrackVictoryPoints().protestant;

	// burned papal debaters
	for (let i = 0; i < game_mod.game.state.burned.length; i++) {
	  let bd = game_mod.game.state.burned[i];
	  if (game_mod.debaters[bd]) {
	    if (game_mod.debaters[bd].faction == "papacy") {
	      base += game_mod.debaters[bd].power;
	    }
	  }
	}
	
	// 1 VP for each full bible translation
        if (game_mod.game.state.translations['full']['german'] == 10) { base++; }
        if (game_mod.game.state.translations['full']['french'] == 10) { base++; }
        if (game_mod.game.state.translations['full']['english'] == 10) { base++; }

        return base;
      },
    });
 



    this.importFaction('faction10', {
      id                :       "faction10" ,
      key               :       "scotland" ,
      name              :       "Scotland",
      nickname          :       "Scotland",
    });



    this.importFaction('faction9', {
      id                :       "faction9" ,
      key               :       "venice" ,
      name              :       "Venice",
      nickname          :       "Venice",
    });



    this.importArmyLeader('suleiman', {
      type		:	"suleiman" ,
      name		: 	"Suleiman",
      personage		:	true,
      army_leader	:	true,
      img		:	"Suleiman.svg",
      battle_rating	:	2,
      command_value	:	12,
    });
 
    this.importArmyLeader('ibrahim-pasha', {
      type		:	"ibrahim-pasha" ,
      name		: 	"Ibrahim Pasha",
      personage		:	true,
      army_leader	:	true,
      img		:	"Ibrahim.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
  
    this.importArmyLeader('charles-v', {
      type		:	"charles-v" ,
      name		: 	"Charles V",
      personage		:	true,
      army_leader	:	true,
      img		:	"Charles_V.svg",
      battle_rating	:	2,
      command_value	:	10,
    });
 
    this.importArmyLeader('duke-of-alva', {
      type		:	"duke-of-alva" ,
      name		: 	"Duke of Alva",
      personage		:	true,
      army_leader	:	true,
      img		:	"Duke_of_Alva.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('ferdinand', {
      type		:	"ferdinand" ,
      name		: 	"Ferdinand",
      personage		:	true,
      army_leader	:	true,
      img		:	"Ferdinand.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('henry-viii', {
      type		:	"henry-viii" ,
      name		: 	"Henry VIII",
      personage		:	true,
      army_leader	:	true,
      img		:	"Henry_VIII.svg",
      battle_rating	:	1,
      command_value	:	8,
    });
 
    this.importArmyLeader('charles-brandon', {
      type		:	"charles-brandon" ,
      name		: 	"Charles Brandon",
      personage		:	true,
      army_leader	:	true,
      img		:	"Brandon.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('francis-i', {
      type		:	"francis-i" ,
      name		: 	"Francis I",
      personage		:	true,
      army_leader	:	true,
      img		:	"Francis_I.svg",
      battle_rating	:	1,
      command_value	:	8,
    });

    this.importArmyLeader('henry-ii', {
      type		:	"henry-ii" ,
      name		: 	"Henry II",
      personage		:	true,
      army_leader	:	true,
      img		:	"Henry_II.svg",
      battle_rating	:	0,
      command_value	:	8,
    });
 
    this.importArmyLeader('montmorency', {
      type		:	"montmorency" ,
      name		: 	"Montmorency",
      personage		:	true,
      army_leader	:	true,
      img		:	"Montmorency.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('andrea-doria', {
      type		:	"andrea-doria" ,
      name		: 	"Andrea Doria",
      personage		:	true,
      army_leader	:	true,
      img		:	"Andrea_Doria.svg",
      battle_rating	:	2,
      command_value	:	0,
    });

    this.importArmyLeader('maurice-of-saxony', {
      type		:	"maurice-of-saxony" ,
      name		: 	"Maurice of Saxony",
      personage		:	true,
      army_leader	:	true,
      img		:	"Maurice_Protestant.svg", // "Maurice_Hapsburg.svg"
      battle_rating	:	1,
      command_value	:	6,
    });

    this.importArmyLeader('dudley', {
      type              :       "dudley" ,
      name              :       "Dudley",
      personage         :       true,
      army_leader       :       true,
      img               :       "Dudley.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('john-frederick', {
      type              :       "john-frederick" ,
      name              :       "John Frederick",
      personage         :       true,
      army_leader       :       true,
      img               :       "John_Frederick.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('philip-hesse', {
      type              :       "philip-hesse" ,
      name              :       "Philip Hesse",
      personage         :       true,
      army_leader       :       true,
      img               :       "Philip_Hesse.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('renegade', {
      type              :       "renegade" ,
      name              :       "Renegade Leader",
      personage         :       true,
      army_leader       :       true,
      img               :       "Renegade.svg",
      battle_rating     :       1,
      command_value     :       6,
    });



/************************

Habsburg conquistadores:
1. Pizarro 3
2. Montejo 2
3. Cortez 4
4. Cordova 1
5. Coronado 1

************************/


      /***** English Conquistadors *****/
      this.importConquistador('english-conquistador1', {
	   faction	     :       "england",
           type              :       "english-conquistador1" ,
           name              :       "English Conquerer",
           personage         :       true,
           img               :       "/his/img/tiles/england/English_Conquest.svg",
	   power	     :	     0,
      });
      this.importConquistador('english-conquistador2', {
	   faction	     :       "england",
           type              :       "english-conquistador2" ,
           name              :       "English Conquerer",
           personage         :       true,
           img               :       "/his/img/tiles/england/English_Conquest.svg",
	   power	     :	     0,
      });


      /***** French Conquistadors *****/
      this.importConquistador('french-conquistador1', {
	   faction	     :       "france",
           type              :       "french-conquistador1" ,
           name              :       "French Conquerer",
           personage         :       true,
           img               :       "/his/img/tiles/france/French_Conquest.svg",
	   power	     :	     0,
      });
      this.importConquistador('french-conquistador2', {
	   faction	     :       "france",
           type              :       "french-conquistador2" ,
           name              :       "French Conquerer",
           personage         :       true,
           img               :       "/his/img/tiles/france/French_Conquest.svg",
	   power	     :	     0,
      });

      /***** Hapsburg Conquistadors *****/
      this.importConquistador('pizarro', {
	   faction	     :       "hapsburg",
           type              :       "pizarro" ,
           name              :       "Francisco Pizarro",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Pizarro.svg",
	   power	     :	     3,
      });
      this.importConquistador('montejo', {
	   faction	     :       "hapsburg",
           type              :       "montejo" ,
           name              :       "Francisco de Montejo",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Montejo.svg",
	   power	     :	     2,
      });
      this.importConquistador('cordova', {
	   faction	     :       "hapsburg",
           type              :       "cordova" ,
           name              :       "Neisa Cordova",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Cordova.svg",
	   power	     :	     4,
      });

      this.importConquistador('coronado', {
	   faction	     :       "hapsburg",
           type              :       "coronado" ,
           name              :       "Francisco Vázquez de Coronado",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Coronado.svg",
	   power	     :	     1,
      });

      this.importConquistador('cortez', {
	   faction	     :       "hapsburg",
           type              :       "cortez" ,
           name              :       "Hernan Cortes",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Cortez.svg",
	   power	     :	     1,
      });



    ////////////////
    // PROTESTANT //
    ////////////////
    this.importDebater('luther-debater', {
      type		:	"luther-debater" ,
      name		: 	"Martin Luther",
      img		:	"LutherDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	4,
      ability		:	"Bonus CP for translation in German zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_german_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'luther-debater', html : `<li class="option" id="luther-debater">Martin Luther +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone" && his_self.canPlayerCommitDebater("protestant", "luther-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tluther-debater");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tgerman");
          his_self.endTurn();
        } 
        return 0; 
      },
    });
    this.importDebater('melanchthon-debater', {
      type		:	"melanchthon-debater" ,
      name		: 	"Philip Melanchthon",
      img		:	"MelanchthonDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"Bonus CP for translation in German zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_german_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'melanchthon-debater', html : `<li class="option" id="melanchthon-debater">Melanchthon +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone"  && his_self.canPlayerCommitDebater("protestant", "melanchthon-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tmelanchthon-debater");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tgerman");
          his_self.endTurn();
        } 
        return 0; 
      },
    });






    this.importDebater('zwingli-debater', {
      type		:	"zwingli-debater" ,
      name		: 	"Ulrich Zwingli",
      img		:	"ZwingliDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Zurich" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'zwingli-debater', html : `<li class="option" id="zwingli-debater">Ulrich Zwingli +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "zwingli-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["zurich","basel","innsbruck","strasburg","besancon","geneva","trent","salzburg","augsburg"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("ulrich_zwingli");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "ulrich_zwingli") {
	  his_self.commitDebater("protestant", "zwingli-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["zurich","basel","innsbruck","strasburg","besancon","geneva","trent","salzburg","augsburg"];
	}
        return 1;
      }
    });

    this.importDebater('bucer-debater', {
      type		:	"bucer-debater" ,
      name		: 	"Martin Bucer",
      img		:	"BucerDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Strasburg" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'bucer-debater', html : `<li class="option" id="bucer-debater">Martin Bucer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "bucer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["strasburg","zurich","basel","geneva","dijon","besancon","stdizier","metz","liege","trier","mainz","nuremberg","worms","augsburg"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("martin_bucer");
	  his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "martin_bucer") {
	  his_self.commitDebater("protestant", "bucer-debater");
	  his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["strasburg","zurich","basel","geneva","dijon","besancon","stdizier","metz","liege","trier","mainz","nuremberg","worms","augsburg"];
	  his_self.game.queue.splice(qe, 1);
	  return 1;
	}
        return 1;
      }
    });
    this.importDebater('oekolampadius-debater', {
      type		:	"oekolampadius-debater" ,
      name		: 	"Johannes Oekolampadius",
      img		:	"OekolampadiusDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Basel" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'oekolampadius-debater', html : `<li class="option" id="oekolampadius-debater">Johannes Oekolampadius +1 Bonus</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation"  && his_self.canPlayerCommitDebater("protestant", "oekolampadius-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["basel","zurich","innsbruck","strasburg","besancon","geneva","turin","grenoble","lyon","dijon","metz"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("oekolampadius");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "oekolampadius") {
	  his_self.commitDebater("protestant", "oekolampdius-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["basel","zurich","innsbruck","strasburg","besancon","geneva","turin","grenoble","lyon","dijon","metz"];
	}
        return 1;
      }
    });



    this.importDebater('bullinger-debater', {
      type		:	"bullinger-debater" ,
      name		: 	"Heinrich Bullinger",
      img		:	"BullingerDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Insert in 2nd round of debate in any Language Zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "debate") {
          return { faction : "protestant" , event : 'bullinger-debater', html : `<li class="option" id="bullinger-debater">substitute Bullinger</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu === "debate" && his_self.canPlayerCommitDebater("protestant", "bullinger-debater")) {
	  if (his_self.game.state.theological_debate.round === 2) {
            if (faction === "protestant") {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "debate") {
	  if (his_self.game.state.theological_debate.attacker === "papacy") {
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater\tbullinger-debater");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_power\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_bonus\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tround2_defender_debater\tbullinger-debater");
	  } else {
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tattacker_debater\tbullinger-debater");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_power\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tround2_attacker_debater\tbullinger-debater");
	  }
          his_self.endTurn();
        }
        return 0;
      },

    });


    this.importDebater('carlstadt-debater', {
      type		:	"carlstadt-debater" ,
      name		: 	"Andreas Carlstadt",
      img		:	"CarlstadtDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"Target 3 German spaces with Treatise, unrest if fails" ,
      committed		: 	0,
      //
      // implemented in his-player, since provides +1 bonus target for publish treastise in German zone
      //
    });





    ////////////
    // PAPACY //
    ////////////
    this.importDebater('cajetan-debater', {
      type		:	"cajetan-debater" ,
      name		: 	"Thomas Cajetan",
      img		:	"CajetanDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	1 ,
      ability		:	"Target 3 spaces with burn books" ,
      committed		: 	0,
      //
      // ability implemented in his-player.js burnBooks
      //
    });
    this.importDebater('caraffa-debater', {
      type		:	"caraffa-debater" ,
      name		: 	"Carlo Caraffa",
      img		:	"CaraffaDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"Target 3 spaces in any zone with burn books" ,
      committed		: 	0,
      //
      // ability implemented in his-player.js burnBooks
      //
    });


    this.importDebater('eck-debater', {
      type		:	"eck-debater" ,
      name		: 	"Johann Eck",
      img		:       "EckDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die in Debate Attacks" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });
    this.importDebater('gardiner-debater', {
      type		:	"gardiner-debater" ,
      name		: 	"Stephen Gardiner",
      img		:	"GardinerDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die in debate in English zone if attacker" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });

    this.importDebater('aleander-debater', {
      type		:	"aleander-debater" ,
      name		: 	"Hieronymus Aleander",
      img		:       "AleanderDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"If concludes debate, winner flips an extra space" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic - note, can benefit protestants too
      //
    });

    this.importDebater('campeggio-debater', {
      type		:	"campeggio-debater" ,
      name		: 	"Lorenzo Campeggio",
      img		:	"CampeggioDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"Roll die after debate loss; if 5 or 6 result is ignored" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });





    this.importDebater('loyola-debater', {
      type		:	"loyola-debater" ,
      name		: 	"Ignatius Loyola",
      img		:	"LoyolaDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	4 ,
      ability		:	"Found Jesuit University for only 2 CP" ,
      committed		: 	0,
      //
      // implemented in his-player -- foundJesuitUniversityWithLoyola
      //
    });

    this.importDebater('pole-debater', {
      type		:	"pole-debater" ,
      name		: 	"Reginald Pole",
      img		:	"PoleDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die for Papacy if at Council of Trent" ,
      committed		: 	0,
    });

    this.importDebater('tetzel-debater', {
      type		:	"tetzel-debater" ,
      name		: 	"Johann Tetzel ",
      img		:	"TetzelDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	1 ,
      ability		:	"1 CP to Saint Peters with Burn Books" ,
      committed		: 	0,
      //
      // implemented in his_player
      //
    });






    this.importDebater('canisius-debater', {
      type		:	"canisius-debater" ,
      name		: 	"Peter Canisius",
      img		:	"CanisiusDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die for Counter-Reformation attempts within 2 spaces of Regensburg" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'canisius-debater', html : `<li class="option" id="canisius-debater">Peter Canisius +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "canisius-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player && ["regensburg","prague","vienna","linz","graz","salzburg","innsbruck","augsburg","worms","nuremberg","leipzig","mainz","kassal"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("peter_canisius");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "peter_canisius") {
	  his_self.commitDebater("papacy", "canisius-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;
	  his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = ["regensburg","prague","vienna","linz","graz","salzburg","innsbruck","augsburg","worms","nuremberg","leipzig","mainz","kassal"];
        }
        return 1;
      }
    });





    this.importDebater('contarini-debater', {
      type		:	"contarini-debater" ,
      name		: 	"Gasparo Contarini",
      img		:	"ContariniDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"+1 die for Counter-Reformations within 2 spaces of Charles V" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'contarini-debater', html : `<li class="option" id="contarini-debater">Gasparo Contarini +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "contarini-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
	    let cx = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	    if (cx) {
	      let targets = [];
	      if (his_self.spaces[cx]) {
	        targets.push(cx);

	        for (let i = 0; i < his_self.spaces[cx].neighbours.length; i++) {

		  let x = his_self.spaces[cx].neighbours[i];
		  if (!targets.includes(x)) { targets.push(x); }

	          for (let ii = 0; ii < his_self.spaces[x].neighbours.length; ii++) {
		    let y = his_self.spaces[x].neighbours[ii];
		    if (!targets.includes(y)) { targets.push(y); }
	  	  }
	        }
	      }
	      if (targets.includes(spacekey)) {
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("gasparo_contarini");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "gasparo_contarini") {
	  his_self.commitDebater("papacy", "contarini-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;

          let cx = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
          if (his_self.spaces[cx]) {
            let targets = [];
            targets.push(cx);

            for (let i = 0; i < his_self.spaces[cx].neighbours.length; i++) {

              let x = his_self.spaces[cx].neighbours[i];
              if (!targets.includes(x)) { targets.push(x); }

              for (let ii = 0; ii < his_self.spaces[x].neighbours.length; ii++) {
                let y = his_self.spaces[x].neighbours[ii];
                if (!targets.includes(y)) { targets.push(y); }
              }
            }
          }

          his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = targets;
        }
        return 1;
      }
    });

    this.importDebater('faber-debater', {
      type		:	"faber-debater" ,
      name		: 	"Peter Faber",
      img		:	"FaberDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+2 die for Counter-Reformations against an Electorate" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'faber-debater', html : `<li class="option" id="faber-debater">Peter Faber +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "faber-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
	    if (["augsburg","trier","cologne","wittenberg","mainz","brandenburg"].includes(spacekey)) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("peter_faber");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "peter_faber") {
	  his_self.commitDebater("papacy", "faber-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;
	  his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = ["augsburg","trier","cologne","wittenberg","mainz","brandenburg"];
        }
        return 1;
      }
    });






    ////////////
    // FRENCH //
    ////////////
    this.importDebater('calvin-debater', {
      type		:	"calvin-debater" ,
      name		: 	"John Calvin",
      img		:	"CalvinDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	4 ,
      ability		:	"Target 3 French-speaking spaces with a treatise" ,
      committed		: 	0,
      //
      // implemented in his-player
      //
    });

    this.importDebater('cop-debater', {
      type		:	"cop-debater" , 
     name		: 	"Nicolas Cop",
      img		:	"CopDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation attempts within 2 spaces of Paris" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'cop-debater', html : `<li class="option" id="cop-debater">Nicholas Cop +1 Roll</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "cop-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player && ["paris","stdizier","dijon","orleans","rouen","boulogne","stquentin","calais","brussels","metz","besancon","lyon","tours","nantes"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("nicholas_cop");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "nicholas_cop") {
          his_self.commitDebater("protestant", "cop-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["paris","stdizier","dijon","orleans","rouen","boulogne","stquentin","calais","brussels","metz","besancon","lyon","tours","nantes"];
        }
        return 1;
      }
    });

    this.importDebater('farel-debater', {
      type		:	"farel-debater" ,
      name		: 	"William Farel",
      img		:	"FarelDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation attempts within 2 spaces of Geneva" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'farel-debater', html : `<li class="option" id="farel-debater">William Farel +1 Roll</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "farel-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player && ["geneva","besancon","basel","strasburg","zurich","metz","dijon","lyon","orleans","limoges","avignon","grenoble","turin","milan","pavia","genoa"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("william_farel");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "william_farel") {
          his_self.commitDebater("protestant", "farel-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["geneva","besancon","basel","strasburg","zurich","metz","dijon","lyon","orleans","limoges","avignon","grenoble","turin","milan","pavia","genoa"];
        }
        return 1;
      }

    });

    this.importDebater('olivetan-debater', {
      type		:	"olivetan-debater" ,
      name		: 	"Pierre Robert Olivetan",
      img		:	"OlivetanDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"Bonus CP for translation in French Zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_french_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'olivetan-debater', html : `<li class="option" id="olivetan-debater">Olivetan +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_french_language_zone"  && his_self.canPlayerCommitDebater("protestant", "olivetan-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_french_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tolivetan-debater");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tfrench");
          his_self.endTurn();
          his_self.updateStatus("acknowledge");
        } 
        return 0; 
      },
    });





    /////////////
    // ENGLISH //
    /////////////
    this.importDebater('cranmer-debater', {
      type		:	"cranmer-debater" ,
      name		: 	"Thomas Cranmer",
      img		:	"CranmerDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation within 2 spaces of London" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'cranmer-debater', html : `<li class="option" id="cranmer-debater">Thomas Cranmer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "cranmer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["london","portsmouth","norwich","plymouth","bristol","wales","shrewsbury","carlisle","york","lincoln"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("thomas_cranmer");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "thomas_cranmer") {
	  his_self.commitDebater("protestant", "cranmer-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["london","portsmouth","norwich","plymouth","bristol","wales","shrewsbury","carlisle","york","lincoln"];
	}
        return 1;
      }
    });

    this.importDebater('wishart-debater', {
      type		:	"wishart-debater" ,
      name		: 	"George Wishart",
      img		:	"WishartDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"+1 die for Reformation attempts in Scotland" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'wishart-debater', html : `<li class="option" id="wishart-debater">George Wishart +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "wishart-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["stirling","glasgow","edinburgh"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("george_wishart");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "george_wishart") {
	  his_self.commitDebater("protestant", "wishart-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["stirling","glasgow","edinburgh"];
	}
        return 1;
      }
    });

    this.importDebater('latimer-debater', {
      type		:	"latimer-debater" ,
      name		: 	"Hugh Latimer",
      img		:	"LatimerDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"+1 die for Reformation attempts in England" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'latimer-debater', html : `<li class="option" id="latimer-debater">Hugh Latimer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "latimer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("hugh_latimer");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "hugh_latimer") {
	  his_self.commitDebater("protestant", "latimer-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich"];
	}
        return 1;
      }
    });

    this.importDebater('knox-debater', {
      type		:	"knox-debater" ,
      name		: 	"John Knox",
      img		:	"KnoxDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"+1 die for Reformation Attempts in England or Scotland" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'knox-debater', html : `<li class="option" id="knox-debater">John Knox +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "knox-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich","glasgow","edinburgh","stirling"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("john_knox");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "john_knox") {
	  his_self.commitDebater("protestant", "knox-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich","glasgow","edinburgh","stirling"];
	}
        return 1;
      }
    });


    this.importDebater('tyndale-debater', {
      type		:	"tyndale-debater" ,
      name		: 	"William Tyndale",
      img		:	"TyndaleDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Bonus CP for translation in English zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_english_language_zone") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'tyndale-debater', html : `<li class="option" id="tyndale-debater">William Tyndale +1 Bonus CP</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone"  && his_self.canPlayerCommitDebater("protestant", "tyndale-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      }, 
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\ttyndale-debater");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tenglish");
          his_self.endTurn();
        }
        return 0;
      },
    });

    this.importDebater('coverdale-debater', {
      type		:	"coverdale-debater" ,
      name		: 	"Myles Coverdale",
      img		:	"CoverdaleDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Bonus CP for translation in English zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_english_language_zone") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'coverdale-debater', html : `<li class="option" id="coverdale-debater">Myles Coverdale +1 Bonus CP</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone"  && his_self.canPlayerCommitDebater("protestant", "coverdale-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      }, 
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tcoverdale-debater");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tenglish");
          his_self.endTurn();
        }
        return 0;
      },
    });


      /***** English Explorers *****/

      this.importExplorer('chancellor', {
           faction           :       "england" ,
           type              :       "chancellor" ,
           name              :       "Chancellor",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Chancellor.svg",
           power	     :       1,
      });

      this.importExplorer('willoughby', {
           faction           :       "england" ,
           type              :       "willoughby" ,
           name              :       "Katherine Willoughby",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Willoughby.svg",
           power	     :       1,
      });

      this.importExplorer('rut', {
           faction           :       "england" ,
           type              :       "rut" ,
           name              :       "John Rut",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Rut.svg",
           power	     :       0,
      });



      /***** French Explorers *****/

      this.importExplorer('cartier', {
           faction           :       "france" ,
           type              :       "cartier" ,
           name              :       "Jacques Cartier",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Cartier.svg",
           power	     :       3,
      });

      this.importExplorer('roberval', {
           faction           :       "france" ,
           type              :       "roberval" ,
           name              :       "Jean-François de La Rocque de Roberval",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Roberval.svg",
           power	     :       1,
      });

      this.importExplorer('verrazano', {
           faction           :       "france" ,
           type              :       "verrazano" ,
           name              :       "Giovanni da Verrazano" ,
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Verrazano.svg",
           power	     :       2,
      });



      /***** Hapsburg Explorers *****/

      this.importExplorer('orellana', {
           faction           :       "hapsburg" ,
           type              :       "orellana",
           name              :       "Hector Rodrigo Enriquez Orellana",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Orellana.svg",
           power	     :       3,
      });

      this.importExplorer('magellan', {
           faction           :       "hapsburg" ,
           type              :       "magellan" ,
           name              :       "Ferdinand Magellan",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Magellan.svg",
           power	     :       4,
      });

      this.importExplorer('leon', {
           faction           :       "hapsburg" ,
           type              :       "leon" ,
           name              :       "Leon",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Leon.svg",
           power	     :       1,
      });

      this.importExplorer('narvaez', {
           faction           :       "hapsburg" ,
           type              :       "narvaez" ,
           name              :       "Sofia Narvaez",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Narvaez.svg",
           power	     :       -1,
      });

      this.importExplorer('de-vaca', {
           faction           :       "hapsburg" ,
           type              :       "de-vaca" ,
           name              :       "Cabeza De Vaca",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/De_Vaca.svg",
           power	     :       0,
      });

      this.importExplorer('de-soto', {
           faction           :       "hapsburg" ,
           type              :       "de-soto" ,
           name              :       "DeSoto",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/DeSoto.svg",
           power	     :       2,
      });



    this.importNavyLeader('barbarossa', {
      type		:	"barbarossa" ,
      name		: 	"Barbarossa",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Barbarossa.svg",
      battle_rating	:	2,
      piracy_rating	:	1,
    });
 
    this.importNavyLeader('dragut', {
      type		:	"dragut" ,
      name		: 	"Dragut",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Dragut.svg",
      battle_rating	:	1,
      piracy_rating	:	2,
    });
 
    this.importNavyLeader('andrea-dorea', {
      type		:	"andrea-dorea" ,
      name		: 	"Andrea Dorea",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Andrea_Dorea.svg",
      battle_rating	:	2,
      piracy_rating	:	0,
    });
 


      this.importReformer('calvin-reformer', {
           type              :       "calvin-reformer" ,
           name              :       "John Calvin",
           reformer          :       true,
           img               :       "CalvinReformer.svg",
	   spacekey	     :	     "geneva",
      });

      this.importReformer('cranmer-reformer', {
           type              :       "cranmer-reformer" ,
           name              :       "Thomas Cranmer ",
           reformer          :       true,
           img               :       "CranmerReformer.svg",
	   spacekey	     :	     "london",
      });

      this.importReformer('luther-reformer', {
           type              :       "luther-reformer" ,
           name              :       "Martin Luther",
           reformer          :       true,
           img               :       "LutherReformer.svg",
	   spacekey	     :	     "wittenberg",
      });

      this.importReformer('zwingli-reformer', {
           type              :       "zwingli-reformer" ,
           name              :       "Huldrych Zwingli",
           reformer          :       true,
           img               :       "ZwingliReformer.svg",
	   spacekey	     :	     "zurich",
      });


    this.importUnit('regular', {
      type		:	"regular" ,
      name		: 	"Regular",
    });
 
    this.importUnit('mercenary', {
      type		:	"mercenary" ,
      name		: 	"Mercenary",
    });
 
    this.importUnit('cavalry', {
      type		:	"cavalry" ,
      name		: 	"Cavalry",
    });
 
    this.importUnit('squadron', {
      type		:	"squadron" ,
      name		: 	"Squadron" ,
      land_or_sea	:	"sea" ,
    });

    this.importUnit('corsair', {
      type		:	"corsair" ,
      name		: 	"Corsair" ,
      land_or_sea	:	"sea" ,
    });

    this.importUnit('debater', {
      type		:	"debater" ,
      name		: 	"Debater",
      debater		:	true,
    });
 
    this.importUnit('reformer', {
      type		:	"reformer" ,
      name		: 	"Reformer",
      reformer		:	true,
    });
 





    this.importWife('anne-boleyn', {
      type		:	"anne-boleyn" ,
      name		: 	"Anne Boleyn",
      personage		:	true,
      img		:	"AnneBoleyn.svg",
    });

    this.importWife('anne-cleves', {
      type		:	"anne-cleves" ,
      name		: 	"Anne Cleves",
      personage		:	true,
      img		:	"AnneCleves.svg",
    });

    this.importWife('catherine-aragon', {
      type		:	"catherine-aragon" ,
      name		: 	"Catherine Aragon",
      personage		:	true,
      img		:	"CatherinAragon.svg",
    });

    this.importWife('jane-seymour', {
      type		:	"jane-seymour" ,
      name		: 	"Jane Seymour",
      personage		:	true,
      img		:	"JaneSeymour.svg",
    });

    this.importWife('katherine-parr', {
      type		:	"katherine-parr" ,
      name		: 	"Katherine Parr",
      personage		:	true,
      img		:	"KatherineParr.svg",
    });

    this.importWife('kathryn-howard', {
      type		:	"kathryn-howard" ,
      name		: 	"Kathryn Howard",
      personage		:	true,
      img		:	"KathrynHoward.svg",
    });


    let first_time_running = 0;

    //
    // initialize
    //
    if (!this.game.state) {

      first_time_running = 1;
      this.game.state = this.returnState();
      this.game.state.players_info = this.returnPlayers(this.game.players.length);
      this.game.spaces = this.returnSpaces();
      this.game.navalspaces = this.returnNavalSpaces();

console.log("PLAYERS INFO: " + JSON.stringify(this.game.state.players_info));

console.log("\n\n\n\n");
console.log("---------------------------");
console.log("---------------------------");
console.log("------ INITIALIZE GAME ----");
console.log("---------------------------");
console.log("---------------------------");
console.log("---------------------------");
console.log("DECK: " + this.game.options.deck);
console.log("\n\n\n\n");

      this.updateStatus("<div class='status-message' id='status-message'>Generating the Game</div>");

      //
      // Game Queue
      //
      this.game.queue.push("round");

//      let deck2 = JSON.parse(JSON.stringify(this.deck));
//      delete deck2['001'];
//      delete deck2['002'];
//      delete deck2['003'];
//      delete deck2['004'];
//      delete deck2['005'];
//      delete deck2['006'];
//      delete deck2['007'];
//      delete deck2['008'];
//
//      this.game.queue.push("DECK\t1\t"+JSON.stringify(deck2));
     this.game.queue.push("DECK\t1\t"+JSON.stringify({})); 
     this.game.queue.push("init");

    }

    //
    // attach events to spaces
    //
    this.spaces = {};
    for (let key in this.game.spaces) {
      this.spaces[key] = this.importSpace(this.game.spaces[key], key);
    }

    //
    // add initial units
    //
    if (first_time_running == 1) {

      //
      // 1517 scenario
      //
      if (this.game.options.scenario === "1517") {

	//
	// 1517 wars and allies / diplomatic situation
	//
	this.setEnemies("hapsburg", "france");
	this.setEnemies("papacy", "france");
	this.setEnemies("ottoman", "hungary");

        //
        // 2P variant
        //
        if (this.game.players.length == 2) {

	  // OTTOMAN
          this.addRegular("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
	  this.addRegular("ottoman", "buda", 1);
	  this.addRegular("ottoman", "belgrade", 1);

	  // HAPSBURG
          this.addRegular("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "tunis", 1);
          this.controlSpace("hapsburg", "tunis", 1);
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 2);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
          this.addRegular("hapsburg", "vienna", 4);
          this.addRegular("hapsburg", "antwerp", 3);
	  this.addRegular("hapsburg", "valladolid");


	  // ENGLAND
          this.addRegular("england", "london", 1);
          this.addRegular("england", "calais", 1);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  // FRANCE
          this.addRegular("france", "paris", 1);
          this.addRegular("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 1);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);
          this.addRegular("france", "milan", 2);

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
	
	  // PROTESTANT
	
	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 1);
	
	  // INDEPENDENT
          this.addRegular("independent", "rhodes", 1);
          //this.addRegular("independent", "metz", 1);
// debug break siege
          this.addRegular("independent", "metz", 2);
          this.addRegular("independent", "florence", 1);
	
	  // DEBATERS
	  this.addDebater("papacy", "eck-debater");
	  this.addDebater("papacy", "campeggio-debater");
	  this.addDebater("papacy", "aleander-debater");
	  this.addDebater("papacy", "tetzel-debater");
	  this.addDebater("papacy", "cajetan-debater");

	  this.addDebater("protestant", "luther-debater");
	  this.addDebater("protestant", "melanchthon-debater");
	  this.addDebater("protestant", "bucer-debater");
	  this.addDebater("protestant", "carlstadt-debater");

	  // CUSTOMIZED CONTROL
	  this.controlSpace("hapsburg", "prague");
	  this.controlSpace("hapsburg", "brunn");
	  this.controlSpace("hapsburg", "breslau");
	  this.controlSpace("ottoman", "buda");
	  this.controlSpace("ottoman", "belgrade");
	  this.controlSpace("ottoman", "ragusa");

	  this.setAllies("hungary", "hapsburg");

	} else {

	  // OTTOMAN
          this.addArmyLeader("ottoman", "istanbul", "suleiman");
          this.addArmyLeader("ottoman", "istanbul", "ibrahim-pasha");
          this.addRegular("ottoman", "istanbul", 7);
          this.addCavalry("ottoman", "istanbul", 1);
          this.addNavalSquadron("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addNavalSquadron("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
          this.addNavalSquadron("ottoman", "athens", 1);

	  // HAPSBURG
	  this.addArmyLeader("hapsburg", "valladolid", "charles-v");
	  this.addArmyLeader("hapsburg", "valladolid", "duke-of-alva");
          this.addRegular("hapsburg", "seville", 1);
          this.addNavalSquadron("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addNavalSquadron("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "tunis", 1);
          this.controlSpace("hapsburg", "tunis");
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 2);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  this.addArmyLeader("hapsburg", "vienna", "ferdinand");
          this.addRegular("hapsburg", "vienna", 4);
          this.addRegular("hapsburg", "antwerp", 3);

	  // ENGLAND
          this.addArmyLeader("england", "london", "henry-viii");
          this.addArmyLeader("england", "london", "charles-brandon");
          this.addRegular("england", "london", 3);
          this.addNavalSquadron("england", "london", 1);
          this.addNavalSquadron("england", "portsmouth", 1);
          this.addRegular("england", "calais", 2);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  // FRANCE
          this.addArmyLeader("france", "paris", "francis-i");
          this.addArmyLeader("france", "paris", "montmorency");
          this.addRegular("france", "paris", 4);
          this.addRegular("france", "rouen", 1);
          this.addNavalSquadron("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 2);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);
          this.addRegular("france", "milan", 2);

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
	
	  // PROTESTANT
	
	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // HUNGARY
          this.addRegular("hungary", "belgrade", 1);
          this.addRegular("hungary", "buda", 5);
          this.addRegular("hungary", "prague", 1);

	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 3);
          this.addNavalSquadron("scotland", "edinburgh", 1);
	
	  // INDEPENDENT
          this.addRegular("independent", "rhodes", 1);
          this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "florence", 1);
	
	  // DEBATERS
	  this.addDebater("papacy", "eck-debater");
	  this.addDebater("papacy", "campeggio-debater");
	  this.addDebater("papacy", "aleander-debater");
	  this.addDebater("papacy", "tetzel-debater");
	  this.addDebater("papacy", "cajetan-debater");

	  this.addDebater("protestant", "luther-debater");
	  this.addDebater("protestant", "melanchthon-debater");
	  this.addDebater("protestant", "bucer-debater");
	  this.addDebater("protestant", "carlstadt-debater");

	}

      }

      //
      // 1532 scenario
      //
      if (this.game.options.scenario === "1532" || this.game.options.scenario === "tournament") {

	  this.game.state.starting_round = 4;
	  this.game.state.round = 3; // the one before 4

	  //
	  // 1532 wars and allies / diplomatic situation
	  //
	  this.setEnemies("hapsburg", "ottoman");
	  this.setEnemies("hapsburg", "protestant");
	  this.setEnemies("papacy", "protestant");
	  this.setAllies("hapsburg", "hungary");
	  this.setActivatedPower("hapsburg", "hungary");

	  // OTTOMAN
          this.addArmyLeader("ottoman", "istanbul", "suleiman");
          this.addArmyLeader("ottoman", "istanbul", "ibrahim-pasha");
          this.addRegular("ottoman", "istanbul", 5);
          this.addCavalry("ottoman", "istanbul", 1);
          this.addNavalSquadron("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addNavalSquadron("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
          this.addNavalSquadron("ottoman", "athens", 1);
          this.addNavyLeader("ottoman", "algiers", "barbarossa");
          this.addRegular("ottoman", "algiers", 2);
          this.addCorsair("ottoman", "algiers", 2);
          this.controlSpace("ottoman", "algiers");
          this.addRegular("ottoman", "buda", 3);
          this.addCavalry("ottoman", "buda", 1);
          this.controlSpace("ottoman", "buda");
          this.addRegular("ottoman", "belgrade", 1);
          this.controlSpace("ottoman", "belgrade");
          this.controlSpace("ottoman", "mohacs");
          this.controlSpace("ottoman", "szegedin");
          this.controlSpace("ottoman", "agram");
          this.controlSpace("ottoman", "rhodes");

	  this.game.state.ottoman_war_winner_vp = 2;
	  this.game.spaces["algiers"].pirate_haven = 1;


	  // HAPSBURG
	  this.addArmyLeader("hapsburg", "valladolid", "charles-v");
	  this.addArmyLeader("hapsburg", "valladolid", "duke-of-alva");
          this.addRegular("hapsburg", "valladolid", 4);
          this.addRegular("hapsburg", "seville", 1);
          this.addNavalSquadron("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addNavalSquadron("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 1);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  this.addArmyLeader("hapsburg", "vienna", "ferdinand");
          this.addRegular("hapsburg", "vienna", 4);
          this.addMercenary("hapsburg", "vienna", 2);
          this.addRegular("hapsburg", "antwerp", 3);
          this.controlSpace("hapsburg", "prague");
          this.controlSpace("hapsburg", "breslau");
          this.controlSpace("hapsburg", "brunn");
          this.controlSpace("hapsburg", "pressburg");
          this.controlSpace("hapsburg", "regensburg");
          this.controlSpace("hapsburg", "salzburg");
          this.controlSpace("hapsburg", "munster");
          this.controlSpace("hapsburg", "cologne");
          this.controlSpace("hapsburg", "trier");
          this.controlSpace("hapsburg", "basel");
          this.controlSpace("hapsburg", "zurich");
          this.controlSpace("hapsburg", "vienna");

	  this.game.state.hapsburg_war_winner_vp = 1;

          this.game.state.newworld['circumnavigation'].faction = "hapsburg";
          this.game.state.newworld['circumnavigation'].claimed = 1;
          this.game.state.newworld['pacificstrait'].faction = "hapsburg";
          this.game.state.newworld['pacificstrait'].claimed = 1;
          this.game.state.newworld['aztec'].faction = "hapsburg";
          this.game.state.newworld['aztec'].claimed = 1;

          this.game.state.newworld['hapsburg_colony1'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony1'].claimed = 1;
          this.game.state.newworld['hapsburg_colony2'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony2'].claimed = 1;

	  this.removeExplorer("hapsburg", "magellan");
	  this.removeExplorer("hapsburg", "leon");
	  this.removeExplorer("hapsburg", "narvaez");
	  this.removeConquistador("hapsburg", "cordova");

	  this.game.state['hapsburg_uncharted'] = 0;

	  // ENGLAND
          this.addArmyLeader("england", "london", "henry-viii");
          this.addArmyLeader("england", "london", "charles-brandon");
          this.addRegular("england", "london", 3);
          this.addMercenary("england", "london", 2);
          this.addNavalSquadron("england", "london", 1);
          this.addNavalSquadron("england", "plymouth", 1);
          this.addNavalSquadron("england", "portsmouth", 1);
          this.addRegular("england", "calais", 2);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  this.game.state.england_card_bonus = 1;
	  this.game.state.henry_viii_marital_status = 1;
	  this.game.state['england_uncharted'] = 0;

	  // FRANCE
          this.addArmyLeader("france", "paris", "francis-i");
          this.addArmyLeader("france", "paris", "montmorency");
          this.addRegular("france", "paris", 4);
          this.addMercenary("france", "paris", 2);
          this.addRegular("france", "rouen", 1);
          this.addNavalSquadron("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 2);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);

	  this.removeExplorer("france", "verrazano");

	  this.game.state.france_card_bonus = 1;
	  this.game.state['france_uncharted'] = 0;
	  this.game.state.french_chateaux_vp = 2;

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addMercenary("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
          this.addMercenary("papacy", "ravenna", 1);
	  this.controlSpace("papacy", "florence");
          this.addRegular("papacy", "florence", 1);
	  this.controlSpace("papacy", "siena");
	
          this.game.state.saint_peters_cathedral['state'] = 0;
          this.game.state.saint_peters_cathedral['vp'] = 1;
	  this.game.state.leaders.leo_x = 0;
	  this.game.state.events.clement_vii = 1;
	  this.game.state.leaders.clement_vii = 1;
	  this.game.state.already_excommunicated.push("luther-debater");

	  // PROTESTANT
	  this.addRegular("protestant", "brandenburg");	
	  this.addRegular("protestant", "wittenberg", 2);
	  this.addRegular("protestant", "mainz");	
	  this.addMercenary("protestant", "mainz", 2);	
	  this.addRegular("protestant", "augsburg", 2);	

          this.addReformer("protestant", "wittenberg", "luther-reformer");
          this.addArmyLeader("protestant", "brandenburg", "philip-hesse");
          this.addArmyLeader("protestant", "wittenberg", "john-frederick");

    	  this.game.state.augsburg_electoral_bonus = 1;
    	  this.game.state.mainz_electoral_bonus = 1;
    	  this.game.state.trier_electoral_bonus = 0;
    	  this.game.state.cologne_electoral_bonus = 0;
    	  this.game.state.wittenberg_electoral_bonus = 1;
    	  this.game.state.brandenburg_electoral_bonus = 1;

          this.game.state.translations['full']['german'] = 0;
          this.game.state.translations['full']['english'] = 0;
          this.game.state.translations['full']['french'] = 0;
          this.game.state.translations['new']['german'] = 6;
          this.game.state.translations['new']['english'] = 2;
          this.game.state.translations['new']['french'] = 4;

	  this.removeDebater("protestant", "zwingli-debater");
	  this.removeReformer("protestant", "geneva", "zwingli-debater");

	  this.convertSpace("protestant", "wittenberg");
	  this.convertSpace("protestant", "brandenburg");
	  this.convertSpace("protestant", "stettin");
	  this.convertSpace("protestant", "lubeck");
	  this.convertSpace("protestant", "magdeburg");

	  this.convertSpace("protestant", "leipzig");
	  this.convertSpace("protestant", "erfurt");
	  this.convertSpace("protestant", "nuremberg");
	  this.convertSpace("protestant", "hamburg");
	  this.convertSpace("protestant", "bremen");

	  this.convertSpace("protestant", "kassel");
	  this.convertSpace("protestant", "brunswick");
	  this.convertSpace("protestant", "mainz");
	  this.convertSpace("protestant", "worms");
	  this.convertSpace("protestant", "strasburg");

	  this.convertSpace("protestant", "basel");
	  this.convertSpace("protestant", "zurich");
	  this.convertSpace("protestant", "augsburg");
	  this.convertSpace("protestant", "breslau");


          // DEBATERS
          this.addDebater("papacy", "eck-debater");
          this.addDebater("papacy", "campeggio-debater");
          this.addDebater("papacy", "aleander-debater");
          this.addDebater("papacy", "contarini-debater");
          this.addDebater("papacy", "tetzel-debater");
          this.addDebater("papacy", "cajetan-debater");

          this.addDebater("protestant", "luther-debater");
          this.addDebater("protestant", "melanchthon-debater");
          this.addDebater("protestant", "bucer-debater");
          this.addDebater("protestant", "carlstadt-debater");
          this.addDebater("protestant", "bullinger-debater");
          this.addDebater("protestant", "oekolampadius-debater");
          this.addDebater("protestant", "tyndale-debater");

	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // HUNGARY
	  this.addRegular("hungary", "prague", 1);

	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 3);
          this.addNavalSquadron("scotland", "edinburgh", 1);
          this.game.spaces['stirling'].fortify = 1;
	
	  // INDEPENDENT
          this.controlSpace("independent", "basel");
          this.controlSpace("independent", "zurich");
          this.controlSpace("independent", "milan");
          this.controlSpace("independent", "tunis");	
          this.controlSpace("independent", "malta", 1);
          this.addRegular("independent", "malta", 1);
          this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "milan", 1);
          this.addRegular("independent", "tunis", 1);

	  // DEBATERS
	  this.setEnemies("ottoman", "hapsburg");
	  this.setEnemies("hapsburg", "protestant");
	  this.setEnemies("papacy", "protestant");
	  this.setAllies("hapsburg", "hungary");

          this.game.state.events.barbary_pirates = 1;
          this.game.state.events.ottoman_piracy_enabled = 1;
          this.game.state.events.ottoman_corsairs_enabled = 1;

      }

      if (this.game.options.scenario === "is_testing") {

	  this.game.state.starting_round = 7;

	  this.setAllies("france", "genoa");
	  this.setAllies("france", "protestant");
	  this.setActivatedPower("protestant", "france");

          this.setAllies("papacy", "hapsburg");
          this.setAllies("papacy", "venice");
	  this.setEnemies("france", "ottoman");
	  this.setEnemies("papacy","france");
	  this.setEnemies("papacy", "ottoman");
	  this.setEnemies("hapsburg", "ottoman");
	  this.setEnemies("protestant", "ottoman");

	  this.controlSpace("papacy", "prague");
	  this.addRegular("papacy", "prague", 4);

          // DEBATERS
          this.addDebater("papacy", "gardiner-debater");
          this.addDebater("papacy", "canisius-debater");
          this.addDebater("papacy", "eck-debater");
          this.addDebater("papacy", "campeggio-debater");
          this.addDebater("papacy", "aleander-debater");
          this.addDebater("papacy", "tetzel-debater");
          this.addDebater("papacy", "cajetan-debater");
          this.addDebater("papacy", "contarini-debater");
          this.addDebater("papacy", "pole-debater");
          this.addDebater("papacy", "caraffa-debater");
          this.addDebater("papacy", "loyola-debater");
          this.addDebater("papacy", "faber-debater");
          this.addDebater("papacy", "canisius-debater");
          this.addDebater("protestant", "bucer-debater");
          this.addDebater("protestant", "luther-debater");
          this.addDebater("protestant", "melanchthon-debater");
          this.addDebater("protestant", "carlstadt-debater");
          this.addDebater("protestant", "luther-debater");
          this.addDebater("protestant", "oekolampadius-debater");
          this.addDebater("protestant", "zwingli-debater");
          this.addDebater("protestant", "bullinger-debater");
          this.addDebater("protestant", "farel-debater");
          this.addDebater("protestant", "cop-debater");
          this.addDebater("protestant", "olivetan-debater");
          this.addDebater("protestant", "calvin-debater");
          this.addDebater("protestant", "cranmer-debater");
          this.addDebater("protestant", "latimer-debater");
          this.addDebater("protestant", "coverdale-debater");
          this.addDebater("protestant", "wishart-debater");
          this.addDebater("protestant", "knox-debater");

	  // REFORMERS
          this.addReformer("protestant", "wittenberg", "luther-reformer");
          this.addReformer("protestant", "zurich", "zwingli-reformer");
          this.addReformer("protestant", "geneva", "calvin-reformer");

	  // PROTESTANTS   
          this.addReformer("protestant", "london", "cranmer-reformer");
          this.addArmyLeader("protestant", "brandenburg", "philip-hesse");

	  for (let key in this.game.spaces) {
	    if (this.game.spaces[key].language == "german") {
	      this.convertSpace("protestant", key);
	    }
	  }

          // FRANCE
          this.game.state.leaders.francis_i = 1;
          this.addArmyLeader("france", "paris", "francis-i");
          this.addRegular("france", "glasgow", 2);
          this.setAllies("france", "scotland");
          this.controlSpace("france", "ragusa");
          this.addRegular("france", "ragusa", 1);
          this.addNavalSquadron("france", "ragusa", 4);

          // HAPSBURG
          this.addArmyLeader("hapsburg", "gibraltar", "duke-of-alva");
          this.addArmyLeader("hapsburg", "naples", "charles-v");
          this.addRegular("hapsburg", "naples", 4);
          this.addNavalSquadron("hapsburg", "naples", 2);
          this.addRegular("hapsburg", "nuremberg", 1);
          this.addRegular("hapsburg", "worms", 1);
          this.addRegular("hapsburg", "kassel", 1);
          this.addRegular("hapsburg", "antwerp", 4);

          // OTTOMAN
          this.addArmyLeader("ottoman", "sofia", "ibrahim-pasha");
          this.addArmyLeader("ottoman", "bucharest", "suleiman");
          this.addCavalry("ottoman", "bucharest", 2);
          this.addRegular("ottoman","athens", 3);
          this.addRegular("ottoman","istanbul", 3);

          // PAPACY
          this.addMercenary("papacy", "siena", 4);
          this.addArmyLeader("papacy", "ravenna", "renegade");
          this.addRegular("papacy", "linz", 4);
          this.addRegular("papacy", "ravenna", 4);
          this.addRegular("papacy", "ravenna", 2);
          this.addRegular("papacy", "rome", 2);
          this.addNavalSquadron("papacy", "rome", 1);
          this.activateMinorPower("papacy", "venice");
          this.controlSpace("papacy", "siena");
          this.addMercenary("papacy", "siena", 1);
          this.addMercenary("papacy", "siena", 1);
          this.addMercenary("papacy", "siena", 1);
          this.addRegular("papacy", "siena", 1);
          this.addRegular("hapsburg", "besancon", 1);

          this.addRegular("protestant", "worms", 3);
          this.addRegular("protestant", "wittenberg", 1);

          // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 1);

          // ENGLAND
          this.addRegular("england", "stirling", 4);
          this.game.state.events.henry_viii_healthy_edward = 1;

	  // GENOA
	  this.addRegular("genoa", "genoa", 2);

	  // TESTING
          this.addRegular("papacy", "turin", 4);

          this.setEnemies("papacy", "france");
          this.addMercenary("france","milan", 2);

          this.addMercenary("protestant","trier", 3);
          this.addArmyLeader("protestant", "trier", "maurice-of-saxony");

	  //this.addMercenary("papacy", "prague", 5);

          this.setAllies("papacy", "hapsburg");
          //this.setActivatedPower("papacy", "hapsburg");

	  //this.addCard("ottoman", "033");
	  //this.addCard("ottoman", "025");
	  //this.addCard("ottoman", "026");
	  //this.addCard("ottoman", "027");

	  this.controlSpace("papacy", "linz");
	  this.controlSpace("papacy", "vienna");
	  this.controlSpace("papacy", "graz");
	  this.controlSpace("papacy", "trieste");
	  this.controlSpace("papacy", "venice");

          this.game.state.events.ottoman_piracy_enabled = 1;
          this.game.state.events.ottoman_corsairs_enabled = 1;

      }

    }

    //
    // and show the board
    //
    this.displayBoard();

  }



  async render(app) {

    if (this.browser_active == 0) { return; }

    if (this.initialize_game_run) {
      return;
    }

    await this.injectGameHTML(htmlTemplate());

    await super.render(app);

    let game_mod = this;

    //
    //
    //
    if (!this.game.state) {
      this.game.state = this.returnState();
    }

    //
    // preload images
    //
    this.preloadImages();


    // required here so menu will be proper
    try {
      if (this.app.options.gameprefs.hereistand_expert_mode == 1) {
        this.confirm_moves = 0;
      } else {
        this.confirm_moves = 1;
      }
    } catch (err) {}


    this.menu.addMenuOption("game-game", "Game");
    this.menu.addSubMenuOption("game-game", {
      text : "Difficulty",
      id : "game-confirm",
      class : "game-confirm",
      callback : null
    });
    this.confirm_moves = 0;
    if (this.app.options.gameprefs) {
      if (this.app.options.gameprefs.his_expert_mode) {
	this.confirm_moves = this.app.options.gameprefs.his_expert_mode;
	if (this.confirm_moves == 1) { this.game_help.enabled = false; }
      }
    }
    this.menu.addSubMenuOption("game-confirm",{
      text: `Newbie ${(this.confirm_moves==1)?"✔":""}`,
      id:"game-confirm-newbie",
      class:"game-confirm-newbie",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 0){
	  document.querySelector("#game-confirm-newbie div").innerHTML = "Newbie ✔";
	  document.querySelector("#game-confirm-expert div").innerHTML = "Expert";
          game_mod.displayModal("Game Settings", "Tutorial Mode re-enabled");
          game_mod.saveGamePreference('his_expert_mode', 0);
	  game_mod.game_help.enabled = true;
	  game_mod.confirm_moves = 1;
        }else{
          game_mod.menu.hideSubMenus();
        }
      }
    });
    this.menu.addSubMenuOption("game-confirm",{ 
      text: `Expert ${(this.confirm_moves==1)?"":"✔"}`,
      id:"game-confirm-expert",
      class:"game-confirm-expert",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 1){
	  document.querySelector("#game-confirm-newbie div").innerHTML = "Newbie";
	  document.querySelector("#game-confirm-expert div").innerHTML = "Expert ✔";
          game_mod.displayModal("Game Settings", "Tutorial Mode disabled");
          game_mod.saveGamePreference('his_expert_mode', 1);
	  game_mod.game_help.hide();
	  game_mod.game_help.enabled = false;
	  game_mod.confirm_moves = 0;
        }else{
          game_mod.menu.hideSubMenus();
        } 
      }
    });


    this.menu.addSubMenuOption("game-game", {
      text : "Gameplay",
      id : "game-gameplay",
      class : "game-gameplay",
      callback : null
    });

    this.faster_play = 1;
    if (this.app.options.gameprefs) {
      if (this.app.options.gameprefs.his_faster_play) {
	this.faster_play = parseInt(this.app.options.gameprefs.his_faster_play);
      }
    }
    this.menu.addSubMenuOption("game-gameplay",{
      text: `Faster ${(this.faster_play==1)?"✔":""}`,
      id:"game-gameplay-faster",
      class:"game-gameplay-faster",
      callback: function(app,game_mod){
        if (game_mod.faster_play == 0){
	  document.querySelector("#game-gameplay-slower div").innerHTML = "Slower ✔";
	  document.querySelector("#game-gameplay-faster div").innerHTML = "Faster";
          game_mod.displayModal("Game Settings", "Gameplay Speedup Disabled");
          game_mod.saveGamePreference('his_faster_play', 0);
	  game_mod.faster_play = 0;
        }else{
          game_mod.menu.hideSubMenus();
        }
      }
    });
      
    this.menu.addSubMenuOption("game-gameplay",{ 
      text: `Slower ${(this.faster_play==1)?"":"✔"}`,
      id:"game-gameplay-slower",
      class:"game-gameplay-slower",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 1){
	  document.querySelector("#game-gameplay-slower div").innerHTML = "Slower";
	  document.querySelector("#game-gameplay-faster div").innerHTML = "Faster ✔";
          game_mod.displayModal("Game Settings", "Gameplay Speedup Enabled");
          game_mod.saveGamePreference('his_faster_play', 1);
	  game_mod.faster_play = 1;
        }else{
          game_mod.menu.hideSubMenus();
        } 
      }
    });


    this.menu.addSubMenuOption("game-game", {
      text : "Log",
      id : "game-log",
      class : "game-log",
      callback : function(app, game_mod) {
        game_mod.menu.hideSubMenus();
        game_mod.log.toggleLog();
      }
    });
/****
    this.menu.addSubMenuOption("game-game", {
      text : "Stats",
      id : "game-stats",
      class : "game-stats",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.handleStatsMenu();
      }
    });
****/
    this.menu.addMenuOption("game-info", "Info");
    this.menu.addSubMenuOption("game-info", {
      text: "Units",
      id: "game-units",
      class: "game-units",
      callback: function(app, game_mod){
	game_mod.menu.hideSubMenus();
        game_mod.units_overlay.render();
      }
    });


/***
    this.menu.addSubMenuOption("game-info", {
      text: "Faction Cards",
      id: "game-faction-cards",
      class: "game-faction-cards",
      callback: function(app, game_mod){
        game_mod.menu.showSubSubMenu("game-faction-cards");
      }
    });
***/

    this.menu.addSubMenuOption("game-info", {
      text : "Cards",
      id : "game-cards",
      class : "game-cards",
      callback : null
    });
    this.menu.addSubMenuOption("game-cards", {
      text: "Discard Pile",
      id: "game-cards-discard",
      class: "game-cards-discard",
      callback: function(app, game_mod){
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("discards");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Papacy",
      id : "game-papacy-cards",
      class : "game-papacy-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("papacy") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "papacy");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("papacy");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Protestant",
      id : "game-protestant-cards",
      class : "game-protestant-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("protestant") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "protestant");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("protestant");
      }
    });
if (this.game.players.length > 2) {
    this.menu.addSubMenuOption("game-cards", {
      text : "England",
      id : "game-england-cards",
      class : "game-england-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("england") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "england");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("england");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "France",
      id : "game-france-cards",
      class : "game-france-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("france") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "france");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("france");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Hapsburg",
      id : "game-hapsburg-cards",
      class : "game-hapsburg-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("hapsburg") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "hapsburg");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("hapsburg");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Ottoman",
      id : "game-ottoman-cards",
      class : "game-ottoman-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("ottoman") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "ottoman");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("ottoman");
      }
    });
}



/****
    this.menu.addSubMenuOption("game-cards", {
      text : "My Hand",
      id : "game-my-hand",
      class : "game-my-hand",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("hand");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Discards",
      id : "game-discards",
      class : "game-discards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("discards");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "All Cards",
      id : "game-all-cards",
      class : "game-all-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("all");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Unplayed",
      id : "game-unplayed-cards",
      class : "game-unplayed-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("unplayed");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Removed",
      id : "game-removed-cards",
      class : "game-removed-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("removed");
      }
    });
****/
    this.menu.addSubMenuOption("game-info", {
      text : "VP",
      id : "game-vp",
      class : "game-vp",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.vp_overlay.render();
      }
    });
/****
    this.menu.addSubMenuOption("game-info", {
      text : "New World",
      id : "game-new-world",
      class : "game-cnew-world",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.newworld_overlay.render();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Chateaux",
      id : "game-chateaux-building",
      class : "game-chateaux-building",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.chateaux_overlay.render("papacy");
      }
    });
****/
    this.menu.addSubMenuOption("game-info", {
      text : "Religion",
      id : "game-religious-conflict",
      class : "game-religious-conflict",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.religious_overlay.render();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Debaters",
      id : "game-debaters",
      class : "game-debaters",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayDebaters();
      }
    });
/***
    this.menu.addSubMenuOption("game-info", {
      text : "Explorers",
      id : "game-explorers",
      class : "game-explorers",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayExplorers();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Conquistadors",
      id : "game-conquistadors",
      class : "game-conquistadors",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayConquistadors();
      }
    });
***/

    this.menu.addMenuOption("game-factions", "Factions");
    this.menu.addSubMenuOption("game-factions", {
      text : "Hapsburgs",
      id : "game-hapsburg",
      class : "game-hapsburg",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("hapsburg");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "England",
      id : "game-england",
      class : "game-england",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("england");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "France",
      id : "game-france",
      class : "game-france",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("france");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Ottomans",
      id : "game-ottoman",
      class : "game-ottoman",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("ottoman");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Protestants",
      id : "game-protestants",
      class : "game-protestants",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("protestant");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Papacy",
      id : "game-papacy",
      class : "game-papacy",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("papacy");
      }
    });

    this.menu.addChatMenu();
    this.menu.render();
    this.log.render();
    this.cardbox.render();

    //
    // add card events -- text shown and callback run if there
    //
    this.cardbox.addCardType("showcard", "", null);
    this.cardbox.addCardType("card", "select", this.cardbox_callback);
    if (app.browser.isMobileBrowser(navigator.userAgent)) {
      this.cardbox.skip_card_prompt = 0;
    }

    //
    // position cities / spaces / etc
    //
    let spaces = this.returnSpaces();
    for (let key in spaces) {
      if (spaces.hasOwnProperty(key)) {
	try {
	  let obj = document.getElementById(key);
	  obj.style.top = spaces[key].top + "px";
	  obj.style.left = spaces[key].left + "px";
        } catch (err) {
	}
      }
    }

    //
    // position pregnancy chart
    //
    let pregnancies = this.returnPregnancyChart();
    for (let key in pregnancies) {
      if (pregnancies.hasOwnProperty(key)) {
	try {
          let idname = "pregnancy"+key;
	  let obj = document.getElementById(idname);
	  obj.style.top = pregnancies[key].top + "px";
	  obj.style.left = pregnancies[key].left + "px";
        } catch (err) {
	}
      }
    }

    //
    // position diplomacy chart
    //
    let d = this.returnDiplomacyTable();
    for (let key in d) {
      if (d.hasOwnProperty(key)) {
	try {
          for (let key2 in d[key]) {
	    divname = key + "_" + key2;
	    let obj = document.getElementById(divname);
	    obj.style.top = d[key][key2].top + "px";
	    obj.style.left = d[key][key2].left + "px";
	  }
        } catch (err) {
	}
      }
    }
    this.game.diplomacy = d;



    //
    // position electorate display
    //
    let elec = this.returnElectorateDisplay();
    for (let key in elec) {
      if (elec.hasOwnProperty(key)) {
        try {
          let obj = document.getElementById(`ed_${key}`);
          obj.style.top = elec[key].top + "px";
          obj.style.left = elec[key].left + "px";
        } catch (err) {
        }
      }
    }



    try {

      if (app.browser.isMobileBrowser(navigator.userAgent)) {
        //this.hammer.render();
      } else {
	let his_self = this;
        this.sizer.render();
        this.sizer.attachEvents('#gameboard');
	//
	// sizer makes draggable 
	//
        //$('#gameboard').draggable({
	//  stop : function(event, ui) {
	//    his_self.saveGamePreference((his_self.returnSlug()+"-board-offset"), ui.offset);
	//  }
	//});
	//
      }

    } catch (err) {}

    this.factionbar.render();

    this.hud.render();

    this.displayBoard();

  }





  popup(card) {

    let c = null;
    if (!c && this.game.deck[0]) { c = this.game.deck[0].cards[card]; }
    if (!c && this.game.deck[1]) { c = this.game.deck[1].cards[card]; }
    if (!c && this.debaters) { 
      c = this.debaters[card];
      if (c) { return `<span class="showcard ${card}" id="${card}">${c.name}</span>`; }
    }
    if (!c) {
      // catches Here I Stand and other removed cards!
      let x = this.returnDeck(true);
      if (x[card]) { c = x[card]; }
    }
    if (c) { 
      if (c.name) {
        return `<span class="showcard ${card}" id="${card}">${c.name}</span>`;
      }
    }
    return `<span class="showcard ${card}" id="${card}">${card}</span>`;
  }

  returnNewCardsForThisTurn(turn = 1) {

    let deck = this.returnDeck();
    let new_deck = {};

    for (let key in deck) {
      if (key != "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
        if (deck[key].turn === turn) {
	  new_deck[key] = deck[key];
        }
      }
    }

    if (turn >= 6) {
      if (this.game.state.henry_viii_healthy_edward == 1 && this.game.state.henry_viii_edward_added != 1) {
	this.game.state.henry_viii_edward_added = 1;
	new_deck["019"] = deck["019"];
      }
      if (this.game.state.henry_viii_sickly_edward == 1 && this.game.state.henry_viii_edward_added != 1) {
	new_deck["019"] = deck["019"];
	this.game.state.henry_viii_edward_added = 1;
      }
      if (this.game.state.henry_viii_add_elizabeth == 1 && this.game.state.henry_viii_sickly_edward == 0 && this.game.state.henry_viii_healthy_edward == 0 && this.game.state.henry_viii_mary_added != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_i_added = 1;
      }
      if (this.game.state.henry_viii_add_elizabeth == 0 && this.game.state.henry_viii_sickly_edward == 0 && this.game.state.henry_viii_healthy_edward == 0 && this.game.state.henry_viii_mary_added != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_i_added = 1;
      }
      if (this.game.state.henry_viii_mary_added == 1 && this.game.state.henry_viii_add_elizabeth == 1 && this.game.state.henry_viii_elizabeth_added != 1) {
	new_deck["023"] = deck["023"];
	this.game.state.henry_viii_elizabeth_added = 1;
      }
      if (this.game.state.henry_viii_mary_i_added_with_sickly_edward_played == 1 && this.game.state.henry_viii_mary_added_twice != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_added_twice = 1;
      }

    }

    return new_deck;

  }

  returnNewDiplomacyCardsForThisTurn(turn = 1) {

    let deck = this.returnDiplomaticDeck();
    let new_deck = {};

    for (let key in deck) {
      if (deck[key].turn === turn) {
        new_deck[key] = deck[key];
      }
    }

    if (turn == (this.game.state.events.schmalkaldic_league_round+1)) {
        new_deck['213'] = deck['213'];
        new_deck['214'] = deck['214'];
        new_deck['215'] = deck['215'];
        new_deck['216'] = deck['216'];
        new_deck['217'] = deck['217'];
        new_deck['218'] = deck['218'];
        new_deck['219'] = deck['219'];
    }

    return new_deck;

  }

  returnDiplomaticDeck() {

    let deck = {};

    deck['201'] = { 
      img : "cards/HIS-201.svg" , 
      name : "Andrea Doria" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {

          let f = his_self.returnAllyOfMinorPower("genoa");
	  if (f != "papacy") {
            his_self.deactivateMinorPower(f, "genoa");
            his_self.activateMinorPower("papacy", "genoa");
	    his_self.updateLog("Papacy allies with Genoa");
	  } else {
	    his_self.game.queue.push("andrea_dorea_placement\tpapacy");
	  }

	}

	if (faction === "protestant") {

          let f = his_self.returnAllyOfMinorPower("genoa");
	  if (f != "france") {
            his_self.deactivateMinorPower(f, "genoa");
            his_self.activateMinorPower("france", "genoa");
	    his_self.updateLog("France allies with Genoa");
	  } else {
	    his_self.game.queue.push("andrea_dorea_placement\tprotestant");
	  }

	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "andrea_dorea_placement") {

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (player == his_self.game.player) {
          his_self.playerSelectSpaceWithFilter(

            "Select Genoa Home Space for 4 Regulars",

            function(space) {
              if (space.home == "genoa") { return 1; }
	      return 0;
            },

            function(spacekey) {
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.endTurn();
            }, 

	    null, 

	    true

          );
	  } else {
	    his_self.updateStatus("Genoa adding 4 Regulars");
	  }

          return 0;
        }
	return 1;
      }
    }
    deck['202'] = { 
      img : "cards/HIS-202.svg" , 
      name : "French Constable Invades" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.setEnemies("france", "papacy");

	let p = his_self.returnPlayerOfFaction("protestant");
	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select French-Controlled Space for Invasion Force",

            function(space) {
	      if (his_self.isSpaceControlled(space, "france")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("french_constable_invades\t"+spacekey);
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant"+"\t1"); // 1 = overlay
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\tmontmorency");
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null ,

	    true 
          );

          return 0;

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "french_constable_invades") {

	  let spacekey = mv[1];
          his_self.game.queue.splice(qe, 1);

	  //
	  // 2P game, so france get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tfrance");
	  his_self.addMove("declare_war\tpapacy\tfrance");

	  let p = his_self.returnPlayerOfFaction("protestant");

	  if (his_self.game.player == p) {

   	    let msg = "Additional Military Support:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">1 squadron in French home port</li>';
            html += '<li class="option" id="mercenaries">2 more mercenaries in '+his_self.returnSpaceName(spacekey)+'</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");
	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select French Home Port",

                  function(space) {
                    if (space.ports.length > 0 && space.home == "france") {
                      return 1;
                    }
                  },

                  function(spacekey) {
		    his_self.updateStatus("French build squadrons in " + his_self.returnSpaceName(spacekey));
                    his_self.addMove("build\tland\tfrance\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
                  },

		  null ,

		  true

                );
	      }
	      if (action === "mercenaries") {
	        his_self.updateStatus("French add mercenaries in " + his_self.returnSpaceName(spacekey));
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
	      }

	    });

	  } else {
	    his_self.updateStatus("Protestants playing French Constable Invades.");
	  }

	  return 0;
	}

        return 1;

      },
    }
    deck['203'] = { 
      img : "cards/HIS-203.svg" , 
      name : "Corsair Raid" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	let opponent_faction = "protestant";
	if (faction === "protestant") { opponent_faction = "papacy"; }

	let d1 = his_self.rollDice(6);
	let d2 = his_self.rollDice(6);
	let d3 = his_self.rollDice(6);
	let d4 = his_self.rollDice(6);

	let hits = 0;

	if (d1 >= 5) { hits++; }
	if (d2 >= 5) { hits++; }
	if (d3 >= 5) { hits++; }
	if (d4 >= 5) { hits++; }

	his_self.updateLog(`${his_self.popup('203')} rolls ` + hits + " hits ["+d1+","+d2+","+d3+","+d4+"]");

        if (his_self.game.player == p) {
	  for (let i = hits-1; i >= 0; i--) {
	    his_self.addMove("corsair_raid\t"+opponent_faction+"\t"+(i+1)+"\t"+hits);
	  }
	  his_self.addMove(`NOTIFY\t${his_self.popup('203')} rolls ${hits} hits`);
	  his_self.endTurn();
	}
	
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "corsair_raid") {

	  // faction is victim
	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let total = parseInt(mv[3]);
	  let hit = "hit";

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; hit = "hits"; }
	  if (num == 3) { num = "3rd"; hit = "hits"; }
	  if (num == 4) { num = "4th"; hit = "hits"; }


	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player == player) {

	    let is_squadron_available = false;
	    if (faction === "papacy") {
	      for (let s in his_self.game.spaces) {
	        let space = his_self.game.spaces[s];
	        for (let key in space.units) {
	          if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
	  	    for (let i = 0; i < space.units[key].length; i++) {
	  	      if (space.units[key][i].type === "squadron") { is_squadron_available = true; }
	            }
	          }
	        }
	      }
	    }
	    if (faction === "protestant") {
	      for (let s in his_self.game.spaces) {
	        let space = his_self.game.spaces[s];
	        for (let key in space.units) {
	          if (key === "france" || key === "ottoman") {
	  	    for (let i = 0; i < space.units[key].length; i++) {
		      if (space.units[key][i].type === "squadron") { is_squadron_available = true; }
	            }
	          }
	        }
	      }
	    }


 	    let msg = "Corsair Raid: "+num+" of "+total+" "+hit+":";
            let html = '<ul>';
            html += '<li class="option" id="discard">discard card</li>';
	    if (is_squadron_available) {
              html += '<li class="option" id="eliminate">eliminate squadron</li>';
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "eliminate") {

                his_self.playerSelectSpaceOrNavalSpaceWithFilter(

                  `Select Space to Remove Naval Squadron` ,

 	          function(space) {
		    if (faction === "papacy") {
		      for (let key in space.units) {
		        if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") { return 1; }
		          }
		        }
		      }
		    }
		    if (faction === "protestant") {
		      for (let key in space.units) {
		        if (key === "france" || key === "ottoman") {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") { return 1; }
		          }
		        }
		      }
		    }
	            return 0;
                  },

                  function(spacekey) {

		    let land_or_sea = "land";
		    let space = null;

	            if (his_self.game.navalspaces[spacekey]) {
		      land_or_sea = "sea";
		      space = his_self.game.navalspaces[spacekey];
	            } else {
		      space = his_self.game.spaces[spacekey];
	            }

		    if (faction === "papacy") {
		      for (let key in space.units) {
		        if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") {
  	    		      $('.option').off();
			      his_self.updateStatus("Papacy removes squadron");
          	  	      his_self.addMove("remove_unit\t"+land_or_sea+"\t"+key+"\t"+"squadron"+"\t"+spacekey+"\t"+0);
          	  	      his_self.addMove("NOTIFY\tPapacy removes squadron from "+his_self.returnSpaceName(spacekey));
          	  	      his_self.endTurn();
			      return 0;
			    }
		          }
		        }
		      }
		    }

		    if (faction === "protestant") {
		      for (let key in space.units) {
		        if (key === "france" || key === "ottoman") {
			  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") {
  	    		      $('.option').off();
			      his_self.updateStatus("Protestants remove squadron");
          	  	      his_self.addMove("remove_unit\t"+land_or_sea+"\t"+key+"\t"+"squadron"+"\t"+spacekey+"\t"+0);
          	  	      his_self.addMove("NOTIFY\tProtestant removes squadron from "+his_self.returnSpaceName(spacekey));
          	  	      his_self.endTurn();
			      return 0;
			    }
		          }
		        }
		      }
		    }

  	    	    $('.option').off();
		    his_self.updateStatus("No Squadrons Available to Remove");
	            his_self.addMove("NOTIFY\tNo Squadrons Available to Remove");
		    his_self.endTurn();
		    return 0;
		  },

		  null,

		  true

                );

	      }

	      if (action === "discard") {
		his_self.addMove("discard_random\t"+faction);
          	his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " discards card");
		his_self.endTurn();
	      }

	    });
	  }
	  return 0;
	}
        return 1;
      }
    }
    deck['204'] = { 
      img : "cards/HIS-204.svg" , 
      name : "Diplomatic Marriage" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player == p) {

	  let mp = his_self.returnMinorPowers();
	  let ca = [];
	  let cd = [];

	  for (let i = 0; i < mp.length; i++) {
	    if (his_self.canFactionActivateMinorPower(faction, mp[i])) {
	      if (his_self.returnAllyOfMinorPower(mp[i]) != faction) {
	        ca.push(mp[i]);
	      }
	    } else {
	      if (his_self.canFactionDeactivateMinorPower(faction, mp[i])) {
	        cd.push(mp[i]);
	      }
	    }
	  }

	  //
	  // 2P modifications
	  //
          if (faction === "protestant") {
	    if (!cd.includes("genoa") && his_self.returnAllyOfMinorPower("genoa") !== "genoa")  { cd.push("genoa"); }
	    if (!cd.includes("venice") && his_self.returnAllyOfMinorPower("venice") !== "venice")  { cd.push("venice"); }
	    if (!cd.includes("scotland") && his_self.returnAllyOfMinorPower("scotland") !== "scotland")  { cd.push("scotland"); }
	    if (!cd.includes("venice")) { cd.push("venice"); }
	    if (!cd.includes("genoa"))  { cd.push("scotland"); }
	    if (!ca.includes("genoa"))  { ca.push("genoa"); }
	    if (!ca.includes("venice")) { ca.push("venice"); }
	  }

	  let msg = 'Activate or De-activate a Minor Power?';
    	  let html = '<ul>';
	  for (let i = 0; i < ca.length; i++) {
            html += `<li class="option" id="activate_${ca[i]}">activate ${ca[i]}</li>`;
	  }
	  for (let i = 0; i < cd.length; i++) {
            html += `<li class="option" id="deactivate_${cd[i]}">deactivate ${cd[i]}</li>`;
	  }
          html += `<li class="option" id="skip">skip</li>`;
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

	    let action = $(this).attr("id");

	    if (action === "skip") { his_self.endTurn(); return 0; }
	    let zzt = action.split("_")[1];

	    if (ca.includes(zzt)) {

	      let finished = 0;

	      if (faction === "protestant" && action === "activate_genoa") {
		his_self.addMove("activate_minor_power\thapsburg\tgenoa");
		finished = 1;
	      }
	      if (faction === "protestant" && action === "activate_venice") {
		his_self.addMove("activate_minor_power\thapsburg\tvenice");
		finished = 1;
	      }
	      if (finished == 0) {
	        let x = action.split("_");
	        action = x[1];
	        his_self.addMove("activate_minor_power\t"+faction+"\t"+action);
	      }

	    } else {
	      his_self.addMove("deactivate_minor_power\t"+his_self.returnAllyOfMinorPower(zzt[1])+"\t"+zzt[1]);
	    }
	    his_self.endTurn();
	  });
	}

	return 0;
      },
    }
    deck['205'] = { 
      img : "cards/HIS-205.svg" , 
      name : "Diplomatic Pressure" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {
	  his_self.game.queue.push("diplomatic_pressure_reveal\tpapacy\tprotestant");
	}

	if (faction === "protestant") {
	  his_self.game.queue.push("diplomatic_pressure_reveal\tprotestant\tpapacy");
	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "diplomatic_pressure_reveal") {

          let faction_taking = mv[1];
          let faction_giving = mv[2];

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player === p2) {
	    if (faction_taking === "protestant") {
              his_self.addMove("diplomatic_pressure_results_protestant\t"+JSON.stringify(his_self.game.deck[1].hand));
	    } else {
              his_self.addMove("diplomatic_pressure_results_papacy\t"+JSON.stringify(his_self.game.deck[1].hand));
	    }
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;
	}


        if (mv[0] === "diplomatic_pressure_results_papacy") {

          let cards = JSON.parse(mv[1]);

          his_self.game.queue.splice(qe, 1);
	  // also remove protestant card (which is next)
          his_self.game.queue.splice(qe-1, 1);
	
	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {

   	    let msg = "Choose Protestant Card:";
            let html = '<ul>';
	    for (let i = 0; i < cards.length; i++) {
              html += `<li class="option showcard" id="${cards[i]}">${his_self.game.deck[1].cards[cards[i]].name}</li>`;
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {
  	      $('.option').off();
              his_self.updateStatus("acknowledge...");
	      let action = $(this).attr("id");
              his_self.addMove("diplomacy_card_event\tprotestant\t"+action);
              his_self.addMove("discard_diplomacy_card\tprotestant\t"+action);
	      // protestant will be dealt another next turn - Jan 24
	      //his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("protestant"))+"\t1");
	      his_self.addMove("NOTIFY\tPapacy selects "+his_self.popup(action));
	      his_self.endTurn();
	    });

  	  } else {
	    salert("Papacy has played Diplomatic Pressure - selecting Protestant card to play");
	  }

          return 0;
        }

        if (mv[0] === "diplomatic_pressure_swap_cards") {

	  let papacy_card = mv[1];
	  let protestant_card = mv[2];

	  if (his_self.returnPlayerOfFaction("papacy") == his_self.game.player) {
	    for (let i = 0; i < his_self.game.deck[1].hand.length; i++) {
	      if (his_self.game.deck[1].hand[i] == papacy_card) {
		his_self.game.deck[1].hand.splice(i, 1);
	      }
	    }
	    his_self.game.deck[1].hand.push(protestant_card);
	  }
	  if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player) {
	    for (let i = 0; i < his_self.game.deck[1].hand.length; i++) {
	      if (his_self.game.deck[1].hand[i] == protestant_card) {
		his_self.game.deck[1].hand.splice(i, 1);
	      }
	    }
	    his_self.game.deck[1].hand.push(papacy_card);
	  }

          his_self.game.queue.splice(qe, 1);

	  return 1;

	}

        if (mv[0] === "diplomatic_pressure_results_protestant") {

          his_self.game.queue.splice(qe, 1);

          let cards = JSON.parse(mv[1]);

 	  let msg = "Papal Card is "+his_self.popup(cards[0]);
          let html = '<ul>';
          html += `<li class="option" id="discard">discard ${his_self.game.deck[1].cards[cards[0]].name}</li>`;
          html += `<li class="option" id="swap">swap ${his_self.game.deck[1].cards[cards[0]].name}</li>`;
    	  html += '</ul>';


	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {
	    his_self.updateStatus("Protestants playing Diplomatic Pressure");
	    return 0;
	  }

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

  	    $('.option').off();
	    let action = $(this).attr("id");
            his_self.updateStatus("acknowledge...");

	    if (action === "discard") {
	      his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("papacy"))+"\t1");
              his_self.addMove("discard_diplomacy_card\tpapacy\t"+cards[0]);
	      his_self.addMove("NOTIFY\tProtestants discard "+his_self.popup(cards[0]));
	      his_self.endTurn();
	    }

	    if (action === "swap") {
	      his_self.addMove("diplomatic_pressure_swap_cards\t"+cards[0]+"\t"+his_self.game.deck[1].hand[0]);
	      his_self.addMove("NOTIFY\tProtestants swap Diplomacy Cards");
	      his_self.endTurn();
	    }

	  });

          return 0;
	}

        return 1;

      },
    }
    deck['206'] = { 
      img : "cards/HIS-206.svg" , 
      name : "French Invasion" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.setEnemies("france", "papacy");

	let p = his_self.returnPlayerOfFaction("protestant");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select French-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "france")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("french_invasion\t"+spacekey);
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
	      if (his_self.game.state.leaders.francis_i) {
                his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\tfrancis-i");
              } else {
		his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\thenry-ii");
              }
	      his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true 

          );

	}

        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "french_invasion") {

	  let spacekey = mv[1];
          his_self.game.queue.splice(qe, 1);

	  //
	  // 2P card, so french get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tfrance");
	  his_self.addMove("declare_war\tpapacy\tfrance");

	  let player = his_self.returnPlayerOfFaction("protestant");
	  if (his_self.game.player == player) {

 	    let msg = "Choose Option:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">1 squadron in French home port</li>';
            html += '<li class="option" id="mercenaries">2 more mercenaries in '+his_self.returnSpaceName(spacekey)+'</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");
	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select French Home Port",

                  function(space) {
                    if (space.ports.length > 0 && space.home == "france") {
                      return 1;
                    }
                  },

                  function(spacekey) {
		    his_self.updateStatus("French add Squadrons in " + his_self.returnSpaceName(spacekey));
                    his_self.addMove("build\tland\tfrance\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
                  },

		  null,

		  true

                );
	      }
	      if (action === "mercenaries") {
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
	      }
	    });
	  } else {
	    his_self.updateLog("Protestants playing " + his_self.popup("206"));
	  }
	  return 0;
	}

        return 1;

      },
    }
    deck['207'] = { 
      img : "cards/HIS-207.svg" , 
      name : "Henry Petitions for Divorce" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");
	if (his_self.game.player == p) {

          let msg = his_self.popup("207") + " played for Diplomatic Event";
          let html = '<ul>';
          html += '<li class="option" id="grant">Grant Divorce</li>';
          html += '<li class="option" id="refuse">Refuse Divorce</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let action = $(this).attr("id");
            $('.option').off();

	    if (action === "grant") {

	      his_self.updateStatus("Papacy grants divorce...");
	      his_self.addMove(`NOTIFY\t${his_self.popup("207")} - Papacy grants divorce...`);
	      his_self.addMove("player_call_theological_debate\tpapacy");
	      his_self.addMove("henry_petitions_for_divorce_grant");
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
	      his_self.endTurn();
	    }

	    if (action === "refuse") {
	      his_self.updateStatus("Papacy refuses divorce...");
	      his_self.addMove(`NOTIFY\t${his_self.popup("207")} - Papacy refuses divorce...`);
	      his_self.addMove("henry_petitions_for_divorce_refuse\t3");
	      his_self.addMove("henry_petitions_for_divorce_refuse\t2");
	      his_self.addMove("henry_petitions_for_divorce_refuse\t1");
	      his_self.endTurn();
	    }

	  });
	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "henry_petitions_for_divorce_grant") {

          his_self.game.queue.splice(qe, 1);
	  his_self.game.state.events.henry_petitions_for_divorce_grant = 1;

	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (his_self.game.player == p) {

            his_self.playerSelectSpaceWithFilter(

              "Select Hapsburg-Controlled Italian Space" ,

              (space) => {
                if (his_self.isSpaceControlled(space.key, "hapsburg") && space.language === "italian") { return 1; }
		return 0;
	      },

              (spacekey) => {
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
	        his_self.addMove(`NOTIFY\tHapsburg recruits 4 mercenaries in ${his_self.returnSpaceName(spacekey)}`);
	        his_self.endTurn();
	      },

    	      null ,

	      true
    
	    );

	  } else {
	    his_self.updateStatus("Protestants selecting Italian space for reinforcements");
	  }

	  return 0;
	}


        if (mv[0] === "henry_petitions_for_divorce_refuse") {

          his_self.game.queue.splice(qe, 1);

	  let num = parseInt(mv[1]);

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }

	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
            his_self.playerSelectSpaceWithFilter(

              `Select Hapsburg-Controlled Space to add ${num} Regular` ,

              function(space) {
	        if (space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) { return 0; }
                if (his_self.isSpaceControlled(space.key, "hapsburg")) { return 1; }
	        return 0;
              },

              function(spacekey) {
                his_self.addMove("build\tland\thapsburg\tregular\t"+spacekey);
	        his_self.addMove(`NOTIFY\tHapsburg add regular in ${his_self.returnSpaceName(spacekey)}`);
          	his_self.endTurn();
              },

              null, 

	      true

	    );
	  }

	  return 0;
	}
	return 1;
      }
    }
    deck['208'] = { 
      img : "cards/HIS-208.svg" , 
      name : "Knights of St. John" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	his_self.game.queue.push("knights-of-saint-john\t"+faction);
	his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
        his_self.game.queue.push(`DEAL\t1\t${p}\t1`);

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "knights-of-saint-john") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (player == his_self.game.player) {

            let fhand_idx = his_self.returnFactionHandIdx(player, faction);
            let c = his_self.game.deck[0].fhand[fhand_idx][his_self.game.deck[0].fhand[fhand_idx].length-1];
	    let card = his_self.game.deck[0].cards[c];
	    let ops = card.ops;

	    his_self.addMove("discard\t"+faction+"\t"+c);
	    his_self.addMove("build_saint_peters_with_cp\t"+ops);
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" pulls "+his_self.popup(c)+ " "+ops+" CP");
	    his_self.endTurn();

	  }

	  return 0;
        }

	return 1;	
      }
    }
    deck['209'] = { 
      img : "cards/HIS-209.svg" , 
      name : "Plague" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } , 
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("plague\t"+faction+"\t3");
	his_self.game.queue.push("plague\t"+faction+"\t2");
	his_self.game.queue.push("plague\t"+faction+"\t1");
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "plague") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);
	  let opponent_faction = "protestant";
	  if (faction === "protestant") { opponent_faction = "papacy"; }

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; his_self.game.state.plague_already_removed = []; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      let anything_here = false;
	      for (let key in space.units) {
		if (space.units[key].length > 1) {
		  if (!his_self.game.state.plague_already_removed.includes(space.key)) {
		    for (let z = 0; z < space.units[key].length; z++) {
		      let u = space.units[key][z];
		      if (u.type === "regular") { return 1; }
		      if (u.type === "mercenary") { return 1; }
		      if (u.type === "cavalry") { return 1; }
		      if (u.type === "corsair") { return 1; }
		      if (u.type === "squadron") { return 1; }
		    }
		  }
		}
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Choose Faction to Destroy Unit:";
              let html = '<ul>';
	      let u = 0;
              if (space.units["hapsburg"].length) { u++; html += '<li class="option" id="hapsburg">hapsburgs</li>'; }
              if (space.units["france"].length) { u++; html += '<li class="option" id="france">france</li>'; }
              if (space.units["england"].length) { u++; html += '<li class="option" id="england">england</li>'; }
              if (space.units["papacy"].length) { u++; html += '<li class="option" id="papacy">papacy</li>'; }
              if (space.units["protestant"].length) { u++; html += '<li class="option" id="protestant">protestant</li>'; }
              if (space.units["ottoman"].length) { u++; html += '<li class="option" id="ottoman">ottoman</li>'; }
              if (space.units["hungary"].length) { u++; html += '<li class="option" id="hungary">hungary</li>'; }
              if (space.units["venice"].length) { u++; html += '<li class="option" id="venice">venice</li>'; }
              if (space.units["scotland"].length) { u++; html += '<li class="option" id="scotland">scotland</li>'; }
              if (space.units["genoa"].length) { u++; html += '<li class="option" id="genoa">genoa</li>'; }
              if (space.units["independent"].length) { u++; html += '<li class="option" id="independent">independent</li>'; }
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();

	        let faction_to_destroy = $(this).attr("id");
   	        let msg = "Destroy Which Unit: ";
                let unittypes = [];
		let unit_destroyed = 0;
                let html = '<ul>';
		let du = -1;
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].command_value == 0) {
		    if (!unittypes.includes(space.units[faction_to_destroy][i].type) &&
		        (space.units[faction_to_destroy][i].type == "regular" ||
		        space.units[faction_to_destroy][i].type == "mercenary" ||
		        space.units[faction_to_destroy][i].type == "squadron" ||
		        space.units[faction_to_destroy][i].type == "corsair" ||
		        space.units[faction_to_destroy][i].type == "cavalry")
		    ) {
		      if (du == -1) { du = i; } else { du = -2; }
  		      html += `<li class="option nonskip" id="${space.units[faction_to_destroy][i].type}">${space.units[faction_to_destroy][i].type}</li>`;
		      unittypes.push(space.units[faction_to_destroy][i].type);
		    }
		  }
		}
  		html += `<li class="option" id="skip">skip</li>`;
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

   	        $('.option').off();
	        $('.option').on('click', function () {

   	          $('.option').off();
	          let unittype = $(this).attr("id");
		  if (unit_destroyed == 1) { return; }	
		  unit_destroyed = 1;

		  if (unittype === "skip") {
          	    his_self.endTurn();
		    return 0;
		  }

          	  his_self.removeUnit(faction_to_destroy, spacekey, unittype);

 	          his_self.game.state.plague_already_removed.push(spacekey);

		  his_self.displaySpace(spacekey);
		  if (num === "3rd") { 
		    his_self.updateStatus("submitted");
		    his_self.addMove("discard_random\t"+opponent_faction);
		  }

          	  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	  his_self.endTurn();
		});

		// auto-submit if only 1 choice
		if (du > -1) { $('.nonskip').click(); }

              });

	      // auto-submit if only 1 choice
	      if (u == 1) { $('.option').click(); }

	    },

            null, 

	    true

	  );

          return 0;

	}

	return 1;
      },
    }
    deck['210'] = { 
      img : "cards/HIS-210.svg" , 
      name : "Shipbuilding" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } , 
      onEvent(his_self, faction) {
        his_self.game.queue.push("shipbuilding_diplomacy_event\t"+faction);
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
    
        if (mv[0] == "shipbuilding_diplomacy_event") {
    
          his_self.game.queue.splice(qe, 1);
                        
          let faction = mv[1];
          let player = his_self.returnPlayerOfFaction(faction);
                    
          if (his_self.game.player === player) { 
    
            if (faction === "papacy") {

              //
              // pick port under Papal control
              //
              his_self.playerSelectSpaceWithFilter(

                "Select Space to add 2 Squadrons" ,

                  (space) => {
                    if (his_self.isSpaceControlled(space.key, "papacy")) {
		      if (space.ports.length > 0) {
			return 1;
		      }
		    }
		    return 0;
		  },

                  (spacekey) => {
                    let space = his_self.game.spaces[spacekey];
                    his_self.addMove("build\tland\tpapacy\t"+"squadron"+"\t"+spacekey);
                    his_self.addMove("build\tland\tpapacy\t"+"squadron"+"\t"+spacekey);
		    his_self.endTurn();
		  },

		  null ,

		  true
    
	      );

            }       
    
            if (faction === "protestant") {
                        
              let msg = "Add 2 Naval Squadrons Where?";
              let html = '<ul>';
              html += '<li class="option" id="french">French - Marseille</li>';
              html += '<li class="option" id="hapsburg">Hapsburg - Naples</li>';
              html += '<li class="option" id="ottoman">Ottoman - any home port</li>';
              html += '<li class="option" id="skip">skip</li>';
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let action = $(this).attr("id");

		if (action === "skip") {
		  his_self.addMove("Protestants do not build any squadrons");
		  his_self.endTurn();
		}

		if (action === "hapsburg") {
                  his_self.addMove("build\tland\thapsburg\t"+"squadron"+"\tnaples");
                  his_self.addMove("build\tland\thapsburg\t"+"squadron"+"\tnaples");
		  his_self.endTurn();
		}

		if (action === "french") {
                  his_self.addMove("build\tland\tfrance\t"+"squadron"+"\tmarseille");
                  his_self.addMove("build\tland\tfrance\t"+"squadron"+"\tmarseille");
		  his_self.endTurn();
		}

		if (action === "ottoman") {
                  //
                  // pick any Ottoman home port
                  //
                  his_self.playerSelectSpaceWithFilter(

                    "Select Ottoman-Controlled Home Port to add 2 Squadrons" ,

                    (space) => {
                      if (his_self.isSpaceControlled(space.key, "ottoman")) {
		        if (space.ports.length > 0) {
			  return 1;
		        }
		      }
		      return 0;
		    },

                    (spacekey) => {
                      let space = his_self.game.spaces[spacekey];
                      his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
                      his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
		      his_self.endTurn();
		    },

		    null ,

		    true
    
	          );

		}

              });

            }

          }
	  return 0;

	}
	return 1;
      },
    }
    deck['211'] = { 
      img : "cards/HIS-211.svg" , 
      name : "Spanish Invasion" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let controlling_power = "papacy";
	let victim_power = "protestant";

	//
	// prior to League formation
	//
	if (his_self.game.state.events.schmalkaldic_league != 1) {
	  controlling_power = "protestant";
	  victim_power = "papacy";
	  his_self.setEnemies("papacy","hapsburg");
	}

	let controlling_player = his_self.returnPlayerOfFaction(controlling_power);

	//
	// remember who controls the invasion
	//
	his_self.game.state.events.spanish_invasion = controlling_power;

	//
	// controlling power gets 1 card
	//
	his_self.game.queue.push("hand_to_fhand\t1\t"+controlling_player+"\t"+controlling_power+"\t1");
        his_self.game.queue.push(`DEAL\t1\t${controlling_player}\t1`);
	his_self.game.queue.push("spanish_invasion_land\t"+controlling_player+"\t"+controlling_power+"\t"+victim_power);

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "spanish_invasion_land") {

          his_self.game.queue.splice(qe, 1);

	  let controlling_player = parseInt(mv[1]);
	  let controlling_power = mv[2];
	  let victim_power = mv[3];

	  if (his_self.game.player === controlling_player) {

  	    //
	    // 2P card, so spanish get activated under protestant control
	    //
	    his_self.addMove("set_activated_powers\t"+controlling_power+"\thapsburg");
	    his_self.addMove("declare_war\t"+victim_power+"\thapsburg");

            his_self.playerSelectSpaceWithFilter(

              "Select Hapsburg-Controlled Space for Invasion Force",

              function(space) {
	        if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	        return 0;
              },

              function(spacekey) {

		his_self.updateStatus("acknowledge...");

	        //
	        // move Duke of Alva, add regulars
	        //
                let ak = his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva");
                let ak_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "duke-of-alva", ak);
          
                his_self.addMove("spanish_invasion_naval\t"+controlling_player+"\t"+spacekey);
		if (ak_idx == -1) {
                  his_self.addMove("add_army_leader" + "\t" + "hapsburg" + "\t" + spacekey + "\t" + "duke-of-alva");
		} else {
                  his_self.addMove("move" + "\t" + "hapsburg" + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		}
	        his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
              },

	      null,

	      true

            );
	  }

          return 0;

	}
        if (mv[0] == "spanish_invasion_naval") {

          his_self.game.queue.splice(qe, 1);

	  let controlling_player = parseInt(mv[1]);
	  let land_spacekey = mv[2];

	  if (his_self.game.player === controlling_player) {

            let msg = "Add Additional Units:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">Naval Squadron</li>';
            html += '<li class="option" id="mercenaries">+2 Mercenaries</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
              $('.option').off();

	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select Hapsburg-Controlled Port for Squadron",

                  function(space) {
	            if (his_self.isSpaceControlled(space, "hapsburg") && space.home == "hapsburg" && space.ports.length > 0) { return 1; }
	            return 0;
                  },

                  function(spacekey) {
		    his_self.updateStatus("acknowledge...");
                    his_self.addMove("build\tland\thapsburg\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
		  },

		  null ,

		  true
                );
	      }

	      if (action === "mercenaries") {
		his_self.updateStatus("acknowledge...");
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+land_spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+land_spacekey);
		his_self.endTurn();
	      }

            });
	  }

	  return 0;

	}

	return 1;
      },
    }
    deck['212'] = { 
      img : "cards/HIS-212.svg" , 
      name : "Venetian Alliance" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	if (faction == "ottoman" && his_self.returnControllingPower("venice") != "venice") {
	  return 1;
	}
	if (faction == "papacy") {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let ally = his_self.returnAllyOfMinorPower("venice");

	// papacy is only faction that can activate
	if (ally === "" || ally === "venice") {
	  his_self.activateMinorPower("papacy", "venice");
	}
	if (ally == "hapsburg") {
	  his_self.deactivateMinorPower("hapsburg", "venice");
	}
        if (ally === "papacy" && faction == "papacy") {
	  his_self.game.queue.push("venetian_alliance_placement");
	}
        if (ally === "papacy" && faction == "ottoman") {
	  his_self.deactivateMinorPower("papacy", "venice");
	}
	his_self.displayWarBox();

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "venetian_alliance_placement") {

          his_self.game.queue.splice(qe, 1);
	  if (his_self.game.player == his_self.returnPlayerOfFaction("papacy")) {  
            his_self.playerSelectSpaceWithFilter(

              "Select Papal-Controlled Port not under Siege",

              function(space) {
	        if (his_self.isSpaceControlled(space, "papacy") && space.ports.length > 0 && !space.besieged) { return 1; }
	        return 0;
              },

              function(spacekey) {
	        his_self.addMove("build\tland\tvenice\t"+"regular"+"\t"+spacekey);
                his_self.addMove("build\tland\tvenice\t"+"squadron"+"\t"+spacekey);
                his_self.addMove("build\tland\tvenice\t"+"squadron"+"\t"+spacekey);
                his_self.endTurn();
              }
            );
            return 0;
          } else {
	    his_self.updateStatus("Papacy executing " + his_self.popup("212"));
	  }

	  return 0;
	}

	return 1;

      },

    }
    deck['213'] = { 
      img : "cards/HIS-213.svg" , 
      name : "Austrian Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; }, 
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select Hapsburg-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy"+"\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\thapsburg\t"+spacekey+"\tferdinand");
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true
          );

	}

        return 0;
      },
    }
    deck['214'] = { 
      img : "cards/HIS-214.svg" , 
      name : "Imperial Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select Hapsburg-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\thapsburg\t"+spacekey+"\tcharles-v");
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true,
          );

	}

        return 0;
      },
    }
    deck['215'] = { 
      img : "cards/HIS-215.svg" , 
      name : "Machiavelli" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let vp = his_self.calculateVictoryPoints();
	let winner = "protestant";

	if (vp["protestant"].vp > vp["papacy"].vp) { winner = "papacy"; }
	if (vp["protestant"].vp == vp["papacy"].vp) { winner = faction; }

	//
	// TODO -- cannot pick an invasion card played earlier this turn
	//
	if (his_self.game.player == his_self.returnPlayerOfFaction(winner)) {

          let msg = "Select Invasion Card:";
          let html = '<ul>';
          html += '<li class="option showcard" id="216">Ottoman Invasion</li>';
          html += '<li class="option showcard" id="214">Imperial Invasion</li>';
          html += '<li class="option showcard" id="213">Austrian Invasion</li>';
          html += '<li class="option showcard" id="211">Spanish Invasion</li>';
          html += '<li class="option showcard" id="206">French Invasion</li>';
          html += '<li class="option showcard" id="202">French Constable Invades</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

	    his_self.updateStatus("acknowledge...");
            let card = $(this).attr("id");
	    his_self.addMove("reshuffle_diplomacy_deck");
	    his_self.addMove("diplomacy_card_event\t"+winner+"\t"+card);
	    his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus("Opponent playing " + his_self.popup("215"));
	}

        return 0;
      },
    }
    deck['216'] = { 
      img : "cards/HIS-216.svg" , 
      name : "Ottoman Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");
	his_self.setEnemies("ottoman", "papacy");

	if (his_self.game.player == p) {

  	  //
	  // 2P card, so ottoman get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tottoman");
	  his_self.addMove("declare_war\tpapacy\tottoman");

          his_self.playerSelectSpaceWithFilter(

            `Select Ottoman-Controlled Port for ${his_self.popup("216")}`,

            function(space) {
	      if (his_self.isSpaceControlled(space, "ottoman") && space.ports.length > 0) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\tottoman\t"+spacekey+"\tsuleiman");
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true 

          );

	}

        return 0;
      },
    }
    deck['217'] = { 
      img : "cards/HIS-217.svg" , 
      name : "Secret Protestant Circle" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");
	let d = his_self.rollDice(6);

	his_self.rollDice("Secret Protestant Circle - rolls: " + d);

	if (d <= 3) {
	  his_self.updateLog("Protestants may flip an Italian and Spanish space");
	  his_self.game.queue.push("secret_protestant_circle\tspanish");
	  his_self.game.queue.push("secret_protestant_circle\titalian");
	} else {
	  his_self.updateLog("Protestants may convert an Italian space");
	  his_self.game.queue.push("secret_protestant_circle\titalian");
	}

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "secret_protestant_circle") {

	  let zone = mv[1];
	  let player = his_self.returnPlayerOfFaction("protestant");
	  if (player === his_self.game.player) {

            his_self.playerSelectSpaceWithFilter(

              "Select Space to Convert Protestant" ,

              function(space) {
                if (space.language === zone) { return 1; }
	        return 0;
              },

              function(spacekey) {
                his_self.addMove("convert\t"+spacekey+"\tprotestant");
                his_self.endTurn();
              },

	      null,

	      true
            );
	  }
	  
          his_self.game.queue.splice(qe, 1);
          return 0;
        }
	return 1;
      }
    }
    deck['218'] = { 
      img : "cards/HIS-218.svg" , 
      name : "Siege of Vienna" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let lockdown = ["regensburg","salzburg","linz","prague","breslau","brunn","vienna","graz","trieste","agram","pressburg","buda"];
	for (let i = 0; i < lockdown.length; i++) {
	  for (let z = 0; z < his_self.game.spaces[lockdown[i]].units["hapsburg"].length; z++) {
	    his_self.game.spaces[lockdown[i]].units["hapsburg"][z].locked = 1;
	  }
	  for (let z = 0; z < his_self.game.spaces[lockdown[i]].units["hungary"].length; z++) {
	    his_self.game.spaces[lockdown[i]].units["hungary"][z].locked = 1;
	  }
	}

	let spaces = his_self.returnSpacesWithFilter(
          function(spacekey) {
            if (his_self.returnFactionLandUnitsInSpace("hapsburg", spacekey)) { return true; }
            if (his_self.returnFactionLandUnitsInSpace("hungary", spacekey)) { return true; }
	    return false;
	  }
	);

	if (spaces.length >= 2) {
	  his_self.game.queue.push("siege_of_vienna\t"+faction+"\t2");
	}
	if (spaces.length >= 1) {
	  his_self.game.queue.push("siege_of_vienna\t"+faction+"\t1");
	}
	if (spaces.length == 0) {
console.log("Siege of Vienna - no valid spaces");
	}

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "siege_of_vienna") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerCommandingFaction(faction);

	  let lockdown = ["regensburg","salzburg","linz","prague","breslau","brunn","vienna","graz","trieste","agram","pressburg","buda"];
	  if (player == his_self.game.player) {

 	    let msg = `${his_self.popup("218")}: remove unit #${num}:`;
            let html = '<ul>';
            html += '<li class="option" id="hapsburg">remove hapsburg unit</li>';
            html += '<li class="option" id="hungary">remove hungarian unit</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

	      let action = $(this).attr("id");

	      if (action === "hapsburg") {

                let spaces = his_self.returnSpacesWithFilter(
                  function(spacekey) {
	            if (!lockdown.includes(spacekey)) { return false; }
                    if (his_self.returnFactionLandUnitsInSpace("hapsburg", spacekey)) { return true; }
                    return false;
                  } 
                );

	        if (spaces.length == 0) {
	 	  his_self.addMove("NOTIFY\tSiege of Vienna - no units to target.");
	 	  his_self.endTurn();
		  return 0;
	        }

                his_self.playerSelectSpaceWithFilter(

                  "Select Space to Remove Unit" ,

                  function(space) {
console.log("considering: " + space.key);
                    if (spaces.includes(space.key)) { return 1; }
	            return 0;
                  },

                  function(spacekey) {

console.log("selected: " + spacekey);

		    let has_mercenary = false;
		    let has_regular = false;
		    let has_cavalry = false;

		    for (let i = 0; i < his_self.game.spaces[spacekey].units["hapsburg"].length; i++) {
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "mercenary") { has_mercenary = true; }
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "regular") { has_regular = true; }
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "cavalry") { has_cavalry = true; }
		    }

   	            let msg = "Choose Unit to Destroy:";
                    let html = '<ul>';
                    if (has_regular) { html += '<li class="option" id="regular">hapsburg regular</li>'; }
                    if (has_mercenary) { html += '<li class="option" id="mercenary">hapsburg mercenary</li>'; }
                    if (has_cavalry) { html += '<li class="option" id="cavalry">hapsburg cavalry</li>'; }
    	            html += '</ul>';

                    his_self.updateStatusWithOptions(msg, html);

   	            $('.option').off();
	            $('.option').on('click', function () {

		      let unittype = $(this).attr("id");
          	      his_self.removeUnit("hapsburg", spacekey, unittype);
		      his_self.displaySpace(spacekey);
          	      his_self.addMove("remove_unit\tland\thapsburg\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	      his_self.endTurn();
		    });
                  },

		  null, 

		  true
                );

              } // end hapsburg


	      if (action === "hungary") {

                let spaces = his_self.returnSpacesWithFilter(
                  function(spacekey) {
	            if (!lockdown.includes(spacekey)) { return false; }
                    if (his_self.returnFactionLandUnitsInSpace("hungary", spacekey)) { return true; }
                    return false;
                  } 
                );

                his_self.playerSelectSpaceWithFilter(

                  "Select Space to Remove Unit" ,

                  function(space) {
                    if (spaces.includes(space.key)) { return 1; }
	            return 0;
                  },

                  function(spacekey) {

		    let has_mercenary = false;
		    let has_regular = false;
		    let has_cavalry = false;

		    for (let i = 0; i < his_self.game.spaces[spacekey].units["hungary"].length; i++) {
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "mercenary") { has_mercenary = true; }
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "regular") { has_regular = true; }
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "cavalry") { has_cavalry = true; }
		    }

   	            let msg = "Choose Unit to Destroy:";
                    let html = '<ul>';
                    if (has_regular) { html += '<li class="option" id="regular">hungarian regular</li>'; }
                    if (has_mercenary) { html += '<li class="option" id="mercenary">hungarian mercenary</li>'; }
                    if (has_cavalry) { html += '<li class="option" id="cavalry">hungarian cavalry</li>'; }
    	            html += '</ul>';

                    his_self.updateStatusWithOptions(msg, html);

   	            $('.option').off();
	            $('.option').on('click', function () {

		      let unittype = $(this).attr("id");
          	      his_self.removeUnit("hungary", spacekey, unittype);
		      his_self.displaySpace(spacekey);
          	      his_self.addMove("remove_unit\tland\thungary\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	      his_self.endTurn();
		    });
                  },

		  null, 

		  true
                );

              } // end hapsburg
            });

	  } // player

          his_self.game.queue.splice(qe, 1);
          return 0;

	} // siege_of_vienna

	return 1;
      }
    }
    deck['219'] = { 
      img : "cards/HIS-219.svg" , 
      name : "Spanish Inquisition" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {
	  his_self.game.queue.push("spanish_inquisition_reveal");
	}

	if (faction === "protestant") {
	  his_self.game.queue.push("request_reveal_hand\tpapacy\tprotestant");
	  his_self.game.queue.push("NOTIFY\tProtestants play Spanish Inquisition");
   	}

        return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "spanish_inquisition_reveal") {

          if (his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {
            his_self.addMove("spanish_inquisition_results\t"+JSON.stringify(his_self.game.deck[1].hand));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;
	}


        if (mv[0] === "spanish_inquisition_results") {

          let cards = JSON.parse(mv[1]);

          his_self.game.queue.splice(qe, 1);
	  // remove protestant play 
          his_self.game.queue.splice(qe-1, 1);

	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {


   	    let msg = "Choose Protestant Card to Discard:";
            let html = '<ul>';
	    for (let i = 0; i < cards.length; i++) {
              html += `<li class="showcard option" id="${cards[i]}">${his_self.game.deck[1].cards[cards[i]].name}</li>`;
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {

  	      $('.option').off();
	      let action = $(this).attr("id");

	      let chosen_card = action;
	      let unchosen_card = "";
	      for (let i = 0; i < cards.length; i++) { if (cards[i] != action) { unchosen_card = cards[i]; } }

              his_self.addMove("diplomacy_card_event\tprotestant\t"+unchosen_card);
              his_self.addMove("discard_diplomacy_card\tprotestant\t"+chosen_card);
	      his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("protestant"))+"\t1");
	      his_self.addMove("NOTIFY\tPapacy selects "+his_self.game.deck[1].cards[action].name+" to discard");
	      his_self.endTurn();

	    });

  	  }

          return 0;
        }

        return 1;

      },
    }
    for (let key in deck) {
      deck[key] = this.addEvents(deck[key]);
    }

    return deck;

  }


  removeCardFromGame(card) {
    if (!this.game.state.removed.includes(card)) { this.game.state.removed.push(card); }
    try { delete this.game.deck[0].cards[card]; } catch (err) {}
    try { delete this.game.deck[0].discards[card]; } catch (err) {}
  }


  returnDeck(include_removed=false) {

    var deck = {};

    /// HOME CARDS
    deck['001'] = { 
      img : "cards/HIS-001.svg" , 
      name : "Janissaries" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "ottoman" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "janissaries" || menu === "janissaries_naval") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
              let f = "ottoman";
              return { faction : f , event : '001', html : `<li class="option" id="001">janissaries (${f})</li>` };
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "janissaries") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
	      if (his_self.doesFactionHaveLandUnitsInSpace("ottoman", spacekey)) {
	        his_self.field_battle_overlay.render(his_self.game.state.field_battle);
                return 1;
              }
            }
          }
        }
        if (menu === "janissaries_naval") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
	      if (his_self.doesFactionHaveNavalUnitsInSpace("ottoman", spacekey)) {
	        his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "janissaries") {
	  his_self.addMove("ACKNOWLEDGE\tOttomans play Janissaries");
          his_self.addMove("discard\tottoman\t001");
          his_self.addMove("janissaries");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        if (menu == "janissaries_naval") {
	  his_self.addMove("ACKNOWLEDGE\tOttomans play Janissaries");
          his_self.addMove("discard\tottoman\t001");
          his_self.addMove("janissaries\tnaval");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "janissaries") {

          his_self.game.queue.splice(qe, 1);
	  his_self.updateLog("Ottoman Empire plays "+his_self.popup('001'));

	  if (mv[1]) {
	    if (mv[1] === "naval") {
	      his_self.game.queue.push("add_naval_battle_bonus_rolls\tottoman\t4");
	      return 1;
	    }
	  }
	  his_self.game.queue.push("add_field_battle_bonus_rolls\tottoman\t5\tjanissaries");

	  return 1;
        }

	return 1;

      },
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

        if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

          //
          // add 4 regulars in Ottoman space
          //
          his_self.playerSelectSpaceWithFilter(
                
            "Add 4 regulars in Ottoman Home Space or Foreign War",
                
            function(space) {
              if (space.home == "ottoman") { return 1; }
              if (space.key === "algiers") { return 0; }
              if (space.neighbours.length == 0) { return 1; }
	      return 0;
            },

	    function(spacekey) {
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.endTurn();
	    },

	    null,

	    true

	  );

        }

	return 0;
      },

    }
    deck['002'] = { 
      img : "cards/HIS-002.svg" , 
      name : "Holy Roman Emperor" ,
      ops : 5 ,
      turn : 1 , 
      type : "normal" ,
      faction : "hapsburg" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let ck = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	let ck_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "charles-v", ck);
	if (ck_idx == -1) { return 0; }
        if (his_self.isBesieged("hapsburg", "charles-v")) { return 0; }
        if (his_self.isCaptured("hapsburg", "charles-v")) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let ck = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	let ak = his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva");
	let ck_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "charles-v", ck);
	let ak_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "duke-of-alva", ak);

	if (ck_idx === -1) {
	  his_self.updateLog("Skipping Holy Roman Emperor - Charles V not on board");
	  return 1;
	}

	if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {	

        his_self.playerSelectSpaceWithFilter(

	  "Select Destination for Charles V: ",

	  function(space) {
		if (
		  space.home === "hapsburg" &&
		  his_self.isSpaceControlled(space, "hapsburg")
	        ) {
		  return 1;
	        }
		return 0;
	  },

	  function(spacekey) {

		if (ak === ck && ak !== "") {

		  let msg = "Move Duke of Alva with Charles V?";
    		  let html = '<ul>';
        	  html += '<li class="option" id="yes">yes</li>';
        	  html += '<li class="option" id="no">no</li>';
    		  html += '</ul>';

    		  his_self.updateStatusWithOptions(msg, html);

	          $('.option').off();
	          $('.option').on('click', function () {

	            let action = $(this).attr("id");
		    his_self.updateStatus("moving...");
		    if (action === "yes") {
		      his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		      if (ck_idx > ak_idx) {
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		      } else {
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		      }
		      his_self.endTurn();
		    } else {
		      his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		      his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		      his_self.endTurn();
		    }
		  });

		} else {
		  his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		  his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		  his_self.endTurn();
		}

	  },

	  null,

	  true 
	);
	} else {
	  his_self.updateStatus("Hapsburgs playing Home Card");
	}

        return 0;
      },
    }
    deck['003'] = { 
      img : "cards/HIS-003.svg" , 
      name : "Six Wives of Henry VIII" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "england" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("six-wives-of-henry-viii\t"+faction);
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "six-wives-of-henry-viii") {

	    let faction = mv[1];
            his_self.game.queue.splice(qe, 1);


	    let target_haps = false;
	    let target_france = false;
	    let target_scotland = false;

	    let options1 = false;
	    let options2 = false;

	    if (!his_self.areAllies("england", "hapsburg") && !his_self.areEnemies("england", "hapsburg")) { target_haps = true; }
	    if (!his_self.areAllies("england", "scotland") && !his_self.areEnemies("england", "scotland")) { target_scotland = true; }
	    if (!his_self.areAllies("england", "france") && !his_self.areEnemies("england", "france")) { target_france = true; }

	    if (target_haps || target_france || target_scotland) {
	      options1 = true;
	    }

	    if (his_self.game.state.round >= 2 && his_self.game.state.leaders.henry_viii == 1) {
	      if (!his_self.isCaptured("england", "henry_viii") && !his_self.isBesieged("hapsburg", "charles-v")) {
	        options2 = true;
	      }
	    }
	  
	    if (options1 && options2) {

	      if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {

                let msg = "Choose an Option: ";
                let html = '<ul>';
                html += `<li class="option" id="war">Declare War</li>`;
                html += `<li class="option" id="marital">Advance Marital Status</li>`;
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {
		
                  let action2 = $(this).attr("id");
	          his_self.updateStatus("submitting...");

	          if (action2 === "war") {
	    	    his_self.addMove("henry_viii_declaration_of_war");
		    his_self.endTurn();
	          }
	          if (action2 === "marital") {
	  	    his_self.addMove("advance_henry_viii_marital_status");
		    his_self.endTurn();
	          }
	        });

	        return 0;

              }
            } 

	    if (options1) {
	      his_self.game.queue.push("henry_viii_declaration_of_war");
	      return 1;
	    }

	    if (options2) {
	      his_self.game.queue.push("advance_henry_viii_marital_status");
	      return 1;
	    }

	  return 0;
        }

	if (mv[0] === "henry_viii_declaration_of_war") {

	  let target_haps = false;
	  let target_france = false;
	  let target_scotland = false;

	  let options1 = false;
	  let options2 = false;

	  if (!his_self.areAllies("england", "hapsburg") && !his_self.areEnemies("england", "hapsburg")) { target_haps = true; }
	  if (!his_self.areAllies("england", "scotland") && !his_self.areEnemies("england", "scotland")) { target_scotland = true; }
	  if (!his_self.areAllies("england", "france") && !his_self.areEnemies("england", "france")) { target_france = true; }

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {

            let msg = "Declare War on Whom?";
            let html = '<ul>';
            if (target_haps) { html += `<li class="option" id="hapsburg">Hapsburg</li>`; }
            if (target_france) { html += `<li class="option" id="france">France</li>`; }
            if (target_scotland) { html += `<li class="option" id="scotland">Scotland</li>`; }
	    html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {
		
              let action2 = $(this).attr("id");
	      his_self.updateStatus("acknowledge");

	      his_self.addMove("ops\tengland\t003\t5");
	      if (action2 === "scotland" && !his_self.areEnemies("england","france")) {
	        his_self.addMove("natural_ally_intervention\tfrance\tscotland\tengland\t0\tEngland declares war on Scotland");
	      }	
	      his_self.addMove("unexpected_war\tengland\t"+action2);
	      his_self.addMove("declare_war\tengland\t"+action2+"\t1"); // 1 = skip natural ally intervention
	      his_self.endTurn();

	    });

	  }

          his_self.game.queue.splice(qe, 1);

	  return 0;

	}

        if (mv[0] === "advance_henry_viii_marital_status") {

          his_self.game.queue.splice(qe, 1);

	  //
	  // Henry VIII already dead, cannot roll
	  //
	  if (his_self.game.state.leaders.mary_i == 1 || his_self.game.state.leaders.edward_vi == 1 || his_self.game.state.leaders_elizabeth_i) {
	    return 1;
	  }

	  his_self.game.state.henry_viii_marital_status++;

	  if (his_self.game.state.henry_viii_marital_status == 1) {
	    his_self.updateLog("Henry VIII requests a divorce...");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 2) {
	    his_self.updateLog("Henry VIII marries Anne Boleyn");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 3) {
	    his_self.updateLog("Henry VIII marries Jane Seymour");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 4) {
	    his_self.updateLog("Henry VIII marries Anne of Cleves");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 5) {
	    his_self.updateLog("Henry VIII marries Kathryn Howard");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 6) {
	    his_self.updateLog("Henry VIII marries Katherine Parr");
	  }


	  his_self.updateLog("Henry VIII marital status now: " + his_self.game.state.henry_viii_marital_status);

	  if (his_self.game.state.henry_viii_marital_status > 7) { his_self.game.state.henry_viii_marital_status = 7; return 1; }

	  if (his_self.game.state.henry_viii_marital_status > 2) {
	    his_self.updateStatus("Henry VIII makes a roll on the pregnancy chart");
	    let dd = his_self.rollDice(6);

	    if (his_self.game.state.henry_viii_rolls.includes(dd)) {
	      while (his_self.game.state.henry_viii_rolls.includes(dd) && dd < 6) {
	        dd++;
	      }
	    }
	    his_self.game.state.henry_viii_rolls.push(dd);

	    if (his_self.game.state.henry_viii_marital_status == 3) { 
	      his_self.updateLog("Henry VIII receives +1 bonus for Jane Seymour");
	      dd++;
	    }

	    his_self.updateLog("Henry VIII rolls: " + dd);

	    // results of pregnancy chart rolls
	    if (dd == 1) {
	      his_self.updateLog("Henry VIII rolls 1: marriage fails");
	    }
	    if (dd == 2) {
	      his_self.updateLog("Henry VIII rolls 2: marriage barren");
	    }
	    if (dd == 3) {
	      his_self.updateLog("Henry VIII rolls 3: wife beheaded - reroll");
	      his_self.game.state.henry_viii_auto_reroll = 1;
	    }
	    if (dd == 4) {
	      his_self.updateLog("Henry VIII rolls 4: Elizabeth I born");
	      his_self.game.state.henry_viii_add_elizabeth = 1;
	    }
	    if (dd == 5) {
	      his_self.updateLog("Henry VIII rolls 5: sickly Edward VI");
	      his_self.game.state.henry_viii_sickly_edward = 1;
	      his_self.game.state.henry_viii_add_elizabeth = 0;
	    }
	    if (dd >= 6) {
	      his_self.updateLog("Henry VIII rolls 6: healthy Edward VI");
	      his_self.game.state.henry_viii_healthy_edward = 1;
	      his_self.game.state.henry_viii_sickly_edward = 0;
	      his_self.game.state.henry_viii_add_elizabeth = 0;
	    }

	  }

	  return 1;
	}

	return 1;
      },

    }
    deck['004'] = { 
      img : "cards/HIS-004.svg" , 
      name : "Patron of the Arts" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "france" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.leaders.francis_i == 1) {
	  if (his_self.isCaptured("france", "francis-i")) { return 0; }
	  if (his_self.isBesieged("france", "francis-i")) { return 0; }
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("patron-of-the-arts\t"+faction);
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "patron-of-the-arts") {
	  let faction = mv[1];
          his_self.game.queue.splice(qe, 1);
	  his_self.chateaux_overlay.render(faction);
          return 1;
        }

	return 1;
      },
    }
    if (this.game.players.length > 2) {
      deck['005'] = { 
        img : "cards/HIS-005.svg" , 
        name : "Papal Bull" ,
        ops : 4 ,
        turn : 1 ,
        type : "normal" ,
        faction : "papacy" ,
        removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
        canEvent : function(his_self, faction) {
	  return 1;
        },
        onEvent : function(his_self, faction) {

	  let do_grounds_for_excommunication_exist = [];
	  let papacy = his_self.returnPlayerOfFaction("papacy");
	  if (his_self.canPapacyExcommunicateFaction("france")) { do_grounds_for_excommunication_exist.push("france"); }
	  if (his_self.canPapacyExcommunicateFaction("england")) { do_grounds_for_excommunication_exist.push("england"); }
	  if (his_self.canPapacyExcommunicateFaction("hapsburg")) { do_grounds_for_excommunication_exist.push("hapsburg"); }

	  //
	  // both options call this function
	  //
	  let excommunicate_leader_subfunction = () => {

	    if (papacy == his_self.game.player) {

              let msg = "Excommunicate Which Leader?";
              let html = '<ul>';
	      for (let z = 0; z < do_grounds_for_excommunication_exist.length; z++) {
                html += `<li class="option" id="${do_grounds_for_excommunication_exist[z]}">${his_self.returnFactionName(do_grounds_for_excommunication_exist[z])}</li>`;
	      }
	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let action2 = $(this).attr("id");
		his_self.updateStatus("clerics processing excommunication...");
	        his_self.addMove("excommunicate_faction\t"+action2);
	        his_self.endTurn();

	      });
	    } else {
	      his_self.updateStatus("Papacy Excommunicating Heretic");
	    }
	  };

	  let excommunicate_reformer_subfunction = () => {

	    if (papacy == his_self.game.player) {

              let msg = "Excommunicate Protestant Reformer:";
	      let reformer_exists = 0;
              let html = '<ul>';
	      for (let key in his_self.reformers) {
	        let s = his_self.returnSpaceOfPersonage("protestant", key);
	        if (s) {
	  	  if (!his_self.game.state.already_excommunicated.includes(key)) {
	            reformer_exists = 1;
                    html += `<li class="option" id="${key}">${his_self.reformers[key].name}</li>`;
	          }
	        }
	      }
	
	      if (reformer_exists == 0) {

                let msg = "Convene Theological Debate?";
                let html = '<ul>';
                html += `<li class="option" id="yes">yes</li>`;
                html += `<li class="option" id="no">no</li>`;
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {

                  let action2 = $(this).attr("id");
	          his_self.updateStatus("convening debate...");

		  if (action2 === "yes") {
		    his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
		    return;
		  }

		  // no
	          his_self.updateLog("No excommunicable Protestant reformers exist");
	          his_self.endTurn();
		  return 0;

	        });

	        return 0;
	      }

	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);
  
              $('.option').off();
              $('.option').on('click', function () {

                let selected_reformer = $(this).attr("id");

	        if (selected_reformer === "cranmer-reformer") {
	  	  his_self.addEndMove("counter_or_acknowledge\tPapal Bull announces excommunication of Cranmer\tpapal_bull_cranmer_excommunication");
		  his_self.addEndMove("RESETCONFIRMSNEEDED\tall");
	        }
	        his_self.addEndMove("excommunicate_reformer\t"+selected_reformer);

                let msg = "Convene Theological Debate after Excommunication?";
                let html = '<ul>';
                html += `<li class="option" id="yes">yes</li>`;
                html += `<li class="option" id="no">no</li>`;
	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {
		
	          his_self.updateStatus("convening...");
                  let action2 = $(this).attr("id");

		  if (action2 === "yes") {
	            his_self.addMove("excommunicate_reformer\t"+selected_reformer);
	            his_self.addMove("player_call_theological_debate\tpapacy");
		    his_self.endTurn();
		    return;
		  }

		  // no
	          his_self.updateLog("No excommunicable Protestant reformers exist");
	          his_self.endTurn();
		  return;

	        });

	      });
            } else {
	      his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	    }
	  };


	  if (papacy == his_self.game.player) {

            let msg = "Excommunicate Heretic?";
            let html = '<ul>';
                html += `<li class="option" id="reformer">Protestant Reformer</li>`;
	        if (do_grounds_for_excommunication_exist.length > 0) {
                  html += `<li class="option" id="leader">Unfaithful Monarch</li>`;
	        }
		html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action2 = $(this).attr("id");
	      if (action2 == "reformer") {
	        excommunicate_reformer_subfunction();
	      } else {
	        excommunicate_leader_subfunction();
    	      }
	    });
	  } else {
	    his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	  }

	  return 0;
	},
      }
    } else {
      deck['005'] = { 
        img : "cards/HIS-005-2P.svg" , 
        name : "Papal Bull" ,
        ops : 4 ,
        turn : 1 ,
        type : "normal" , 
        faction : "papacy" ,
        removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
        canEvent : function(his_self, faction) {
	  return 1;
        },
        onEvent : function(his_self, faction) {

	  let papacy = his_self.returnPlayerOfFaction("papacy");
	  if (papacy == his_self.game.player) {

            let msg = "Excommunicate Protestant Reformer:";
	    let reformer_exists = 0;
            let html = '<ul>';
	    for (let key in his_self.reformers) {
	      let s = his_self.returnSpaceOfPersonage("protestant", key);
	      if (s) {
		if (!his_self.game.state.already_excommunicated.includes(key)) {
	          reformer_exists = 1;
                  html += `<li class="option" id="${key}">${his_self.reformers[key].name}</li>`;
	        }
	      }
	    }
	
	    if (reformer_exists == 0) {

              let msg = "Convene Theological Debate?";
              let html = '<ul>';
              html += `<li class="option" id="yes">yes</li>`;
              html += `<li class="option" id="no">no</li>`;
	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let action2 = $(this).attr("id");
	        his_self.updateStatus("submitting...");

		if (action2 === "yes") {
		  his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
		  return;
		}

		// no
	        his_self.updateLog("No excommunicable Protestant reformers exist");
	        his_self.endTurn();
		return 0;

	      });

	      return 0;
	    }

	    html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);
  
            $('.option').off();
            $('.option').on('click', function () {

              let selected_reformer = $(this).attr("id");

	      if (selected_reformer === "cranmer-reformer") {
		his_self.addEndMove("counter_or_acknowledge\tPapal Bull announces excommunication of Cranmer\tpapal_bull_cranmer_excommunication");
		his_self.addEndMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.addEndMove("excommunicate_reformer\t"+selected_reformer);

              let msg = "Convene Theological Debate after Excommunication?";
              let html = '<ul>';
              html += `<li class="option" id="yes">yes</li>`;
              html += `<li class="option" id="no">no</li>`;
	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {
		
	        his_self.updateStatus("convening...");
                let action2 = $(this).attr("id");

		if (action2 === "yes") {
	          his_self.addMove("excommunicate_reformer\t"+selected_reformer);
	          his_self.addMove("player_call_theological_debate\tpapacy");
		  his_self.endTurn();
		  return;
		}

		// no
	        his_self.updateLog("No excommunicable Protestant reformers exist");
	        his_self.endTurn();
		return;

	      });

	    });

	    return 0;

          } else {
	    his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	  }

	  return 0;
	},
      }
    }
    deck['006'] = { 
      img : "cards/HIS-006.svg" , 
      name : "Leipzig Debate" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" , 
      faction : "papacy" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

        his_self.game.state.tmp_papacy_may_specify_debater = 1;
        his_self.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 1;

	if (his_self.game.player === p) {

          let msg = "Select Language Zone for Theological Debate:";
          let html = '<ul>';

          if (his_self.returnDebatersInLanguageZone("german", "protestant")) { 
            html += '<li class="option" style="" id="german">German</li>';
          }
          if (his_self.returnDebatersInLanguageZone("french", "france")) { 
            html += '<li class="option" style="" id="french">French</li>';
          }
          if (his_self.returnDebatersInLanguageZone("english", "france")) { 
            html += '<li class="option" style="" id="english">English</li>';
          }
          html += '</ul>';

	  //
  	  // show visual language zone selector
  	  //
  	  his_self.language_zone_overlay.render("catholic_counter_reformation");

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let language_zone = $(this).attr("id");

            let msg = "Target Committed or Uncommitted Protestant?";
            let html = '<ul>';
            if (1 <= his_self.returnDebatersInLanguageZone(language_zone, "protestant", 0)) {
              html += '<li class="option" id="uncommitted">Uncommitted</li>';
            }
            if (1 <= his_self.returnDebatersInLanguageZone(language_zone, "protestant", 1)) {
              html += '<li class="option" id="committed">Committed</li>';
            }
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let is_committed = $(this).attr("id");
	      if (is_committed == "uncommitted") { is_committed = 0; } else { is_committed = 1; }

              let msg = "Leigzip Debate Format?";
              let html = '<ul>';
              html += '<li class="option" id="select">Pick My Debater</li>';
	      // or prohibit uncommitted debaters
              if (is_committed == 0 && 1 < his_self.returnDebatersInLanguageZone(language_zone, "protestant", is_committed)) {
                html += '<li class="option" id="prohibit">Prohibit Protestant Debater</li>';
              }
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
  
              $('.option').off();
              $('.option').on('click', function () {

                let opt = $(this).attr("id");

	        if (opt === "select") {

                  let msg = "Select Uncommitted Papal Debater:";
                  let html = '<ul>';
		  for (let i = 0; i < his_self.game.state.debaters.length; i++) {
		    let d = his_self.game.state.debaters[i];
		    if (d.faction === "papacy" && d.committed === 0) {
            	      html += `<li class="option" id="${d.type}">${d.name}</li>`;
		    }
		  }
		  html += '</ul>';
                  his_self.updateStatusWithOptions(msg, html);
  
                  $('.option').off();
                  $('.option').on('mouseover', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.show(action2);
                    }
                  });
                  $('.option').on('mouseout', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.hide(action2);
                    }
                  });
                  $('.option').on('click', function () {
                    his_self.language_zone_overlay.hide();
                    let selected_papal_debater = $(this).attr("id");
	            his_self.addMove("theological_debate");
        	    his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t" + language_zone);
        	    his_self.addMove("RESETCONFIRMSNEEDED\tall");
	            if (is_committed == 0) {
		      his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"uncommitted\t" + selected_papal_debater);
	            } else { 
		      his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"committed\t" + selected_papal_debater);
		    }
		    his_self.endTurn();
		  });
	
	        } else {

                  let msg = "Prohibit Protestant Debater:";
                  let html = '<ul>';
		  for (let i = 0; i < his_self.game.state.debaters.length; i++) {
		    let d = his_self.game.state.debaters[i];
		    if (d.faction !== "papacy" && d.language_zone === language_zone && d.committed == is_committed) {
            	      html += `<li class="option" id="${i}">${d.name}</li>`;
		    }
		  }
		  html += '</ul>';
                  his_self.updateStatusWithOptions(msg, html);
  
                  $('.option').off();
                  $('.option').on('mouseover', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.show(action2);
                    }
                  });
                  $('.option').on('mouseout', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.hide(action2);
                    }
                  });
                  $('.option').on('click', function () {
                    his_self.language_zone_overlay.hide();
                    let selected_idx = parseInt($(this).attr("id"));
		    let prohibited_protestant_debater = his_self.game.state.debaters[selected_idx].type;
	            his_self.addMove("theological_debate");
        	    his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t" + language_zone);
        	    his_self.addMove("RESETCONFIRMSNEEDED\tall");
	 	    if (is_committed == 0) {
	              his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"uncommitted\t\t"+prohibited_protestant_debater);
		    } else {
	              his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"committed\t\t"+prohibited_protestant_debater);
		    }
		    his_self.endTurn();
		  });
	
	        }

	      });
	    });
	  });

	} else {
	  his_self.updateStatus("Papacy calling Theological Debate");
	}

	return 0;
      },

    }

    deck['007'] = { 
      img : "cards/HIS-007.svg" , 
      name : "Here I Stand" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "protestant" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
       
	let cards_available = 0;
        for (let key in his_self.game.deck[0].discards) { cards_available++; }
        if (cards_available == 0) { return 0; }

	if (his_self.game.state.leaders.luther == 1) { return 1; }
	if (Object.keys(his_self.game.deck[0].discards).length > 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player === p) {

	  let msg = "Retrieve Card from Discard Pile: ";
          let html = '<ul>';
	  for (let key in his_self.game.deck[0].discards) {
	    if (parseInt(key) > 9) {
              html += `<li class="option" id="${key}">${his_self.game.deck[0].cards[key].name}</li>`;
	    }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
          $('.option').on('mouseover', function() {
            let action2 = $(this).attr("id");
            his_self.cardbox.show(action2);
          });
          $('.option').on('mouseout', function() {
            let action2 = $(this).attr("id");
            his_self.cardbox.hide(action2);
          });
	  $('.option').on('click', function () {

	    $('.option').off();
	    let card = $(this).attr("id");

	    let msg = "Play or Hold Card? ";
            let html = '<ul>';
            html += '<li class="option" id="play">play card</li>';
            html += '<li class="option" id="hold">hold card</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action == "play") {

		his_self.addMove("card\tprotestant\t"+card);
		his_self.addMove("discard\tprotestant\t007");
		his_self.addMove("NOTIFY\tProtestants retrieve "+his_self.popup(card));
		his_self.endTurn();

	      } else {

		his_self.addMove("discard\tprotestant\t007");
    		his_self.addMove("cards_left\tprotestant\t"+(parseInt(his_self.game.state.cards_left["protestant"])+1));
		his_self.addMove("NOTIFY\tProtestants retrieve "+his_self.popup(card));
		his_self.addMove("here_i_stand_event\t"+card);
		his_self.endTurn();

	      }

	    });
	  });
	} else {
	  his_self.updateStatus("Protestants retrieving card: " + his_self.popup("007"));
	}

	return 0;
      },
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu === "debate") {
	  if (extra === "german") {
            return { faction : "protestant" , event : '007', html : `<li class="option" id="007">Here I Stand (assign Luther)</li>` };
	  }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "debate") {
	  if (extra === "german") {
	    // Wartburg stops Luther
	    if (his_self.game.state.events.wartburg == 1) { 
	      return 0;
	    }
	    if (his_self.game.state.leaders.luther == 1) {
	      if (his_self.game.state.theological_debate) {
		if (his_self.game.state.theological_debate.round1_attacker_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round1_defender_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round2_attacker_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round2_defender_debater == "luther-debater") { return 0; }
	        if (player === his_self.returnPlayerOfFaction("protestant")) {
	          if (his_self.canPlayerPlayCard("protestant", "007")) {
		    return 1;
		  } else {
		  }
	        }
	      }
	    }
	  }
	}
	return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "debate") {
	  his_self.addMove("discard\tprotestant\t007");
	  his_self.addMove("NOTIFY\t"+his_self.popup("007") + ": Luther enters Theological Debate");
	  his_self.addMove("here_i_stand_response");
	  his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "here_i_stand_event") {

          his_self.game.queue.splice(qe, 1);

	  //
	  // first option not implemented
	  //
          let card = mv[1];

	  if (his_self.game.deck[0].discards[card]) {

	    let p = his_self.returnPlayerOfFaction("protestant");

	    //
	    // player returns to hand
	    //
	    if (his_self.game.player === p) {
              let fhand_idx = his_self.returnFactionHandIdx(p, "protestant");
	      his_self.game.deck[0].fhand[fhand_idx].push(card);
	    }

	    //
	    // everyone removes from discards
	    //
	    delete his_self.game.deck[0].discards[card];

	  }

	  return 1;
	}

        if (mv[0] === "here_i_stand_response") {

          his_self.game.queue.splice(qe, 1);

	  his_self.updateLog("Protestants trigger " + his_self.popup("007"));
	  his_self.game.queue.push("ACKNOWLEDGE\tProtestants swap Martin Luther into debate");

	  //
	  // second option -- only possible if Wartburg not in-play
	  //
	  if (his_self.game.state.events.wartburg == 0) {

	    //
	    // existing protestant debater is committed, but de-activated (bonus does not apply)
	    //
	    for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	      let d = his_self.game.state.debaters[i];
	      if (his_self.game.state.theological_debate.attacker === "papacy") {
	        if (his_self.game.state.theological_debate.round == 1) {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round1_defender_debater) {
	  	    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        } else {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round2_defender_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        }
	      } else {
	        if (his_self.game.state.theological_debate.round == 1) {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round1_attacker_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        } else {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round2_attacker_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        }
	      }
	    }

	    let is_luther_committed = 0;
	    for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	      if (his_self.game.state.debaters[i].key === "luther-debater") {
		if (his_self.game.state.debaters[i].committed == 1) { is_luther_committed = 1; }
	      }
	    }
	    for (let i = 0; i < his_self.game.state.excommunicated.length; i++) {
	      if (his_self.game.state.excommunicated[i].debater) {
	        if (his_self.game.state.excommunicated[i].debater.type === "luther-debater") {
		  if (his_self.game.state.excommunicated[i].committed == 1) { is_luther_committed = 1; }
	        }
	      }
	    }

	    if (his_self.game.state.theological_debate.attacker === "papacy") {
	      if (his_self.game.state.theological_debate.round == 1) {
                his_self.game.state.theological_debate.round1_defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater_power = 4;
                his_self.game.state.theological_debate.defender_debater_bonus = 1;
		if (is_luther_committed == 0) {
                  his_self.game.state.theological_debate.defender_debater_bonus++;
		}
	      } else {
                his_self.game.state.theological_debate.round2_defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater_power = 4;
                his_self.game.state.theological_debate.defender_debater_bonus = 1;
		if (is_luther_committed == 0) {
                  his_self.game.state.theological_debate.defender_debater_bonus++;
		}
	      }
	    } else {
	      if (his_self.game.state.theological_debate.round == 1) {
                his_self.game.state.theological_debate.round1_attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater_power = 4;
                his_self.game.state.theological_debate.attacker_debater_bonus = 3;
	      } else {
                his_self.game.state.theological_debate.round2_attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater_power = 4;
                his_self.game.state.theological_debate.attacker_debater_bonus = 3;
	      }
	    }
	  }

	  // re-render debate overlay with luther there
          his_self.debate_overlay.render(his_self.game.state.theological_debate);
          his_self.displayTheologicalDebater(his_self.game.state.theological_debate.attacker_debater, true);
          his_self.displayTheologicalDebater(his_self.game.state.theological_debate.defender_debater, false);

	  return 1;

        }

	return 1;
      },
    }
    // 95 Theses
    deck['008'] = { 
      img : "cards/HIS-008.svg" , 
      name : "Luther's 95 Theses" ,
      ops : 0 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.factionbar.setActive("protestant");

	// set player to protestant
	player = his_self.returnPlayerOfFaction("protestant");

	let players_to_go = [];
	for (let i = 1; i < his_self.game.players.length; i++) {
	  if (i != his_self.returnPlayerOfFaction("protestant")) {
	    players_to_go.push(i);
	  }
	}

	// protestant gets 2 roll bonus at start
	his_self.game.state.tmp_protestant_reformation_bonus = 1;
	his_self.game.state.tmp_protestant_reformation_bonus_spaces = [];
	his_self.game.state.tmp_catholic_reformation_bonus = 0;
	his_self.game.state.tmp_catholic_reformation_bonus_spaces = [];
	his_self.game.state.tmp_reformations_this_turn = [];
	his_self.game.state.wittenberg_electoral_bonus = 1;

	his_self.game.queue.push("hide_overlay\ttheses");
        his_self.game.queue.push("ACKNOWLEDGE\tThe Reformation has begun!");
	his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("STATUS\tProtestants selecting reformation targets...\t"+JSON.stringify(players_to_go));
	his_self.game.queue.push("show_overlay\ttheses");
        his_self.convertSpace("protestant", "wittenberg");
        his_self.convertSpace("protestant", "wittenberg");
        his_self.addUnit("protestant", "wittenberg", "regular");
        his_self.addUnit("protestant", "wittenberg", "regular");
        his_self.addReformer("protestant", "wittenberg", "luther-reformer");
        his_self.displaySpace("wittenberg");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "catholic_counter_reformation") {

	  his_self.updateStatus("Catholic Counter-Reformation...");

          let player = parseInt(mv[1]);
          if (his_self.returnPlayerOfFaction(mv[1])) { player = his_self.returnPlayerOfFaction(mv[1]); }
          let language_zone = "german";
	  if (mv[2]) { language_zone = mv[2]; }
	  let spillover = 0;
	  if (mv[3]) { spillover = parseInt(mv[3]); } // allow reformation outside target area

	  his_self.game.queue.splice(qe, 1);

	  let target_spaces = his_self.countSpacesWithFilter(
	    function(space) {
	      if (
	        space.religion === "protestant" &&
	        ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
	        !his_self.game.state.tmp_counter_reformations_this_turn.includes(space.key) &&
	        ( 
		  his_self.isSpaceAdjacentToReligion(space, "catholic")
		  ||
		  space.university == 1
	        )
	      ) {
	        return 1;
	      }
	      return 0;
	    }
	  );

	  //
	  // no valid reformation targets
	  //
	  if (target_spaces == 0) {
	    his_self.updateStatus("No valid counter-reformation targets"); 
	    his_self.updateLog("No valid counter-reformation targets"); 
	    his_self.game.queue.splice(qe, 1);
	    return 1;
	  }


	  if (his_self.game.player == player) {
	    if (target_spaces > 0) {

	    if (language_zone != "all" && language_zone != "") {
	      his_self.theses_overlay.render(language_zone);
	    } else {
	      his_self.theses_overlay.render();
	    }

            his_self.playerSelectSpaceWithFilter(

	      "Select Counter-Reformation Attempt",

	      //
	      // protestant spaces adjacent to catholic 
	      //
	      function(space) {
		if (
		  space.religion === "protestant" &&
		  ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
		  !his_self.game.state.tmp_counter_reformations_this_turn.includes(space.key) &&
		  his_self.isSpaceAdjacentToReligion(space, "catholic")
	        ) {
		  return 1;
	        }
		return 0;
	      },

	      //
	      // launch counter_reformation
	      //
	      function(spacekey) {
	  	his_self.updateStatus("Counter-Reformation attempt: "+his_self.returnSpaceName(spacekey));
		his_self.addMove("counter_reformation\t"+spacekey+"\t"+language_zone);
		let name = his_self.game.spaces[spacekey].name;
		his_self.addMove("counter_or_acknowledge\tCounter-Reformation Attempt: "+his_self.returnSpaceName(spacekey)+"\tcatholic_counter_reformation\t"+name);
                his_self.addMove("RESETCONFIRMSNEEDED\tall");
		his_self.endTurn();
	      },

	      null, // cancel func

	      1     // permit board clicks

	    );
	    } else {
	      his_self.addMove("counter_or_acknowledge\tCatholic Counter-Reformation - no valid targets");
              his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      his_self.endTurn();
	    }
	  } else {
	    his_self.updateStatus("Catholic Counter-Reformation in Process");
	  }

          return 0;

        }

        if (mv[0] == "protestant_reformation") {

	  his_self.updateStatus("Protestant Reformation...");

          let player = parseInt(mv[1]);
          if (his_self.returnPlayerOfFaction(mv[1])) { player = his_self.returnPlayerOfFaction(mv[1]); }
          let language_zone = "german";
	  if (mv[2]) { language_zone = mv[2]; }
	  let spillover = 0;
	  if (mv[3]) { spillover = parseInt(mv[3]); } // allow reformation outside target area

	  his_self.game.queue.splice(qe, 1);

	  let target_spaces = his_self.countSpacesWithFilter(
	    function(space) {
	      if (
		space.religion == "catholic" &&
		!his_self.game.state.tmp_reformations_this_turn.includes(space.key) &&
		((spillover == 1 || space.language == language_zone) || language_zone == "all") &&
		(
			his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
			||
			his_self.isSpaceAdjacentToReligion(space, "protestant")
			||
			his_self.doesSpaceContainProtestantReformer(space)
			||
			his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
		)
	      ) {
	        return 1;
	      }
	      return 0;
	    }
	  );

	  //
	  // no valid reformation targets
	  //
	  if (target_spaces == 0) {
	    his_self.updateStatus("No valid reformation targets"); 
	    his_self.updateLog("No valid reformation targets"); 
	    his_self.game.queue.splice(qe, 1);
	    return 1;
	  }

	  if (his_self.game.player == player) {
	    if (target_spaces > 0) {

	      if (language_zone != "all" && language_zone != "") {
	        his_self.theses_overlay.render(language_zone);
	      } else {
	        his_self.theses_overlay.render();
	      }

              his_self.playerSelectSpaceWithFilter(

	        "Select Reformation Target",

	        //
	        // catholic spaces adjacent to protestant 
	        //
	        function(space) {
	  	  if (
		    space.religion === "catholic" &&
		    !his_self.game.state.tmp_reformations_this_turn.includes(space.key) &&
		    ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
		    (
			his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
			||
			his_self.isSpaceAdjacentToReligion(space, "protestant")
			||
			his_self.doesSpaceContainProtestantReformer(space)
			||
			his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
		    )
	          ) {
		    return 1;
	          }
		  return 0;
	        },

	        //
	        // launch reformation
	        //
	        function(spacekey) {
	  	  his_self.addMove("reformation\t"+spacekey+"\t"+language_zone);
		  his_self.addMove("counter_or_acknowledge\tProtestant Reformation Attempt in "+his_self.returnSpaceName(spacekey)+"\tprotestant_reformation\t"+spacekey);
        	  his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  	  his_self.updateStatus("Reformation attempt in "+his_self.returnSpaceName(spacekey));
		  his_self.endTurn();
	        },
	        null ,
	        1     // permit board clicks
	      );
	    } else {
	      his_self.addMove("counter_or_acknowledge\tProtestant Reformation - no valid targets");
              his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      his_self.updateStatus("No Valid Targets");
	      his_self.endTurn();
	    }
	  } else {
	    his_self.updateStatus("Protestant Reformation...");
	  }
          return 0;
        }
	return 1;
      }
    }
    deck['009'] = { 
      img : "cards/HIS-009.svg" , 
      name : "Barbary Pirates" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Algiers is in play, the Ottomans may now build corsairs and engage in piracy!",
          title : "Barbary Pirates!",
          img : "/his/img/backgrounds/events/An_Action_between_an_English_Ship_and_Vessels_of_the_Barbary_Corsairs.jpg",
	  msg : "Barbary Pirates in Play...",
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	// algiers space is now in play
	his_self.game.spaces['algiers'].home = "ottoman";
	his_self.game.spaces['algiers'].political = "ottoman";
	his_self.game.spaces['algiers'].pirate_haven = 1;
	his_self.addRegular("ottoman", "algiers", 2);
	his_self.addCorsair("ottoman", "algiers", 2);
	his_self.game.state.events.barbary_pirates = 1;
	his_self.game.state.events.ottoman_piracy_enabled = 1;
	his_self.game.state.events.ottoman_corsairs_enabled = 1;

	return 1;
      },

    }
    deck['010'] = { 
      img : "cards/HIS-010.svg" , 
      name : "Clement VII" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Leo X is replaced by Clement VII. Papacy may now hold a card between turns.",
          title : "Accession of Clement VII",
          img : "/his/img/backgrounds/events/clement-vii.png",
	  msg : "Clement VII becomes Pope...",
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.clement_vii = 1;
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 1;
	return 1;
      },
    }
    deck['011'] = { 
      img : "cards/HIS-011.svg" , 
      name : "Defender of the Faith" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let papacy = his_self.returnPlayerOfFaction("papacy");

	if (faction === "england") {
	  let faction_hand_idx = his_self.returnFactionHandIdx(player, "england");   
 	  his_self.game.queue.push("hand_to_fhand\t1\t"+(player)+"\t"+his_self.game.state.players_info[player-1].factions[faction_hand_idx]+"\t1");
	  his_self.game.queue.push(`DEAL\t1\t${player}\t1`);
        }
	// three counter-reformation attempts
	his_self.game.queue.push(`hide_overlay\tburn_books`);
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['012'] = { 
      img : "cards/HIS-012.svg" , 
      name : "Master of Italy" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 

	let keys = ["genoa","milan", "venice", "florence", "naples"];
	let f = {};

	for (let key in keys) {
	  let fac = his_self.returnFactionControllingSpace(keys[key]);
	  let owner = his_self.returnAllyOfMinorPower(fac);
	  if (!f[owner]) { f[owner] = 1; }
	  else { f[owner]++; }
	}

	for (let key in f) {
	  if (f[key] >= 4) {
	    return 1;
	  }
	  if (f[key] == 3) {
	    return 1;
	  }
	  if (f[key] == 2) {
	    return 1;
	  }
	}

	return 0;
      } ,
      onEvent : function(his_self, faction) {

        let keys = ["genoa","milan", "venice", "florence", "naples"];
        let f = {};
        for (let key in keys) {
          let fac = his_self.returnFactionControllingSpace(keys[key]);
          let owner = his_self.returnAllyOfMinorPower(fac);
          if (!f[owner]) { f[owner] = 1; }
          else { f[owner]++; }
        } 
        
        for (let key in f) {
          if (f[key] >= 4) {
	    his_self.gainVictoryPoints(faction, 3);
          }
          if (f[key] == 3) {
	    his_self.gainVictoryPoints(faction, 2);
          }
          if (f[key] == 2) {
	    let player = his_self.returnPlayerOfFaction(key);
 	    his_self.game.queue.push("hand_to_fhand\t1\t"+(player)+"\t"+key+"\t1");
	    his_self.game.queue.push(`DEAL\t1\t${player}\t1`);
          }
        }

	his_self.displayVictoryTrack();

	return 1;

      }
    }
    let sl_img = "cards/HIS-013.svg";
    if (this.game.players.length == 2) {
      sl_img = "cards/HIS-013-2P.svg";
    }
    deck['013'] = { 
      img : sl_img,
      name : "Schmalkaldic League" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	  if (his_self.game.state.round >= 2 && his_self.returnNumberOfProtestantSpacesInLanguageZone("all") >= 12) {
	    return 1; 
	  }
	  return 0;
      },
      onEvent : function(his_self, faction) {

        his_self.game.state.events.schmalkaldic_league_round = his_self.game.state.round;
        his_self.game.state.events.schmalkaldic_league = 1;
	his_self.schmalkaldic_overlay.render();
        his_self.setEnemies("protestant","papacy");
        his_self.setEnemies("protestant","hapsburg");
        his_self.setAllies("papacy","hapsburg");

	//
	// protestant home + political spaces
	//
	// skip keys are home for other factions
	let skip_keys = ["innsbruck","linz","vienna","graz","zurich","basel"];
	for (let key in his_self.game.spaces) {
	  s = his_self.game.spaces[key];
	  if (s.language == "german") { 
	    if (s.religion == "protestant") {
	      if (!s.fortified) {
	        s.political = "protestant";
	      }
	      if (!skip_keys.includes(key)) {
	 	s.home = "protestant";
	      }
	    }
	  }
	}
	for (let i = 0; i < his_self.game.state.activated_powers["protestant"].length; i++) {
	  if (his_self.game.state.activated_powers["protestant"][i] === "hapsburg") {
	    his_self.game.state.activated_powers["protestant"].splice(i, 1);
	    his_self.game.state.events.spanish_invasion = "";
	  }
	}

	//
	// John Frederick and Philip of Hesse
	//
	let jf_added = 0;
	if (his_self.isSpaceControlled("wittenberg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "wittenberg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "wittenberg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("brandenburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "brandenburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "brandenburg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("augsburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "augsburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "augsburg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("mainz", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "mainz") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "mainz", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("trier", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "trier") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "trier", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("cologne", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "cologne") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "cologne", "john-frederick");
	  jf_added = 1;
	}
	jf_added = 0;
	if (his_self.isSpaceControlled("mainz", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "mainz") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "mainz", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("cologne", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "cologne") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "cologne", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("trier", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "trier") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "trier", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("augsburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "augsburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "augsburg", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("brandenburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "brandenburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "brandenburg", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("wittenberg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "wittenberg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "wittenberg", "philip-hesse");
	  jf_added = 1;
	}

	//
	// move protestant regulars in catholic spaces to nearest protestant-controlled electorates
	//
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].political != "protestant") {
	    if (his_self.game.spaces[key].units["protestant"].length > 0) {
	      let already_routed_through = {};
    	      let res = his_self.returnNearestSpaceWithFilter(
				key ,
				function(spacekey) {
				  if (his_self.game.spaces[spacekey].type === "electorate" && his_self.game.spaces[spacekey].political === "protestant") { return 1; }
				  return 0;
				},
				function(spacekey) {
        			  if (already_routed_through[spacekey] == 1) { return 0; }
				  already_routed_through[spacekey] = 1;
				  return 1;
				},
				0, // transit passes (no need)
				0, // transit seas (no need)
				"protestant" ,
				0 // already crossed sea zone
	      );

	      for (let z = 0; z < his_self.game.spaces[key].units["protestant"].length; z++) {
    		let u = his_self.game.spaces[key].units["protestant"][z];
		if (u.type == "regular" || u.type == "mercenary" || u.army_leader == true) {
		  if (res.length > 0) {
		    his_self.game.spaces[res[0].key].units["protestant"].push(u);
		  }
    		  his_self.game.spaces[key].units["protestant"].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }
	}

	//
	// in 2P papacy now controls hapsburg
	//
	if (his_self.game.players.length == 2) {
          his_self.game.state.activated_powers["papacy"].push("hapsburg");
	}

	his_self.removeCardFromGame("013");

	his_self.displayBoard();
	return 1;

      }
    }
    deck['014'] = { 
      img : "cards/HIS-014.svg" , 
      name : "Paul III" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Clement VII is replaced by Paul III. Papacy now wins ties Counter-Reformation rolls.",
          title : "Accession of Paul III",
          img : "/his/img/backgrounds/events/paul-iii.jpg",
	  msg : "Paul III becomes Pope...",
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.events.paul_iii = 1;
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 0;
	his_self.removeCardFromGame('010'); // remove clement vii
	his_self.game.state.leaders.paul_iii = 1;
	return 1;
      },
    }
    deck['015'] = { 
      img : "cards/HIS-015.svg" , 
      name : "Society of Jesus" ,
      ops : 2 ,
      turn : 5 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.events.society_of_jesus = 1;
	let papacy = his_self.returnPlayerOfFaction("papacy");
	if (his_self.game.player === papacy) {
    	  his_self.playerSelectSpaceWithFilter(
      	    "Select Catholic-Controlled Space for First Jesuit University",
      	    function(space) {
              if (space.religion === "catholic" && space.university != 1) { return 1; }
              return 0; 
            },          
            function(destination_spacekey) {
	      his_self.game.spaces[destination_spacekey].university = 1;
	      his_self.displaySpace(destination_spacekey);
    	      his_self.playerSelectSpaceWithFilter(
      	        "Select Catholic-Controlled Space for Second Jesuit University",
       	        function(space) {
                  if (space.key != destination_spacekey && space.religion === "catholic" && space.university != 1) { return 1; }
                  return 0; 
                },
                function(second_spacekey) {
	          his_self.game.spaces[second_spacekey].university = 1;
	          his_self.displaySpace(second_spacekey);
                  his_self.addMove("found_jesuit_university\t"+second_spacekey);
                  his_self.addMove("found_jesuit_university\t"+destination_spacekey);
	          his_self.addMove("SETVAR\tstate\tevents\tpapacy_may_found_jesuit_universities\t1");
                  his_self.endTurn();
	        },
		null,
		true
	      );
	    },
	    null,
	    true
	  );
        }
	return 0;
      },    
    }
    deck['016'] = { 
      img : "cards/HIS-016.svg" , 
      name : "Calvin" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.leaders['luther'] = 0;
	his_self.game.state.leaders['calvin'] = 1;

	let x = his_self.returnSpaceOfPersonage("protestant", "luther-reformer");
	let y = his_self.returnIndexOfPersonageInSpace("protestant", "luther-reformer", x);

	if (y > -1) {
	  his_self.game.spaces[x].units["protestant"].splice(y, 1);
	}

	for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	  if (his_self.game.state.debaters[i].type === "luther-debater") {
	    his_self.game.state.debaters.splice(i, 1);
	  }
	}

	his_self.displaySpace(x);
	his_self.updateLog("Luther dies and is replaced by Calvin");

	return 1;
      }
    }
    deck['017'] = { 
      img : "cards/HIS-017.svg" , 
      name : "Council of Trent" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.council_of_trent = {};
	his_self.game.state.council_of_trent.papacy = {};
	his_self.game.state.council_of_trent.protestants = {};

	his_self.game.queue.push("hide_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_results");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_protestants");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_papacy");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "council_of_trent_add_debaters") {

          his_self.game.queue.splice(qe, 1);
	  
	  let faction = mv[1];
	  let debaters = mv[2];

	  if (faction === "papacy") {
	    his_self.game.state.council_of_trent.papacy.debaters = JSON.parse(debaters);
	  } else {
	    his_self.game.state.council_of_trent.protestants.debaters = JSON.parse(debaters);
	  }

	  return 1;

	}

        if (mv[0] === "council_of_trent_papacy") {

          his_self.game.queue.splice(qe, 1);
	  his_self.council_of_trent_overlay.render("papacy");

	  return 0;

	}

        if (mv[0] === "council_of_trent_results") {

          his_self.game.queue.splice(qe, 1);
	  //
	  // this adds stuff to the queue -- so we pass through
	  //
	  his_self.council_of_trent_overlay.render("results");

	  return 1;

	}

        if (mv[0] === "council_of_trent_protestants") {

          his_self.game.queue.splice(qe, 1);
	  his_self.council_of_trent_overlay.render("protestant");

	  return 0;

        }

	return 1;
      },
    }
    deck['018'] = { 
      img : "cards/HIS-018.svg" , 
      name : "Dragut" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	// barbarossa dies, replaced by Dragut
	let s = his_self.returnSpaceOfPersonage("ottoman", "barbarossa");
	if (s != "") {
	  let idx = his_self.returnIndexOfPersonageInSpace("ottoman", "barbarossa", s);
	  if (idx > -1) {
	    his_self.game.spaces[s].units["ottoman"].splice(idx, 1);
	    his_self.addNavyLeader("ottoman", s, "dragut");
	  }	  
	}

	return 1;
      },
    }
    deck['019'] = { 
      img : "cards/HIS-019.svg" , 
      name : "Edward VI" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

	his_self.game.state.leaders.edward_vi = 1;
	his_self.game.state.leaders.henry_viii = 0;
	his_self.game.state.leaders.mary_i = 0;
	his_self.game.state.leaders.elizabeth_i = 0;

	let placed = 0;

        // henry_viii dies, replaced by dudley
        let s = his_self.returnSpaceOfPersonage("england", "henry_viii");
        if (s != "") {
          let idx = his_self.returnIndexOfPersonageInSpace("england", "henry_viii", s);
          if (idx > -1) {
            his_self.game.spaces[s].units["england"].splice(idx, 1);
            his_self.addArmyLeader("england", s, "dudley");
	    placed = 1;
          } 
        }
        
	if (placed == 0) {
          his_self.addArmyLeader("england", "london", "dudley");
	}

	return 1;
      },
    }

    deck['020'] = { 
      img : "cards/HIS-020.svg" , 
      name :"Henry II" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.leaders.francis_i = 0;
	his_self.game.state.leaders.henry_ii = 1;
	let placed = 0;

        // francis_i dies replaced by henry_ii
        let s = his_self.returnSpaceOfPersonage("france", "francis_i");
        if (s != "") {
          let idx = his_self.returnIndexOfPersonageInSpace("france", "francis_i", s);
          if (idx > -1) {
            his_self.game.spaces[s].units["france"].splice(idx, 1);
            his_self.addArmyLeader("france", s, "henry_ii");
	    placed = 1;
          } 
        }
        
	if (placed == 0) {
          his_self.addArmyLeader("france", "paris", "henry_ii");
	}

	return 1;
      },
    }
    deck['021'] = { 
      img : "cards/HIS-021.svg" , 
      name : "Mary I" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

	his_self.game.state.leaders.edward_vi = 0;
	his_self.game.state.leaders.mary_i = 1;

	//
	// it is possible that a healthy Edward has already been born before this
	// card has been played, in which case Mary I is actually Edward VI since
	// the succession passes to him.
	//
        if (his_self.game.state.henry_viii_healthy_edward == 1) {
	  let deck = his_self.returnDeck();
	  let card = deck["019"];
	  card.onEvent(his_self,faction);
	  return 1;
        }

	//
	// otherwise remove Edward from the Deck
	//
	his_self.removeCardFromGame('019'); // remove edward_vi if still in deck

	//
	// if sickly edward has been born but this card has been played, we want
	// to push it back into the deck next turn. the card will be removed because
	// it is a mandatory card, so we make a note to re-add it next turn.
	//
        if (his_self.game.state.henry_viii_sickly_edward == 1) {
	  his_self.game.state.henry_viii_mary_i_added_with_sickly_edward_played = 1;
	  return 1;
        }

	//
	// if Elizabeth has been born, we will tag to add her next round
	//
	// this code is in returnNewCards...
	//
	let placed = 0;
	if (his_self.game.state.leaders.henry_viii == 1) {

	  his_self.game.state.leaders.henry_viii = 0; 

          // mary_i replaces edward_vi or henry_viii
          let s = his_self.returnSpaceOfPersonage("england", "henry_viii");
          if (s != "") {
            let idx = his_self.returnIndexOfPersonageInSpace("england", "henry_viii", s);
            if (idx > -1) {
              his_self.game.spaces[s].units["england"].splice(idx, 1);
              his_self.addArmyLeader("england", s, "dudley");
	      placed = 1;
            } 
          }
	}

	if (placed == 0) {
          his_self.addArmyLeader("england", "london", "dudley");
	}

	return 1;
      },
    }
    deck['022'] = { 
      img : "cards/HIS-022.svg" , 
      name : "Julius III" ,
      ops : 2 ,
      turn : 7 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Paul III is replaced by Julius III. Papacy wins Counter-Reformation ties.",
          title : "Accession of Julius III",
          img : "/his/img/backgrounds/events/julius-iii.jpg",
	  msg : "Julius III becomes Pope...",
        }
      } ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 0;
	his_self.game.state.leaders.paul_iii = 0;
	his_self.game.state.leaders.julius_iii = 1;
	his_self.removeCardFromGame('010');
	his_self.removeCardFromGame('014');
	return 1;
      },
    }
    deck['023'] = { 
      img : "cards/HIS-023.svg" , 
      name : "Elizabeth I" ,
      ops : 2 ,
      turn : 0 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) { return 1; },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

	his_self.game.state.leaders.henry_viii = 0;
	his_self.game.state.leaders.edward_vi = 0;
	his_self.game.state.leaders.mary_i = 0;
	his_self.game.state.leaders.elizabeth_i = 1;
	his_self.removeCardFromGame('019');
	his_self.removeCardFromGame('021');
	return 1;
      },
    }
    deck['024'] = { 
      img : "cards/HIS-024.svg" , 
      name : "Arquebusiers" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "pre_field_battle_rolls" || menu === "pre_naval_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('024')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (!his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '024', html : `<li class="option" id="024">arquebusiers (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('024')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        if (menu === "pre_naval_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('024')) {
	      if (his_self.doesPlayerHaveNavalUnitsInSpace(his_self.game.player, spacekey)) {
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_naval_battle_rolls") {
	  his_self.addMove("insert_before_counter_or_acknowledge\tadd_naval_battle_bonus_rolls\t"+faction+"\t2");
	  his_self.addMove("discard\t"+faction+"\t024");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("024"));
	  his_self.endTurn();
        }
        if (menu === "pre_field_battle_rolls") {
	  his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t2");
	  his_self.addMove("discard\t"+faction+"\t024");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("024"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['025'] = { 
      img : "cards/HIS-025.svg" , 
      name : "Field Artillery" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('025')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (!his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '025', html : `<li class="option" id="025">field artillery (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('025')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  if (faction === "france" || faction === "ottoman") {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t3");
	  } else {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t2");
	  }
	  his_self.addMove("discard\t"+faction+"\t024");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("025"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['026'] = { 
      img : "cards/HIS-026.svg" , 
      name : "Mercenaries Bribed" ,
      ops : 3 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('026')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (f === "ottoman") { return {}; }
	  if (!his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '026', html : `<li class="option" id="026">mercenaries bribed (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('026')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  his_self.addMove("mercenaries_bribed\t"+faction);
	  his_self.addMove("discard\t"+faction+"\t026");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("025"));
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "mercenaries_bribed") {

          his_self.game.queue.splice(qe, 1);

	  let cmd = "field_battle\t" + his_self.game.state.field_battle.spacekey+"\t"+his_self.game.state.field_battle.attacker_faction;

	  console.log("QUEUE: " + JSON.stringify(his_self.game.queue));

          let faction = mv[1];
	  let card_player_is_attacker = true;
	  if (his_self.game.state.field_battle.faction_map[faction] == his_self.game.state.field_battle.defender_faction) { card_player_is_attacker = false; }

          let spacekey = his_self.game.state.field_battle.spacekey;
          let fmap = his_self.game.state.field_battle.faction_map;
          let remove_next_mercenary = 1;
          let total_mercenaries_removed = 0;

	  if (card_player_is_attacker) {
	    for (let f in fmap) {
	      if (fmap[f] == his_self.game.state.field_battle.defender_faction) {
		for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		  let u = his_self.game.spaces[spacekey].units[f][z];
		  if (u.type === "mercenary") {
		    if (remove_next_mercenary) {
		      his_self.game.spaces[spacekey].units[f].splice(z, 1);
		      z--;
		      total_mercenaries_removed++;
		      remove_next_mercenary = 0;
		    } else {
		      remove_next_mercenary = 1;
		    }
		  }
		}  
	      }
	    }
	  } else {
	    for (let f in fmap) {
	      if (fmap[f] == his_self.game.state.field_battle.attacker_faction) {
		for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		  let u = his_self.game.spaces[spacekey].units[f][z];
		  if (u.type === "mercenary") {
		    if (remove_next_mercenary) {
		      his_self.game.spaces[spacekey].units[f].splice(z, 1);
		      z--;
		      total_mercenaries_removed++;
		      remove_next_mercenary = 0;
		    } else {
		      remove_next_mercenary = 1;
		    }
		  }
		}  
	      }
	    }
	  }

	  his_self.addMercenary(faction, spacekey, total_mercenaries_removed);

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lmv = his_self.game.queue[i].split("\t");
	    if (lmv[0].indexOf("field_b") == 0) {
	      his_self.game.queue.splice(i, 1); 
	    } else {
	      if (lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("HALTED") == 0 || lmv[0].indexOf("counter_or_ac") == 0) {
	      } else {
	        his_self.game.queue.splice(i+1, 0, cmd);
	        i = 0;
	      }
	    }
	  }
        }
        return 1;
      },
    }
    deck['027'] = { 
      img : "cards/HIS-027.svg" , 
      name : "Mercenaries Grow Restless" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_assault_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('027')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              return { faction : f , event : '027', html : `<li class="option" id="027">mercenaries grow restless (${f})</li>` };
              break;
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_assault_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('027')) {
	        let assault_spacekey = "";
	        if (his_self.game.state.assault) {
	          if (his_self.game.state.assault.spacekey) {
		    let fac = his_self.returnFactionControllingSpace(his_self.game.state.assault.spacekey);
		    if (his_self.game.player == his_self.returnPlayerCommandingFaction(fac)) {
                      return 1;
	 	    }
	 	  }
	 	}
	      }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_assault_rolls") {
	  his_self.addMove(`mercenaries_grow_restless\t${faction}`);
  	  his_self.addMove(`discard\t${faction}\t027`);
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("027"));
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "mercenaries_grow_restless") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  his_self.updateLog(his_self.returnFactionName(faction) + " triggers " + his_self.popup("027"));
	  salert(his_self.returnFactionName(faction) + " events Mercenaries Grow Restless!"); 

          let player = his_self.returnPlayerOfFaction(faction);
	  let space = his_self.game.spaces[his_self.game.state.assault.spacekey];
	  let attacker_land_units_remaining = 0;
	  let defender_land_units_remaining = 0;
	  for (let f in his_self.game.state.assault.faction_map) {
            if (his_self.game.state.assault.faction_map[f] === his_self.game.state.assault.attacker_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		if (space.units[f][z].type === "mercenary") {
		  space.units[f].splice(z, 1);
		  z--;
		} else {
		  if (space.units[f][z].type === "cavalry" || space.units[f][z].type === "regular") {
		    attacker_land_units_remaining++;
		  }
		}
	      }
            }       
            if (his_self.game.state.assault.faction_map[f] === his_self.game.state.assault.defender_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		let u = space.units[f][z];
	        if (u.type === "mercenary" || u.type === "regular" || u.type === "cavalry") {
		  defender_land_units_remaining++;
		}
	      }
	    }
          }

	  if (defender_land_units_remaining > attacker_land_units_remaining) {

	    //
	    // remove rest of assault
	    //
	    for (let i = his_self.game.queue.length-1; i > 0 ; i--) {
	      let lmv = his_self.game.queue[i].split("\t");
	      if (!(lmv[0].indexOf("assault") == 0 || lmv[0].indexOf("counter") == 0 || lmv[0].indexOf("RESETC") == 0 || lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("discard") == 0)) {
		break;
	      } else {
	        if (lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("discard") == 0) {

	        } else {
		  his_self.game.queue.splice(i, 1);
	        }
	      }
	    }

	    his_self.game.queue.push("break_siege");
	    his_self.game.queue.push("hide_overlay\tassault");
    	    his_self.game.queue.push(`discard\t${faction}\t027`);

	  //
	  // assault may continue -- this will take us back to the acknowledge menu
	  //
	  } else {

	    //
	    // remove rest of assault
	    //
	    for (let i = his_self.game.queue.length-1; i > 0 ; i--) {
	      let lmv = his_self.game.queue[i].split("\t");
	      if (!(lmv[0].indexOf("discard") == 0 || lmv[0].indexOf("continue") == 0 || lmv[0].indexOf("play") == 0)) {
		his_self.game.queue.splice(i, 1);
	      } else {
		break;
	      }
	    }

	    his_self.game.queue.push(`assault\t${his_self.game.state.assault.attacker_faction}\t${his_self.game.state.assault.spacekey}`);
	    his_self.game.queue.push("hide_overlay\tassault");
    	    his_self.game.queue.push(`discard\t${faction}\t027`);

	  }

	}


        return 1;
      }
    }
    deck['028'] = { 
      img : "cards/HIS-028.svg" , 
      name : "Siege Mining" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_assault_rolls") {
 	  if (his_self.game.player != his_self.game.state.active_player) {
	    return {};
	  }

          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('028')) {
                f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
                return { faction : f , event : '028', html : `<li class="option" id="028">siege mining (${f})</li>` };
              }
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) { // extra= assault spacekey
        if (menu == "pre_assault_rolls") {
          if (his_self.game.player != his_self.game.state.active_player) { return 0; }
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('028')) {
	      return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_assault_rolls") {
	  his_self.addMove("add_assault_bonus_rolls\t"+faction+"\t3");
	  his_self.addMove("discard\t"+faction+"\t028");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("028"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['029'] = { 
      img : "cards/HIS-029.svg" , 
      name : "Surprise Attack" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('029')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '029', html : `<li class="option" id="029">surprise attack (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) { // extra = spacekey of assault
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('029')) {
	        for (let f in his_self.game.spaces[extra].units) {
		  if (his_self.returnFactionLandUnitsInSpace(f, his_self.game.spaces[extra]) > 0) {
		    if (his_self.game.player == his_self.returnPlayerCommandingFaction(f)) {
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  let is_attacker = false;
	  for (let f in his_self.game.state.field_battle.faction_map) {
	    if (his_self.game.state.field_battle.faction_map[f] === his_self.game.state.field_battle.attacker_faction) {
	      is_attacker = true;
	    }
	  }
	  if (is_attacker) {
	    his_self.addMove("insert_before_counter_or_acknowledge\tfaction_assigns_hits_first_field_battle\tattacker");
	  } else {
	    his_self.addMove("insert_before_counter_or_acknowledge\tfaction_assigns_hits_first_field_battle\tdefender");
	  }

	  his_self.addMove("discard\t"+faction+"\t029");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("029"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['030'] = { 
      img : "cards/HIS-030.svg" , 
      name : "Tercios" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('030')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (f !== "hapsburg") { return {}; }
          return { faction : f , event : '024', html : `<li class="option" id="030">tercios (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('030')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
	          if (his_self.game.spaces[spacekey].units["hapsburg"].length > 1) {
                    return 1;
                  }
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_field_battle_rolls") {
	  if (faction === "hapsburg") {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t2");
            his_self.addMove("insert_before_counter_or_acknowledge\tSETVAR\tstate\tfield_battle\ttercios\t1");
	    his_self.addMove("discard\t"+faction+"\t024");
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("024"));
	    his_self.endTurn();
          } else {
	    let nhr = 0;
	    for (let i = 0; i < his_self.game.spaces[his_self.game.state.field_battle.spacekey].units["hapsburg"].length; i++) {
	      if (his_self.game.spaces[his_self.game.state.field_battle.spacekey].units["hapsburg"][i].type == "regular") {
		nhr++;
	      }
	    }
	    if (nhr >= 3) {
	      let rolls_removed = 0;
	      if (his_self.game.state.field_battle.faction_map["hapsburg"] === his_self.game.state.field_battle.attacker_faction) {
		for (let z = his_self.game.state.field_battle.attacker_modified_rolls.length-1; z >= 0 && rolls_removed < 3; z--) {
		  his_self.game.state.field_battle.attacker_modified_rolls.splice(z, 1);
		  rolls_removed++;
	        }
	      } else {
		for (let z = his_self.game.state.field_battle.defender_modified_rolls.length-1; z >= 0 && rolls_removed < 3; z--) {
		  his_self.game.state.field_battle.defender_modified_rolls.splice(z, 1);
		  rolls_removed++;
	        }
	      }
	    }
	  }
        }
        return 1;
      },
    }
    deck['031'] = { 
      img : "cards/HIS-031.svg" , 
      name : "Foul Weather" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "move" || menu == "assault" || menu == "piracy") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('031')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '031', html : `<li class="option" id="031">foul weather (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "move" || menu == "assault" || menu == "piracy") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('031')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "move" || menu == "assault" || menu == "piracy") {
	  his_self.addMove(`foul_weather\t${player}\t${faction}`);
  	  his_self.addMove("discard\t"+faction+"\t"+"031");
	  if (his_self.game.deck[0].discards["032"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "foul_weather") {

          let player = mv[1];
          let faction = mv[2];
          his_self.game.queue.splice(qe, 1);

	  his_self.displayModal(his_self.returnFactionName(faction) + " triggers Foul Weather");

	  his_self.updateLog(his_self.returnFactionName(faction) + " triggers " + his_self.popup("031"));
	  his_self.game.state.events.foul_weather = 1;

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    if (his_self.game.queue[i].indexOf("play") == -1 && his_self.game.queue[i].indexOf("continue") == -1 && his_self.game.queue[i].indexOf("discard") == -1 && his_self.game.queue[i].indexOf("cards_left") == -1) {
	      his_self.game.queue.splice(i, 1);
	    } else {
	      break;
	    }
	  }

	  return 1;

        }

	return 1;
      }
    }
    deck['032'] = { 
      img : "cards/HIS-032.svg" , 
      name : "Gout" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "move" || menu == "assault") {
	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }

	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }

	  if (f == "") { return {}; }

	  let includes_army_leader = false;

	  if (menu == "assault") {
	    for (let i = his_self.game.queue.length-1; i > 0; i--) {
	      let lqe = his_self.game.queue[i];
	      if (lqe.indexOf("assault") == 0) {
		let lmv = lqe.split("\t");
		if (lmv[0] === "assault") {
		  let faction = lmv[1];
		  let source = lmv[2];
		  let unit_idx = -1;
		  let space = his_self.game.spaces[source];
		  for (let i = 0; i < space.units[faction].length; i++) {
		    if (space.units[faction][i].army_leader == true) {
		      includes_army_leader = true;
		    }
		  }
		}
	      }
	    }
	  }

	  if (menu == "move") {
	    for (let i = his_self.game.queue.length-1; i > 0; i--) {
	      let lqe = his_self.game.queue[i];
	      if (lqe.indexOf("move") == 0) {
		let lmv = lqe.split("\t");
		if (lmv[0] === "move") {
		  let faction = lmv[1];
		  let source = lmv[3];
		  let unit_idx = parseInt(lmv[5]);
		  let unit = his_self.game.spaces[source].units[faction][unit_idx];
		  if (unit.army_leader == true) {
		    includes_army_leader = true;
		  }
		}
	      }
	    }
	  }

	  if (includes_army_leader) {
            return { faction : f , event : '032', html : '<li class="option" id="032">play gout</li>' };
	  } 
       }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "move" || menu == "assault") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      return 1;
	    }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
	if (menu === "assault") {

	  let faction = null;
	  let source = null;
	  let unit_idx = null;

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("assault") == 0) {
	      let lmv = lqe.split("\t");
	      faction = lmv[1];
	      source = lmv[2];
	      if (lmv[0] === "assault") {
	        let space = his_self.game.spaces[source];
	        for (let i = 0; i < space.units[faction].length; i++) {
	          if (space.units[faction][i].army_leader) {
	            unit_idx = i;
	          }
	        }
	      }
	      break;
	    }
	  }

	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }

	  if (faction == null || source == null || unit_idx == null) { his_self.endTurn(); return 0; }
	  his_self.addMove(`gout\t${faction}\t${source}\t${unit_idx}\t${f}`);
  	  his_self.addMove(`discard\t${f}\t032`);
	  if (his_self.game.deck[0].discards["031"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
          his_self.endTurn();

	}


        if (menu === "move") {

	  let faction = null;
	  let source = null;
	  let unit_idx = null;

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("move") == 0) {
	      let lmv = lqe.split("\t");
	      if (lmv[0] === "move") {
		faction = lmv[1];
		source = lmv[3];
		unit_idx = parseInt(lmv[5]);
		break;
	      }
	    }
	  }

	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }

	  if (faction == null || source == null || unit_idx == null) { his_self.endTurn(); return 0; }
	  his_self.addMove(`gout\t${faction}\t${source}\t${unit_idx}\t${f}`);
  	  his_self.addMove(`discard\t${f}\t032`);
	  if (his_self.game.deck[0].discards["031"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
          his_self.endTurn();

        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "gout") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let triggering_faction = mv[4];

	  his_self.displayModal(his_self.returnFactionName(triggering_faction) + " triggers Gout");

	  his_self.game.spaces[source].units[faction][unit_idx].gout = true;
	  his_self.updateLog(his_self.game.spaces[source].units[faction][unit_idx].name + " has come down with gout");
          his_self.game.queue.splice(qe, 1);

	  //
	  // "lose 1 CP"
	  //
	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("continue") != 0 && lqe.indexOf("play") != 0) {
	      his_self.game.queue.splice(i, 1);
	    } else {
	      break;
	    }
	  }
	  return 1;

	}

        return 1;
      }
    }
    deck['033'] = { 
      img : "cards/HIS-033.svg" , 
      name : "Landsknechts" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {
        his_self.game.queue.push("landsknechts\t"+faction);
	return 1;
      },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('033')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }
          return { faction : f , event : '033', html : `<li class="option" id="033">landsknechts (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "pre_field_battle_rolls") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace();
	    if (fis.includes(f)) {
	      if (his_self.game.deck[0].fhand[i].includes('033')) {
	        return 1;
	      }
	    }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  if (faction == "ottoman" || faction == "france") {
	  } else {
	    his_self.addMove("add_units_before_field_battle\t"+faction+"\t"+"mercenary"+"\t"+4);
	    his_self.endTurn();            
	  }
	}
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "landsknechts") {

          let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == player) {

	    if (faction === "hapsburg") {
              his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", 4, "hapsburg",
	        function(space) {
	  	  if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
		  if (his_self.returnFactionLandUnitsInSpace("hapsburg", space.key)) { return 1; }
		  if (his_self.returnFriendlyLandUnitsInSpace("hapsburg", space.key)) { return 1; }
	        } ,
	        null ,
	        null ,
	        true
	      );
	    } else {
	      if (faction === "ottoman") {
                his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter("mercenary", 2,
	          function(space) {
		    for (let key in space.units) {
		      for (let i = 0; i < space.units[key].length; i++) {
		        if (space.units[key][i].type === "mercenary") { return 1; }
		      }
		    }
	          } ,
	          null ,
	          null ,
	          true
	        );
	      } else {
                his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", 2, faction,
	          function(space) {
		    if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
		    if (his_self.returnFactionLandUnitsInSpace(faction, space.key)) { return 1; }
		    if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
		    return 0;
	          } ,
	          null ,
	          null ,
	          true
	        );
	      }
	    }
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing Landsknechts");
	  }

          his_self.game.queue.splice(qe, 1);
	  return 0;

        }

	return 1;
      },
    }
    deck['034'] = { 
      img : "cards/HIS-034.svg" , 
      name : "Professional Rowers" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "pre_naval_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              i = 100;
            }
	    if (his_self.game.state.naval_battle.attacker_faction != f && his_self.game.state.naval_battle.defender-faction != f) { return {}; }
            return { faction : f , event : '001', html : `<li class="option" id="001">janissaries (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_naval_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
              let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              if (his_self.doesFactionHaveNavalUnitsInSpace(f, spacekey)) {
                his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_naval_battle_rolls") {
	  his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" play " + his_self.popup("034"));
          his_self.addMove("discard\t"+faction+"\t034");
          his_self.addMove("add_naval_battle_bonus_rolls\t"+faction+"\t3");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        return 0;
      },
    }
    deck['035'] = { 
      img : "cards/HIS-035.svg" , 
      name : "Siege Artillery" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "pre_assault_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('035')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              i = 100;
              return { faction : f , event : '035', html : `<li class="option" id="035">siege artillery (${f})</li>` };
            }
          }
        }   
        return {};
      }, 
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_assault_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('035')) {
	      let assault_spacekey = his_self.game.state.assault.spacekey;
	      let attacker_faction = his_self.game.state.assault.attacker_faction;
	      if (4 >= his_self.returnHopsToFortifiedHomeSpace(assault_spacekey, attacker_faction)) {
		his_self.assault_overlay.render(his_self.game.state.assault);
		return 1;
	      }
              return 0;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_assault_rolls") {
	  his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("035"));
          his_self.addMove("discard\t"+faction+"\t035");
          his_self.addMove("add_assault_bonus_rolls\t"+faction+"\t2");
          his_self.addMove("SETVAR\tstate\tassault\tsiege_artillery\t1");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("035"));
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        return 0;
      },
    }
    deck['036'] = { 
      img : "cards/HIS-036.svg" , 
      name : "Swiss Mercenaries" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      canEvent : function(his_self, faction) { return 1; } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      onEvent : function(his_self, faction) {

	let target_number = 2;
	let placing_faction = faction;
	if (faction == "ottoman") { placing_faction = "france"; target_number = 4; }
	if (faction == "france") { target_number = 4; }
	his_self.game.queue.push("swiss_mercenaries_place\t"+placing_faction+"\t"+target_number);

	return 1;

      },
      menuOption  :       function(his_self, menu, player) {
        if (menu === "assault") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('036')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (f != "") {
            return { faction : f , event : '036', html : `<li class="option" id="036">swiss mercenaries (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "assault") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('036')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "assault") {
	  let target_faction = faction;
	  let target_number = 2;
	  if (faction == "ottoman" || faction == "france") {
	    target_faction = "france";
	    target_number = 4;
	  }
	  his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("036"));
	  // this places the units, so if reset no problem
	  his_self.addMove("add_units_before_field_battle\t"+target_faction+"\t"+"mercenary"+"\t"+target_number);
          his_self.addMove("discard\t"+faction+"\t036");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("036"));
	  his_self.endTurn();
	}
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "swiss_mercenaries_place") {

          let faction = mv[1];
          let num = parseInt(mv[2]);
          his_self.game.queue.splice(qe, 1);

	  let player = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == player) {
            his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", num, faction,
	      function(space) {
		for (let f in space.units) {
		  for (let z = 0; z < space.units[f].length; z++) { 
		    if (space.units[f][z].besieged > 0) { return 0; }
	          }
	        }
		if (his_self.returnFactionLandUnitsInSpace(faction, space.key)) { return 1; }
		if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
	        return 0;
	      } ,
	      null ,
	      null ,
	      true
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("036"));
	  }

	  return 0;
        }

	return 1;
      },
    }
    deck['037'] = { 
      img : "cards/HIS-037.svg" , 
      name : "The Wartburg" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; } ,
      menuOption  :       function(his_self, menu, player, card="") {

        if (menu == "event") {

	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }

	  let p = his_self.returnPlayerOfFaction();

          if (his_self.game.state.leaders.luther !== 1) { return {}; }
          if (card === "") { return {}; }
          if (!his_self.game.deck[0]) { return {}; }

	  //
	  // card evented
	  //
	  let cardobj = his_self.game.deck[0].cards[card];

	  //
	  // cannot cancel non-papal home cards
	  //
	  if (card === "001" || card == "002" || card == "003" || card == "004") { return {}; }

	  //
	  // cannot cancel these three types of cards
	  //
	  if (cardobj.type === "response") { return {}; }
	  if (cardobj.type === "mandatory") { return {}; }
	  if (cardobj.type === "combat") { return {}; }

          return { faction : "protestant" , event : '037', html : `<li class="option" id="037">wartburg (protestant)</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "event") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('037')) {
	      if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player) {
 		return 1;
	      }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "event") {
	  his_self.addMove("RESETCONFIRMSNEEDED\tall");
          his_self.addMove("NOTIFY\tWartburg Evented");
          his_self.addMove("wartburg");
          his_self.addMove("discard\tprotestant\t037");
          his_self.addMove("commit\tprotestant\tluther-debater");
	  his_self.endTurn();
	  his_self.updateStatus("wartburg acknowledge");
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "wartburg") {

          his_self.game.queue.splice(qe, 1);

	  his_self.displayModal("Protestants cancel event with the Wartburg");

	  his_self.updateStatus(his_self.popup("037") + " triggered");
	  his_self.game.state.events.wartburg = 1;
	  his_self.commitDebater("protestant", "luther-debater", 0);
	  his_self.updateLog(his_self.popup("037") + " triggered");

	  //
	  // remove event from execution and end player turn
	  //
	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lmv = his_self.game.queue[i].split("\t");
	    if (lmv[0] !== "remove" && lmv[0] !== "discard" && lmv[0] !== "round" && lmv[0] !== "play") {
	      his_self.game.queue.splice(i, 1);
	    } else {
	      if (lmv[0] === "round" || lmv[0] === "play") {
	        i = -1;
		break;
	      }
	    }
	  }

	  return 1;

        }

	return 1;
      },
    }
    deck['038'] = { 
      img : "cards/HIS-038.svg" , 
      name : "Halley's Comet" ,
      ops : 2 ,
      turn : 3 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu != "" && menu != "pre_spring_deployment") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }

          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('038')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '038', html : `<li class="option" id="038">halley's comet (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu != "" && menu != "pre_spring_deployment") {
	  if (his_self.game.state.active_player === his_self.game.player) { 
	    // not in translation and reformation overlays
	
	    if (menu.indexOf("lation") > 0 || menu.indexOf("ormation") > 0) {
	      return 0;
	    }
	  }
	  if (!his_self.game.deck) { return 0; }
	  if (!his_self.game.deck[0]) { return 0; }
	  if (!his_self.game.deck[0].fhand) { return 0; }
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('038')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu != "" && menu != "pre_spring_deployment") {
  	  his_self.addMove("remove\t"+faction+"\t038");
  	  his_self.addMove("event\t"+faction+"\t038");
  	  his_self.addMove("discard\t"+faction+"\t038");
	  his_self.endTurn();
        }
        return 0;
      },
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);

	if (player == his_self.game.player) {

	  let msg = "Target which Power?";
	  let html = '<ul>';

	  if (faction != "protestant") { html += '<li class="option" id="protestant">Protestant</li>'; }
	  if (faction != "papacy") { html += '<li class="option" id="papacy">Papacy</li>'; }
	  if (his_self.game.players.length > 2) {
	    if (faction != "england") { html += '<li class="option" id="england">England</li>'; }
	    if (faction != "france") { html += '<li class="option" id="france">France</li>'; }
	    if (faction != "hapsburg") { html += '<li class="option" id="hapsburg">Hapsburg</li>'; }
	    if (faction != "ottoman") { html += '<li class="option" id="ottoman">Ottoman</li>'; }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let target_faction = $(this).attr("id");

  	    let msg = "Force Power to Discard or Skip Turn?";
	    let html = '<ul>';
	    html += '<li class="option" id="discard">discard random card</li>';
	    html += '<li class="option" id="skip">skip next turn</li>';
	    html += '<ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      his_self.updateStatus("submitted");

	      if (action === "discard") {
                his_self.addMove("discard_random\t"+target_faction);
  	        his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to discard a card");
		his_self.endTurn();
	      }

	      if (action === "skip") {
                his_self.addMove("skip_next_impulse\t"+target_faction);
  	        his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to skip next turn");
		his_self.endTurn();
	      }

	    });
	  });

          return 0;

        }

	return 0;
      },
    }
    deck['039'] = { 
      img : "cards/HIS-039.svg" , 
      warn : ["papacy"] ,
      name : "Augsburg Confession" ,
      ops : 4 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.isCommitted("melanchthon-debater")) { return 0; }
 	return 1;
      } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);

	if (his_self.isCommitted("melanchthon-debater")) { return 1; }
	his_self.game.state.events.augsburg_confession = 1;
	his_self.commitDebater("papacy", "melanchthon-debater", 0); // 0 = no bonus

	return 1;
      },
    }
    deck['040'] = { 
      img : "cards/HIS-040.svg" , 
      name : "MachiaveIIi: The Prince" ,
      ops : 3 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);

	if (player == his_self.game.player) {

	  let powers = his_self.returnImpulseOrder();
	  let msg = "Declare War on which Power?";

          let html = '<ul>';
	  for (let i = 0; i < powers.length; i++) {
	    if (powers[i] !== faction) {
              html += `<li class="option" id="${powers[i]}">${powers[i]}</li>`;
	    }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");

            his_self.addMove("ops\t"+faction+"\t"+"040"+"\t"+2);
	    his_self.addMove("unexpected_war\t"+faction+"\t"+action);
            his_self.addMove("declare_war\t"+faction+"\t"+action);
	    his_self.endTurn();

	  });


        }

        return 0;
      },
    }

    deck['041'] = { 
      img : "cards/HIS-041.svg" , 
      name : "Marburg Colloquy" ,
      warn : ["papacy"] ,
      ops : 5 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { 
	if (
	  (his_self.isCommitted("luther-debater") != 1 || his_self.isCommitted("melanchthon-debater"))
	  &&
	  (his_self.isCommitted("zwingli-debater") != 1 || his_self.isCommitted("oekolampadius-debater"))
	) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");
	if (his_self.game.player === player) {

	  let msg = "Commit which Debaters?";
          let html = '<ul>';
	  if (his_self.isCommitted("luther-debater") != 1) {
	    if (his_self.isCommitted("zwingli-debater") != 1) {
              html += '<li class="option" id="lz">Luther and Zwingli</li>';
	    }
	    if (his_self.isCommitted("oekolampadius-debater") != 1) {
              html += '<li class="option" id="lo">Luther and Oekolampadius</li>';
	    }
	  }
	  if (his_self.isCommitted("melanchthon-debater") != 1) {
	    if (his_self.isCommitted("zwingli-debater") != 1) {
              html += '<li class="option" id="mz">Melanchthon and Zwingli</li>';
	    }
	    if (his_self.isCommitted("oekolampadius-debater") != 1) {
              html += '<li class="option" id="mo">Melanchthon and Oekolampadius</li>';
	    }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    let refs = 0;

            his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");

	    if (action === "lz") {
	      his_self.addMove("commit\tprotestant\tluther-debater");
	      his_self.addMove("commit\tprotestant\tzwingli-debater");
	      refs = 7;
	    }
	    if (action === "lo") {
	      his_self.addMove("commit\tprotestant\tluther-debater");
	      his_self.addMove("commit\tprotestant\toekolampadius-debater");
	      refs = 6;
	    }
	    if (action === "mz") {
	      his_self.addMove("commit\tprotestant\tzwingli-debater");
	      his_self.addMove("commit\tprotestant\tmelanchthon-debater");
	      refs = 6;
	    }
	    if (action === "mo") {
	      his_self.addMove("commit\tprotestant\toekolampadius-debater");
	      his_self.addMove("commit\tprotestant\tmelanchthon-debater");
	      refs = 5;
	    }

	    for (let i = 0; i < refs; i++) {
              his_self.prependMove("protestant_reformation\t"+player+"\tall");
	    }
            his_self.prependMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	    his_self.endTurn();

	  });
	}
	return 0;
      },
    }
    deck['042'] = { 
      img : "cards/HIS-042.svg" , 
      name : "Roxelana" ,
      ops : 4 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.roxelana = 1;

	if (faction === "ottoman") {
	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("ottoman")) {
	    his_self.addMove("ops\tottoman\t042\t4");
	    his_self.endTurn();
	    return 1;
	  }
	} else {

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

	    let msg = "Send Suleiman to Istanbul (2 CP)?";
            let html = '<ul>';
                html += '<li class="option" id="yes">yes</li>';
                html += '<li class="option" id="no">no</li>';
                html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      his_self.updateStatus("acknowledge");
	      $('.option').off();
	      let action = $(this).attr("id");

	      let sk = his_self.returnSpaceOfPersonage("ottoman", "suleiman");
	      let sk_idx = his_self.returnIndexOfPersonageInSpace("ottoman", "suleiman", sk);

	      if (action === "yes" && sk != "") {
	        his_self.addMove("ops\t"+faction+"\t042\t2");
	        his_self.addMove("move" + "\t" + "ottoman" + "\t" + "land" + "\t" + sk + "\t" + "istanbul" + "\t" + sk_idx + "\t1");
	      }
	      if (action === "no") {
	        his_self.addMove("ops\t"+faction+"\t042\t4"); 
	      }
	      his_self.endTurn();

	    });
	    return 0;
	  }
	}

	return 0;
      },
    }
    deck['043'] = { 
      img : "cards/HIS-043.svg" , 
      name : "Zwingli Dons Armor" ,
      ops : 3 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");
	let targets = ["zurich","innsbruck","salzberg","linz","graz","regensburg","augsburg","nuremberg","worms","basel","geneva","turin","grenoble","lyon","besancon","dijon","metz","strasburg"];

	//
	// we all remove the reformer
	//
	his_self.removeReformer("protestant", "zurich", "zwingli-reformer");
	his_self.removeDebater("protestant", "zwingli-debater");

        if (player == his_self.game.player) {
          let count = his_self.countSpacesWithFilter(function(space) {
            if (targets.includes(space.key) && his_self.hasCatholicLandUnits(space.key)) {
              return 1
            }
            return 0;
          });

          if (count == 0) { return 1; }

          his_self.playerSelectSpaceWithFilter(
            "Select Space to Remove Catholic Land Unit",
            function(space) {
              if (targets.includes(space.key) && his_self.hasCatholicLandUnits(space.key)) {
                return 1
              }
              return 0;
            },
            function(spacekey) {

              let catholic_land_units = his_self.returnCatholicLandUnitsInSpace(spacekey);
              let msg = "Remove which Unit?";
              let html = '<ul>';
              for (let i = 0; i < catholic_land_units.length; i++) {
                let u = his_self.game.spaces[spacekey].units[catholic_land_units[i].faction][catholic_land_units[i].unit_idx];
                html += `<li class="option" id="${catholic_land_units[i].faction}_${catholic_land_units[i].unit_idx}">${catholic_land_units[i].faction} - ${u.type}</li>`;
              }

	      if (catholic_land_units.length == 1) {
		his_self.addMove("destroy_unit_by_index\t"+catholic_land_units[0].faction+"\t"+spacekey+"\t"+"\t"+catholic_land_units[0].unit_idx);
		his_self.endTurn();
		return 0;
	      }

              his_self.updateStatusWithOptions(msg, html);

	      $('.option').off();
	      $('.option').on('click', function () {
	        $('.option').off();
	        let x = $(this).attr("id").split("_");
		his_self.addMove("destroy_unit_by_index\t"+x[0]+"\t"+spacekey+"\t"+"\t"+x[1]);
		his_self.endTurn();            
	      });
            },
            null,
            true,
          );
        }
	return 0;
      },
    }
    deck['044'] = { 
      img : "cards/HIS-044.svg" , 
      name : "Affair of the Placards" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (his_self.isCommitted("cop-debater")) { return 0; } return 1; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("cop-debater")) { return 1; }

	his_self.commitDebater("protestant", "cop-debater", 0); // no bonus

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("NOTIFY\t"+his_self.popup("044"));

	return 1;
      },
    }
    deck['045'] = { 
      img : "cards/HIS-045.svg" , 
      name : "Calvin Expelled" ,
      ops : 1 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

        let obj = {};
        obj.faction = "protestant";

        his_self.excommunicateReformer("calvin-reformer");
	his_self.commitDebater("protestant", "calvin-debater");
	his_self.removeDebater("protestant", "calvin-debater");

	his_self.displaySpace("geneva");

        return 1;
      },
    }
    deck['046'] = { 
      img : "cards/HIS-046.svg" , 
      name : "Calvin's Institutes" ,
      ops : 5 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (!his_self.isCommitted("calvin-debater")) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("calvin-debater")) { return 1; }

	his_self.commitDebater("protestant", "calvin-debater", 0); // no bonus

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("SETVAR\tstate\tevents\tcalvins_institutes\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("SETVAR\tstate\tevents\tcalvins_institutes\t1");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("NOTIFY\tCalvin's Institutes");

	return 1;
      },
    }
    deck['047'] = { 
      img : "cards/HIS-047.svg" , 
      name : "Copernicus" ,
      ops : 6 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

        let home_spaces = his_self.returnSpacesWithFilter(
	  function(spacekey) {
	    if (his_self.game.spaces[spacekey].home === faction) {
	      return 1;
	    }
	    return 0;
	  }
	);

	let total = home_spaces.length;
	let count = 0;
	let double_vp = 0;

	for (let i = 0; i < home_spaces.length; i++) {
	  if (his_self.game.spaces[home_spaces[i]].religion === "protestant") { count++; }
	}

	if (count >= (total/2)) {
	  double_vp = 1;
	}

	//
	//
	//
	if (double_vp == 1) {

	  // faction will gain when counted
	  his_self.game.state.events.copernicus = faction;
	  his_self.game.state.events.copernicus_vp = 2;
	  his_self.displayVictoryTrack();

	  return 1;

	} else {

	  his_self.game.state.events.copernicus = faction;
	  his_self.game.state.events.copernicus_vp = 1;

	  let p = his_self.returnPlayerOfFaction(faction);

	  //
	  // player processes and adds move / ends turn
	  //
	  if (his_self.game.player == p) {

	    let msg = "Which would you prefer?";
    	    let html = '<ul>';
                html += '<li class="option" id="draw">draw 1 card</li>';
                html += '<li class="option" id="discard">protestants discard</li>';
    		html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {
	      let action = $(this).attr("id");

	      if (action === "draw") {

	 	//	
	 	// deal a card	
	 	//
	        let cardnum = 1;

                his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
                his_self.addMove("DEAL\t1\t"+p+"\t"+(cardnum));
		his_self.endTurn();

	      } else {

                his_self.addMove("discard_random\tprotestant");
		his_self.endTurn();

	      }
	    });

	  }
	}

	return 0;

      },

    }
    deck['048'] = { 
      img : "cards/HIS-048.svg" , 
      name : "Galleons" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	if (his_self.game.state.galleons['france'] == 0 || his_self.game.state.galleons['england'] == 0 || his_self.game.state.galleons['hapsburg'] == 0) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player == p) {

	    let msg = "Which Faction gets Galleons?";
    	    let html = '<ul>';
	    if (his_self.game.state.galleons['france'] == 0) {
                html += '<li class="option" id="france">France</li>';
 	    }  
	    if (his_self.game.state.galleons['england'] == 0) {
                html += '<li class="option" id="england">England</li>';
 	    }  
	    if (his_self.game.state.galleons['england'] == 0) {
                html += '<li class="option" id="hapsburg">Hapsburgs</li>';
 	    }  
 		html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {
	      his_self.updateStatus("acknowledge");
	      let action = $(this).attr("id");
	      his_self.addMove("display_new_world");
	      his_self.addMove("SETVAR\tstate\tgalleons\t"+action+"\t1");
	      his_self.endTurn();
	    });
	}

	return 0;

      },
    }
    deck['049'] = { 
      img : "cards/HIS-049.svg" , 
      name : "Huguenot Raiders" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	for (let key in his_self.game.spaces) {

	  let space = his_self.game.spaces[key];

	  if (space.home == "protestant") { if (his_self.game.state.raiders['protestant'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }
	  if (space.home == "england") { if (his_self.game.state.raiders['england'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }
	  if (space.home == "france") { if (his_self.game.state.raiders['france'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }

	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Choose Faction for Huguenot Raiders?";
          let html = '<ul>';
	  if (space.home == "protestant") { if (his_self.game.state.raiders['protestant'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") {
	    html += '<li class="option" id="protestant">Protestant</li>';
	  } } }
	  if (space.home == "england") { if (his_self.game.state.raiders['england'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") {
	    html += '<li class="option" id="england">England</li>';
	  } } }
	  if (space.home == "france") { if (his_self.game.state.raiders['france'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") {
	    html += '<li class="option" id="france">France</li>';
	  } } }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
            his_self.game.queue.push("SETVAR\tstate\traiders\t"+action+"\t1");
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " selecting Raiders");
	}

	return 0;
      },
    }
    deck['050'] = { 
      img : "cards/HIS-050.svg" , 
      name : "Mercator's Map" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { if (his_self.game.state.may_explore['hapsburg'] == 1 || his_self.game.state.may_explore['france'] == 1 || his_self.game.state.may_explore['england'] == 1) { return 1; } return 0; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Launch Voyage of Discovery for Whom?";
          let html = '<ul>';
          if (his_self.game.state.may_explore['england'] == 1) { 
	    html += '<li class="option" id="england">England</li>';
          }
          if (his_self.game.state.may_explore['france'] == 1) { 
	    html += '<li class="option" id="france">France</li>';
          }
          if (his_self.game.state.may_explore['hapsburg'] == 1) { 
            html += '<li class="option" id="hapsburg">Hapsburg</li>';
          }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

            his_self.addMove("explore\t"+action);
	    his_self.addMove("display_new_world");
            his_self.addMove("SETVAR\tstate\tevents\tmercators_map\t"+action);
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing Mercator's Map");
	}

	return 0;
      },
    }
    deck['051'] = { 
      img : "cards/HIS-051.svg" , 
      name : "Michael Servetus" ,
      ops : 4 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.updateLog(his_self.returnFactionName(faction) + " +1 VP from Michael Servetus");
	his_self.game.state.events.michael_servetus = faction;
	his_self.game.queue.push("discard_random\tprotestant");

	return 1;

      }
    }
    deck['052'] = { 
      img : "cards/HIS-052.svg" , 
      name : "Michelangelo" ,
      ops : 4 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let x = his_self.rollDice(6);
	let y = his_self.rollDice(6);

	his_self.updateLog("Papacy rolls "+x+" and "+y);

	his_self.game.queue.push("build_saint_peters_with_cp\t"+(x+y));

        return 1;
          
      },
    }
    deck['053'] = { 
      img : "cards/HIS-053.svg" , 
      name : "Plantations" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.plantations['england'] == 0) { return 1; }
	if (his_self.game.state.plantations['hapsburg'] == 0) { return 1; } 
	if (his_self.game.state.plantations['france'] == 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Choose Faction for Plantations?";
          let html = '<ul>';
	  if (his_self.game.state.plantations['england'] == 0) {
	    html += '<li class="option" id="england">England</li>';
	  }
	  if (his_self.game.state.plantations['france'] == 0) {
	    html += '<li class="option" id="france">France</li>';
	  }
	  if (his_self.game.state.plantations['hapsburg'] == 0) {
	    html += '<li class="option" id="hapsburg">Hapsburg</li>';
	  }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
            his_self.addMove("SETVAR\tstate\tplantations\t"+action+"\t1");
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " building Plantations");
	}

	return 0;
      },
    }
    deck['054'] = { 
      img : "cards/HIS-054.svg" , 
      name : "Potosi Silver Mines " ,
      ops : 3 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Who Discovers the Potosi Silver Mines?";
          let html = '<ul>';
          html += '<li class="option" id="england">England</li>';
          html += '<li class="option" id="france">France</li>';
          html += '<li class="option" id="hapsburg">Hapsburg</li>';
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
	    his_self.addMove("SETVAR\tstate\tevents\tpotosi_silver_mines\t"+action);
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " placing Potosi Silver Mines");
	}

	return 0;
      },
    }
    deck['055'] = { 
      img : "cards/HIS-055.svg" , 
      name : "Jesuit Education" ,
      ops : 3 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (his_self.game.state.events.society_of_jesus) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {
	if (his_self.game.state.events.society_of_jesus) { his_self.game.queue.push("jesuit_education"); }
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "jesuit_education") {

          his_self.game.queue.splice(qe, 1);

	  if (!his_self.game.state.events.society_of_jesus) {
	    return 1;
	  }

	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select Catholic Space for 1st Jesuit University",
	      function(space) { if (space.religion === "catholic" && space.university != 1) { return 1; } return 0; },
	      function(spacekey) {
	        his_self.game.spaces[spacekey].university = 1;
	        his_self.displaySpace(spacekey);
		his_self.addMove("found_jesuit_university\t"+spacekey);
		let first_spacekey = spacekey;
	
	        his_self.playerSelectSpaceWithFilter(
	          "Select Catholic Space for 2nd Jesuit University",
	          function(space) { if (space.key != first_spacekey && space.religion === "catholic" && space.university != 1) { return 1; } return 0; },
	          function(spacekey) {
		    his_self.updateStatus("building universities...");
	            his_self.game.spaces[spacekey].university = 1;
	            his_self.displaySpace(spacekey);
		    his_self.addMove("found_jesuit_university\t"+spacekey);
		    his_self.endTurn();
		  },
		  null,
		  true
		);

	      },
	      null ,
	      true
	    );

	  } else {
	    his_self.updateStatus("Papacy building Jesuit Universities");
	  }

	  return 0;

        }
        return 1;
      }


    }
    deck['056'] = { 
      img : "cards/HIS-056.svg" , 
      warn : ["protestant"] ,
      name : "Papal Inquistion" ,
      ops : 5 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("caraffe-debater")) { return 1; }

	his_self.commitDebater("papacy", "caraffe-debater", 0); // no bonus
	his_self.addMove("papal_inquisition_target_player");
	his_self.addMove("papal_inquisition_convert_spaces");
	his_self.endTurn();

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "papal_inquisition_convert_spaces") {

	  let player = his_self.returnPlayerOfFaction("papacy");
          his_self.game.queue.splice(qe, 1);

	  let count = his_self.countSpacesWithFilter(function(space) {
	    if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0;
	  });
	  if (count == 0) { return 1; }

	  if (his_self.game.player === player) {

	    his_self.playerSelectSpaceWithFilter(
	      "Select Protestant Space to Convert",
	      function(space) { if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0; },
	      function(spacekey) {
		his_self.addMove("convert\t"+spacekey+"\tcatholic");
		if (count == 1) { his_self.endTurn(); return 0; }

	        his_self.playerSelectSpaceWithFilter(
	          "Select Protestant Space to Convert",
	          function(space) { if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0; },
	          function(spacekey) {
		    his_self.addMove("convert\t"+spacekey+"\tcatholic");
		    his_self.endTurn();
		  },
		  null,
		  true
		);
	      },
	      null ,
	      true
	    );

	  } else {
	    his_self.updateStatus("Papal Inquisition - Religion Conversion");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_target_player") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {

 	    let msg = "Choose Player to Reveal Cards:";
            let html = '<ul>';
            html += '<li class="option" id="protestant">Protestant</li>';
            if (his_self.game.players.length > 2) { html += '<li class="option" id="england">England</li>'; }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      his_self.updateStatus("selecting...");
	      let action = $(this).attr("id");

              his_self.addMove("papal_inquisition_card_draw\t"+action);
              his_self.addMove("request_reveal_hand\tpapacy\t"+action);
              his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus("Papal Inquisition - Selecting Target");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_card_draw") {

	  let target = mv[1];
	  let player = his_self.returnPlayerOfFaction("papacy");

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player === player) {

 	    let msg = "Choose Action:";
            let html = '<ul>';
            html += `<li class="option" id="draw">draw ${target} card</li>`;
            html += '<li class="option" id="recover">recover from discard pile</li>';
            html += '<li class="option" id="debate">initiate debate +2 dice</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "draw") {
                his_self.addMove("pull_card\tpapacy\t"+target);
                his_self.endTurn();
	      }
	      if (action === "recover") {
                his_self.addMove("papal_inquisition_recover_discard");
                his_self.endTurn();
	      }
	      if (action === "debate") {
                his_self.addMove("papal_inquisition_debate");
                his_self.endTurn();
	      }
	    });
	  } else {
	    his_self.updateStatus("Papal Inquisition - Follow-Up Action");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_recover_discard") {

	  let player = his_self.returnPlayerOfFaction("papacy");

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player == player) {

            let msg = "Retrieve Card from Discard Pile: ";
            let html = '<ul>';
            for (let key in his_self.game.deck[0].discards) {
              html += `<li class="option" id="${key}">${his_self.game.deck[0].cards[key].name}</li>`;
            }
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {
              $('.option').off();
              let card = $(this).attr("id");
              his_self.addMove("papal_inquisition_recover_card\t"+card);
              his_self.endTurn();
            });

	  } else {
	    his_self.updateStatus("Papal Inquisition - Recovering Card");
	  }

	  return 0;
        }

        if (mv[0] == "papal_inquisition_recover_card") {

          let card = mv[1];

          if (his_self.game.deck[0].discards[card]) {

            let p = his_self.returnPlayerOfFaction("papacy");

            //
            // player returns to hand
            //
            if (his_self.game.player === p) {
              let fhand_idx = his_self.returnFactionHandIdx(p, faction);
              his_self.game.deck[0].fhand[fhand_idx].push(card);
            }

            //
            // everyone removes from discards
            //
            delete his_self.game.deck[0].discards[card];

          }

	  return 1;

	}

        if (mv[0] == "papal_inquisition_debate") {

          his_self.game.queue.splice(qe, 1);
	  his_self.game.state.events.papal_inquisition_debate_bonus = 1;
	  his_self.game.queue.push("SETVAR\tstate\tevents\tpapal_inquisition_debate_bonus\t0");
	  his_self.game.queue.push("papal_inquisition_call_theological_debate");
	  return 1;

	}
        if (mv[0] == "papal_inquisition_call_theological_debate") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
	    his_self.playerCallTheologicalDebate(his_self, player, "papacy");
	  } else {
	    his_self.updateStatus("Papacy calling Theological Debate");
	  }
 
	  return 0;

        }

      return 1;

      }
    }
    deck['057'] = { 
      img : "cards/HIS-057.svg" , 
      name : "Philip of Hesse's Bigamy" ,
      ops : 2 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("philip_of_hesse_bigamy");
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "remove_philip_of_hesse") {

	  let ph = his_self.returnSpaceOfPersonage("protestant", "philip-hesse");
	  his_self.removeArmyLeader("protestant", ph, "philip-hesse");
	  his_self.displaySpace(ph);
	  his_self.updateLog("Philip of Hesse removed from game");
          his_self.game.queue.splice(qe, 1);

	  return 1;

	}

        if (mv[0] == "philip_of_hesse_bigamy") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("protestant");
	  let ph = his_self.returnSpaceOfPersonage("protestant", "philip-hesse");

	  if (his_self.game.player === player) {

 	    let msg = "Choose Action: ";
            let html = '<ul>';
            html += '<li class="option" id="discard">discard card</li>';
            if (ph) { html += '<li class="option" id="hesse">remove Philip of Hesse</li>'; }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "hesse") {
		his_self.addMove("remove_philip_of_hesse");
		his_self.endTurn();
	      }

	      if (action === "discard") {
		his_self.addMove("discard_random\tprotestant");
		his_self.endTurn();
	      }

	    });
	  } else {
	    his_self.updateStatus("Protestants - Philip of Hesse's Bigamy");
	  }

	  return 0;

	}

        return 1;

      }
    }
    deck['058'] = { 
      img : "cards/HIS-058.svg" , 
      warn : ["protestant"] ,
      name : "Spanish Inquisition" ,
      ops : 5 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let count = his_self.countSpacesWithFilter(function(space) {
	      if (space.religion == "protestant" && space.language == "spanish") {
		return 1;
	      }
	      return 0;
	  });

          if (count > 0) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select First Space to Convert", 
	      function(space) {
	        if (space.religion == "protestant" && space.language == "spanish") {
		  return 1;
	        }
	        return 0;
	      },

	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
	        let first_choice = space.key;
	        let spaces = his_self.returnSpacesWithFilter(
          	  function(spacekey) {
		    let s2 = his_self.game.spaces[spacekey];
	            if (s2.religion == "protestant" && s2.language == "spanish" && s2.key != first_choice) {
		      return 1;
	            }
	            return 0;
	  	  }
	        );

	        if (spaces.length == 0) {
		  his_self.addMove("spanish_inquisition_secondary\t"+faction);
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
		  his_self.endTurn();
		  return 0;
	        }

                if (count > 1) {
	          his_self.playerSelectSpaceWithFilter(

	            "Select Second Space to Convert", 

	            function(space2) {
	              if (s2.religion == "protestant" && s2.language == "spanish" && s2.key != first_choice) {
		        return 1;
	              }
	              return 0;
		    },

	            function(second_choice) {
		      his_self.addMove("spanish_inquisition_secondary\t"+faction);
		      his_self.addMove("convert\t"+second_choice+"\tcatholic");
		      his_self.addMove("convert\t"+first_choice+"\tcatholic");
		      his_self.endTurn();
	            },
		    null , 
		    true 
	          );
	  	} else {
		  his_self.addMove("spanish_inquisition_secondary\t"+faction);
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
	          his_self.endTurn();
	        }
	      },
	      null ,
	      true 
	    );
	  } else {
	    his_self.updateStatus("No acceptable Protestant targets for Spanish Inquisition");
	    his_self.addMove("spanish_inquisition_secondary\t"+faction);
	    his_self.endTurn();
	  }
        } else {
          his_self.updateStatus("Papacy playing "+his_self.popup("067"));
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "show_hand_and_save") {


          let faction_taking = mv[1];
          let faction_giving = mv[2];

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player == p2) {
            let fhand_idx = his_self.returnFactionHandIdx(p2, faction_giving);
            his_self.addMove("share_hand_and_save\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;

        }

        if (mv[0] === "share_hand_and_save") {

          let faction_taking = mv[1];
          let faction_giving = mv[2];
          let cards = JSON.parse(mv[3]);

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player == p1) {
            for (let i = 0; i < cards.length; i++) {
	      his_self.game.state.pulled_cards.push({ faction : faction_giving , card : cards[i] });
            }
          }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


        if (mv[0] === "select_from_saved_and_discard") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == p) {
 	    his_self.playerFactionSelectCardWithFilter(
	      faction,
	      "Select Card to Discard",
	      function(card) {
	        for (let i = 0; i < his_self.game.state.pulled_cards.length; i++) {
	          if (card === his_self.game.state.pulled_cards[i].card) { return 1; }
	        }
	        return 0;
	      },
	      function(card) {
	        let f = "";
	        for (let i = 0; i < his_self.game.state.pulled_cards.length; i++) {
	          if (card === his_self.game.state.pulled_cards[i].card) { f = his_self.game.state.pulled_cards[i].faction; }
	        }
                his_self.addMove("discard\t"+f+"\t"+card);
	        his_self.endTurn();
	      }
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " giving card to Papacy");
	  }

          return 0;

	}


        if (mv[0] === "spanish_inquisition_secondary") {

          his_self.game.queue.splice(qe, 1);

          let faction = mv[1];
          let p = his_self.returnPlayerOfFaction(faction);
          let hp = his_self.returnPlayerOfFaction("hapsburg");

	  // debate piggy-backs off papal inquisition
          his_self.game.queue.push("papal_inquisition_call_theological_debate");
          his_self.game.queue.push("hand_to_fhand\t1\t"+hp+"\t"+"hapsburg"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+hp+"\t"+1);
	  his_self.game.queue.push("select_from_saved_and_discard\thapsburg");
	  his_self.game.queue.push("show_hand_and_save\t"+faction+"\tengland");
	  his_self.game.queue.push("show_hand_and_save\t"+faction+"\tprotestant");

	  return 1;
        }

	return 1;
      },
    }
    deck['059'] = { 
      img : "cards/HIS-059.svg" , 
      name : "Lady Jane Grey" ,
      ops : 3 ,
      turn : 6 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.england_has_changed_rulers_this_turn != 0) { 
	  let expected = 0;
	  if (!his_self.game.deck[0].discards['003']) { let expected = 1; }
	  if (his_self.game.state.cards_left["england"] > expected) { return 1; }
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p1 = his_self.returnPlayerOfFaction(faction);

        his_self.addMove("lady_jane_grey_papacy_discard\t"+faction);
        his_self.addMove("hand_to_fhand\t1\t"+p1+"\t"+faction+"\t1");
        his_self.addMove("DEAL\t1\t"+p1+"\t"+1);
        his_self.addMove("pull_card\t"+faction+"\tengland");
        his_self.endTurn();

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "lady_jane_grey_papacy_discard") {

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == p) {
 	    his_self.playerFactionSelectCardWithFilter(
	      faction,
	      "Select Card to Give Away",
	      function(card) {
                let fhand_idx = his_self.returnFactionHandIdx(p, faction);
		let handlen = his_self.game.deck[0].fhand[fhand_idx].length;
		let card1 = his_self.game.deck[0].fhand[fhand_idx][handlen-1];
		let card2 = his_self.game.deck[0].fhand[fhand_idx][handlen-2];
	        if (card === card1 || card === card2) { return 1; }
		return 0;
	      },
	      function(card) {
                his_self.addMove("give_card\t"+"papacy"+"\t"+faction+"\t"+card);
	        his_self.endTurn();
	      }
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " giving card to Papacy");
	    his_self.updateLog(his_self.returnFactionName(faction) + " giving card to Papacy");
	  }

	  return 0;
	}

	return 1;
      },
    }
    deck['060'] = { 
      img : "cards/HIS-060.svg" , 
      name : "Maurice of Saxony" ,
      ops : 4 ,
      turn : 6 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction="") {

        let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
        let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");

	if (
	  (his_self.game.player == his_self.returnPlayerCommandingFaction("hapsburg") && pms != "") ||
	  (his_self.game.player == his_self.returnPlayerCommandingFaction("protestant") && hms != "")
	) { return 1; }

	return 0; 

      } ,
      onEvent : function(his_self, faction) {

        if (faction == "papacy") { faction = "hapsburg"; }

	if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

  	  his_self.playerSelectSpaceWithFilter(
	    "Select Fortified Space for Maurice of Saxony" ,
	    function(space) {
	      if (his_self.isSpaceControlled(space.key, faction) && his_self.isSpaceFortified(space.key)) {
	        return 1;
	      }
	      return 0;
	    },
	    function(spacekey) {
	      his_self.addMove("maurice_of_saxony\t"+faction+"\t"+spacekey);
	      his_self.endTurn();
	    },
	    null,
	    true
	  );

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("060"));
	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "maurice_of_saxony") {

	  let faction = mv[1];
	  let spacekey = mv[2];

          for (let i = 0; i < his_self.game.players.length; i++) {
            let p = his_self.game.state.players_info[i];
            for (let z = 0; z < p.captured.length; z++) {
	      if (p.captured[z].type == "maurice-of-saxony") {
		p.captured[z].splice(z, 1);
	      }
	    }
          }

          his_self.game.queue.splice(qe, 1);
          let ms = his_self.returnSpaceOfPersonage(his_self.game.state.events.maurice_of_saxony, "maurice-of-saxony");

	  if (his_self.game.state.events.maurice_of_saxony != "" || ms != "") {

	    let current_owner = his_self.game.state.events.maurice_of_saxony;
            let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
            let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");
	    if (pms) { ms = pms; current_owner = "protestant"; }
	    if (hms) { ms = hms; current_owner = "hapsburg"; }

	    let loop_length = his_self.game.spaces[ms].units[current_owner].length;
	    for (let i = 0; i < loop_length; i++) {
	      let u = his_self.game.spaces[ms].units[current_owner][i];
	      if (u.type === "mercenary" || u.type === "maurice-of-saxony") {
	        his_self.game.spaces[spacekey].units[faction].push(u);
	        his_self.game.spaces[ms].units[current_owner].splice(i, 1);
		i--;
	        loop_length = his_self.game.spaces[ms].units[current_owner].length;
		if (u.type === "maurice-of-saxony") {
		  u.img = "Maurice_Hapsburg.svg";
		  if (faction === "protestant") {
		    u.img = "Maurice_Protestant.svg";
		  }
		}
	      }
	    }

	  } else {

	    his_self.addArmyLeader(faction, spacekey, "maurice-of-saxony");

	    let current_owner = "protestant";
            let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
            let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");
	    if (pms) { ms = pms; current_owner = "protestant"; }
	    if (hms) { ms = hms; current_owner = "hapsburg"; }

	    let ms_idx = his_self.returnIndexOfPersonageInSpace(faction, "maurice-of-saxony", ms);
	    let u = his_self.game.spaces[ms].units[faction][ms_idx];
	    u.img = "Maurice_Hapsburg.svg";
	    if (faction === "protestant") { u.img = "Maurice_Protestant.svg"; }

	  }
	
	  his_self.game.state.events.maurice_of_saxony = faction;
	  return 1;

	}

	return 1;
      }
    }
    deck['061'] = { 
      img : "cards/HIS-061.svg" , 
      warn : ["protestant"] ,
      name : "Mary Defies Council" ,
      ops : 1 ,
      turn : 7 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['062'] = { 
      img : "cards/HIS-062.svg" , 
      name : "Book of Common Prayer" ,
      warn : ["papacy"] ,
      ops : 2 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { if (his_self.isDebaterCommitted("cranmer-debater")) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {

	let d = his_self.rollDice(6);

        if (d == 3 || d == 4) {
	  his_self.game.queue.push("player_add_unrest\t"+faction+"\tenglish\tcatholic");
	}        
        if (d == 5) {
	  his_self.game.queue.push("player_add_unrest\t"+faction+"\tenglish\tcatholic");
	} 
        if (d == 6) {
	  for (let spacekey in his_self.game.spaces) {
	    if (his_self.game.spaces[spacekey].language == "english" && his_self.game.spaces[spacekey].religion == "catholic") {
	      his_self.game.queue.push("unrest\t"+spacekey);
	    }
          }
	}

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    let dom_img = "cards/HIS-063.svg";
    if (this.game.players.length == 2) { dom_img = "cards/HIS-063-2P.svg"; }
    if (parseInt(this.game.options['game-wizard-players-select']) == 2) {
      dom_img = "cards/HIS-063-2P.svg";
    }
    deck['063'] = { 
      img : dom_img , 
      name : "Dissolution of the Monasteries" ,
      ops : 4 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("discard_random\tpapacy");

	return 1;
      }
    }
    deck['064'] = { 
      img : "cards/HIS-064.svg" , 
      name : "Pilgrimage of Grace" ,
      ops : 3 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === player) {

	    let already_selected = [];

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

		his_self.endTurn();

	   }, null, true);
	   }, null, true);
	   }, null, true);
	   }, null, true);
	   }, null, true);

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("064"));
	}

	   return 0;
      },
    }
    deck['065'] = { 
      img : "cards/HIS-065.svg" , 
      warn : ["papacy"] ,
      name : "A Mighty Fortress" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.isDebaterCommitted("luther-debater")) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	player = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("commit\tprotestant\tluther-debater");

	return 1;
      },
    }
    deck['066'] = { 
      img : "cards/HIS-066.svg" , 
      name : "Akinji Raiders" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	let enemies = his_self.returnEnemies("ottoman");
	let neighbours = [];
	let spaces = his_self.returnSpacesWithFilter(
	  function(spacekey) {
	    if (his_self.game.spaces[spacekey].units["ottoman"].length > 0) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units["ottoman"].length; z++) {
	        if (his_self.game.spaces[spacekey].units["ottoman"][z].type === "cavalry") {
	          if (his_self.isSpaceControlled(spacekey, "ottoman")) {
		    return 1;
		  }
	        }
	      }
	    }
	  }
        );

	//
	// two hops !
	//
	for (let i = 0; i < spaces.length; i++) {
	  let s = his_self.game.spaces[spaces[i]];
	  for (let ii = 0; ii < s.neighbours.length; ii++) {
	    if (!neighbours.includes(s.neighbours[ii])) { neighbours.push(s.neighbours[ii]); }
	  }
	}
	for (let i = 0; i < neighbours.length; i++) {
	  if (his_self.isSpaceControlled(neighbours[i], "ottoman")) {
	    let s = his_self.game.spaces[neighbours[i]];
	    for (let ii = 0; ii < s.neighbours.length; ii++) {
	      if (!neighbours.includes(s.neighbours[ii])) { neighbours.push(s.neighbours[ii]); }
	    }
	  }
	}

	//
	// enemy control any of these neighbours?
	//
	for (let i = 0; i < neighbours.length; i++) {
	  for (let ii = 0; ii < enemies.length; ii++) {
	    if (his_self.isSpaceControlled(neighbours[i], enemies[ii])) {
	      return 1;
	    }
	  }
	}

	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerCommandingFaction(faction);
	let target_which_faction = [];
	let neighbours = [];

	if (his_self.game.player == p) {

	  let enemies = his_self.returnEnemies("ottoman");
	  let spaces = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.game.spaces[spacekey].units["ottoman"].length > 0) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units["ottoman"].length; z++) {
	        if (his_self.game.spaces[spacekey].units["ottoman"][z].type === "cavalry") {
	          if (his_self.isSpaceControlled(spacekey, "ottoman")) {
	  	    return 1;
		  }
	        }     
	      }
	    }
	  });

	  //
	  // two hops !
	  //
	  for (let i = 0; i < spaces.length; i++) {
	    let s = his_self.game.spaces[spaces[i]];
	    for (let ii = 0; ii < s.neighbours.length; ii++) {
	      if (!neighbours.includes(s.neighbours[ii])) { neighbours.push(s.neighbours[ii]); }
	    }
	  }
	  for (let i = 0; i < neighbours.length; i++) {
	    if (his_self.isSpaceControlled(neighbours[i], "ottoman")) {
	      let s = his_self.game.spaces[neighbours[i]];
	      for (let ii = 0; ii < s.neighbours.length; ii++) {
	        if (!neighbours.includes(s.neighbours[ii])) { neighbours.push(s.neighbours[ii]); }
	      }
	    }
	  }

	  //
	  // enemy control any of these neighbours?
	  //
	  for (let i = 0; i < neighbours.length; i++) {
	    for (let ii = 0; ii < enemies.length; ii++) {
	      if (his_self.isSpaceControlled(neighbours[i], enemies[ii])) {
	        if (!target_which_faction.includes(enemies[ii])) { target_which_faction.push(enemies[ii]); }
	      }
	    }
	  }
	}

        let msg = "Steal Random Card from Which Faction?";
        let html = '<ul>';
        for (let i = 0; i < target_which_faction.length; i++) {
           html += '<li class="option" id="${target_which_faction[i]}">${target_which_faction[i]}</li>';
	}
	html += '</ul>';

    	his_self.updateStatusWithOptions(msg, html);

	$('.option').off();
	$('.option').on('click', function () {

	  let action = $(this).attr("id");
	  his_self.addMove("pull_card\tottoman\t"+action);
          his_self.endTurn();

	});

        return 0;
      }
    }
    deck['067'] = { 
      img : "cards/HIS-067.svg" , 
      warn : ["protestant"] ,
      name : "Anabaptists" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let count = his_self.countSpacesWithFilter(function(space) {
	      if (space.religion == "protestant" && his_self.isOccupied(space) == 0 && !his_self.isElectorate(space)) {
		return 1;
	      }
	      return 0;
	  });

          if (count > 0) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select First Space to Convert", 
	      function(space) {
	        if (space.religion == "protestant" && his_self.isOccupied(space) == 0 && !his_self.isElectorate(space)) {
		  return 1;
	        }
	        return 0;
	      },

	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
	        let first_choice = space.key;
	        let spaces = his_self.returnSpacesWithFilter(
          	  function(spacekey) {
		    let s2 = his_self.game.spaces[spacekey];
	            if (s2.religion == "protestant" && his_self.isOccupied(s2.key) == 0 && !his_self.isElectorate(s2.key) && s2.key != first_choice) {
		      return 1;
	            }
	            return 0;
	  	  }
	        );

	        if (spaces.length == 0) {
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
		  his_self.endTurn();
		  return 0;
	        }

                if (count > 1) {
	          his_self.playerSelectSpaceWithFilter(

	            "Select Second Space to Convert", 

	            function(space2) {
	              if (space2.key !== first_choice && space2.religion == "protestant" && his_self.isOccupied(space2.key) == 0 && !his_self.isElectorate(space2.key)) {
		        return 1;
	              }
	              return 0;
		    },

	            function(second_choice) {
		      his_self.addMove("convert\t"+second_choice+"\tcatholic");
		      his_self.addMove("convert\t"+first_choice+"\tcatholic");
		      his_self.endTurn();
	            },
		    null , 
		    true 
	          );
	  	} else {
	          his_self.updateStatus("No acceptable targets for Anabaptists");
	          his_self.endTurn();
	        }
	      },
	      null ,
	      true 
	    );
	  } else {
	    his_self.updateStatus("No acceptable targets for Anabaptists");
	    his_self.endTurn();
	  }
        } else {
          his_self.updateStatus("Papacy playing "+his_self.popup("067"));
        }
        return 0;
      },
    }
    deck['068'] = { 
      img : "cards/HIS-068.svg" , 
      name : "Andrea Doria" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("genoa");
	if (faction !== f) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("genoa");
	his_self.deactivateMinorPower(f, "genoa");
	his_self.activateMinorPower(faction, "genoa");
	return 1;
      },
    }
    deck['069'] = { 
      img : "cards/HIS-069.svg" , 
      name : "Auld Alliance" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("scotland");
        if (faction === "france") {
	  return 1;
	}
        if (faction === "england" && f !== "") {
	  return 1;
	} 
	return 0;
      },
      onEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("scotland");
	if (faction === "england") {
 	  if (f !== "") {
	    his_self.deactivateMinorPower(f, "scotland");
	  }
	}
	if (faction === "france") {
	  if (f == "") {
	    his_self.activateMinorPower(faction, "scotland");
	  } else {
	    if (f === "france") {


	      let p = his_self.returnPlayerOfFaction("france");
	      if (p === his_self.game.player) {

	        //
	        // add upto 3 new French regulars in any Scottishhome space under French control that isnot under siege.
	        //
   	        his_self.playerSelectSpaceWithFilter(

	  	  "Select Unbesieged Scottish Home Space Under French Control", 

		  function(space) {
		    if (space.home == "scotland") {
		      if (his_self.isSpaceControlled(space, "france")) {
		        if (!space.besieged) {
		          return 1;
		        }
		      }
		    }
		  },

		  function(spacekey) {
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
		    his_self.endTurn();
		  }
	        );

		return 0;

	      } else {
		return 0;
	      }
	    } else {
	      his_self.deactivateMinorPower(f, "scotland");
	    }
	  }
	}
	return 1;
      },
    }
    deck['070'] = { 
      img : "cards/HIS-070.svg" , 
      name : "Charles Bourbon" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league != 1) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (p == his_self.game.player) {

	  his_self.playerSelectSpaceWithFilter(

	    "Select Unbesieged Space You Control",

	    function(space) {
	      // 2P must be German or Iralian space
	      if (his_self.game.players.length == 2) { if (space.language != "italian" && space.language != "german") { return 0; } }
	      if (space.besieged) { return 0; }
	      if (his_self.isSpaceControlled(space, faction)) { return 1; }
	      // if at war with France, unoccupied near Lyon is OK
	      if (his_self.areEnemies(faction, "france")) {
	        if (space.neighbours.includes("lyon") && his_self.isUnoccupied(space)) { return 1; }
	      }
	      return 0;
	    },

	    function(spacekey) {
	      let space = his_self.game.spaces[spacekey];
	      his_self.addMove("add_army_leader\t"+faction+"\t"+spacekey+"\t"+"renegade");
	      if (spacekey === "avignon" || spacekey === "grenoble" || spacekey === "geneva" || spacekey === "dijon" || spacekey === "orleans" || spacekey === "limoges") {
                his_self.addMove("control\t"+faction+"\t"+spacekey);
	      }
	      if (faction != "ottoman") {
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
	      } else {
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
	      }
	      his_self.endTurn();
	    },

	    null,

	    true 

	  );
	} else {
	  his_self.updateStatus(his_self.popup("070") + " entering play");
	}

	return 0;
      },
    }
    let csr_img = "cards/HIS-071.svg";
    if (this.game.players.length == 2) { csr_img = "cards/HIS-071-2P.svg"; }
    deck['071'] = { 
      img : csr_img , 
      name : "City State Rebels" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.players.length == 2) {
	  if (his_self.game.state.events.schmalkaldic_league == 1) { 
	    for (let key in his_self.game.spaces) {
	      let space = his_self.game.spaces[key];
              if (space.type == "electorate" && space.political == "hapsburg") { return 1; }
	    }
	  }
	  return 0;
	}
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (p == his_self.game.player) {

	  his_self.playerSelectSpaceWithFilter(

	    "Select Occupied Territory",

	    function(space) {

	      // 2P game - may be played against electorate under Hapsburg Control
	      if (his_self.game.players.length == 2) {
		if (his_self.game.state.events.schmalkaldic_league == 1) { if (space.type == "electorate" && space.political == "hapsburg") { return 1; } }
	        return 0;
	      }

	      if (space.type == "key" && space.home === "independent" && (space.political !== space.home && space.political !== "" && space.political)) { return 1; }

	      if (space.home !== space.political && space.political !== "" && space.type == "key") {
		if (!space.besieged) {
	          if (!his_self.areAllies(space.home, space.political)) { 
		    if (space.home !== "" && space.political !== "") { return 1; }
		  }
	        }
	      }

	      // electorate under hapsburg control
	      if (his_self.game.state.events.schmalkaldic_league == 1) {
		if (his_self.isElectorate(space.key)) {
		  if (his_self.isSpaceControlled(space.key, "hapsburg")) { return 1; }
		}
	      }

	      return 0;
	    },

	    function(spacekey) {
	      his_self.updateStatus("selected");
	      his_self.addMove("city-state-rebels\t"+faction+"\t"+spacekey);
	      his_self.endTurn();
	    },

	    null,

	    true

	  );
	} else {
	  his_self.updateStatus("Opponent playing " + his_self.popup("071"));
	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "city-state-rebels") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let respondent = his_self.returnFactionControllingSpace(spacekey);

          his_self.game.queue.splice(qe, 1);

          his_self.updateLog(his_self.returnFactionName(faction) + " plays " + his_self.popup("071") + " against " + spacekey);

	  let hits = 0;
	  for (let i = 0; i < 5; i++) {
	    let roll = his_self.rollDice(6);
            his_self.updateLog(` ... roll ${5-i}: + ${roll}`);
	    if (roll >= 5) {
	      hits++;
	    }
	  }

	  let p = his_self.returnPlayerCommandingFaction(respondent);
	  if (p == 0) {
	    for (let z = 0, assigned_hits = 0; assigned_hits < hits && z < his_self.game.spaces[spacekey].units[respondent].length; z++) {
	      try {
	        if (his_self.game.spaces[spacekey].units[respondent][z].type == "regular") {
		  his_self.game.spaces[spacekey].units[respondent].splice(z, 1);
		  z--;
	      } } catch (err) {
	      }
	    }
	    his_self.game.queue.push("finish-city-state-rebels\t"+faction+"\t"+respondent+"\t"+spacekey);
	    return 1;
	  }
	  if (his_self.game.player == p) {
	    his_self.addMove("finish-city-state-rebels\t"+faction+"\t"+respondent+"\t"+spacekey);
	    his_self.playerAssignHits(respondent, spacekey, hits, 1);
	  }
	  
	  return 0;
        }


	if (mv[0] === "finish-city-state-rebels") {

          his_self.game.queue.splice(qe, 1);

	  let faction    = mv[1];
	  let respondent = mv[2];
	  let spacekey   = mv[3];
	  let space      = his_self.game.spaces[spacekey];

	  // do land or naval units remain
	  let anything_left = 0; 
	  for (let i = 0; i < space.units[respondent].length; i++) {
	    let u = space.units[respondent][i];
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "squadron" || u.type == "corsair" || u.type != "mercenary") {
	      anything_left = 1;
	    }
	  }

	  if (!anything_left) {

            for (let i = 0; i < space.units[f].length; i++) {
              his_self.captureLeader(faction, respondent, spacekey, space.units[f][i]);
              space.units[f].splice(i, 1);
              i--;
            }
	    let who_gets_control = his_self.returnAllyOfMinorPower(space.home);
	    space.political = who_gets_control;
            his_self.addRegular(space.home, space.key, 1);
          }

	  his_self.displaySpace(spacekey);

	  return 1;
	}

	return 1;

      },
    }
    deck['072'] = { 
      img : "cards/HIS-072.svg" , 
      name : "Cloth Price Fluctuate" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	if (his_self.isSpaceControlled("calais", "england") && his_self.isSpaceControlled("antwerp", "hapsburg")) {

          let p1 = his_self.returnPlayerOfFaction("england");
          let p2 = his_self.returnPlayerOfFaction("hapsburg");

          his_self.game.queue.push("cloth-prices-fluctuate-option1\t"+faction);

          his_self.game.queue.push("hand_to_fhand\t1\t"+p1+"\t"+"england"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p1+"\t"+1);

          his_self.game.queue.push("hand_to_fhand\t1\t"+p2+"\t"+"hapsburg"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p2+"\t"+1);

	} else {

          his_self.game.queue.push("cloth-prices-fluctuate-option2\t"+faction);

	}

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "cloth-prices-fluctuate-option1") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  if (faction === "ottoman") {

	    //
	    // place 2 cavalry in home space not under siege
	    //
	    his_self.playerSelectSpaceWithFilter(
	      "Select Home Space not under Siege",
	      function(space) {
	        if (space.besieged) { return 0; }
	        if (his_self.isSpaceControlled(space, faction)) { return 1; }
	        return 0;
	      },
	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
	        his_self.endTurn();
	      }
	    );

	  } else {

	    //
	    // place 2 mercenaries in home space not under siege
	    //
	    his_self.playerSelectSpaceWithFilter(
	      "Select Home Space not under Siege",
	      function(space) {
	        if (space.besieged) { return 0; }
	        if (his_self.isSpaceControlled(space, faction)) { return 1; }
	        return 0;
	      },
	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
	        his_self.endTurn();
	      }
	    );
	  }
        }


        if (mv[0] == "cloth-prices-fluctuate-option2") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let f = his_self.returnFactionControllingSpace("antwerp");
	  if (f === "") { f = his_self.game.spaces["antwerp"].home; }

	  // f discards a card
          his_self.addMove("discard_random\t"+f);

	  //
	  // add unrest
	  //
          his_self.playerSelectSpaceWithFilter(
	    "Add Unrest",
	    function(space) {
	      if (space.key == "antwerp") { return 1; }
	      if (space.key == "brussels") { return 1; }
	      if (space.key == "amsterdam") { return 1; }
	      if (space.language == "italian") { return 1; }
	      if (space.home == "hapsburg" && space.language == "italian") { return 1; }
	      if (space.home == "hapsburg" && space.language == "german") { return 1; }
	      return 0;
	    },
	    function(unrest_spacekey1) {
              his_self.addMove("unrest\t"+unrest_spacekey1);
              his_self.playerSelectSpaceWithFilter(
  	        "Add Unrest",
	        function(space) {
	          if (space.key == unrest_spacekey1) { return 1; }
	          if (space.key == "antwerp") { return 1; }
	          if (space.key == "brussels") { return 1; }
	          if (space.key == "amsterdam") { return 1; }
	          if (space.language == "italian") { return 1; }
	          if (space.home == "hapsburg" && space.language == "italian") { return 1; }
	          if (space.home == "hapsburg" && space.language == "german") { return 1; }
	        return 0;
	        },
	        function(unrest_spacekey2) {
                  his_self.addMove("unrest\t"+unrest_spacekey2);
	          his_self.endTurn();
	        }
              );
	    }
          );
	  return 0;
	}

	return 1;

      },
    }
    deck['073'] = { 
      img : "cards/HIS-073.svg" , 
      name : "Diplomatic Marriage" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player == p) {

	  let mp = his_self.returnMinorPowers();
	  let ca = [];
	  let cd = [];

	  for (let i = 0; i < mp.length; i++) {
	    if (his_self.canFactionActivateMinorPower(faction, mp[i])) {
	      if (his_self.returnAllyOfMinorPower(mp[i]) == faction) {
	        cd.push(mp[i]);
	      } else {
	        ca.push(mp[i]);
	      }
	    }
	  }
	
	  let msg = 'Activate or De-activate a Minor Power?';
    	  let html = '<ul>';
	  for (let i = 0; i < ca.length; i++) {
            html += `<li class="option" id="${ca[i]}">activate ${ca[i]}</li>`;
	  }
	  for (let i = 0; i < cd.length; i++) {
            html += `<li class="option" id="${cd[i]}">deactivate ${cd[i]}</li>`;
	  }
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {
	    let action = $(this).attr("id");
	    if (ca.includes(action)) {
	      if (faction === "hapsburg" && action == "hungary") {
		his_self.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance = 1;
	      }
	      his_self.addMove("activate_minor_power\t"+faction+"\t"+action);
	    } else {
	      his_self.addMove("deactivate_minor_power\t"+faction+"\t"+action);
	    }
	    his_self.endTurn();
	  });
	}

	return 0;
      },
    }
    deck['074'] = { 
      img : "cards/HIS-074.svg" , 
      name : "Diplomatic Overture" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player != 0) {

	  // deal 2 cards to faction
	  his_self.game.queue.push("diplomatic-overture\t"+faction);
          his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
          his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);

	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "diplomatic-overture") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
	  let does_player_have_non_mandatory_card = false;
	  let does_player_have_non_home_card = false;

	  for (let i = 0; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (his_self.game.deck[0].cards[his_self.game.deck[0].fhand[fhand_idx][i]].type != "mandatory") { does_player_have_non_mandatory_card = true; }
	    if (parseInt(his_self.game.deck[0].fhand[fhand_idx][i]) > 8) { does_player_have_non_home_card = true; }
	  }

	  if (his_self.game.player == p) {

	    his_self.playerSelectFactionWithFilter(
	      "Select Faction to Give Card",
	      function(f) { if (f !== faction) { return 1; } },
	      function(recipient) {
 	        his_self.playerFactionSelectCardWithFilter(
	          faction,
	          "Select Card to Give Away",
	          function(card) {
		    // no to home cards
		    if (parseInt(card) < 9) { return 0; }
		    // no to mandatory events unless I only have them
		    if (his_self.game.deck[0].cards[card].type == "mandatory" && does_player_have_non_mandatory_card) { return 0; }
		    // otherwise yes
		    return 1; 
		  },
	          function(card) {
                    his_self.addMove("give_card\t"+recipient+"\t"+faction+"\t"+card);
	  	    his_self.endTurn();
	          }
	        );
	      }
	    );
	  }
	  return 0;
	}
	return 1;
      },
    }
    deck['075'] = { 
      img : "cards/HIS-075.svg" , 
      name : "Erasmus" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (his_self.game.state.round < 3) {

	  let player = his_self.returnPlayerOfFaction("protestant");

          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	} else {

	  let player = his_self.returnPlayerOfFaction("papacy");   

          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	}

	return 1;
      },
    }
    deck['076'] = { 
      img : "cards/HIS-076.svg" , 
      name : "Foreign Recruits" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction === "protestant") { 
          if (his_self.game.state.activated_powers[faction].length > 0) { return 1; }
	  return 0;
        };
	return 1;
      },
      onEvent : function(his_self, faction) {

	if (his_self.game.state.activated_powers[faction].length > 0) {

	  let msg = "Which Faction gets Recruits?";
    	  let html = '<ul>';
	  if (!(faction == "protestant" && his_self.game.state.events.schmalkaldic_league != 1)) {
            html += `<li class="option" id="${faction}">${his_self.returnFactionName(faction)}</li>`;
	  }
	  for (let i = 0; i < his_self.game.state.activated_powers[faction].length; i++) {
	    let f = his_self.game.state.activated_powers[faction][i];
            html += `<li class="option" id="${f}">${his_self.returnFactionName(f)}</li>`;
 	  }  
 	  html += '</ul>';
    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {
	    his_self.updateStatus("acknowledge");
	    let action = $(this).attr("id");
  	    his_self.playerPlayOps("", action, 4, "build");
	  });

	  return 0;
	}

	//
	// if no activated factions, must be us
	//
	his_self.updateStatus(his_self.returnFactionName(faction) + " playing "+ his_self.popup("076"));
	let player = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player == player) {
	  his_self.game.state.events.foreign_recruits = faction;
  	  his_self.playerPlayOps("", faction, 4, "build");
	}

	return 0;
      },
    }
    deck['077'] = { 
      img : "cards/HIS-077.svg" , 
      name : "Fountain of Youth" ,
      ops : 2 ,
      turn : 2 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.explorations.length > 0 || his_self.game.state.conquests.length > 0) { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {

        let player = his_self.returnPlayerCommandingFaction(faction);

        if (his_self.game.player === player) { 

	  let msg = "Cancel Which Expedition / Conquest?";
          let html = '<ul>';
	  for (let i = 0; i < his_self.game.state.explorations.length; i++) {
	    if (his_self.game.state.explorations[i].round == his_self.game.state.round) {
              html += `<li class="option" id="exploration-${his_self.game.state.explorations[i].faction}">${his_self.returnFactionName(his_self.game.state.explorations[i].faction)} (exploration)</li>`;
	    }
	  }
	  for (let i = 0; i < his_self.game.state.conquests.length; i++) {
	    if (his_self.game.state.conquests[i].round == his_self.game.state.round) {
              html += `<li class="option" id="conquest-${his_self.game.state.conquests[i].faction}">${his_self.returnFactionName(his_self.game.state.conquests[i])} (conquest)</li>`;
	    }
	  }
          html += '</ul>';

 	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    let x = action.split("-");
	    his_self.addMove("display_new_world");
	    if (x[0] === "exploration") {
	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels "+his_self.returnFactionName(x[1])+" exploration");
	      his_self.addMove("remove_exploration\t"+x[1]); 
	    } else {
	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels "+his_self.returnFactionName(x[1])+" conquest");
	      his_self.addMove("remove_conquest\t"+x[1]); 
	    }

	    his_self.endTurn();

	  });
	}
        return 0;
      },
    }
    deck['078'] = { 
      img : "cards/HIS-078.svg" , 
      warn : ["papacy"] ,
      name : "Frederick the Wise" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");

	//
	// protestants get wartburg card if in discards
	//
        if (his_self.game.deck[0].discards["037"]) {
	  his_self.game.deck[0].cards["037"] = his_self.game.deck[0].discards["037"];
	  delete his_self.game.deck[0].discards["037"];
	  if (his_self.game.player == p) {
            let fhand_idx = his_self.returnFactionHandIdx(p, "protestant");
	    his_self.game.deck[0].fhand[fhand_idx].push("037");
	  }
	}

	//
	// protestants can convert german-language space closest to wittenberg
	//
	his_self.game.queue.push("frederick_the_wise\t2");
	his_self.game.queue.push("frederick_the_wise\t1");
	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "frederick_the_wise") {

          his_self.game.queue.splice(qe, 1);
	  let faction = "protestant";
	  let num = mv[1];

	  res = his_self.returnNearestSpaceWithFilter(
	    "wittenberg",
	    function(spacekey) {
	      if (his_self.game.spaces[spacekey].religion == "catholic" && his_self.game.spaces[spacekey].language == "german") { return 1; }
	      return 0;
	    },
	    function(propagation_filter) {
	      return 1;
	    },
	    0,
	    1,
	  );

	  //
	  // if no options, skip
	  //
	  if (res.length <= 0) { 
	    his_self.updateLog("No viable spaces for Frederick the Wise");
	    return 1;
	  }

	  //
	  // otherwise pick closest space
	  //
	  if (his_self.game.player == his_self.returnPlayerOfFaction("protestant")) {
 	    his_self.playerSelectSpaceWithFilter(
  	      "Select Towns to Convert Protestant: ",
	      (space) => {
	        for (let i = 0; i < res.length; i++) { if (space.key == res[i].key) { return 1; } }
	        return 0;
	      },
	      (spacekey) => {
	        his_self.addMove("convert" + "\t" + spacekey + "\t" + "protestant");
	        his_self.endTurn();
	      },
	      null,
	      true
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName("protestant") + " playing " + his_self.popup("078"));
	  }

	  return 0;

	}

	return 1;
      }
    }
    deck['079'] = { 
      img : "cards/HIS-079.svg" , 
      name : "Fuggers" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
      
        his_self.game.queue.push("cards_left\t"+faction+"\t"+(parseInt(his_self.game.state.cards_left[faction])+2));
        his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
        his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
        his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
	his_self.game.state.events.fuggers = faction;

	return 1;
      },
    }
    deck['080'] = { 
      img : "cards/HIS-080.svg" , 
      name : "Gabelle Revolt" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player == p) {

	  let space1 = "";
	  let space2 = "";

          his_self.playerSelectSpaceWithFilter(
	    "Select 1st Unoccupied French Home Space: ",
	    function(space) {
	      if (
		space.home === "france" &&
		!his_self.isOccupied(space)
	      ) {
		return 1;
	      }
	      return 0;
	    },
	    function(spacekey) {

	      space1 = spacekey;

              his_self.playerSelectSpaceWithFilter(
	        "Select 1st Unoccupied French Home Space: ",
	        function(space) {
	          if (
	  	    space.home === "france" &&
	  	    space.key != space1 &&
		    !his_self.isOccupied(space)
	          ) {
		    return 1;
	          }
	          return 0;
	        },
		function(spacekey2) {
		  his_self.updateStatus("adding unrest...");
		  space2 = spacekey2;
		  his_self.addMove("unrest\t"+space1);
		  his_self.addMove("unrest\t"+space2);
		  his_self.endTurn();
		},
		null,
		true
	      );
	    },
	    null,
	    true,
	  );
        }

        return 0;
      },
    }
    deck['081'] = { 
      img : "cards/HIS-081.svg" , 
      name : "Indulgence Vendor" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.game.queue.push("indulgence-vendor\t"+faction);
	his_self.game.queue.push("pull_card\t"+faction+"\tprotestant");

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "indulgence-vendor") {

	  let faction = mv[1];
  
          his_self.game.queue.splice(qe, 1);

	  let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
	  let card = his_self.game.state.last_pulled_card;
	  let ops = his_self.game.deck[0].cards[card].ops;

  	  his_self.game.queue.push("show_overlay\tfaction\tpapacy");
	  for (let i = 0; i < ops; i++) {
  	    his_self.game.queue.push("build_saint_peters");
	  }

  	  his_self.game.queue.push("discard\t"+faction+"\t"+card);

	  return 1;

        }

	return 1;

      },
    }
    deck['082'] = { 
      img : "cards/HIS-082.svg" , 
      name : "Janissaries Rebel" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let at_war = false;
	let f = his_self.returnImpulseOrder();
	for (let i = 0; i < f.length; i++) {
	  if (f[i] !== "ottoman") {
	    if (his_self.areEnemies(f[1], "ottoman")) {
	      at_war = true;
	    }
	  }
	}

	let spaces_to_select = 4;
	if (at_war) { spaces_to_select = 2; }

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].home == "ottoman") { return 1; }
	    return 0;
	  });

	  if (res.length < spaces_to_select) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("janissaries_rebel\t"+faction+"\t"+(spaces_to_select-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "janissaries_rebel") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].home == "ottoman") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("088"));
	  }
  
	  return 0;

	}

	return 1;
      },
    }
    deck['083'] = { 
      img : "cards/HIS-083.svg" , 
      name : "John Zapolya" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	//
	//
	//
	if (his_self.game.spaces["buda"].besieged > 0) {

	} else {

	  if (his_self.game.spaces["buda"].political == "" || his_self.game.spaces["buda"].political === "hungary") {
	    his_self.addRegular("hungary", "buda", 4);
	  } else {
	    his_self.addRegular(his_self.game.spaces["buda"].political, "buda", 4);
	  }
	}

	return 1;
      },
    }
    deck['084'] = { 
      img : "cards/HIS-084.svg" , 
      name : "Julia Gonzaga" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.barbary_pirates) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {
	his_self.game.state.events.julia_gonzaga_activated = 1;
	his_self.game.state.events.julia_gonzaga = "ottoman";

	return 1;
      },
    }
    deck['085'] = { 
      img : "cards/HIS-085.svg" , 
      name : "Katherina Bora" ,
      warn : ["papacy"] ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (!his_self.isDebaterCommitted("luther-debater")) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	//
	// protestant player gets 5 Reformation Attempts
	//
	let p = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	//
	// and commit luther
	//
	his_self.commitDebater("protestant", "luther-debater");
	  
	return 1;
      },
    }
    deck['086'] = { 
      img : "cards/HIS-086.svg" , 
      name : "Knights of St. John" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	//
	// knights are on map
	//
	if (his_self.game.state.knights_of_st_john != "") {

	  let space = his_self.game.spaces[his_self.game.state.knights_of_st_john];

	  let connected = false;
	  if (!his_self.isBesieged(space)) {
            for (let i = 0; i < space.ports.length; i++) {
              let sea = space.ports[i];
              for (let z = 0; z < sea.ports.length; z++) {
                if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
                  connected = true;
                }
              }
            }
          }

	  if (connected) {
	    his_self.game.queue.push("knights_ottoman_pull\tpapacy");
            his_self.game.queue.push("pull_card\tpapacy\tottoman");
	  }

        } else {

	  let p = his_self.returnPlayerOfFaction("hapsburg");
	  if (his_self.game.player === p) {

 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to place Knights of St. John`,

	      (space) => {
		if (space.home === "hapsburg") {
		  if (space.ports.length > 0) { 
		    if (his_self.isSpaceControlled(space.key, "hapsburg")) {
		      return 1;
		    }
		  }
		}
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("knightify_space\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	    
	  } else {
	    his_self.updateStatus("Hapsburgs placing Knights of St. John");
	  }

	  return 0;

	}

        return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "knightify_space") {

          his_self.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let space = his_self.game.spaces[spacekey];

	  space.home = "independent";
	  space.political = "independent";
	  his_self.game.queue.push("fortify\t"+spacekey);

	  return 1;

	}

        if (mv[0] == "knights_ottoman_pull") {

          let faction = mv[1];
          his_self.game.queue.splice(qe, 1);

          let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
          let card = his_self.game.state.last_pulled_card;
          let ops = his_self.game.deck[0].cards[card].ops;

          his_self.game.queue.push("show_overlay\tfaction\tpapacy");
          for (let i = 0; i < ops; i++) {
            his_self.game.queue.push("build_saint_peters");
          }
          his_self.game.queue.push("discard\t"+faction+"\t"+card);

          return 1;

	}

	return 1;
      },
    }
    deck['087'] = { 
      img : "cards/HIS-087.svg" , 
      name : "Mercenaries Demand Pay" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	//
	// protestant player gets 5 Reformation Attempts
	//
	let p = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player == p) {

	  // pick a faction
  	  his_self.playerSelectFactionWithFilter(

	    "Select Faction to Target: ",

	    function(f) {
	      if (f !== faction) { return 1; }
	      return 0;
	    },

	    function (target) {
	      his_self.addMove("mercenaries-demand-pay\t"+target+"\t"+faction);
	      his_self.endTurn();
	    }
	  );
	}
	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "mercenaries-demand-pay") {

          his_self.game.queue.splice(qe, 1);

	  let target = mv[1];
	  let faction = mv[2];
	  let player = his_self.returnPlayerOfFaction(target);

	  his_self.displayModal(his_self.returnFactionName(faction) + " plays Mercenaries Demand Pay");

	  if (player == his_self.game.player) {

            his_self.playerFactionSelectCardWithFilter(

	      target,

	      "Select Card to Discard: ",

	      function(card) {
		let c = his_self.game.deck[0].cards[card];
	        if (c.type === "mandatory") { return 0; }
		return 1;
	      },

	      function(card) {

		let c = his_self.game.deck[0].cards[card].ops;	      

  	  	his_self.game.queue.push("discard\t"+faction+"\t"+card);

		let retained = 2;
		if (c == 2) { retained = 4; }
		if (c == 3) { retained = 6; }
		if (c == 4) { retained = 10; }
		if (c >= 5) {
		  his_self.endTurn();
		  return;
		}

		//
		// player must discard down to N (retained) mercenaries
		//
		his_self.playerRetainUnitsWithFilter(
		  target,
		  function(spacekey, unit_idx) {
		    if (his_self.game.spaces[spacekey].units[target][unit_idx].type == "mercenary") { return 1; }
		    return 0;
		  },
		  retained
		);
	      }
	    );
	  }
	  return 0;
        }
	return 1;
      }
    }
    deck['088'] = { 
      img : "cards/HIS-088.svg" , 
      name : "Peasants' War" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
        let res = his_self.returnSpacesWithFilter(function(spacekey) {
	  if (his_self.isOccupied(spacekey)) { return 0; }
	  if (his_self.game.spaces[spacekey].language == "german") { return 1; }
	  return 0;
	});
	if (res.length > 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].language == "german") { return 1; }
	    return 0;
	  });


	  let spaces_to_select = 5;
	  if (res.length < 5) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("peasants_war\t"+faction+"\t"+(5-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "peasants_war") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

	    //
	    // pick unit on map with player land units and select one to remove
	    //
 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].language == "german") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("088"));
	  }
  
	  return 0;

	}

	return 1;
      }
    }
    deck['089'] = { 
      img : "cards/HIS-089.svg" , 
      name : "Pirate Haven" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	if (his_self.game.state.events.barbary_pirates == 1) {

	  let target_oran = false;
	  let target_tripoli = false;

	  if (his_self.isUnoccupied("oran") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("oran"))) {
	    let oran = his_self.game.spaces["oran"];
	    for (let i = 0; i < oran.ports.length; i++) {
	      let sea = his_self.game.navalspaces[oran.ports[i]];
	      for (let z = 0; z < sea.ports.length; z++) {
	        if (his_self.game.spaces[sea.ports[z]].fortress == 1) {
	          if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
	  	    target_oran = true;
		  }
	        }
	      }
	    }
	  }
	  if (his_self.isUnoccupied("tripoli") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("tripoli"))) {
	    let tripoli = his_self.game.spaces["tripoli"];
	    for (let i = 0; i < tripoli.ports.length; i++) {
	      let sea = his_self.game.navalspaces[tripoli.ports[i]];
	      for (let z = 0; z < sea.ports.length; z++) {
	        if (his_self.game.spaces[sea.ports[z]].fortress == 1) {
	          if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
		    target_tripoli = true;
		  }
	        }
	      }
	    }
	  }

	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("ottoman");

	if (his_self.game.player == p) {
	let target_oran = false;
	let target_tripoli = false;

	if (his_self.isUnoccupied("oran") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("oran"))) {
	  let oran = his_self.game.spaces["oran"];
	  for (let i = 0; i < oran.ports.length; i++) {
	    let sea = oran.ports[i];
	    for (let z = 0; z < sea.ports.length; z++) {
	      if (his_self.game.spaces[sea.ports[z]].fortress == 1) {
	        if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
		  target_oran = true;
		}
	      }
	    }
	  }
	}
	if (his_self.isUnoccupied("tripoli") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("tripoli"))) {
	  let tripoli = his_self.game.spaces["tripoli"];
	  for (let i = 0; i < tripoli.ports.length; i++) {
	    let sea = tripoli.ports[i];
	    for (let z = 0; z < sea.ports.length; z++) {
	      if (his_self.game.spaces[sea.ports[z]].fortress == 1) {
	        if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
		  target_tripoli = true;
		}
	      }
	    }
	  }
	}

   	let msg = "Convert Space into Pirate Haven: ";
        let html = '<ul>';
  	if (target_tripoli) { html += `<li class="option" id="tripoli">Tripoli</li>`; }
  	if (target_oran)    { html += `<li class="option" id="oran">oran</li>`; }
    	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

   	$('.option').off();
	$('.option').on('click', function () {

   	  $('.option').off();
	  let action2 = $(this).attr("id");
	  his_self.updateStatus("converting...");

	  his_self.addMove("pirate_haven\t"+action2);
	  his_self.endTurn();

	});
	}
	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "pirate_haven") {

          his_self.game.queue.splice(qe, 1);
	  let spacekey = mv[1];

	  his_self.addRegular("ottoman", spacekey, 1);
	  his_self.addCorsair("ottoman", spacekey, 2);
	  his_self.game.spaces[spacekey].pirate_haven = 1;
	  his_self.game.spaces[spacekey].fortified = 1;

	  his_self.displaySpace(spacekey);

	  return 1;

	}

        return 1;
      },
    }
    deck['090'] = { 
      img : "cards/HIS-090.svg" , 
      warn : ["papacy"] ,
      name : "Printing Press" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

        his_self.game.state.printing_press_active = 1;

	let p = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['091'] = { 
      img : "cards/HIS-091.svg" , 
      name : "Ransom" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	  if (his_self.game.state.players_info[i].captured.length > 0) {
	    return 1;
	  } 	
	}	
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

  	  //
	  // list of all captured leaders
	  //
	  let captured_leaders = [];
	  let options = [];

	  for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	    for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
	      captured_leaders.push({ faction : his_self.game.state.players_info[i].captured[ii].faction , leader : his_self.game.state.players_info[i].captured[ii].type , player : i , idx : ii });
	      options.push(his_self.game.state.players_info[i].captured[ii].type);
	    } 	
	  }	

   	  let msg = "Select Leader to Ransom: ";
	  let html = '<ul>';
	  for (let i = 0; i < options.length; i++) { html += `<li class="option" id="${i}">${options[i].leader}</li>`; }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

   	  $('.option').off();
	  $('.option').on('click', function () {
   	    $('.option').off();
	    let options_idx = $(this).attr("id");
	    his_self.addMove("ransom\t"+options[options_idx].leader);
	    his_self.endTurn();
	  });

	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "ransom_placement") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let spacekey = mv[2];

	  if (his_self.game.state.ransomed_leader != null) {
	    his_self.game.spaces[spacekey].units[faction].push(his_self.game.state.ransomed_leader);
	    his_self.game.state.ransomed_leader = null;
	  } 

	  return 1;

	}

        if (mv[0] == "ransom") {

          his_self.game.queue.splice(qe, 1);

	  his_self.game.state.ransomed_leader = null;
	  let ransomed_leader_type = mv[1];
	  let ransomed_leader = null;

	  for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	    for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
	      if (his_self.game.state.players_info[i].captured[ii].type == ransomed_leader_type) {
	        randomed_leader = his_self.game.state.players_info[i].captured[ii];
		his_self.game.state.players_info[i].captured.splice(ii, 1);
	      }
	    } 	
	  }	

	  if (ransomed_leader === null) { return; }

	  let player = his_self.returnPlayerOfFaction(ransomed_leader.owner);
	  if (player == his_self.game.player) {

            his_self.playerFactionSelectSpaceWithFilter(

	      ransomed_leader.owner,

	      "Select Fortified Home Space: ",

	      function(spacekey) {
		if (his_self.game.spaces[spacekey].type == "fortress" && his_self.game.spaces[spacekey].home == ransomed_leader.owner) {
		  return 1;
		}
		return 0;
	      },

	      function(space) {
		his_self.addMove("ransom_placement\t"+ransomed_leader.owner+"\t"+space.key);
		his_self.endTurn();
	      }
	    );
	  }
	  return 0;
        }
	return 1;
      }
    }
    deck['092'] = { 
      img : "cards/HIS-092.svg" , 
      warn : ["ottoman"] ,
      name : "Revolt in Egypt" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.revolt_in_egypt == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayEgypt();

        his_self.addRegular("independent", "egypt", 1);
        his_self.addRegular("independent", "egypt", 1);
        his_self.addRegular("independent", "egypt", 1);

        his_self.game.state.events.revolt_in_egypt = 1;

        his_self.game.queue.push("revolt_in_egypt_leader_removal\tottoman");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t3");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t2");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_in_egypt_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

   	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      let space = his_self.game.spaces[key];
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                let u = space.units["ottoman"][i];
	        if (u.army_leader) {
	  	  options.push({ spacekey : key , idx : i , name : u.name });
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

   	      $('.option').off();
	      let options_idx = $(this).attr("id");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tottoman\tland\t"+options[options_idx].spacekey+"\tegypt\t"+options[options_idx].idx);
              his_self.endTurn();

	    });

	  } else {
	    his_self.updateStatus("Ottomans selecting Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "revolt_in_egypt_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["ottoman"].length > 0) {
		  for (let z = 0; z < space.units["ottoman"].length; z++) {
		    let u = space.units["ottoman"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["squadron"];
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                if (space.units["ottoman"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["ottoman"][i].type) && space.units["ottoman"][i].army_leader != true && space.units["ottoman"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["ottoman"][i].type}">${space.units["ottoman"][i].type}</li>`;
		    unittypes.push(space.units["ottoman"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
		  return 0;
		}

          	his_self.removeUnit("ottoman", spacekey, unittype);

		his_self.displaySpace(spacekey);


		console.log("!!!");
		console.log("!!! plague unit removal");
		console.log("!!!");
          	console.log("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tottoman\t"+unittype+"\tegypt");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}

        return 1;
      }
    }
    deck['093'] = { 
      img : "cards/HIS-093.svg" , 
      name : "Revolt in Ireland" ,
      warn : ["england"] ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.revolt_in_ireland == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayIreland();

        his_self.addRegular("independent", "ireland", 1);
        his_self.addRegular("independent", "ireland", 1);
        his_self.addRegular("independent", "ireland", 1);

        his_self.game.state.events.revolt_in_ireland = 1;

	if (faction == "france" || faction == "hapsburg") {
          his_self.game.queue.push("revolt_in_ireland_bonus_resistance\t"+faction);
	}

        his_self.game.queue.push("revolt_in_ireland_leader_removal\tengland");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t4");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t3");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t2");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_in_ireland_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
  
	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

 	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      let space = his_self.game.spaces[key];
              for (let i = 0; i < space.units["england"].length; i++) {
                let u = space.units["england"][i];
	        if (u.army_leader) {
		  options.push({ spacekey : key , idx : i , name : u.name });
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

	      let options_idx = $(this).attr("id");
   	      $('.option').off();

	      his_self.updateStatus("shifting forces to Ireland...");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tengland\tland\t"+options[options_idx].spacekey+"\tireland\t"+options[options_idx].idx);
              his_self.endTurn();

	    });

	  } else {
	    his_self.updateStatus("England choosing Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "revolt_in_ireland_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["england"].length > 0) {
		  for (let z = 0; z < space.units["england"].length; z++) {
		    let u = space.units["england"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["squadron"];
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["england"].length; i++) {
                if (space.units["england"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["england"][i].type) && space.units["england"][i].army_leader != true && space.units["england"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["england"][i].type}">${space.units["england"][i].type}</li>`;
		    unittypes.push(space.units["england"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
		  return 0;
		}

          	his_self.removeUnit("england", spacekey, unittype);

		his_self.displaySpace(spacekey);


		console.log("!!!");
		console.log("!!! plague unit removal");
		console.log("!!!");
          	console.log("remove_unit\t"+land_or_sea+"\t"+"england"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"england"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tengland\t"+unittype+"\tireland");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}


        if (mv[0] == "revolt_in_ireland_bonus_resistance") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  let p = his_self.returnPlayerCommandingFaction(faction);

	  if (his_self.game.player === p) {

            let msg = "Remove 1 Land Unit to Fortify Irish Resistance?";
            let html = '<ul>';
            html += '<li class="option" id="yes">yes</li>';
            html += '<li class="option" id="no">no</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");

	      his_self.updateStatus("acknowledge");

              if (action == "yes") {
		
		//
		// pick unit on map with player land units and select one to remove
		//
 	 	his_self.playerSelectSpaceWithFilter(

		  "Select Space to Remove 1 Land Unit",

		  (space) => { if (his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0) { return 1; } else { return 0; } },

		  (spacekey) => {
		    
      		    let opts = his_self.returnFactionLandUnitsInSpace(faction, spacekey);
		    let space = his_self.game.spaces[spacekey];

            	    let msg = "Remove which Land Unit?";
            	    let html = '<ul>';

		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "cavalry") {
   	                html += `<li class="option" id="${i}">cavalry</li>`;
			break;
		      }
		    }
		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "regular") {
   	                html += `<li class="option" id="${i}">regular</li>`;
			break;
		      }
		    }
		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "mercenary") {
   	                html += `<li class="option" id="${i}">mercenary</li>`;
			break;
		      }
		    }

            	    html += '</ul>';

            	    his_self.updateStatusWithOptions(msg, html);

	            $('.option').off();
        	    $('.option').on('click', function () {

	              let action = parseInt($(this).attr("id"));

		      his_self.updateStatus("removing unit...");
		      his_self.addMove(	"remove_unit" + "\t" +
					"land" + "\t" +
					faction + "\t" +
					space.units[faction][action].type + "\t" +
					space.key );
		      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" removes unit from " + space.key);
		      his_self.endTurn();

		    });
		  },
		);
		return 0;
	      }
              if (action === "no") {
		his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" does not support Irish rebels");
		his_self.endTurn();
	      }
	    });
	  }
	  return 0;
        }
        return 1;
      }
    }
    deck['094'] = { 
      img : "cards/HIS-094.svg" , 
      name : "Revolt of the Communeros" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].language == "spanish") { return 1; }
	    return 0;
	  });


	  let spaces_to_select = 3;
	  if (res.length < 3) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("revolt_of_the_communeros\t"+faction+"\t"+(3-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_of_the_communeros") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

	    //
	    // pick unit on map with player land units and select one to remove
	    //
 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].language == "spanish") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("094"));
	  }
  
	  return 0;

	}

	return 1;
      }
    }
    deck['095'] = { 
      img : "cards/HIS-095.svg" , 
      warn : ["papacy"] ,
      name : "Sack of Rome" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	let regulars_in_rome = 0;
	let sack_of_rome = false;
	for (let i = 0; i < his_self.game.spaces["rome"].units.length; i++) {
	  let u = his_self.game.spaces["rome"].units[i];
	  if (u.type == "regular") { regulars_in_rome++; }
	}

	let max_non_papal_mercenaries = 0;
	let spacekey = "";
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].language == "italian") {
	    let non_papal_mercenaries = 0;
	    for (let f in his_self.game.spaces[key].units) {
	      if (f != "papacy" && his_self.isAlliedMinorPower(f, "papacy") != true) {
		for (let i = 0; i < his_self.game.spaces[key].units[f].length; i++) {
		  let u = his_self.game.spaces[key].units[f][i];
		  if (u.type == "mercenary") {
		    non_papal_mercenaries++;  
		  }
	        }
	      }
	    }
	    if (non_papal_mercenaries > regulars_in_rome && non_papal_mercenaries > max_non_papal_mercenaries) {
	      spacekey = key;
	      max_non_papal_mercenaries = non_papal_mercenaries;
	      sack_of_rome = true;
	    }
	  }
	}
	return sack_of_rome;
      },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.sack_of_rome = 1;

	let regulars_in_rome = 0;
	let sack_of_rome = false;
	for (let i = 0; i < his_self.game.spaces["rome"].units.length; i++) {
	  let u = his_self.game.spaces["rome"].units[i];
	  if (u.type == "regular") { regulars_in_rome++; }
	}

	let max_non_papal_mercenaries = 0;
	let spacekey = "";
	let fact = "";
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].language == "italian") {
	    let non_papal_mercenaries = 0;
	    for (let f in his_self.game.spaces[key].units) {
	      if (f != "papacy" && his_self.isAlliedMinorPower(f, "papacy") != true) {
		for (let i = 0; i < his_self.game.spaces[key].units[f].length; i++) {
		  let u = his_self.game.spaces[key].units[f][i];
		  if (u.type == "mercenary") {
		    non_papal_mercenaries++;  
		    fact = f;
		  }
	        }
	      }
	    }
	    if (non_papal_mercenaries > regulars_in_rome && non_papal_mercenaries > max_non_papal_mercenaries) {
	      spacekey = key;
	      max_non_papal_mercenaries = non_papal_mercenaries;
	      sack_of_rome = true;
	    }
	  }
	}

	if (!sack_of_rome) { return 1; }

	//
	// otherwise we have a field battle
	//
 	his_self.game.spaces["rome"].units[fact] = his_self.game.spaces[spacekey].units[fact];
 	his_self.game.spaces[spacekey].units[fact] = [];
	his_self.game.queue.push("post_sack_of_rome_retreat\t"+fact+"\t"+spacekey);
	his_self.game.queue.push("field_battle\trome\t"+fact);

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "post_sack_of_rome_retreat") {

          let faction = mv[1];
          let spacekey = mv[2];

 	  his_self.game.spaces[spacekey].units[faction] = his_self.game.spaces["rome"].units[faction];
 	  his_self.game.spaces["rome"].units[faction] = [];
	 
	  //
	  // 2P game give cards to Protestants
	  //
	  if (his_self.game.players.length == 2) { faction = "protestant"; }

	  //
	  // if the papacy lost
	  //
	  if (his_self.game.state.field_battle.attacker_hits > his_self.game.state.field_battle.defender_hits) {

	    //
	    // remove this card from game
	    //
	    his_self.removeCardFromGame("095");

	    //
	    // deduct vp
	    //
	    let total_to_deduct = 5;
            his_self.game.state.saint_peters_cathedral['state'] -= total_to_deduct;
            if (his_self.game.state.saint_peters_cathedral['state'] < 0) {
	      let surplus = his_self.game.state.saint_peters_cathedral['state'] * -1;
	      if (his_self.game.state.saint_peters_cathedral['vp'] > 0) {
		his_self.game.state.saint_peters_cathedral['vp']--;
		his_self.game.state.saint_peters_cathedral['state'] = 5 - surplus;
	      } else {
		his_self.game.state.saint_peters_cathedral['state'] = 0;
	      }
	    }

	    //
	    // pull two cards
	    //
	    let faction_cards_left = his_self.game.state.cards_left[faction];
	    if (his_self.game.players.length == 2 || (faction != "hapsburg" || faction != "france")) {
	      let expected = 4;
	      if (!his_self.game.deck[0].discards['005']) { expected--; }
	      if (!his_self.game.deck[0].discards['006']) { expected--; }
	      if (his_self.game.state.cards_left["papacy"] < expected) { expected--; }
	      if (his_self.game.state.cards_left["papacy"] < expected) { expected--; }
	      if (expected >= 2) {
  	        his_self.game.queue.push("sack_of_rome_if_two_surplus_cards_discard\t"+faction+"\t"+faction_cards_left);
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	      }
	      if (expected == 1) {
	        his_self.game.queue.push("NOTIFY\tPapacy has one card available for pull...");
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	      }
	      if (expected == 0) {
	        his_self.game.queue.push("NOTIFY\tPapacy has no cards available for pull...");
	      }
	    } else {
	      his_self.game.queue.push("discard_random\tpapacy");
	      his_self.game.queue.push("discard_random\tpapacy");
	    }

	  }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


	if (mv[0] === "sack_of_rome_if_two_surplus_cards_discard") {

	  let faction = mv[1];
	  let faction_cards_left = parseInt(mv[2]);
	  let cards = [];
	  let surplus_cards = 0;

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
	    for (let i = faction_cards_left; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	      surplus_cards++;
	      cards.push(his_self.game.deck[0].fhand[fhand_idx][i]);
	    }

	    while (surplus_cards > 2) { cards.shift(); surplus_cards--; }
	  
	    if (surplus_cards == 2) {
	      his_self.addMove("select_and_discard\t"+faction+"\t"+JSON.stringify(cards));
	    }
	    his_self.endTurn();
	  }

          return 0;

	}

	return 1;

      },
    }
    deck['096'] = { 
      img : "cards/HIS-096.svg" , 
      name : "Sale of Moluccas" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.newworld['circumnavigation'].faction) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let f = his_self.game.state.newworld['circumnavigation'].faction;
	let p = his_self.returnPlayerCommandingFaction(f);

        his_self.game.queue.push('hand_to_fhand\t1\t' + p + '\t' + faction + "\t1");
        his_self.game.queue.push('DEAL\t1\t' + p + '\t' + 2);
	
	return 1;
      }
    }
    deck['097'] = { 
      img : "cards/HIS-097.svg" , 
      name : "Scots Raid" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.areAllies("france", "scotland")) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	//
	// displace from Stirling
	//
	for (let i = 0; i < his_self.game.spaces["stirling"].units["england"].length; i++) {
	  his_self.game.spaces["london"].units["england"].push(his_self.game.spaces["stirling"].units["england"][i]);
	}
	his_self.game.spaces["stirling"].units["england"] = [];

	if (his_self.game.player === his_self.returnPlayerOfFaction("france")) {

	  //
	  // choose between 3 and 6 OPs
	  //
	  let msg = "Scots Raid: move French Army Leader to Scotland?";
          let html = '<ul>';
          html += '<li class="option" id="yes">Yes (3 OPs)</li>';
          html += '<li class="option" id="no">No (6 OPs)</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

     	  $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");
 	    his_self.updateStatus("acknowledge");

	    if (action === "yes") {

              let msg = "Move Army Leader: ";
              let options = [];
              for (let key in his_self.game.spaces) {
                let space = his_self.game.spaces[key];
                for (let i = 0; i < space.units["france"].length; i++) {
                  let u = space.units["france"][i];
                  if (u.army_leader) {
                    options.push({ spacekey : key , idx : i , name : u.name });
                  }
                }
              }

              let html = '<ul>';
              for (let i = 0; i < options.length; i++) {
                html += `<li class="option" id="${i}">${options[i].name}</li>`;
              }
              html += `<li class="option" id="skip">skip</li>`;
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let options_idx = $(this).attr("id");
		his_self.updateStatus("acknowledge");

                his_self.addMove("ops\tfrance\t097\t3");
                his_self.addMove("move\tfrance\tland\t"+options[options_idx].spacekey+"\tstirling\t"+options[options_idx].idx);
                his_self.endTurn();

              });
	    }

	    if (action === "no") {
              his_self.addMove("ops\tfrance\t097\t3");
	      his_self.endTurn();
	    }

	  });
	}

	return 0;

      },
    }
    deck['098'] = { 
      img : "cards/HIS-098.svg" , 
      name : "Search for Cibola" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.cabot_england == 1) { return 1; }
	if (his_self.game.state.events.cabot_france == 1) { return 1; }
	if (his_self.game.state.events.cabot_hapsburg == 1) { return 1; }
	if (his_self.game.state.colonies.length > 0) { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {

        let player = his_self.returnPlayerCommandingFaction(faction);
        if (his_self.game.player === player) { 

	  let msg = "Cancel Which Expedition?";
          let html = '<ul>';
	  for (let i = 0; i < his_self.game.state.colonies.length; i++) {
            html += `<li class="option" id="${his_self.game.state.colonies[i].faction}">${his_self.returnFactionName(his_self.game.state.colonies[i].faction)}</li>`;
	  }
	  if (his_self.game.state.events.cabot_england == 1) {
            html += `<li class="option" id="cabot_england">sebastian cabot (england)</li>`;
	  }
	  if (his_self.game.state.events.cabot_france == 1) {
            html += `<li class="option" id="cabot_france">sebastian cabot (france)</li>`;
	  }
	  if (his_self.game.state.events.cabot_hapsburg == 1) {
            html += `<li class="option" id="cabot_hapsburg">sebastian cabot (haps)</li>`;
	  }
          html += '</ul>';

 	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    if (action === "cabot_england") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_england\t0"); }
	    if (action === "cabot_hapsburg") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_hapsburg\t0"); }
	    if (action === "cabot_france") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_france\t0"); }
	    if (action === "england") {  his_self.addMove("remove_colony\tengland"); }
	    if (action === "hapsburg") {  his_self.addMove("remove_colony\thapsburg"); }
	    if (action === "france") {  his_self.addMove("remove_colony\tfrance"); }

	    his_self.endTurn();

	  });
	}
        return 0;
      },
    }
    deck['099'] = { 
      img : "cards/HIS-099.svg" , 
      name : "Sebastian Cabot" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      canEvent : function(his_self, faction) {
	if (faction == "protestant" || faction == "england" || faction == "hapsburg") { return 1; }
	return 0;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction == "england" && his_self.game.state.events.cabot_england == 0) { return 1; }
	if (faction == "france" && his_self.game.state.events.cabot_france == 0) { return 1; }
	if (faction == "hapsburg" && his_self.game.state.events.cabot_hapsburg == 0) { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {
	if (faction == "england") { his_self.game.state.events.cabot_england = 1; }
	if (faction == "france") { his_self.game.state.events.cabot_france = 1; }
	if (faction == "hapsburg") { his_self.game.state.events.cabot_hapsburg = 1; }
	his_self.displayExploration();
        return 1;
      },
    }
    deck['100'] = { 
      img : "cards/HIS-100.svg" , 
      name : "Shipbuilding" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction == "protestant") { return 0; }
	return 1;
      },
      onEvent(his_self, faction) {
        his_self.game.queue.push("shipbuilding_action_phase_event\t"+faction+"\t2");
        his_self.game.queue.push("shipbuilding_action_phase_event\t"+faction+"\t1");
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
    
        if (mv[0] == "shipbuilding_action_phase_event") {
    
          his_self.game.queue.splice(qe, 1);
          let faction = mv[1];
	  let num = parseInt(mv[2]);

          let player = his_self.returnPlayerCommandingFaction(faction);

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }

          if (his_self.game.player === player) { 
    
            his_self.playerSelectSpaceWithFilter(

              `Select Space to add ${num} Squadron` ,

              (space) => {
                if (his_self.isSpaceControlled(space.key, faction) && space.home === faction) {
	          if (space.ports.length > 0) {
	   	    return 1;
		  }
		}
		return 0;
	      },

              (spacekey) => {

                let space = his_self.game.spaces[spacekey];

	        if (faction === "ottoman") {
		  if (spacekey === "algiers" || space.pirate_haven == 1) {
                    his_self.addMove("build\tland\t"+faction+"\t"+"squadron"+"\t"+spacekey);
		    his_self.endTurn();
		  } else {

	  	    let msg = "Produce Corsair instead of Squadron?";
          	    let html = '<ul>';
          	    html += '<li class="option" id="corsair">Corsair</li>';
          	    html += '<li class="option" id="squadron">Squadron</li>';
          	    html += '</ul>';

 		    his_self.updateStatusWithOptions(msg, html);

          	    $('.option').off();
	  	    $('.option').on('click', function () {

          	      $('.option').off();
	  	      let unittype = $(this).attr("id");
                      his_self.addMove("build\tland\t"+faction+"\t"+unittype+"\t"+spacekey);
		      his_self.endTurn();

		    });
		  }
		} else {
                  his_self.addMove("build\tland\t"+faction+"\t"+"squadron"+"\t"+spacekey);
		  his_self.endTurn();
		}
	      },
   	      null ,
	      true
	    );
          }
	  return 0;
	}
	return 1;
      },
    }
    deck['101'] = { 
      img : "cards/HIS-101.svg" , 
      name : "Smallpox" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction == "england" || faction == "hapsburg" || faction == "france") { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {
        his_self.game.queue.push("conquer\t"+faction);
	his_self.game.state.events.smallpox = faction;
	his_self.displayConquest();
        return 1;
      },
    }
    deck['102'] = { 
      img : "cards/HIS-102.svg" , 
      name : "Spring Preparations" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_spring_deployment") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('102')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '102', html : `<li class="option" id="102">spring preparations (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "pre_spring_deployment") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('102')) {
	      if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player && his_self.game.players.length == 2) { 
 		return 0;
	      }
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_spring_deployment") {
	  if (his_self.game.player === player) {
            his_self.addMove("spring_preparations\t"+faction);
	    his_self.endTurn();
	  }
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "spring_preparations") {

          let faction = mv[1];

	  let capitals = his_self.returnCapitals(faction);
	  for (let i = 0; i < capitals.length; i++) {
	    his_self.addRegular(faction, capitals[i], 1);
	    his_self.displaySpace(capitals[i]);
	  }

          his_self.game.state.spring_deploy_across_passes.push(faction);
          his_self.game.state.spring_deploy_across_seas.push(faction);
          his_self.game.state.events.spring_preparations = faction;

          his_self.game.queue.splice(qe, 1);
          return 1;

        }

	return 1;

      },
    }
    deck['103'] = { 
      img : "cards/HIS-103.svg" , 
      name : "Threat to Power" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let msg = "Target Which Minor Army Leader?";
          let html = '<ul>';
	  if (his_self.returnSpaceOfPersonage("england", "charles-brandon") != "") {
            html += '<li class="option" id="brandon">Charles Brandon (England)</li>';
	  }
	  if (his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva") != "") {
            html += '<li class="option" id="duke">Duke of Alva (Hapsburgs)</li>';
          }
	  if (his_self.returnSpaceOfPersonage("france", "montmorency") != "") {
            html += '<li class="option" id="montmorency">Montmorency (France)</li>';
          }
	  if (his_self.returnSpaceOfPersonage("ottoman", "ibrahim-pasha") != "") {
            html += '<li class="option" id="pasha">Ibrahim Pasha (Ottomans)</li>';
          }
	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    his_self.addMove("threat_to_power\t"+action);
	    his_self.endTurn();


	  });
	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "threat_to_power") {

	  let leader = mv[1];
	  let faction = "";
	  let leader_found = false;

	  if (leader == "brandon") 	{ leader = "charles-brandon"; faction = "england"; }
	  if (leader == "duke") 	{ leader = "duke-of-alva"; faction = "hapsburg"; }
	  if (leader == "montmorency") { leader = "montmorency"; faction = "france"; }
	  if (leader == "pasha") 	{ leader = "ibrahim-pasha"; faction = "ottoman"; }

	  let r = his_self.rollDice(6);

	  let idx = -1;
	  let s = his_self.returnSpaceOfPersonage(faction, leader);
	  if (s) {
	    idx = his_self.returnIndexOfPersonageInSpace(faction, leader, s); 
	    leader_found = true;
	  }

	  //
	  // removed from game
	  //
	  if (r >= 4) {

	    if (leader_found) {
	      his_self.game.spaces[s].units[faction].splice(idx, 1);
	      his_self.displaySpace(s);
	    }

	  //
	  // temporarily removed from game
	  //
	  } else {

            if (s !== "") {
              idx = his_self.returnIndexOfPersonageInSpace(faction, leader, s);
            }

            let obj = {};
            obj.space = s;
            obj.faction = faction;
            obj.leader = his_self.game.spaces[s].units[faction][idx];

            if (idx != -1) {
              his_self.game.spaces[s].units[faction].splice(idx, 1);
            }

            his_self.game.state.military_leaders_removed_until_next_round.push(obj);

	    his_self.displaySpace(s.key);

            his_self.game.queue.splice(qe, 1);
            return 1;

	  }
        }

	return 1;
      }
    }
    deck['104'] = { 
      img : "cards/HIS-104.svg" , 
      name : "Trace Italienne" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	//if (his_self.game.state.events.schmalkaldic_league != 1 && faction == "protestant") { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          his_self.playerSelectSpaceWithFilter(

            "Select Space to Fortify" ,

            function(space) {
              if (space.type != "fortress" && space.type != "electorate" && space.type != "key") { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.updateStatus("selected...");
	      let s = his_self.game.spaces[spacekey];
	      if (s.home === "independent" && s.political === "") {
	      } else {
		let controller = s.political;
		if (controller == "") { controller = s.home; }
		if (controller == "") { controller = "independent"; }
                his_self.addMove("build\tland\t"+controller+"\t"+"regular"+"\t"+spacekey);
	      }
	      his_self.addMove(`NOTIFY\t${his_self.returnFactionName(faction)} adds fortress to ${his_self.returnName(spacekey)}`);
              his_self.addMove("fortify\t"+spacekey);
	      his_self.endTurn();
            },

	    null,

	    true

          );
        } else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("104"));;
	}

        return 0;
      },
    }
    deck['105'] = { 
      img : "cards/HIS-105.svg" , 
      name : "Treachery!" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let spaces_under_siege = his_self.countSpacesWithFilter(
	  function(space) {
	    if (
	      space.besieged > 0
	    ) {
	      return 1;
	    }
	    return 0;
	  }
	);
	if (spaces_under_siege > 0) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          his_self.playerSelectSpaceWithFilter(

            "Select Space Under Siege:" ,

            function(space) {
              if (space.besieged > 0) { return 1; }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let attacker = "";

	      for (let key in space.units) {
		for (let i = 0; i < space.units[key].length; i++) {
		  let u = space.units[key][i];
		  if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
		    if (space.units[key][i].besieged != 1 && space.units[key][i].besieged != true) {
		      attacker = key;
		      if (attacker == "protestant" || attacker == "papacy" || attacker == "hapsburg" || attacker == "ottoman" || attacker == "england" || attacker == "france") { break; }
		    }
		  }
		}
	      }
	      // emergency sanity check -- anyone
	      if (attacker == "") {
		for (let key in space.units) {
		  for (let z = 0; z < space.units[key].length; z++) {
		    let u = space.units[key][z];
		    if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { attacker = key; }
		  }
	        }
	      }	      


	      if (attacker != "") {
                his_self.addMove("treachery\t"+attacker+"\t"+spacekey);
	        his_self.addMove("assault\t"+attacker+"\t"+spacekey);
                his_self.endTurn();
	      } else {
                his_self.addMove("NOTIFY\t"+his_self.popup("105") + " cannot find attacker in siege");
                his_self.endTurn();
	      }
            }
          );

          return 0;
        }
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "treachery") {

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = "";

	  let defenders = [];
	  let space = his_self.game.spaces[spacekey];

	  let total_attackers = 0;
	  let total_defenders = 0;

	  for (let key in space.units) {
	    if (space.units[key].length > 0) {
	      if (space.units[key][0].besieged > 0) {
		total_defenders += his_self.returnFactionLandUnitsInSpace(key, spacekey);
		defenders.push(key);
	      }
	      if (space.units[key][0].besieged == 0) {
		total_attackers += his_self.returnFactionLandUnitsInSpace(key, spacekey);
	      }
	    }
	  }

	  if (total_defenders < total_attackers) {
	    his_self.game.queue.push(`control\t${attacker}\t${spacekey}`);
	    his_self.updateLog(his_self.popup("105") + " - besiegers capture defenders and control space");
	    for (let i = 0; i < defenders.length; i++) {
	      his_self.game.queue.push(`purge_units_and_capture_leaders\t${defenders[i]}\t${attacker}\t${spacekey}`);
	    }
	  }

          his_self.game.queue.splice(qe, 1);
	  
	}

        return 1;
      },
    }
    deck['106'] = { 
      img : "cards/HIS-106.svg" , 
      name : "Unpaid Mercenaries" ,
      ops : 4 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let spaces_with_mercenaries = his_self.countSpacesWithFilter(
	  function(space) {
	    for (let key in space.units) {
	      for (let i = 0; i < space.units[key].length; i++) {
		if (space.units[key][i].type == "mercenary") { return 1; }
	      }
	    }
	    return 0;
	  }
	);
	if (spaces_with_mercenaries > 0) { 
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          his_self.playerSelectSpaceWithFilter(

            "Select Space With Unpaid Mercenaries" ,

            function(space) {
	      for (let key in space.units) {
	        for (let i = 0; i < space.units[key].length; i++) {
	  	  if (space.units[key][i].type == "mercenary") { return 1; }
	        }
	      }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let factions = [];

	      for (let key in space.units) {
		for (let i = 0; i < space.units[key].length; i++) {
		  if (space.units[key][i].type == "mercenary") {
		    if (!factions.includes(key)) {
		      factions.push(key);
		    }
		  }
		}
	      }

	      if (factions.length > 0) {

 	        let msg = "Choose Faction to Lose Mercenaries:";
                let html = '<ul>';
	        for (let i = 0; i < factions.length; i++) {
                  html += `<li class="option" id="${factions[i]}">${factions[i]}</li>`;
		}
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

 		$('.option').off();
	  	$('.option').on('click', function () {

 		  $('.option').off();
	    	  let action = $(this).attr("id");

		  for (let z = 0; z < his_self.game.spaces[spacekey].units[action].length; z++) {
		    if (his_self.game.spaces[spacekey].units[action][z].type === "mercenary") {
		      his_self.addMove(`destroy_unit_by_index\t${action}\t${spacekey}\t${z}`);
		    }
		  }
		  his_self.addMove(`NOTIFY\t${his_self.popup("106")} destroys all mercenaries in ${his_self.returnSpaceName(spacekey)}`);
		  his_self.endTurn();
		});

	      } else {
		for (let z = 0; z < his_self.game.spaces[spacekey].units[factions[0]].length; z++) {
		  his_self.addMove(`destroy_unit_by_index\t${factions[0]}\t${spacekey}\t${z}`);
		}
		his_self.endTurn();
	      }
            },

	    null,

	    true
          );

        }

        return 0;
      },
    }
    deck['107'] = { 
      img : "cards/HIS-107.svg" , 
      name : "Unsanitary Camp" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let sswf_function = () => {

          his_self.playerSelectSpaceWithFilter(

            "Select Space With Land Units" ,

            function(space) {
	      for (let key in space.units) {
	        if (his_self.returnFactionLandUnitsInSpace(key, space.key) > 0) { return 1; }
	      }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let factions = [];

	      for (let key in space.units) {
	        if (his_self.returnFactionLandUnitsInSpace(key, space.key) > 0) { factions.push(key); }
	      }

	      if (factions.length > 0) {

 	        let msg = "Choose Faction to Suffer Losses:";
                let html = '<ul>';
		let op = 0;
	        for (let i = 0; i < factions.length; i++) {
		  op++;
                  html += `<li class="option" id="${factions[i]}">${factions[i]}</li>`;
		}
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

 		$('.option').off();
	  	$('.option').on('click', function () {

 		  $('.option').off();
	    	  let action = $(this).attr("id");

		  if (his_self.game.player == his_self.returnPlayerCommandingFaction(action)) {
                    let c = confirm("Unorthodox! Are you sure you want to sicken your own men?");
                    if (!c) { sswf_function(); return; }
            	  }

		  let total_units = 0;
		  let regular_units = 0;
		  let total_to_delete = 0;
		  let regulars_to_delete = 0;
		  let nonregulars_to_delete = 0;

		  for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		    let u = his_self.game.spaces[spacekey].units[action][z];
		    if (u.type == "regular") { regular_units++; }
		    if (u.type == "cavalry" || u.type == "regular" || u.type == "mercenary") { total_units++; }
		  }

		  total_to_delete = Math.ceil(total_units/3);
		  regulars_to_delete = Math.ceil(total_to_delete/2);
		  nonregulars_to_delete = total_to_delete - regulars_to_delete;
		
		  for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		    let u = his_self.game.spaces[spacekey].units[action][z];
		    if (u.type == "regular" && regulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		      regulars_to_delete--;
		    }
		    if (u.type != "regular" && nonregulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		      nonregulars_to_delete--;
		    }
		  }

		  if (total_to_delete > 1) {
		    his_self.addMove(`SALERT\tUnsanitary Camp destroys ${total_to_delete} ${his_self.returnFactionName(action)} units in ${his_self.returnSpaceName(spacekey)}`); 
		  } else {
		    his_self.addMove(`SALERT\tUnsanitary Camp destroys ${total_to_delete} ${his_self.returnFactionName(action)} units in ${his_self.returnSpaceName(spacekey)}`); 
		  }
		  his_self.addMove(`NOTIFY\t${his_self.popup("107")} strikes ${his_self.returnSpaceName(spacekey)}`); 
		  his_self.endTurn();
		});

	        // auto-submit if only 1 choice
                if (op == 1) { $('.option').click(); }

	      } else {

		let action = factions[0];
		let total_units = 0;
		let regular_units = 0;
		let total_to_delete = 0;
		let regulars_to_delete = 0;
		let nonregulars_to_delete = 0;

		for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		  let u = his_self.game.spaces[spacekey].units[action][z];
		  if (u.type == "regular") { regular_units++; }
		  if (u.type == "cavalry" || u.type == "regular" || u.type == "mercenary") { total_units++; }
		}

		total_to_delete = Math.ceil(total_units/3);
		regulars_to_delete = Math.ceil(total_to_delete/2);
		nonregulars_to_delete = total_to_delete - regulars_to_delete;
		
		for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		  let u = his_self.game.spaces[spacekey].units[action][z];
		  if (u.army_leader != true) {
		    if (u.type == "regular" && regulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		    }
		    if ((u.type != "regular" && (u.type == "mercenary" || u.type == "cavalry")) && nonregulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		      nonregulars_to_delete--;
		    }
		  }
		}
		his_self.endTurn();
	      }
            },

	    null,

	    true
          );

	  } // sswf
	  sswf_function();

        } else {
	  his_self.updateLog(his_self.returnFactionName(faction) + " playing " + his_self.popup("107"));
	}
        return 0;
      },
    }
    deck['108'] = { 
      img : "cards/HIS-108.svg" , 
      name : "Venetian Alliance" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	if (faction == "papacy") { return 1; }
	if (faction == "ottoman") { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let ally = his_self.returnAllyOfMinorPower("venice");

	if ((ally === "" || ally === "venice") && faction === "papacy") {
	  his_self.activateMinorPower("papacy", "venice");
	} else {
	  if (faction === "papacy" || faction === "ottoman") {
	    his_self.deactivateMinorPower("hapsburg", "venice");
	  }
	}
	his_self.displayWarBox();

	return 1;

      },
    }
    deck['109'] = { 
      img : "cards/HIS-109.svg" , 
      name : "Venetian Informant" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_spring_deployment") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('109')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '109', html : `<li class="option" id="109">venetian informant (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "pre_spring_deployment") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('109')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_spring_deployment") {
	  if (his_self.game.player === player) {
            his_self.addMove("discard\t"+faction+"\t109");
            his_self.addMove("venetian_informant\t"+faction);
            his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("109"));
	    his_self.endTurn();
	  }
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "show_hand") {
        
          let faction_taking = mv[1];
          let faction_giving = mv[2];
          
          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);
          
          if (his_self.game.player == p2) {
            let fhand_idx = his_self.returnFactionHandIdx(p2, faction_giving);
            his_self.addMove("share_hand\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;

        }

        if (mv[0] === "share_hand") {
        
          let faction_taking = mv[1];
          let faction_giving = mv[2];
          let cards = JSON.parse(mv[3]);

	  his_self.deck_overlay.render("Venetian Informant", cards);
          
          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);
          
          if (his_self.game.player == p1) {

	    for (let i = 0; i < cards.length; i++) {
	      his_self.updateLog(his_self.returnFactionName(faction_giving) + ": " + his_self.popup(cards[i]));
	    }
          }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


        if (mv[0] == "venetian_informant") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (player == his_self.game.player) {

	    if (his_self.game.players.length == 2) {

	      if (faction === "protestant") {
	        his_self.addMove("show_hand\tprotestant\tpapacy");
	        his_self.endTurn();
	      } else {
	        his_self.addMove("show_hand\tpapacy\tprotestant");
	        his_self.endTurn();
	      }

	      return 0;

	    } else {

	      let powers = his_self.returnImpulseOrder();
	      let msg = "View which Faction Cards?";

              let html = '<ul>';
	      for (let i = 0; i < powers.length; i++) {
	        if (powers[i] != faction && his_self.returnPlayerCommandingFaction(powers[i]) > 0) {
                  html += `<li class="option" id="${powers[i]}">${his_self.returnFactionName(powers[i])}</li>`;
	        }
	      }
              html += '</ul>';

    	      his_self.updateStatusWithOptions(msg, html);

	      $('.option').off();
	      $('.option').on('click', function () {
	        $('.option').off();
	        let action = $(this).attr("id");
	        his_self.addMove("show_hand\t"+faction+"\t"+action);
	        his_self.endTurn();
	      });

	    }

	  }

	  return 0;

        }

	return 1;

      },
    }
    deck['110'] = { 
      img : "cards/HIS-110.svg" , 
      name : "War in Persia" ,
      warn : ["ottoman"] ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.war_in_persia == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayPersia();

        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);

        his_self.game.state.events.war_in_persia = 1;

        his_self.game.queue.push("war_in_persia_leader_removal\tottoman");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t5");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t4");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t3");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t2");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "war_in_persia_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

   	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      let space = his_self.game.spaces[key];
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                let u = space.units["ottoman"][i];
	        if (u.army_leader) {
	          options.push({ spacekey : key , idx : i , name : u.name });
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

   	      $('.option').off();
	      let options_idx = $(this).attr("id");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tottoman\tland\t"+options[options_idx].spacekey+"\tpersia\t"+options[options_idx].idx);
              his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus("Ottomans selecting Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "war_in_persia_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["ottoman"].length > 0) {
		  for (let z = 0; z < space.units["ottoman"].length; z++) {
		    let u = space.units["ottoman"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["squadron","corsair"]; // avoids listing these units
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                if (space.units["ottoman"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["ottoman"][i].type) && space.units["ottoman"][i].army_leader != true && space.units["ottoman"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["ottoman"][i].type}">${space.units["ottoman"][i].type}</li>`;
		    unittypes.push(space.units["ottoman"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
//		  return 0;
		}

          	his_self.removeUnit("ottoman", spacekey, unittype);

		his_self.displaySpace(spacekey);

		if (num === "5th") { 
		  return 0;
		}

          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tottoman\t"+unittype+"\tpersia");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}

        return 1;
      }
    }
    deck['111'] = { 
      img : "cards/HIS-111.svg" , 
      name : "Colonial Governor/Native Uprising" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player == p) {

          let html = '<ul>';
              html += `<li class="option" id="hapsburg">Hapsburg Governor</li>`;
              html += `<li class="option" id="england">English Governor</li>`;
              html += `<li class="option" id="france">French Governor</li>`;
              html += '</ul>';

          his_self.updateStatusWithOptions("Select Colonial Governor", html);

 	  $('.option').off();
	  $('.option').on('click', function () {
 	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.addMove("display_new_world");
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" selected " + his_self.returnFactionName(action) + " governor");
	    his_self.addMove("SETVAR\tstate\tevents\tcolonial_governor\t"+action);
	    his_self.endTurn();	    
	  });

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " selecting Colonial Governor");
	}

	return 0;

      },
    }
    deck['112'] = { 
      img : "cards/HIS-112.svg" , 
      name : "Thomas More" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (faction === "protestant" || faction === "england") {

	  let p = his_self.returnPlayerCommandingFaction("england");

          his_self.game.state.events.more_executed_limits_debates = 1;
	  his_self.game.state.events.more_executed = 1;

	  if (p > 0) {
            his_self.game.queue.push('remove\t'+faction+'\t112');
            his_self.game.queue.push('select_and_discard\t' + faction);
            his_self.game.queue.push('hand_to_fhand\t1\t' + p + '\t' + faction + "\t1");
            his_self.game.queue.push('DEAL\t1\t' + p + '\t' + 2);
	  }
          his_self.game.queue.push("NOTIFY\tThomas More prevents debates in England this turn");

	} else {

	  his_self.game.state.events.more_bonus = 1;
	  if (his_self.game.state.events.henry_viii_marital_status >= 2) {
            his_self.game.queue.push('remove\t'+faction+'\t112');
	  }

	  //
	  // pope gets to call a debate and gets +1 bonus dice in England 
	  // or +3 bonus dice in England.
	  //
	  if (his_self.returnPlayerCommandingFaction("papacy") == his_self.game.player) {

            let msg = "Convene Theological Debate?";
            let html = '<ul>';
            html += `<li class="option" id="yes">yes</li>`;
            html += `<li class="option" id="no">no</li>`;
            html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action2 = $(this).attr("id");
              his_self.updateStatus("submitting...");

              if (action2 === "yes") {
                his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
                return 0;
              }

              // no
              his_self.updateLog("Papacy refrains from holding debate");
              his_self.endTurn();

            });

	  }

	  return 0;

	}

	return 1;
      },

    }
    deck['113'] = { 
      img : "cards/HIS-113.svg" , 
      name : "Imperial Coronation" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) {
	let s = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	if (s) { if (s.language == "italian") { return 1; } }
	return 0;
      },
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let s = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	if (s) {
	  try { if (his_self.game.spaces[s]) { s = his_self.game.spaces[s]; } } catch (err) {}
	  if (s.language == "italian") {

    	    let hp = his_self.returnPlayerOfFaction("hapsburg");
  	    let pf = his_self.returnPlayerOfFaction(faction);

	    if (his_self.game.players.length != 2) {
	      his_self.game.queue.push("hand_to_fhand\t1\t"+hp+"\t"+"hapsburg"+"\t1");
              his_self.game.queue.push(`DEAL\t1\t${hp}\t1`);
	    }
	    if (faction !== "hapsburg") {
	      his_self.game.queue.push("hand_to_fhand\t1\t"+pf+"\t"+faction+"\t1");
              his_self.game.queue.push(`DEAL\t1\t${pf}\t1`);
	    }
	  }
	}

	return 1;
      },
    }
    deck['114'] = { 
      img : "cards/HIS-114.svg" , 
      name : "La Forets's Embassy in Istanbul" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { if (his_self.areAllies("ottoman", "france")) { return 1; } return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (his_self.areAllies("ottoman", "france")) {

  	  let fp = his_self.returnPlayerOfFaction("france");
  	  let op = his_self.returnPlayerOfFaction("ottoman");

	  his_self.game.queue.push("hand_to_fhand\t1\t"+op+"\t"+"ottoman" + "\t1");
          his_self.game.queue.push(`DEAL\t1\t${op}\t1`);
	  his_self.game.queue.push("hand_to_fhand\t1\t"+op+"\t"+"france" + "\t1");
          his_self.game.queue.push(`DEAL\t1\t${fp}\t1`);
	
	}

	return 1;
      },
    }
    deck['115'] = { 
      img : "cards/HIS-115.svg" , 
      name : "Thomas Cromwell" ,
      ops : 3 ,
      turn : 4 ,
      type : "response" ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerCommandingFaction(faction);

	if (his_self.game.player == p) {

   	let msg = "Which Action?";
        let html = '<ul>';
        if (his_self.game.deck[0].discards["063"]) {
          html += '<li class="option showcard" id="063">retrieve Dissolution of the Monasteries</li>';
        }
        html += '<li class="option" id="treatise">publish treatise in England</li>';
    	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

	$('.option').off();
	$('.option').on('click', function () {

	  $('.option').off();
	  let action = $(this).attr("id");
	  his_self.updateStatus("processing");

	  if (action === "063") {
	    his_self.addMove("thomas_cromwell_retrieves_monasteries");
	    his_self.endTurn();
	  }
	
	  if (action === "treatise") {
	    his_self.addMove("player_publish_treatise\tengland");
	    his_self.endTurn();
	  }

	  return 0;
	});

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("115") );
	}
	return 0;
      },
      removeFromDeckAfterPlay : function(his_self, player) {
	if (his_self.game.state.henry_viii_rolls.includes(1)) { return 1; }
	if (his_self.game.state.henry_viii_rolls.includes(2)) { return 1; }
	if (his_self.game.state.henry_viii_rolls.includes(3)) { return 1; }
	return 0;
      },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "papal_bull_cranmer_excommunication") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('115')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '115', html : `<li class="option" id="115">thomas cromwell (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "papal_bull_cranmer_excommunication") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('115')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "papal_bull_cranmer_excommunication") {
	  his_self.addMove(`thomas_cromwell_cancels_bull`);
  	  his_self.addMove("discard\t"+faction+"\t"+"115");
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

	if (mv[0] === "thomas_cromwell_retrieves_monasteries") {
          if (his_self.game.deck[0].discards["063"]) {
	    his_self.game.deck[0].cards["063"] = his_self.game.deck[0].discards["063"];
	    delete his_self.game.deck[0].discards["063"];
	    if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {
              let fhand_idx = his_self.returnFactionHandIdx(p, "england");
	      his_self.game.deck[0].fhand[fhand_idx].push("063");
	    }
	  }
	  return 1;
	}

        if (mv[0] === "thomas_cromwell_cancels_bull") {
	  his_self.updateLog("Thomas Cromwell cancels Cranmer Excommunication");
	  // cancel the excommunication and fall through
          his_self.game.queue.splice(qe, 1);
          his_self.game.queue.splice(qe-1, 1);
	  return 1;
	}

	return 1;
      },
    }
    deck['116'] = { 
      img : "cards/HIS-116.svg" , 
      name : "Rough Wooing" ,
      ops : 3 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.henry_viii_healthy_edward == 1 || his_self.game.state.henry_viii_sickly_edward == 1) {
	  if (his_self.areAllies("france", "scotland")) {
	    return 1;
	  }
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let england_roll = his_self.rollDice(6);
	let france_roll = his_self.rollDice(6);
	let spaces = ["stirling","glasgow","edinburgh"];


	let english_units = 0;
	let french_units = 0;

	for (let i = 0; i < spaces.length; i++) {
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["england"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["england"][i];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { english_units++; }
	  }
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["france"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["france"][i];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { french_units++; }
	  }
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["scotland"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["scotland"][i];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { french_units++; }
	  }
	}
	
	his_self.updateLog("French roll: " + france_roll + " (+2)");
	his_self.updateLog("English roll: " + england_roll);

	if ((2+french_units) <= english_units) {
	  his_self.unsetAllies("france","scotland");
	  his_self.setAllies("england","scotland");
	  for (let i = 0; i < spaces.length; i++) {
	    for (let z = 0; z < his_self.game.spaces[spaces[i]].units["france"].length; z++) {
	      if (his_self.game.spaces[spaces[i]].units["france"][z].type == "squadron") {
	        his_self.game.spaces["paris"].units["rouen"].push(his_self.game.spaces[spaces[i]].units["france"][z]);
	      } else {
	        his_self.game.spaces["paris"].units["france"].push(his_self.game.spaces[spaces[i]].units["france"][z]);
	      }
	    }
	    his_self.game.spaces[spaces[i]].units["france"] = [];
	  }
	  his_self.updateLog("Scotland becomes an English ally...");
	}

	return 1;

      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; }
    }


    //
    // cards removed from 2P game
    //
if (this.game.players.length == 2) {
    delete deck["001"];
    delete deck["002"];
    delete deck["003"];
    delete deck["004"];
    delete deck["009"];
    delete deck["018"];
    delete deck["030"];
    delete deck["034"];
    delete deck["040"];
    delete deck["042"];
    delete deck["048"];
    delete deck["049"];
    delete deck["050"];
    delete deck["053"];
    delete deck["054"];
    delete deck["058"];
    delete deck["059"];
    delete deck["066"];
    delete deck["068"];
    delete deck["069"];
    delete deck["072"];
    delete deck["073"];
    delete deck["074"];
    delete deck["077"];
    delete deck["080"];
    delete deck["082"];
    delete deck["083"];
    delete deck["084"];
    delete deck["086"];
    delete deck["087"];
    delete deck["089"];
    delete deck["092"];
    delete deck["093"];
    delete deck["094"];
    delete deck["096"];
    delete deck["097"];
    delete deck["098"];
    delete deck["099"];
    delete deck["100"];
    delete deck["101"];
    delete deck["103"];
    delete deck["108"];
    delete deck["110"];
    delete deck["111"];
    delete deck["112"];
    delete deck["113"];
    delete deck["114"];
    delete deck["115"];
    delete deck["116"];

}
if (this.game.options.scenario === "1532" && include_removed == false) {

    delete deck["008"];
    delete deck["009"];
    delete deck["010"];
    delete deck["011"];
    // deleted on creation
    //delete deck["013"];
    delete deck["038"];
    delete deck["039"];
    delete deck["041"];
    delete deck["043"];
    delete deck["078"];
    delete deck["083"];
    delete deck["085"];
    delete deck["088"];
    delete deck["095"];
    delete deck["096"];
    delete deck["112"];
    delete deck["113"];
}
if (this.game.state) {
  if (this.game.state.removed && include_removed == false) {
    for (let z = 0; z < this.game.state.removed.length; z++) {
console.log("DELETING Z: " + z);
      try { delete deck[this.game.state.removed[z]]; } catch (err) {}
    }
  }
}

    for (let key in deck) {
      deck[key].key = key;
      deck[key] = this.addEvents(deck[key]);
      if (!deck[key].warn) { deck[key].warn = []; }
    }

    return deck;

  }



  returnSpaceName(spacekey) {
    if (this.game.spaces[spacekey]) { return this.game.spaces[spacekey].name; }
    if (this.game.navalspaces[spacekey]) { return this.game.navalspaces[spacekey].name; }
    return spacekey;
  }

 
  moveFactionUnitsInSpaceToCapitalIfPossible(faction, spacekey) {

    let space = this.game.spaces[spacekey];
    let cap = this.returnControlledCapitals(faction);
    let cap_idx = 0;
    
    //
    // do not control capital? remove
    //
    if (cap.length == 0) {
      for (let z = 0; z < space.units[faction].length; z++) {
        let u = space.units[faction][z];
        if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "corsair" || u.type == "squadron") {
          space.units[faction].splice(z, 1);
          z--;
        }
      }
      return;
    }

    //
    // otherwise move to capital, randomly
    //
    for (let ii = 0; ii < space.units[faction].length; ii++) {
      let u = space.units[faction][ii];
      if (u.type === "cavalry" || u.type === "regular" || u.type === "mercenary") {
        if (cap.length > 0) {
          let selected_capital = cap[cap_idx];
          cap_idx++;
          if ((cap_idx+1) > cap.length) { cap_idx = 0; }
          this.game.spaces[selected_capital].units[faction].push(u);
        }
        space.units[faction].splice(ii, 1);
        ii--;
      }
    }
  }       

 

  resetBesiegedSpaces() {
    for (let space in this.game.spaces) {
      if (space.besieged == 2) { space.besieged = 1; }
    }
  }
  removeBesiegedSpaces() { this.removeSieges(); }
  removeSieges() {
    for (let space in this.game.spaces) {
      if (space.besieged > 0) {
        this.removeSiege(space);
	this.displaySpace(space);
      }
    }
  }
  removeSiege(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.besieged = 0;
    for (let key in space.units) {
      for (let i = 0; i < space.units[key].length; i++) {
        space.units[key][i].besieged = 0;
        space.units[key][i].relief_force = 0;
      }
    }
  }

  resetLockedTroops() {
    for (let space in this.game.spaces) {
      for (let f in this.game.spaces[space].units) {
        for (let z = 0; z < this.game.spaces[space].units[f].length; z++) {
          this.game.spaces[space].units[f][z].locked = false;
        }
      }
    }
  }

  addUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.unrest = 1;
  }

  removeUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.unrest = 0;
  }

  hasProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units["protestant"].length; i++) {
      let unit = space.units["protestant"][i];
      if (unit.reformer) { return true; }
    }
    for (let i = 0; i < space.units["england"].length; i++) {
      let unit = space.units["england"][i];
      if (unit.reformer) { return true; }
    }
    for (let i = 0; i < space.units["france"].length; i++) {
      let unit = space.units["france"][i];
      if (unit.reformer) { return true; }
    }
    return false;
  }



  hasProtestantLandUnits(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    //
    // only protestant units count
    //
    for (let i = 0; i < space.units["protestant"].length; i++) {
      let unit = space.units["protestant"][i];
      if (unit.type == "regular" || unit.type == "mercenary") { return true; }
    }

    //
    // unless Edward VI or Elizabeth I are on the throne
    //
    if (this.game.state.leaders.edward_vi == 1 || this.game.state.leaders.elizabeth_i == 1) {

      //
      // then british mercenaries and regulars count
      //
      for (let i = 0; i < space.units["england"].length; i++) {
        let unit = space.units["england"][i];
        if (unit.type == "regular" || unit.type == "mercenary") { return true; }
      }

      //
      // or Scottish ones if Scotland is allied to England
      //
      if (this.areAllies("england", "scotland")) {
        for (let i = 0; i < space.units["scotland"].length; i++) {
          let unit = space.units["scotland"][i];
          if (unit.type == "regular" || unit.type == "mercenary") { return true; }
        }
      }

    }

    return false;

  }

  returnCatholicLandUnitsInSpace(space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let units = [];

    for (let f in space.units) {
      if (f != "protestant" && f != "ottoman") {
	if (f == "england" && (this.game.state.leaders.edward_vi != 1 || this.game.state.leaders.elizabeth_i != 1)) {
          for (let z = 0; z < space.units[f].length; z++) {
	    let u = space.units[f][z];
	    if (u.type === "regular" || u.type === "mercenary" || u.type === "cavalry") { units.push({ faction : f , unit_idx : z }); }
	  }
	} else {
          for (let z = 0; z < space.units[f].length; z++) {
	    let u = space.units[f][z];
	    if (u.type === "regular" || u.type === "mercenary" || u.type === "cavalry") { units.push({ faction : f , unit_idx : z }); }
	  }
	}
      }
    }

    return units;

  }

  hasCatholicLandUnits(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != "protestant" && f != "ottoman") {
	if (f == "england" && (this.game.state.leaders.henry_viii != 1 && this.game.state.leaders.edward_vi != 1 && this.game.state.leaders.elizabeth_i != 1)) {
          if (this.returnFactionLandUnitsInSpace(f, space)) { return true; }
	} else {
	  if (f == "england") {
            if (this.returnFactionLandUnitsInSpace(f, space)) { return false; }
	  } else {
            if (this.returnFactionLandUnitsInSpace(f, space)) { return true; }
	  }
	}
      }
    }

    return false;
  }


  isUnoccupied(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space];  } } catch (err) {}
    for (let key in space.units) {
      if (this.returnFactionLandUnitsInSpace(key, space.key) > 0) { return 0; }
    }
    return 1;
  }

  isNavalSpaceFriendly(space, faction) {
   
    // if a port, must be controlled by faction
    try {
      if (this.game.spaces[space]) { 
	space = this.game.spaces[space];  
        if (space.language != undefined) { return this.isSpaceFriendly(space, faction); }
      }
    } catch (err) {}

    // if naval space, must not have enemy of faction
    try { 
      if (this.game.navalspaces[space]) {
	space = this.game.navalspaces[space]; 
        for (let f in space.units) {
          if (space.units[f].length > 0) {
	    if (this.areEnemies(f, faction)) { return 0; }
          }	
        }
      } 
    } catch (err) {}

    return 1;

  }


  canFactionMoveIntoSpace(faction, space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);
    // maybe space is controlled by minor power but we are allied with or enemies of actual controller
    if (this.isMinorPower(cf)) { cf = this.returnControllingPower(cf); }
    if (cf === faction) { return 1; }
    if (this.areEnemies(faction, cf)) { return 1; }
    if (this.areAllies(faction, cf)) { return 1; }
    if (this.isSpaceIndependent(space.key)) {

      // if controlled by non-independent, we cannot enter
      if (cf !== "independent") { return 0; }

      let is_empty = true;
      for (let key in space.units) {
	if (key != "independent") {
	  // don't let ourselves be blocked by non-controlling allies/enemies
          if (!this.areAllies(faction, key) && !this.areEnemies(faction, key)) {
            if (space.units[key].length > 0) {
              if (this.returnFactionLandUnitsInSpace(key, space.key, 1)) {
                is_empty = false;
  	        if (!this.areEnemies(faction, key) && !this.areAllies(faction, key)) { return 0; }
	      }
	    }
          }
        }
      }
      if (is_empty) { return 1; }
    }
    return 0;
  }

  isSpaceFriendly(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);
    if (cf === faction) { return true; }
    return this.areAllies(cf, faction);
  }

  isSpaceHostileOrIndependent(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (this.isSpaceHostile(space, faction)) { return true; }
    if (this.isSpaceIndependent(space)) { return true; }
    return false;
  }

  isSpaceIndependent(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.political === "independent") { return true; }
    if (space.home === "independent") { return true; }
    return false;
  }

  isSpaceHomeSpace(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.home === faction) { return true; }
    return false;
  }

  doesSpaceHaveNonFactionNavalUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != faction) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "squadron") { return true; }
	  if (u.type == "corsair") { return true; }
        }
      }
    }
    return false;
  }

  doesSpaceHaveNonFactionUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != faction) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "regular") { return true; }
	  if (u.type == "mercenary") { return true; }
	  if (u.type == "cavalry") { return true; }
        }
      }
    }
    return false;
  }

  doesSpaceHaveEnemyUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areEnemies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (i.army_leader || i.navy_leader) { return true; }
	  if (i.personage == true) { return false; } else { return true; }
        }
      }
    }
    return false;
  }

  isSpaceHostile(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);
    if (cf === faction) { return false; }
    return this.areEnemies(cf, faction);
  }


  doesSpaceHaveLineOfControl(space, faction) { return this.isSpaceInLineOfControl(space, faction); }
  isSpaceInLineOfControl(space, faction, transit_passes=1, transit_seas=1) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let already_routed_through = {};

    //
    // path of spaces and sea-zones from that space to friendly-controlled, 
    // fortified space that is a home space for that power or one of its allies 
    // (this even includes home spaces of minor powers allied to your major 
    // power allies). All spaces on the path (except the space where the path 
    // ends) must be:
    //
    // • friendly-controlled,
    // • free of enemy units (including naval units and leaders)
    // • free of unrest.
    //
    let res = this.returnNearestSpaceWithFilter(

      space.key ,

      // capitals are good destinations
      function(spacekey) {
        let invalid_choice = false;
        if (his_self.isSpaceFortified(spacekey) && his_self.isSpaceHomeSpace(spacekey, faction)) { 
	  invalid_choice = true;
	}
        if (!his_self.isSpaceFriendly(spacekey, faction)) { invalid_choice = false; }
        return invalid_choice;
      },

      // route through this?
      function(spacekey) {
        if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
        if (his_self.isSpaceFriendly(spacekey, faction) && his_self.doesSpaceHaveEnemyUnits(spacekey, faction) == false && his_self.isSpaceInUnrest(spacekey) != true) {
	  return 1;
	}
	return 0;
      },

      // transit passes? 0
      transit_passes,

      // transit seas?
      transit_seas,

      // faction? optional
      faction,

      // already crossed sea zone optional
      0
    );

    return res.length;

  }

  isSpaceControlled(space, faction) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    // home spaces that have not fallen to another power.
    if (space.home == faction && space.political == "") { return true; }

    // home spaces that have not fallen to another power.
    if (space.home == faction && space.political == faction) { return true; }

    if (space.home == "" && space.political == faction) { return true; }

    // independent (gray) spaces seized by the power.
    if (space.home == "independent" && space.political == faction) { return true; }

    // home spaces of other powers seized by the power.
    if (space.home != faction && space.political == faction) { return true; }
    if (space.home == faction && space.political == faction) { return true; }

    // home spaces of allied minor powers. 
    if (space.political == "" && space.home != faction && this.isAlliedMinorPower(space.home, faction)) { return true; }

    return false;
  }

  isSpaceFortified(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.type === "electorate" || space.type === "key" || space.type === "fortress") { return true; }
    return false;
  }

  returnHopsToFortifiedHomeSpace(source, faction) {
    let his_self = this;
    try { if (this.game.spaces[source]) { source = this.game.spaces[source]; } } catch (err) {}
    return this.returnHopsBetweenSpacesWithFilter(source, function(spacekey) {
      if (his_self.isSpaceFortified(his_self.game.spaces[spacekey])) {
	if (his_self.isSpaceControlled(spacekey, faction)) {
	  if (his_self.game.spaces[spacekey].home === faction) {
	    return 1;
	  }
	}
      }
      return 0;
    });
  }
  returnHopsToDestination(source, destination) {
    try { if (this.game.spaces[source]) { destination = this.game.spaces[source]; } } catch (err) {}
    try { if (this.game.spaces[destination]) { destination = this.game.spaces[destination]; } } catch (err) {}
    return this.returnHopsBetweenSpacesWithFilter(source, function(spacekey) {
      if (spacekey === destination.key) { return 1; }
      return 0;  
    });
  }

  returnHopsBetweenSpacesWithFilter(space, filter_func) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let map = {};
    let sources = [];
    let hop = 0;

    let addHop = function(sources, hop) {

      hop++;
      
      let new_neighbours = [];

      for (let i = 0; i < sources.length; i++) {
	for (let z = 0; z < his_self.game.spaces[sources[i]].neighbours.length; z++) {
	  let sourcekey = his_self.game.spaces[sources[i]].neighbours[z];
	  if (!map[sourcekey]) {
	    map[sourcekey] = 1;
	    new_neighbours.push(sourcekey);

	    //
	    // if we have a hit, it's this many hops!
	    //
	    if (filter_func(sourcekey)) { return hop; }
	  }
	}
      }

      if (new_neighbours.length > 0) {
	return addHop(new_neighbours, hop);
      } else {
	return 0;
      }

    }

    return addHop(space.neighbours, 0);   

  }

  //
  // similar to above, except it can cross a sea-zone
  //
  isSpaceConnectedToCapitalSpringDeployment(space, faction, transit_seas=1) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let capitals = this.returnCapitals(faction);
    let already_routed_through = {};
    let transit_passes = 0;
    let hostile_sea_passes = 0;

    if (this.game.state.spring_deploy_across_seas.includes(faction)) {
      hostile_sea_passes = 1;
    }
    if (this.game.state.spring_deploy_across_passes.includes(faction)) {
      transit_passes = 1;
    }

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // capitals are good destinations
      function(spacekey) {
        if (capitals.includes(spacekey)) { return 1; }
        return 0;
      },


      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	return 0;
      },

      0, // include source

      // transit passes? 0
      transit_passes,

      // transit seas? 1
      transit_seas,
     
      // faction? optional
      faction,

      // already crossed sea zone optional
      0,

      // is spring deployment
      1
    );

    if (res.length > 0) {
      return 1;
    }

    return 0;

  }

  isSpaceAdjacentToReligion(space, religion) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.neighbours.length; i++) {
      if (this.game.spaces[space.neighbours[i]].religion === religion) {
	return true;
      }
    }
    return false;
  }

  isSpaceAdjacentToProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let z = 0; z < space.neighbours.length; z++) {
      if (this.doesSpaceContainProtestantReformer(space.neighbours[z])) { return true; }
    }
    return false;
  }

  // either in port or in adjacent sea
  returnNumberOfSquadronsProtectingSpace(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let number_of_squadrons_in_port = 0;
    let number_of_squadrons_at_sea = 0;

    //
    // in port
    //
    for (let f in space.units) {
      for (let i = 0; i < space.units[f].length; i++) {
        if (space.units[f][i].type == "squadron") {
	  if (space.units[f][i].besieged != 0) { number_of_squadrons_in_port++; }
	}
      }
    }

    //
    // adjacent sea
    //
    for (let p = 0; p < space.ports.length; p++) {

      let sea = this.game.navalspaces[space.ports[p]];

      for (let f in sea.units) {

	// faction at sea is friendly to port space controller
	if (this.isSpaceFriendly(space, f)) {
	  for (let i = 0; i < sea.units[f].length; i++) {
	    if (sea.units[f][i].type == "squadron") {
	      number_of_squadrons_at_sea++;
	    }
	  }
	}
      }
    }

    return (number_of_squadrons_in_port + number_of_squadrons_at_sea);

  }
  doesSpaceContainProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units["protestant"].length; i++) {
      if (space.units["protestant"][i].reformer == true) { return true; }
    }
    return false;
  }

  isSpaceAPortInTheSameSeaZoneAsACatholicPort(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let seas = [];
    for (let i = 0; i < space.ports.length; i++) {
      if (!seas.includes(space.ports[i])) { seas.push(space.ports[i]); }
    }
    for (let s in this.game.spaces) {
      let sp = this.game.spaces[s];
      if (sp.religion == "catholic" && sp.ports.length > 0) {
	for (let z = 0; z < sp.ports.length; z++) {
	  if (seas.includes(sp.ports[z])) { return true; }
	}
      }
    }  
    return false;
  }

  isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let seas = [];
    for (let i = 0; i < space.ports.length; i++) {
      if (!seas.includes(space.ports[i])) { seas.push(space.ports[i]); }
    }
    for (let s in this.game.spaces) {
      let sp = this.game.spaces[s];
      if (sp.religion == "protestant" && sp.ports.length > 0) {
	for (let z = 0; z < sp.ports.length; z++) {
	  if (seas.includes(sp.ports[z])) { return true; }
	}
      }
    }  
    return false;
  }


  returnSpacesWithFilter(filter_func) {
    let spaces = [];
    for (let spacekey in this.game.spaces) {
      if (filter_func(spacekey) == 1) { spaces.push(spacekey); }
    }
    return spaces;
  }

  isSpaceFactionCapital(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let capitals = this.returnCapitals(faction);
    for (let i = 0; i < capitals.length; i++) {
      if (capitals[i] === space.key) { return true; }
    }
    return false;
  }

  isSpaceInUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.unrest == 1) { return true; }
    return false;
  }

  isSpaceUnderSiege(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.besieged > 0) { return true; }
    return false;
  }

  isSpaceConnectedToCapital(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let capitals = this.returnCapitals(faction);
    let already_routed_through = {};

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // capitals are good destinations
      function(spacekey) {
        if (capitals.includes(spacekey)) { return 1; }
        return 0;
      },

      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	return 0;
      }
    );

    return 1;
  }

  returnFactionControllingSpace(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let factions = this.returnImpulseOrder(); 
    for (let i = 0; i < factions.length; i++) {
      if (this.isSpaceControlled(space.key, factions[i])) { return factions[i]; }
    }
    if (space.political) { return space.political; }
    return space.home;
  }

  returnSpaceOfPersonage(faction, personage) {
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i]) {
	    if (this.game.spaces[key].units[faction][i].type === personage) {
  	      return key;
            }
          }
        }
      }
    }
    return "";
  }

  returnIndexOfPersonageInSpace(faction, personage, spacekey="") {
    if (spacekey === "") { return -1; }
    if (!this.game.spaces[spacekey]) { return -1; }
    for (let i = 0; i < this.game.spaces[spacekey].units[faction].length; i++) {
      if (this.game.spaces[spacekey].units[faction][i].type === personage) {
        return i;
      }
    }
    return -1;
  }

  returnNavalTransportDestinations(faction, space, ops) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let viable_destinations = [];
    let viable_navalspaces = [];
    let options = [];
    let ops_remaining = ops-1;    

    for (let i = 0; i < space.ports.length; i++) {
      if (this.doesFactionHaveNavalUnitsInSpace(faction, space.ports[i])) {
	viable_navalspaces.push({key : space.ports[i] , ops_remaining : ops_remaining});
      }
    }

    //
    // this loop through the graph and finds all of the spaces that can theoretically
    // be reached given the OPS available to the user and the presence of a naval unit
    // in the connecting sea spaces. these destinations are put into "viable_navalspaces"
    //
    while (ops_remaining > 1) {
      ops_remaining--;
      for (let i = 0; i < viable_navalspaces.length; i++) {
	for (let z = 0; z < this.game.navalspaces[viable_navalspaces[i].key].neighbours.length; z++) {
	  let ns = this.game.navalspaces[viable_navalspaces[i].key].neighbours[z];
          if (this.doesFactionHaveNavalUnitsInSpace(faction, ns)) {
	    let already_included = 0;
	    for (let z = 0; z < viable_navalspaces.length; z++) {
	      if (viable_navalspaces[z].key == ns) { already_included = 1; }
	    }
	    if (already_included == 0) {
	      viable_navalspaces.push({ key : ns , ops_remaining : ops_remaining });
	    }
	  }
	}
      }
    }

    //
    // we now look for ports that are in these viable navalspaces, and list ones which 
    // are valid movement destinations. this means allied or independent or enemies of 
    // the active power that is moving.
    //
    for (let i = 0; i < viable_navalspaces.length; i++) {
      let key = viable_navalspaces[i].key;
      for (let z = 0; z < this.game.navalspaces[key].ports.length; z++) {      
	let port = this.game.navalspaces[key].ports[z];
	if (port != space.key) {

	  //
          // you cannot move into spaces that are not allied or enemies
	  //
          if (this.canFactionMoveIntoSpace(faction, port)) { 
	    viable_destinations.push({ key : port , cost : (viable_navalspaces[i].ops_remaining-1)});
	  }
	}
      }
    }

    return viable_destinations;

  }


  returnFactionNavalUnitsToMove(faction) {

    let units = [];

    //
    // include minor-activated factions
    //
    let fip = [];
    fip.push(faction);
    if (this.game.state.activated_powers[faction]) {
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
        fip.push(this.game.state.activated_powers[faction][i]);
      }
    }

    //
    // if this is the 2P game, include any major activated units
    //
    if (faction != "independent" && faction != "scotland" && faction != "genoa" && faction != "venice" && faction != "hungary") {
      if (this.game.players.length == 2) {
        if (this.areAllies(faction, "hapsburg") && faction != "hapsburg") { fip.push("hapsburg"); }
        if (this.areAllies(faction, "protestant") && faction != "protestant") { fip.push("protestant"); }
        if (this.areAllies(faction, "france") && faction != "france") { fip.push("france"); }
        if (this.areAllies(faction, "england") && faction != "england") { fip.push("england"); }
        if (this.areAllies(faction, "papacy") && faction != "papacy") { fip.push("papacy"); }
        if (this.areAllies(faction, "ottoman") && faction != "ottoman") { fip.push("ottoman"); }
      }
    }

    //
    // find units
    //
    for (let i = 0; i < fip.length; i++) {
      for (let key in this.game.spaces) {

	//
	// we only care about units in ports
	//
	if (this.game.spaces[key].ports) {
	if (this.game.spaces[key].ports.length > 0) {
	  let ships = [];
	  let leaders = [];
	  for (let z = 0; z < this.game.spaces[key].units[fip[i]].length; z++) {

	    //
	    // only add leaders if there is a ship in port
	    //
	    let u = this.game.spaces[key].units[fip[i]][z];
	    u.idx = z;

	    if (u.navy_leader == true) {
	      leaders.push(u);
	    } else {
	      if (u.land_or_sea === "sea" || u.land_or_sea === "both") {
		ships.push(u);
	      }
	    }
	  }

	  //
	  // add and include location
	  //
	  if (ships.length > 0) {
	    for (let y = 0; y < ships.length; y++) {
	      ships[y].spacekey = key;
	      ships[y].faction = fip[i];
	      units.push(ships[y]);
	    }
	    for (let y = 0; y < leaders.length; y++) {
	      leaders[y].spacekey = key;
	      leaders[y].faction = faction;
	      units.push(leaders[y]);
	    }
	  }
	}
        }
      }
    }

    //
    // add ships and leaders out-of-port
    //
    for (let i = 0; i < fip.length; i++) {
      for (let key in this.game.navalspaces) {
	for (let z = 0; z < this.game.navalspaces[key].units[fip[i]].length; z++) {
	  this.game.navalspaces[key].units[fip[i]][z].spacekey = key;
	  this.game.navalspaces[key].units[fip[i]][z].faction = fip[i];
	  units.push(this.game.navalspaces[key].units[fip[i]][z]);
	}
      }
    }

    return units;
  }






  returnOverstackedUnitsToCapitals() {

    for (let i in this.game.spaces) {
      if (this.isSpaceFortified(this.game.spaces[i])) {

        let space = this.game.spaces[i];
        let f = this.returnFactionControllingSpace(i);

        let num_friendly_units = this.returnFriendlyLandUnitsInSpace(f, space);
        let num_faction_units = this.returnFactionLandUnitsInSpace(f, space);
        let capitals = this.returnCapitals(f);

        if (num_friendly_units > 4 && !capitals.includes(i)) {

          let units_preserved = 0;
          for (let q in space.units) {

            //  capital of unit is
            let cap = this.returnControlledCapitals(q);
            let cap_idx = 0;

            for (let ii = 0; ii < space.units[q].length; ii++) {
              let u = space.units[q][ii];
              if (u.type === "cavalry" || u.type === "regular" || u.type === "mercenary") {
                units_preserved++;
                if (units_preserved > 4) {
                  if (cap.length > 0) {
                    let selected_capital = cap[cap_idx];
                    this.game.spaces[selected_capital].units[q].push(space.units[q][ii]);
                    cap_idx++;
                    if ((cap_idx+1) > cap.length) {
                      cap_idx = 0;
                    }
                    this.displaySpace(selected_capital);
                    this.displaySpace(space.key);
                  }
                  space.units[q].splice(ii, 1);
                  ii--;
                }
              }
            }
          }
          this.updateLog("OVERSTACKING in " + this.returnName(i) + " (some units returned to capital)");
          this.displaySpace(i);
        }
      }
    }

  }


  // max-units is number of units permitted, usually passed as 4 to find spaces that are not over-capacity
  returnNearestFriendlyFortifiedSpacesTransitPasses(faction, space, max_units=0) {
    return this.returnNearestFriendlyFortifiedSpaces(faction, space, 1, max_units);
  }
  returnNearestFriendlyFortifiedSpaces(faction, space, transit_passes = 0, max_units=0) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let original_spacekey = space.key;
    let his_self = this;
    let already_routed_through = {};

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // fortified spaces
      function(spacekey) {

	//
	// non-protestants can't move into electorates, so they aren't friendly fortified spaces 
	// for anyone at this point.
	//
	if (faction !== "protestant" && his_self.game.state.events.schmalkaldic_league != 1) {
	  if (his_self.isElectorate(spacekey)) { return 0; }
	}

	//
	// we provide an exception for capitals as they can hold more than MAX_UNITS
	//
	if (max_units > 0) {
	  if (spacekey != "paris" && spacekey != "london" && spacekey != "istanbul" && spacekey != "vienna" && spacekey != "valladolid" && spacekey != "rome") {
	    if (his_self.returnFactionLandUnitsInSpace(faction, space.key, 1) >= max_units) { return 0; }
	  }
	}

        if (his_self.isSpaceFortified(his_self.game.spaces[spacekey])) {
	  if (his_self.isSpaceControlled(spacekey, faction)) {
	    return 1;
	  }
	  if (his_self.isSpaceFriendly(spacekey, faction)) {
	    return 1;
	  }
	}
        return 0;
      },

      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	if (spacekey == original_spacekey) { return 1; }
	return 0;
      }, 


      true , // include source

      transit_passes, // cross passes?
    );

    return res;

  }


  returnNearestFactionControlledPorts(faction, spacekey) {

    let space = spacekey;

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}

    let his_self = this;
    let already_routed_through = {};

    let res = this.returnNearestNavalSpaceOrPortWithFilter(

      space.key,

      // ports
      function(spacekey) {
        if (his_self.game.spaces[spacekey]) {
	  if (his_self.isSpaceControlled(spacekey, faction)) {
	    return 1;
	  }
	}
        return 0;
      },

      // route through this
      function(spacekey) {	
        if (his_self.game.spaces[spacekey]) { return 0; }
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	return 1;
      }
    );

    return res;

  }


  canFactionRetreatToSpace(faction, space, attacker_comes_from_this_space="") {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.spaces[attacker_comes_from_this_space]) { attacker_comes_from_this_space = this.game.spaces[attacker_comes_from_this_space]; } } catch (err) {}
    if (space === attacker_comes_from_this_space) { return 0; }
    if (this.isSpaceInUnrest(space) == 1) { return 0; }
    for (let z in space.units) {
      if (this.returnFactionLandUnitsInSpace(z, space.key)) {
	if (!this.areAllies(z, faction, 1)) { return 0; }
      }
    }
    if (this.isSpaceControlled(space, faction) == 1) { return 1; }
    if (this.isSpaceFriendly(space, faction) == 1) { return 1; }
    return 0;
  }

  canFactionRetreatToNavalSpace(faction, space) {
    let is_port_space = false;
    try { if (this.game.spaces[space]) { is_port_space = true; space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    if (is_port_space == true) {
      let fac = this.returnFactionControllingSpace(space);
      if (this.areEnemies(fac, faction)) { return 0; }
      if (this.areAllies(fac, faction, 1)) { return 1; } else { return 0; }
    } else {
      for (let z in space.units) {
        if (this.returnFactionNavalUnitsInSpace(z, space.key)) {
	  if (this.areEnemies(z, faction, 1)) { return 0; }
        }
      }
    }
    if (this.isNavalSpaceFriendly(space, faction) == 1) { return 1; }
    if (this.isSpaceFriendly(space, faction) == 1) { return 1; }
    return 0;
  }

  convertSpace(religion, space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (religion === "papacy") { religion = "catholic"; }
    space.religion = religion;
    this.displayBoard();
  }

  controlSpace(faction, space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.political = faction;
    space.occupier = faction;

    if (space.key === "oran" || space.key === "tripoli") {
      if (faction === "ottoman") {
	space.home = "ottoman";
      }
      if (faction === "hapsburg") {
	space.home = "hapsburg";
      }
    }

    //
    // check if triggers defeat of Hungary Bohemia
    //
    if (this.game.step.game > 5) {
      this.triggerDefeatOfHungaryBohemia();
    }

  }


  returnDefenderFaction(attacker_faction, space) {
    // called in combat, this finds whichever faction is there but isn't allied to the attacker
    // or -- failing that -- whichever faction is recorded as occupying the space.
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      let luis = 0;
      if (space.language == undefined) {
        luis = this.returnFactionSeaUnitsInSpace(f, space.key);
      } else {
        luis = this.returnFactionLandUnitsInSpace(f, space.key);
      }
      if (luis > 0) {
        if (!this.areAllies(attacker_faction, f) && f !== attacker_faction) {
	  return f;
	}
      }
    }
    return this.returnFactionOccupyingSpace(space);
  }

  returnFactionOccupyingSpace(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.occupier != "" && space.occupier != undefined && space.occupier != "undefined" && space.occupier != 'undefined') { 
      // whoever had units here first
      if (space.units[space.occupier]) {
        if (space.units[space.occupier].length > 0) {
          return space.occupier; 
        }
      }
    }
    // or whoever has political control
    if (space.political != "") { return space.political; }
    // or whoever has home control
    if (space.owner != -1) { return space.owner; }
    return space.home;
  }

  returnNonFactionLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f !== faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnHostileOrIndependentLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (!this.areAllies(faction, f, 1)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnHostileLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areEnemies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnFriendlyLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areAllies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnFactionLandUnitsInSpace(faction, space, include_minor_allies=false) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      } else {
	if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
          for (let i = 0; i < space.units[f].length; i++) {
            if (space.units[f][i].type === "regular") { luis++; }
            if (space.units[f][i].type === "mercenary") { luis++; }
            if (space.units[f][i].type === "cavalry") { luis++; }
          }
        }
      }
    }
    return luis;
  }

  returnFactionNavalUnitsInSpace(faction, space, include_minor_allies=false) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "squadron") { luis++; }
          if (space.units[f][i].type === "corsair") { luis++; }
        }
      } else {
	if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
          for (let i = 0; i < space.units[f].length; i++) {
            if (space.units[f][i].type === "squadron") { luis++; }
            if (space.units[f][i].type === "corsair") { luis++; }
          }
        }
      }
    }
    return luis;
  }

  returnFactionSeaUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (space.units[faction][i].type === "squadron") { luis++; }
      if (space.units[faction][i].type === "corsair") { luis++; }
    }
    return luis;
  }

  doesOtherFactionHaveNavalUnitsInSpace(exclude_faction, key) {
    if (this.game.spaces[key]) {
      for (let f in this.game.spaces[key].units) {
	if (f != exclude_faction) {
          if (this.game.spaces[key].units[f]) {
            for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
              if (this.game.spaces[key].units[f][i].type === "squadron" || this.game.spaces[key].units[f][i].type === "corsair") {
  	        return 1;
              }
            }
	  }
	}
      }
      return 0;
    }
    if (this.game.navalspaces[key]) {
      for (let f in this.game.navalspaces[key].units) {
	if (f != exclude_faction) {
          if (this.game.navalspaces[key].units[f]) {
            for (let i = 0; i < this.game.navalspaces[key].units[f].length; i++) {
              if (this.game.navalspaces[key].units[f][i].type === "squadron" || this.game.navalspaces[key].units[f][i].type === "corsair") {
  	        return 1;
              }
            }
	  }
	}
      }
      return 0;
    }
    return 0;
  }

  doesPlayerHaveLandUnitsInSpace(p1, spacekey) {
    for (let f in this.game.spaces[spacekey].units) {
      if (this.returnPlayerCommandingFaction(f) == p1) {
        for (let i = 0; i < this.game.spaces[spacekey].units[f].length; i++) {
          if (
	    this.game.spaces[spacekey].units[f][i].type == "regular" || 
	    this.game.spaces[spacekey].units[f][i].type == "cavalry" || 
	    this.game.spaces[spacekey].units[f][i].type == "mercenary") 
	  {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  doesFactionHaveLandUnitsInSpace(faction, key) {
    if (this.game.spaces[key]) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
          if (this.game.spaces[key].units[faction][i].type === "regular" || this.game.spaces[key].units[faction][i].type === "cavalry" || this.game.spaces[key].units[faction][i].type === "mercenary") {
  	    return 1;
          }
        }
      }
    }
    return 0;
  }
  doesFactionHaveNavalUnitsInSpace(faction, key) {
    if (this.game.spaces[key]) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
          if (this.game.spaces[key].units[faction][i].type === "squadron" || this.game.spaces[key].units[faction][i].type === "corsair") {
  	    return 1;
          }
        }
      }
    }
    if (this.game.navalspaces[key]) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
          if (this.game.navalspaces[key].units[faction][i].type === "squadron" || this.game.navalspaces[key].units[faction][i].type === "corsair") {
  	    return 1;
          }
        }
      }
    }
    return 0;
  }

  doesFactionHaveNavalUnitsOnBoard(faction) {
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
	  return 1;
	}
      }
    }
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i].land_or_sea === "sea") {
	    return 1;
	  }
	}
      }
    }
    return 0;
  }

  returnNavalFactionMap(space, faction1, faction2) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let faction_map = {};

    for (let f in space.units) {
      if (f === faction1 || this.returnPlayerCommandingFaction(f) == this.returnPlayerCommandingFaction(faction1)) {
        faction_map[f] = faction1;
      }
      if (f === faction2 || this.returnPlayerCommandingFaction(f) == this.returnPlayerCommandingFaction(faction2)) {
        faction_map[f] = faction2;
      }
    }
    return faction_map;
  }


  

  returnFactionMap(space, faction1, faction2) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let faction_map = {};

    for (let f in space.units) {
      if (this.returnFactionLandUnitsInSpace(f, space)) {
        if (f == faction1) {
          faction_map[f] = faction1;
        } else {
          if (f == faction2) {
            faction_map[f] = faction2;
          } else {
            if (this.areAllies(f, faction1)) {
              faction_map[f] = faction1;
            }
            if (this.areAllies(f, faction2)) {
              faction_map[f] = faction2;
            }
            if (this.returnPlayerCommandingFaction(f) === faction1) {
              faction_map[f] = faction1;
	    }
            if (this.returnPlayerCommandingFaction(f) === faction2) {
              faction_map[f] = faction2;
	    }
          }
        }
      }
    }
    // ensures factions are listed even if their spaces are empty
    if (!faction_map[faction1]) { faction_map[faction1] = faction1; }
    if (!faction_map[faction2]) { faction_map[faction2] = faction2; }
    return faction_map;
  }

  returnHomeSpaces(faction) {

    let spaces = [];

    for (let i in this.game.spaces) {
      if (this.game.spaces[i].home === faction) { spaces.push(i); }
    }

    return spaces;

  }

  //
  // transit seas calculates neighbours across a sea zone
  //
  // if transit_seas and faction is specified, we can only cross if
  // there are no ports in a zone with non-faction ships.
  //
  returnNeighboursAsArrayOfKeys(space, transit_passes=1, transit_seas=0, faction="") {
    let res = [];
    let x = this.returnNeighbours(space, transit_passes, transit_seas, faction);
    for (let i = 0; i < x.length; i++) {
      res.push(x[i].neighbour);
    }
    return res;
  }
  returnNeighbours(space, transit_passes=1, transit_seas=0, faction="", is_spring_deployment=0) {
try {

    let is_naval_space = false;

    // not a naval space
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; is_naval_space = true; } } catch (err) {}
    try { if (this.game.navalspaces[space.key]) { is_naval_space = true; } } catch (err) {}


    if (transit_seas == 0 && is_naval_space != true) {
      if (transit_passes == 1) {
	let res = [];
	for (let z = 0; z < space.neighbours.length; z++) {
	  res.push({ neighbour : space.neighbours[z] , overseas : false });
	} 
        return res;
      }
      let neighbours = [];
      for (let i = 0; i < space.neighbours.length; i++) {
        let x = space.neighbours[i];      
        if (!space.pass.includes(x)) {
  	  neighbours.push({ neighbour : x , overseas : false });
        }
      }
      return neighbours;
    } else {

      let neighbours = [];

      if (transit_passes == 1 && is_naval_space != true) {
	for (let z = 0; z < space.neighbours.length; z++) {
	  neighbours.push({ neighbour : space.neighbours[z] , overseas : false });
	}
      } else {
        for (let i = 0; i < space.neighbours.length; i++) {
          let x = space.neighbours[i];
	  if (is_naval_space != true) {
            if (!space.pass.includes(x)) {
              neighbours.push({ neighbour : x , overseas : false });
            }
          }
        }
      }

      //
      // any ports ?
      //
      if (space.ports) {
        if (space.ports.length > 0) {
	  for (let i = 0; i < space.ports.length; i++) {
	    let navalspace = "";

	    if (this.game.navalspaces[space.ports[i]]) {
	      navalspace = this.game.navalspaces[space.ports[i]];
	    } else {
	      navalspace = this.game.spaces[space.ports[i]];
	    }

	    let any_unfriendly_ships = false;


	    let ignore_hostiles = false;

	    if (this.game.state.spring_deploy_across_passes.includes(faction) && is_spring_deployment == 1) { ignore_hostiles = true; }

	    if (navalspace.ports) {
	      if (faction != "") {
	        for (let z = 0; z < navalspace.ports.length; z++) {
	          if (this.doesOtherFactionHaveNavalUnitsInSpace(faction, navalspace.ports[z])) {
		    if (this.game.state.events.spring_preparations != faction) {
	              if (ignore_hostiles == false) {
		        any_unfriendly_ships = true;
		      }
		    }
		  }
	        }
	      }
              for (let z = 0; z < navalspace.ports.length; z++) {
		let already_listed = false;
	        for (let zz = 0; zz < neighbours.length; zz++) {
	          if (neighbours[zz].neighbour === navalspace.ports[z]) {
		    already_listed = true;
		  }
 		}
	        if (already_listed == false && any_unfriendly_ships == false) {
	          neighbours.push({ neighbour : navalspace.ports[z] , overseas : true });
	        };
	      }
	    }
 	  }
        }
      }
      return neighbours;
    }
} catch (err) {
  alert("return neighbours bug pls report: " + JSON.stringify(err));
}
    return [];
  }


  //
  // only calculates moves from naval spaces, not outbound from ports
  //
  returnNavalNeighbours(space, transit_passes=1) {
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let neighbours = [];
    for (let i = 0; i < space.ports.length; i++) {
      let x = space.ports[i];
      neighbours.push(x);
    }
    for (let i = 0; i < space.neighbours.length; i++) {
      let x = space.neighbours[i];
      neighbours.push(x);
    }

    return neighbours;
  }




  //
  // returns adjacent naval and port spaces
  //
  returnNavalAndPortNeighbours(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}

    let key = space.key;
    let neighbours = [];

    //
    // ports add only naval spaces
    //
    if (this.game.spaces[key]) {
      for (let i = 0; i < space.ports.length; i++) {
        let x = space.ports[i];
        neighbours.push(x);
      }
    }

    //
    // naval spaces add ports
    //
    if (this.game.navalspaces[key]) {
      for (let i = 0; i < space.ports.length; i++) {
        let x = space.ports[i];
        neighbours.push(x);
      }
      for (let i = 0; i < space.neighbours.length; i++) {
        let x = space.neighbours[i];
        neighbours.push(x);
      }
    }

    return neighbours;
  }


  //
  // returns both naval and port movement options
  //
  returnNavalMoveOptions(spacekey) {

    let neighbours = [];

    if (this.game.navalspaces[spacekey]) {
      for (let i = 0; i < this.game.navalspaces[spacekey].neighbours.length; i++) {
	neighbours.push(this.game.navalspaces[spacekey].neighbours[i]);
      }
      for (let i = 0; i < this.game.navalspaces[spacekey].ports.length; i++) {
	neighbours.push(this.game.navalspaces[spacekey].ports[i]);
      }
    } else {
      if (this.game.spaces[spacekey]) {
        for (let i = 0; i < this.game.spaces[spacekey].ports.length; i++) {
	  neighbours.push(this.game.spaces[spacekey].ports[i]);
        }
      }
    }

    return neighbours;
  }


  //
  // find the nearest destination.
  //
  returnNearestNavalSpaceOrPortWithFilter(sourcekey, destination_filter, propagation_filter, include_source=1) {

    //
    // return array with results + hops distance
    //
    let results = [];
    let searched_spaces = {};
    let pending_spaces = {};

    //
    // if the source matches our destination, return it
    //
    if (include_source == 1) {
      if (destination_filter(sourcekey)) {
        results.push({ space : sourcekey , hops : 0 });
        return results;
      }
    }

    //
    // put the neighbours into pending
    //
    let n = this.returnNavalNeighbours(sourcekey);

    for (let i = 0; i < n.length; i++) {
      pending_spaces[n[i]] = { hops : 0 , key : n[i] };
    }

    //
    // otherwise propagate outwards searching pending
    //
    let continue_searching = 1;
    while (continue_searching) {

      let count = 0;
      for (let key in pending_spaces) {

	count++;
	let hops = pending_spaces[key].hops;

	if (destination_filter(key)) {
	  results.push({ hops : (hops+1) , key : key });	
	  continue_searching = 0;
	  if (searched_spaces[key]) {
	    // we've searched for this before
	  } else {
	    searched_spaces[key] = { hops : (hops+1) , key : key };
	  }
	} else {

	  if (this.game.navalspaces[key]) {

	    for (let z = 0; z < this.game.navalspaces[key].ports.length; z++) {

	      let k = this.game.navalspaces[key].ports[z];

	      if (destination_filter(k)) {
	  	results.push({ hops : (hops+1) , key : k });	
	  	continue_searching = 0;
	  	if (searched_spaces[k]) {
	  	  // we've searched for this before
	  	} else {
	  	  searched_spaces[k] = { hops : (hops+1) , key : k };
	  	}
	      }
	    }
	  }

        }

	if (continue_searching) {
	  if (propagation_filter(key)) {
    	    for (let i = 0; i < this.game.navalspaces[key].neighbours.length; i++) {
	      if (searched_spaces[this.game.navalspaces[key].neighbours[i]]) {
		// don't add to pending as we've transversed before
	      } else {
      	        pending_spaces[this.game.navalspaces[key].neighbours[i]] = { hops : (hops+1) , key : this.game.navalspaces[key].neighbours[i] };
	      }
    	    }
	  }
	  searched_spaces[key] = { hops : (hops+1) , key : key };
	}
	delete pending_spaces[key];

      }
      if (count == 0) {
	continue_searching = 0;
	for (let newkey in pending_spaces) {
	  if (pending_spaces[newkey]) { continue_searching = 1; }
	}
      }
    }

    //
    // at this point we have results or not 
    //
    return results;

  }

  //
  // find the nearest destination.
  //
  // transit_eas = filters on spring deploment criteria of two friendly ports on either side of the zone + no uncontrolled ships in zone
  //
  //
  // res = {
  //  hops : N ,   
  //  key : spacekey ,
  //  overseas : 1/0 ,
  // }
  //
  returnNearestSpaceWithFilter(sourcekey, destination_filter, propagation_filter, include_source=1, transit_passes=0, transit_seas=0, faction="", already_crossed_sea_zone=0, is_spring_deployment=0) {

    //
    // return array with results + hops distance
    //
    let results = [];
    let searched_spaces = {};
    let pending_spaces = {};


    //
    // if the source matches our destination, return it
    //
    if (include_source == 1) {
      if (destination_filter(sourcekey)) {
        results.push({ key : sourcekey , space : sourcekey , hops : 0 });
        return results;
      }
    }

    //
    // put the neighbours into pending
    //
    let n = this.returnNeighbours(sourcekey, transit_passes, transit_seas, faction, is_spring_deployment);

    for (let i = 0; i < n.length; i++) {
      pending_spaces[n[i].neighbour] = { hops : 0 , key : n[i] , overseas : n[i].overseas };
    }

    //
    // otherwise propagate outwards searching pending
    //
    let continue_searching = 1;
    while (continue_searching) {

      let count = 0;
      for (let key in pending_spaces) {

	count++;
	let hops = pending_spaces[key].hops;

	if (destination_filter(key)) {
	  // found results? this is last pass
	  results.push({ hops : (hops+1) , key : key , overseas : pending_spaces[key].overseas });	
	  continue_searching = 0;
	  if (searched_spaces[key]) {
	    // we've searched for this before
	  } else {
	    searched_spaces[key] = { hops : (hops+1) , key : key };
	  }
	} else {
	  if (propagation_filter(key)) {
	    let nn = [];
	    if (pending_spaces[key].overseas) {
	      nn = this.returnNeighbours(key, transit_passes, 0, faction);
	    } else {
	      nn = this.returnNeighbours(key, transit_passes, 1, faction);
	    }
    	    for (let i = 0; i < nn.length; i++) {
	      if (searched_spaces[nn[i].neighbour]) {
		// don't add to pending as we've transversed before
	      } else {
      	        pending_spaces[nn[i].neighbour] = { hops : (hops+1) , key : this.game.spaces[key].neighbours[i] , overseas : nn[i].overseas };
	      }
    	    }
	  }
	  searched_spaces[key] = { hops : (hops+1) , key : key , overseas : 0 };
	}
	delete pending_spaces[key];
      }

      if (count == 0) {
	continue_searching = 0;
	for (let newkey in pending_spaces) {
	  if (pending_spaces[newkey]) { continue_searching = 1; }
	}
      }
    }

    //
    // at this point we have results or not 
    //
    return results;

  }

  isSpaceElectorate(spacekey) {
    if (spacekey === "augsburg") { return true; }
    if (spacekey === "mainz") { return true; }
    if (spacekey === "trier") { return true; }
    if (spacekey === "cologne") { return true; }
    if (spacekey === "wittenberg") { return true; }
    if (spacekey === "brandenburg") { return true; }
    return false;
  }

  returnNumberOfCatholicElectorates() {
    let controlled_keys = 0;
    if (!this.isSpaceControlled('augsburg', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('mainz', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('trier', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('cologne', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfProtestantElectorates() {
    let controlled_keys = 0;
    if (this.isSpaceControlled('augsburg', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('mainz', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('trier', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('cologne', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys++; }
    return controlled_keys;
  }
  returnProtestantElectorates() {
    let controlled_keys = [];
    if (this.isSpaceControlled('augsburg', "protestant")) { controlled_keys.push("augsburg"); }
    if (this.isSpaceControlled('mainz', "protestant")) { controlled_keys.push("mainz"); }
    if (this.isSpaceControlled('trier', "protestant")) { controlled_keys.push("trier"); }
    if (this.isSpaceControlled('cologne', "protestant")) { controlled_keys.push("cologne"); }
    if (this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys.push("wittenberg"); }
    if (this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys.push("brandenburg"); }
    return controlled_keys;
  }
  returnNumberOfElectoratesControlledByCatholics(political_control=0) {
    let controlled_keys = 0;
    if (political_control == 1) {
      if (this.game.spaces['augsburg'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['mainz'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['trier'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['cologne'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['wittenberg'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['brandenburg'].political != "protestant") { controlled_keys++; }
      return controlled_keys;
    }
    if (this.game.spaces['augsburg'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['mainz'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['trier'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['cologne'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['wittenberg'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['brandenburg'].religion === "catholic") { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfElectoratesControlledByProtestants(political_control=0) {
    let controlled_keys = 0;
    if (political_control == 1) {
      if (this.game.spaces['augsburg'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['mainz'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['trier'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['cologne'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['wittenberg'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['brandenburg'].political === "protestant") { controlled_keys++; }
      return controlled_keys;
    }
    if (this.game.spaces['augsburg'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['mainz'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['trier'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['cologne'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['wittenberg'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['brandenburg'].religion === "protestant") { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfKeysControlledByFaction(faction) {
    let controlled_keys = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].type === "key") {
        let owner = this.game.spaces[key].political;
        if (owner == "") { owner = this.game.spaces[key].home; }
        owner = this.returnControllingPower(owner);
        if (owner == this.factions[faction].key) {
          controlled_keys++;
        }
      }
    }

/********* TODO - remove if no problems as OWNER check above 
    //
    // minor allied powers
    //
    if (faction === this.returnAllyOfMinorPower("genoa")) {
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].type === "key") {
          if (this.game.spaces[key].political === "genoa" || (this.game.spaces[key].political === "" && this.game.spaces[key].home === "genoa")) {
            controlled_keys++;
          }
        }
      }
    }
    if (faction === this.returnAllyOfMinorPower("scotland")) {
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].type === "key") {
          if (this.game.spaces[key].political === "scotland" || (this.game.spaces[key].political === "" && this.game.spaces[key].home === "scotland")) {
            controlled_keys++;
          }
        }
      }
    }
    if (faction === this.returnAllyOfMinorPower("hungary")) {
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].type === "key") {
          if (this.game.spaces[key].political === "hungary" || (this.game.spaces[key].political === "" && this.game.spaces[key].home === "hungary")) {
            controlled_keys++;
          }
        }
      }
    }
    if (faction === this.returnAllyOfMinorPower("venice")) {
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].type === "key") {
          if (this.game.spaces[key].political === "venice" || (this.game.spaces[key].political === "" && this.game.spaces[key].home === "venice")) {
            controlled_keys++;
          }
        }
      }
    }
***************/

    return controlled_keys;
  }
  returnNumberOfKeysControlledByPlayer(player_num) {
    let faction = this.game.state.players_info[player_num-1].faction;
    let controlled_keys = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].type === "key") {
        if (this.game.spaces[key].political === this.factions[faction].key || (this.game.spaces[key].political === "" && this.game.spaces[key].home === this.factions[faction].key)) {
          controlled_keys++;
        }
      }
    }
    return controlled_keys;
  }

  returnNumberOfCatholicSpacesInLanguageZone(language="", do_not_count_unrest = 0) {  
    let catholic_spaces = 0;
    for (let key in this.game.spaces) {
      if (do_not_count_unrest == 0) {
        if ((this.game.spaces[key].unrest == 1 && this.game.spaces[key].religion == "protestant") || this.game.spaces[key].religion === "catholic") {
  	  if (language == "" || language == "all" || this.game.spaces[key].language == language) {
	    catholic_spaces++;
	  }
	}
      } else {
        if (this.game.spaces[key].religion === "catholic") {
  	  if (language == "" || language == "all" || this.game.spaces[key].language == language) {
	    catholic_spaces++;
	  }
        }
      }
    }
    return catholic_spaces;
  }

  returnNumberOfProtestantSpacesInLanguageZone(language="", do_not_count_unrest = 0) {  
    let protestant_spaces = 0;
    for (let key in this.game.spaces) {
      if (do_not_count_unrest == 0) {
        if (this.game.spaces[key].religion === "protestant" && this.game.spaces[key].unrest == 0) {
	  if (language == "all" || language == "" || this.game.spaces[key].language == language) {
	    protestant_spaces++;
	  }
        }
      } else {
        if (this.game.spaces[key].religion === "protestant") {
	  if (language == "all" || language == "" || this.game.spaces[key].language == language) {
	    protestant_spaces++;
	  }
        }
      }
    }
    return protestant_spaces;
  }


  returnNavalSpaces() {

    let seas = {};

    seas['irish'] = {
      top : 775 ,
      left : 1100 ,
      name : "Irish Sea" ,
      ports : ["glasgow"] ,
      neighbours : ["biscay","north","channel"] ,
    }
    seas['biscay'] = {
      top : 1500 ,
      left : 1400 ,
      name : "Bay of Biscay" ,
      ports : ["brest", "nantes", "bordeaux", "corunna" ] ,
      neighbours : ["irish","channel","atlantic"] ,
    }
    seas['atlantic'] = {
      top : 2700 ,
      left : 850 ,
      name : "Atlantic Ocean" ,
      ports : ["gibraltar" , "seville" , "corunna"] ,
      neighbours : ["biscay"] ,
    }
    seas['channel'] = {
      top : 1020 ,
      left : 1450 ,
      name : "English Channel" ,
      ports : ["brest", "plymouth", "portsmouth", "rouen", "boulogne", "calais" ] ,
      neighbours : ["irish","biscay","north"] ,
    }
    seas['north'] = {
      top : 350 ,
      left : 2100 ,
      name : "North Sea" ,
      ports : ["london", "norwich", "berwick", "edinburgh", "calais", "antwerp", "amsterdam", "bremen", "hamburg" ] ,
      neighbours : ["irish","channel","baltic"] ,
    }
    seas['baltic'] = {
      top : 50 ,
      left : 3150 ,
      name : "Baltic Sea" ,
      ports : ["lubeck", "stettin" ] ,
      neighbours : ["north"] ,
    }
    seas['gulflyon'] = {
      top : 1930 ,
      left : 2430 ,
      name : "Gulf of Lyon" ,
      ports : ["cartagena", "valencia", "palma", "barcelona" , "marseille", "nice" , "genoa", "bastia" ] ,
      neighbours : ["barbary","tyrrhenian"] ,
    }
    seas['barbary'] = {
      top : 2330 ,
      left : 2430 ,
      name : "Barbary Coast" ,
      ports : ["gibraltar", "oran", "cartagena", "algiers" , "tunis", "cagliari" , "palma" ] ,
      neighbours : ["gulflyon","tyrrhenian","ionian","africa"] ,
    }
    seas['tyrrhenian'] = {
      top : 2260 ,
      left : 3300 ,
      name : "Tyrrhenian Sea" ,
      ports : ["genoa" , "bastia" , "rome" , "naples" , "palermo" , "cagliari" , "messina" ] ,
      neighbours : ["barbary","gulflyon"] ,
    }
    seas['africa'] = {
      top : 2770 ,
      left : 4200 ,
      name : "North African Coast" ,
      ports : ["tunis" , "tripoli" , "malta" , "candia" , "rhodes" ] ,
      neighbours : ["ionian","barbary","aegean"] ,
    }
    seas['aegean'] = {
      top : 2470 ,
      left : 4450 ,
      name : "Aegean Sea" ,
      ports : ["rhodes" , "candia" , "coron" , "athens" , "salonika" , "istanbul" ] ,
      neighbours : ["black","africa","ionian"] ,
    }
    seas['ionian'] = {
      top : 2390 ,
      left : 3750 ,
      name : "Ionian Sea" ,
      ports : ["malta" , "messina" , "coron", "lepanto" , "corfu" , "taranto" ] ,
      neighbours : ["black","aegean","adriatic"] ,
    }
    seas['adriatic'] = {
      top : 1790 ,
      left : 3400 ,
      name : "Adriatic Sea" ,
      ports : ["corfu" , "durazzo" , "scutari" , "ragusa" , "trieste" , "venice" , "ravenna" , "ancona" ] ,
      neighbours : ["ionian"] ,
    }
    seas['black'] = {
      top : 1450 ,
      left : 4750 ,
      name : "Black Sea" ,
      ports : ["istanbul" , "varna" ] ,
      neighbours : ["aegean"] ,
    }

    for (let key in seas) {
      seas[key].units = {};
      seas[key].units['england'] = [];
      seas[key].units['france'] = [];
      seas[key].units['hapsburg'] = [];
      seas[key].units['ottoman'] = [];
      seas[key].units['papacy'] = [];
      seas[key].units['protestant'] = [];
      seas[key].units['venice'] = [];
      seas[key].units['genoa'] = [];
      seas[key].units['hungary'] = [];
      seas[key].units['scotland'] = [];
      seas[key].units['independent'] = [];
      seas[key].key = key;
    }

    return seas;
  }

  returnSpaceName(key) {
    if (this.game.spaces[key]) { return this.game.spaces[key].name; }
    if (this.game.navalspaces[key]) { return this.game.navalspaces[key].name; }
    return "Unknown";
  }


  returnSpacesInUnrest() {
    let spaces_in_unrest = [];
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].unrest == 1) { spaces_in_unrest.push(key); }
    }
    return spaces_in_unrest;
  }

  returnSpacesWithAdjacentFactionInfantry(faction) {
    return this.returnSpacesWithFactionInfantry(faction, true);
  }

  returnSpacesWithFactionInfantry(faction, adjacency_ok=false) {
    let spaces_with_infantry = [];
    for (let key in this.game.spaces) {
      let added = false;
      if (this.game.spaces[key].units[faction].length > 0) {
        spaces_with_infantry.push(key);
        added = true;
      }
      if (adjacency_ok == true && added == false) {
        for (let i = 0; i < this.game.spaces[key].neighbours.length; i++) {
          let n = this.game.spaces[key].neighbours[i];
	  if (added == false && this.game.spaces[n].units[faction].length > 0) {
	    spaces_with_infantry.push(key);
	    added = true;
	  }
	}
      }
    }
    return spaces_with_infantry;
  }

  returnSpaces() {

    let spaces = {};

    spaces['stirling'] = {
      top: 70,
      left: 1265,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["irish"],
      neighbours: ["glasgow","edinburgh"],
      language: "english",
      type: "fortress"
    }
    spaces['glasgow'] = {
      top: 225,
      left: 1285,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["irish"],
      neighbours: ["stirling","edinburgh","carlisle"],
      language: "english",
      type: "town"
    }
    spaces['edinburgh'] = {
      top: 125,
      left: 1420,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["stirling","glasgow","berwick"],
      language: "english",
      type: "key"
    }
    spaces['berwick'] = {
      top: 183,
      left: 1572,
      home: "england",
      political: "england",
      ports: ["north"],
      neighbours: ["edinburgh","carlisle","york"],
      language: "english",
      religion: "catholic",
      type: "town"
    }
    spaces['carlisle'] = {
      top: 276,
      left: 1447,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["glasgow","berwick","york","shrewsbury"],
      language: "english",
      type: "town"
    }
    spaces['york'] = {
      top: 375,
      left: 1595,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["berwick","carlisle","shrewsbury","lincoln"],
      language: "english",
      type: "key"
    }
    spaces['wales'] = {
      top: 633,
      left: 1398,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["shrewsbury","bristol"],
      language: "english",
      type: "town"

    }
    spaces['shrewsbury'] = {
      top: 521,
      left: 1535,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["wales","carlisle","york","london","bristol"],
      language: "english",
      type: "town"
    }
    spaces['lincoln'] = {
      top: 531,
      left: 1706,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["london","york"],
      language: "english",
      type: "town"
    }
    spaces['norwich'] = {
      top: 538,
      left: 1896,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["north"],
      neighbours:["london"],
      language: "english",
      type: "town"
    }
    spaces['bristol'] = {
      top: 688,
      left: 1554,
      home: "england",
      political: "england",
      religion: "catholic",
      language: "english",
      ports: ["irish"],
      neighbours: ["shrewsbury","wales","plymouth","portsmouth","london"],
      type: "key"
    }
    spaces['london'] = {
      top: 706,
      left: 1785,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["norwich","lincoln","bristol","portsmouth","shrewsbury"],
      language: "english",
      type: "key"
    }
    spaces['plymouth'] = {
      top: 898,
      left: 1398,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["bristol","portsmouth"],
      language: "english",
      type: "town"
    }
    spaces['portsmouth'] = {
      top: 821,
      left: 1661,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["plymouth","bristol","london"],
      language: "english",
      type: "town"
    }
    spaces['calais'] = {
      top: 745,
      left: 2022,
      home: "england",
      political: "england",
      religion: "catholic",
      ports:["north"], 
      neighbours: ["boulogne","brussels","antwerp"],
      language: "french",
      type: "key"
    }

    spaces['boulogne'] = {
      top: 880,
      left: 1955,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["calais","rouen","paris","stquentin"],
      language: "french",
      type: "town"
    }
    spaces['stquentin'] = {
      name: "St. Quentin",
      top: 933,
      left: 2093,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["brussels","stdizier","paris","boulogne"],
      language: "french",
      type: "town"
    }
    spaces['stdizier'] = {
      name: "St. Dizier",
      top: 1043,
      left: 2205,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["brussels","stquentin","paris","dijon","metz"],
      language: "french",
      type: "town"
    }
    spaces['paris'] = {
      top: 1063,
      left: 2009,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["rouen","boulogne","stquentin","stdizier","dijon","orleans"],
      language: "french",
      type: "key"
    }
    spaces['rouen'] = {
      top: 1000,
      left: 1805,
      home: "france",
      political: "france",
      ports: ["channel"],
      religion: "channelc",
      neighbours: ["boulogne","paris","tours","nantes"],
      language: "french",
      type: "key"
    }
    spaces['orleans'] = {
      top: 1217,
      left: 2018,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["paris","tours","dijon","lyon"],
      language: "french",
      type: "town"
    }
    spaces['dijon'] = {
      top: 1205,
      left: 2204,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["stdizier","paris","orleans","lyon","besancon"],
      language: "french",
      type: "town"
    }
    spaces['limoges'] = {
      top: 1398,
      left: 1975,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["tours","bordeaux","lyon"],
      language: "french",
      type: "town"
    }
    spaces['tours'] = {
      top: 1277,
      left: 1849,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["rouen","nantes","bordeaux","limoges","orleans"],
      language: "french",
      type: "town"
    }
    spaces['nantes'] = {
      top: 1310,
      left: 1650,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["biscay"],
      neighbours: ["brest","rouen","tours","bordeaux"],
      language: "french",
      type: "town"
    }
    spaces['brest'] = {
      top: 1173,
      left: 1409,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["channel","biscay"],
      neighbours: ["nantes"],
      language: "french",
      type: "town"
    }
    spaces['bordeaux'] = {
      top: 1568,
      left: 1780,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["biscay"],
      neighbours: ["navarre", "nantes","tours","limoges"],
      pass: ["navarre"],
      language: "french",
      type: "key"
    }
    spaces['lyon'] = {
      top: 1445,
      left: 2312,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["avignon","limoges","orleans","dijon","geneva","grenoble"],
      language: "french",
      type: "key"
    }
    spaces['grenoble'] = {
      top: 1590,
      left: 2437,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["turin","lyon","geneva"],
      pass: ["turin"],
      language: "french",
      type: "town"
    }
    spaces['avignon'] = {
      top: 1645,
      left: 2292,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["barcelona","toulouse","lyon","marseille"],
      pass: ["barcelona"],
      language: "french",
      type: "town"
    }
    spaces['marseille'] = {
      top: 1781,
      left: 2390,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["avignon","nice"],
      language: "french",
      type: "key"
    }
    spaces['toulouse'] = {
      top: 1740,
      left: 1990,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["barcelona","bordeaux","avignon"],
      pass: ["barcelona"],
      language: "french",
      type: "town"
    }

    spaces['munster'] = {
      top: 537,
      left: 2500,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["bremen","kassel","cologne","amsterdam"],
      language: "german",
      type: "town"
    }
    spaces['bremen'] = {
      top: 422,
      left: 2595,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["north"],
      neighbours:["munster","brunswick","hamburg"],
      language: "german",
      type: "town"
    }
    spaces['hamburg'] = {
      top: 345,
      left: 2758,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["bremen","brunswick","lubeck"],
      language: "german",
      type: "town"
    }
    spaces['lubeck'] = {
      top: 258,
      left: 2985,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["baltic"],
      neighbours: ["hamburg","magdeburg","brandenburg","stettin"],
      language: "german",
      type: "town"
    }
    spaces['stettin'] = {
      top: 310,
      left: 3214,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["baltic"],
      neighbours: ["lubeck","brandenburg"],
      language: "german",
      type: "town"
    }
    spaces['brandenburg'] = {
      top: 467,
      left: 3080,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["stettin","lubeck","magdeburg","wittenberg","breslau"],
      language: "german",
      type: "electorate"
    }
    spaces['wittenberg'] = {
      top: 610,
      left: 3133,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["brandenburg","magdeburg","leipzig","prague","breslau"],
      language: "german",
      type: "electorate"
    }
    spaces['magdeburg'] = {
      top: 536,
      left: 2935,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["lubeck","brandenburg","wittenberg","erfurt","brunswick"],
      language: "german",
      type: "town"
    }
    spaces['brunswick'] = {
      top: 568,
      left: 2722,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["bremen","hamburg","magdeburg","kassel"],
      language: "german",
      type: "town"
    }
    spaces['cologne'] = {
      top: 726,
      left: 2500,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["munster","mainz","liege"],
      language: "german",
      type: "electorate"
    }
    spaces['kassel'] = {
      top: 714,
      left: 2665,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["munster","brunswick","erfurt","nuremberg","mainz"],
      language: "german",
      type: "town"
    }
    spaces['erfurt'] = {
      top: 750,
      left: 2824,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["magdeburg","kassel","leipzig"],
      language: "german",
      type: "town"
    }
    spaces['leipzig'] = {
      top: 690,
      left: 2983,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["wittenberg","prague","nuremberg","erfurt"],
      language: "german",
      type: "town"
    }
    spaces['regensburg'] = {
      top: 956,
      left: 3033,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["nuremberg","augsburg","salzburg","linz"],
      language: "german",
      type: "town"
    }
    spaces['salzburg'] = {
      top: 1108,
      left: 3147,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["graz","linz","regensburg","augsburg","innsbruck"],
      pass: ["graz"],
      language: "german",
      type: "town"
    }
    spaces['augsburg'] = {
      top: 1084,
      left: 2864,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["innsbruck","worms","nuremberg","regensburg","salzburg"],
      pass: ["innsbruck"],
      language: "german",
      type: "electorate"
    }
    spaces['nuremberg'] = {
      top: 930,
      left: 2837,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["augsburg","worms","mainz","kassel","leipzig","regensburg"],
      language: "german",
      type: "town"
    }
    spaces['mainz'] = {
      top: 872,
      left: 2668,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["trier","cologne","kassel","nuremberg","worms"],
      language: "german",
      type: "electorate"
    }
    spaces['trier'] = {
      top: 897,
      left: 2521,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["liege","metz","mainz"],
      language: "german",
      type: "electorate"
    }
    spaces['strasburg'] = {
      top: 1070,
      left: 2578,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["metz","besancon","basel","worms"],
      language: "german",
      type: "town"
    }
    spaces['worms'] = {
      top: 1009,
      left: 2704,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["strasburg","mainz","nuremberg","augsburg"],
      language: "german",
      type: "town"
    }
    spaces['navarre'] = {
      top: 1814,
      left: 1702,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["bordeaux","zaragoza","bilbao"],
      pass: ["bordeaux"],
      language: "spanish",
      type: "key"
    }
    spaces['bilbao'] = {
      top: 1825,
      left: 1533,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["corunna","valladolid","zaragoza","navarre"],
      language: "spanish",
      type: "town"
    }
    spaces['corunna'] = {
      top: 1870,
      left: 1015,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["biscay","atlantic"],
      neighbours: ["bilbao","valladolid"],
      language: "spanish",
      type: "town"
    }
    spaces['valladolid'] = {
      top: 2058,
      left: 1394,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["corunna","bilbao","madrid"],
      language: "spanish",
      type: "key"
    }
    spaces['zaragoza'] = {
      top: 2025,
      left: 1777,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["navarre","bilbao","madrid","barcelona"],
      language: "spanish",
      type: "town"
    }
    spaces['barcelona'] = {
      top: 2062,
      left: 2106,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["toulouse","avignon","zaragoza","valencia"],
      pass: ["toulouse","avignon"],
      language: "spanish",
      type: "key"
    }
    spaces['palma'] = {
      top: 2266,
      left: 2211,
      home: "hapsburg",
      political: "",
      ports: ["gulflyon","barbary"],
      neighbours: ["cartagena","cagliari"],
      language: "other",
      religion: "catholic",
      type: "town"
    }
    spaces['madrid'] = {
      top: 2236,
      left: 1550,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["cordoba","valladolid","zaragoza","valencia"],
      language: "spanish",
      type: "town"
    }
    spaces['valencia'] = {
      top: 2333,
      left: 1871,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["cartagena","madrid","barcelona"],
      language: "spanish",
      type: "town"
    }
    spaces['cartagena'] = {
      top: 2593,
      left: 1830,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","barbary"],
      neighbours: ["granada","valencia"],
      language: "spanish",
      type: "town"
    }
    spaces['granada'] = {
      top: 2657,
      left: 1558,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["cordoba","gibraltar","cartagena"],
      language: "spanish",
      type: "town"
    }
    spaces['seville'] = {
      top: 2642,
      left: 1319,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["atlantic"],
      neighbours: ["cordoba","gibraltar"],
      language: "spanish",
      type: "key"
    }
    spaces['cordoba'] = {
      top: 2530,
      left: 1446,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["madrid","seville","granada"],
      language: "spanish",
      type: "town"
    }
    spaces['gibraltar'] = {
      top: 2814,
      left: 1374,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["atlantic","barbary"],
      neighbours: ["seville","granada"],
      language: "spanish",
      type: "fortress"
    }
    spaces['oran'] = {
      top: 2822,
      left: 1902,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["barbary"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['algiers'] = {
      top: 2656,
      left: 2275,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["barbary"],
      neighbours: [],
      language: "other",
      type: "key"
    }
    spaces['tunis'] = {
      top: 2599,
      left: 2945,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["barbary","africa"],
      neighbours: [],
      language: "other",
      type: "key"
    }
    spaces['cagliari'] = {
      top: 2320,
      left: 2828,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports:["tyrrhenian","barbary"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['palermo'] = {
      top: 2421,
      left: 3260,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["messina"],
      language: "italian",
      type: "town"
    }
    spaces['messina'] = {
      top: 2429,
      left: 3475,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian","ionian"],
      neighbours: ["palermo","naples","taranto"],
      language: "italian",
      type: "town"
    }
    spaces['cerignola'] = {
      top: 1915,
      left: 3426,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["taranto","ancona","rome"],
      language: "italian",
      type: "town"
    }
    spaces['taranto'] = {
      top: 2080,
      left: 3597,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["ionian"],
      neighbours: ["cerignola","naples","messina"],
      language: "italian",
      type: "town"
    }
    spaces['naples'] = {
      top: 2087,
      left: 3358,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["rome","taranto","messina"],
      language: "italian",
      type: "key"
    }
    spaces['malta'] = {
      top: 2715,
      left: 3380,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["ionian","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['vienna'] = {
      top: 1020,
      left: 3474,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["brunn","linz","graz","pressburg"],
      language: "german",
      type: "key"
    }
    spaces['linz'] = {
      top: 1045,
      left: 3288,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["prague","regensburg","salzburg","vienna"],
      language: "german",
      type: "town"
    }
    spaces['graz'] = {
      top: 2715,
      left: 3380,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["salzburg","vienna","mohacs","agram","trieste"],
      pass: ["salzburg"],
      language: "german",
      type: "town"
    }
    spaces['trieste'] = {
      top: 1392,
      left: 3257,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["graz","agram","zara","venice"],
      language: "italian",
      type: "town"
    }
    spaces['innsbruck'] = {
      top: 1170,
      left: 3016,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["augsburg","trent","zurich","salzburg"],
      pass: ["augsburg","trent"],
      language: "german",
      type: "town"
    }
    spaces['tripoli'] = {
      top: 3030,
      left: 3316,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["north"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['candia'] = {
      top: 2670,
      left: 4484,
      home: "venice",
      political: "",
      religion: "catholic",
      ports: ["aegean","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['rhodes'] = {
      top: 2524,
      left: 4730,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["aegean","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['corfu'] = {
      top: 2210,
      left: 3868,
      home: "venice",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['coron'] = {
      top: 2510,
      left: 4146,
      home: "ottoman",
      political: "",
      religion: "other",
      ports:["ionian","aegean"],
      neighbours: ["athens"],
      language: "other",
      type: "town"
    }
    spaces['athens'] = {
      top: 2346,
      left: 4286,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["aegean"],
      neighbours: ["larissa","lepanto","coron"],
      language: "other",
      type: "key"
    }
    spaces['lepanto'] = {
      top: 2320,
      left: 4057,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["ionian"],
      neighbours: ["larissa","athens"],
      language: "other",
      type: "town"
    }
    spaces['larissa'] = {
      top: 2184,
      left: 4130,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["durazzo","lepanto","athens","salonika"],
      pass: ["durazzo"],
      language: "other",
      type: "town"
    }
    spaces['salonika'] = {
      top: 2010,
      left: 4164,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["aegean"],
      neighbours: ["larissa","edirne"],
      language: "other",
      type: "key"
    }
    spaces['durazzo'] = {
      top: 2040,
      left: 3844,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["adriatic"],
      neighbours: ["larissa","scutari"],
      pass: ["larissa"],
      language: "other",
      type: "town"
    }
    spaces['scutari'] = {
      top: 1860,
      left: 3819,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["adriatic"],
      neighbours: ["nezh","ragusa","durazzo"],
      pass: ["nezh"],
      language: "other",
      type: "fortress"
    }
    spaces['edirne'] = {
      top: 1840,
      left: 4532,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["varna","istanbul","salonika","sofia",],
      language: "other",
      type: "key"
    }
    spaces['istanbul'] = {
      top: 1890,
      left: 4775,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["black","aegean"],
      neighbours: ["edirne","varna"],
      language: "other",
      type: "key"
    }
    spaces['varna'] = {
      top: 1620,
      left: 4653,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["black"],
      neighbours: ["bucharest","edirne","istanbul"],
      language: "other",
      type: "town"
    }
    spaces['bucharest'] = {
      top: 1430,
      left: 4459,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["nicopolis","varna"],
      language: "other",
      type: "town"
    }
    spaces['nicopolis'] = {
      top: 1570,
      left: 4336,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["szegedin","sofia","bucharest","belgrade"],
      pass: ["szegedin","sofia"],
      language: "other",
      type: "town"
    }
    spaces['sofia'] = {
      top: 1765,
      left: 4275,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["nicopolis","nezh","edirne"],
      pass: ["nicopolis"],
      language: "other",
      type: "town"
    }
    spaces['nezh'] = {
      top: 1652,
      left: 4070,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["scutari","belgrade","sofia"],
      pass: ["scutari"],
      language: "other",
      type: "town"
    }


    spaces['belgrade'] = {
      top: 1450,
      left: 3894,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["ragusa","szegedin","mohacs","agram","nezh","nicopolis"],
      pass: ["ragusa"],
      language: "other",
      type: "key"
    }
    spaces['szegedin'] = {
      top: 1268,
      left: 3846,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["nicopolis","buda","belgrade"],
      pass: ["nicopolis"],
      language: "other",
      type: "town"
    }
    spaces['mohacs'] = {
      top: 1353,
      left: 3710,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["buda","graz","agram","belgrade"],
      language: "other",
      type: "town"
    }
    spaces['graz'] = {
      top: 1208,
      left: 3374,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["vienna","mohacs","agram","trieste"],
      language: "german",
      type: "town"
    }
    spaces['agram'] = {
      top: 1373,
      left: 3460,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["zara","graz","trieste","belgrade","mohacs"],
      pass: ["zara"],
      language: "other",
      type: "town"
    }
    spaces['buda'] = {
      top: 1104,
      left: 3746,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["pressburg","mohacs","szegedin"],
      language: "other",
      type: "key"
    }
    spaces['pressburg'] = {
      top: 1080,
      left: 3613,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["vienna","buda"],
      language: "other",
      type: "town"
    }
    spaces['brunn'] = {
      top: 840,
      left: 3526,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["breslau","prague","vienna"],
      language: "other",
      type: "town"
    }
    spaces['breslau'] = {
      top: 640,
      left: 3466,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["brandenburg","wittenberg","brunn"],
      language: "other",
      type: "town"
    }
    spaces['prague'] = {
      top: 785,
      left: 3230,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["wittenberg","leipzig","linz"],
      language: "other",
      type: "key"
    }
    spaces['amsterdam'] = {
      top: 546,
      left: 2244,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["antwerp","munster"],
      language: "other",
      type: "town"
    }
    spaces['antwerp'] = {
      top: 669,
      left: 2168,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["antwerp","liege","brussels","calais"],
      language: "other",
      type: "key"
    }
    spaces['brussels'] = {
      top: 823,
      left: 2201,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["antwerp","calais","stquentin","stdizier","liege"],
      language: "french",
      type: "fortress"
    }
    spaces['liege'] = {
      top: 783,
      left: 2351,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["cologne","trier","metz","brussels","antwerp"],
      language: "french",
      type: "town"
    }
    spaces['metz'] = {
      top: 995,
      left: 2384,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["liege","trier","strasburg","besancon","stdizier"],
      language: "french",
      type: "key"
    }
    spaces['besancon'] = {
      top: 1169,
      left: 2390,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["metz","dijon","geneva","basel","strasburg"],
      language: "french",
      type: "fortress"
    }
    spaces['basel'] = {
      top: 1211,
      left: 2558,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["strasburg","besancon","geneva","zurich"],
      language: "german",
      type: "town"
    }
    spaces['zurich'] = {
      top: 1216,
      left: 2712,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["basel","innsbruck"],
      language: "german",
      type: "town"
    }
    spaces['geneva'] = {
      top: 1367,
      left: 2474,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["basel","besancon","lyon","turin","grenoble"],
      pass: ["turin"],
      language: "french",
      type: "town"
    }
    spaces['milan'] = {
      top: 1373,
      left: 2746,
      home: "independent",
      political: "france",
      religion: "catholic",
      neighbours: ["trent","modena","pavia","turin"],
      language: "italian",
      type: "key"
    }
    spaces['trent'] = {
      top: 1310,
      left: 2933,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["innsbruck","milan","modena","venice"],
      pass: ["innsbruck"],
      language: "italian",
      type: "town"
    }
    spaces['modena'] = {
      top: 1486,
      left: 2951,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["trent","milan","pavia","florence","ravenna","venice"],
      language: "italian",
      type: "town"
    }
    spaces['pavia'] = {
      top: 1505,
      left: 2800,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["milan","turin","genoa","modena"],
      language: "italian",
      type: "town"
    }
    spaces['turin'] = {
      top: 1530,
      left: 2585,
      home: "independent",
      political: "france",
      religion: "catholic",
      neighbours: ["milan","pavia","geneva","grenoble","genoa"],
      pass: ["grenoble","geneva"],
      language: "italian",
      type: "town"
    }
    spaces['nice'] = {
      top: 1733,
      left: 2580,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["genoa","marseille"],
      pass: ["genoa"],
      language: "french",
      type: "town"
    }
    spaces['florence'] = {
      top: 1642,
      left: 2976,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["modena","genoa","siena"],
      language: "italian",
      type: "key"
    }
    spaces['siena'] = {
      top: 1805,
      left: 2988,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["genoa","florence","rome"],
      language: "italian",
      type: "town"
    }
    spaces['bastia'] = {
      top: 1829,
      left: 2784,
      home: "genoa",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","tyrrhenian"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['genoa'] = {
      top: 1626,
      left: 2726,
      home: "genoa",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","tyrrhenian"],
      neighbours: ["nice","pavia","turin","modena","siena"],
      pass: ["nice"],
      language: "italian",
      type: "key"
    }
    spaces['rome'] = {
      top: 1924,
      left: 3125,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["siena","ancona","cerignola","naples"],
      language: "italian",
      type: "key"
    }
    spaces['ancona'] = {
      top: 1754,
      left: 3238,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["ravenna","rome","cerignola"],
      language: "italian",
      type: "town"
    }
    spaces['ravenna'] = {
      top: 1596,
      left: 3130,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["venice","modena","ancona"],
      language: "italian",
      type: "key" 
    }
    spaces['venice'] = {
      top: 1399,
      left: 3086,
      home: "venice",
      political: "",
      religion: "catholic",
      ports:["adriatic"],
      neighbours: ["trent","modena","ravenna","trieste"],
      language: "italian",
      type: "key"
    }
    spaces['zara'] = {
      top: 1571,
      left: 3374,
      home: "venice",
      political: "",
      religion: "catholic",
      neighbours: ["agram","ragusa","trieste"],
      pass: ["agram"],
      language: "other",
      type: "town"
    }
    spaces['ragusa'] = {
      top: 1750,
      left: 3660,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["belgrade","zara","scutari"],
      pass: ["belgrade"],
      language: "italian",
      type: "town"
    }

    //
    // foreign war cards are spaces
    //
    spaces['egypt'] = {
      top: 800,
      left: 4500,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }
    spaces['ireland'] = {
      top: 800,
      left: 4125,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }
    spaces['persia'] = {
      top: 500,
      left: 3800,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }

    for (let key in spaces) {
      spaces[key].key = key;
      spaces[key].units = {};
      spaces[key].units['england'] = [];
      spaces[key].units['france'] = [];
      spaces[key].units['hapsburg'] = [];
      spaces[key].units['ottoman'] = [];
      spaces[key].units['papacy'] = [];
      spaces[key].units['protestant'] = [];
      spaces[key].units['venice'] = [];
      spaces[key].units['genoa'] = [];
      spaces[key].units['hungary'] = [];
      spaces[key].units['scotland'] = [];
      spaces[key].units['independent'] = [];
      spaces[key].university = 0;
      spaces[key].unrest = 0;
      if (!spaces[key].ports) { spaces[key].ports = []; }
      if (!spaces[key].pass) { spaces[key].pass = []; }
      if (!spaces[key].name) { spaces[key].name = key.charAt(0).toUpperCase() + key.slice(1); }
      if (!spaces[key].key) { spaces[key].key = key; }
      if (!spaces[key].besieged) { spaces[key].besieged = 0; }
      if (!spaces[key].besieged_factions) { spaces[key].besieged_factions = []; }
    }

    return spaces;

  }


  isOccupied(space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    for (let key in space.units) {
      if (space.units[key].length > 0) { return 1; }
    }

    return 0;
  }

  isElectorate(spacekey) {

    try { if (spacekey.key) { spacekey = spacekey.key; } } catch (err) {}

    if (spacekey === "augsburg") { return 1; }
    if (spacekey === "trier") { return 1; }
    if (spacekey === "cologne") { return 1; }
    if (spacekey === "wittenberg") { return 1; }
    if (spacekey === "mainz") { return 1; }
    if (spacekey === "brandenburg") { return 1; }
    return 0;
  }

  //
  // import space attaches events / functions to spaces if they do not exist
  //
  importSpace(obj, key) {

    let his_self = this;

    obj.key = key;

    if (obj.name == null)               { obj.name = "Unknown"; }
    if (obj.owner == null)              { obj.owner = -1; }          
    if (obj.type == null)               { obj.type = "town"; }     
    if (obj.debaters == null)           { obj.debaters = []; }     
    if (obj.returnView == null)		{ 

      obj.returnView = function () {

	let html = '<div class="space_view" id="">';

	let space = his_self.game.spaces[obj.key];

	let home = obj.home;
	let religion = obj.religion;
	let political = obj.political;
	let language = obj.language;
	if (!political) { political = obj.home; }

	if (political == "genoa" || political == "venice" || political == "scotland" || political == "hungary" || political == "independent") { his_self.game.state.board[political] = his_self.returnOnBoardUnits(political); } else {
	  if (home == "genoa" || home == "venice" || home == "scotland" || home == "hungary" || home == "independent") { his_self.game.state.board[home] = his_self.returnOnBoardUnits(home); }
	}

	html += `
	  <div class="space_name">${obj.name}</div>
	  <div class="space_properties">
	    <div class="religion"><div class="${religion}" style="background-image: url('${his_self.returnReligionImage(religion)}')"></div><div class="label">${religion} religion</div></div>
	    <div class="political"><div class="${political}" style="background-image: url('${his_self.returnControlImage(political)}')"></div><div class="label">${political} control</div></div>
	    <div class="language"><div class="${language}" style="background-image: url('${his_self.returnLanguageImage(language)}')"></div><div class="label">${language} language</div></div>
	    <div class="home"><div class="${home}" style="background-image: url('${his_self.returnControlImage(home)}')"></div><div class="label">${home} home</div></div>
	  </div>
	  <div class="space_units">
	`;

        for (let key in space.units) {
	  html += his_self.returnArmyTiles(key, obj.key);
	  html += his_self.returnMercenaryTiles(key, obj.key);
	  html += his_self.returnPersonagesTiles(key, obj.key);
	  html += his_self.returnNavalTiles(key, obj.key);
        }

        for (let f in space.units) {
	  if (space.units[f].length > 0) {
            for (let i = 0; i < space.units[f].length; i++) {
	      let b = "";
	      if (space.units[f][i].besieged) { b = ' (besieged)'; }
	      html += `<div class="space_unit">${f} - ${space.units[f][i].type} ${b}</div>`;
	    }
	  }
	}

	html += `</div>`;
	html += `</div>`;

	return html;

      };

    }

    return obj;

  }


  //
  // Allies
  //
  // are by definition major powers as opposed minor / activated powers, although 
  // if you ask areAllies() or areEnemies() on combinations of faction names that 
  // include minor-activated powers like scotland or genoa these functions will 
  // politely let you know if those minor-powers are activated to an ally or enemy
  //
  returnDeclarationOfWarCost(f1, f2) {
    if (f1 == "ottoman") {
      if (f2 == "ottoman") 	{ return 0; }
      if (f2 == "hapsburg") 	{ return 2; }
      if (f2 == "england") 	{ return 2; }
      if (f2 == "france") 	{ return 2; }
      if (f2 == "papacy") 	{ return 2; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 1; }
    }
    if (f1 == "hapsburg") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 2; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 4; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 2; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 1; }
      if (f2 == "venice") 	{ return 2; }
    }
    if (f1 == "england") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 1; }
      if (f2 == "england") 	{ return 0; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 3; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 1; }
      if (f2 == "venice") 	{ return 0; }
    }
    if (f1 == "france") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 3; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 0; }
      if (f2 == "papacy") 	{ return 3; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 2; }
      if (f2 == "venice") 	{ return 1; }
    }
    if (f1 == "papacy") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 4; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 0; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 2; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 2; }
    }
    if (f1 == "protestant") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 0; }
      if (f2 == "england") 	{ return 2; }
      if (f2 == "france") 	{ return 2; }
      if (f2 == "papacy") 	{ return 0; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 1; }
    }
    return 0;
  }
  returnDeclarationOfWarTargets(faction) {

    let na = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (!this.areAllies(faction, io[i])) { na.push(io[i]); }
      }
    }
    if (!this.areAllies(faction, "genoa")) { na.push("genoa"); }
    if (!this.areAllies(faction, "scotland")) { 
      if (faction != "protestant" && faction != "papacy" && faction != "ottoman") { na.push("scotland"); }
    }
    if (!this.areAllies(faction, "venice")) { 
      if (faction != "england") { na.push("venice"); }
    }

    let rv = [];

    for (let i = 0; i < na.length; i++) {
      if (na[i] != faction) {
        if (this.returnDeclarationOfWarCost(faction, na[i]) > 0) {
	  rv.push({ faction : na[i] , cost : this.returnDeclarationOfWarCost(faction, na[i]) });
        }
      }
    } 

    return rv;
  }

  returnAllies(faction) { 
    let f = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (this.areAllies(faction, io[i])) { f.push(io[i]); }
      }
    }
    if (this.areAllies(faction, "genoa")) { f.push("genoa"); }
    if (this.areAllies(faction, "venice")) { f.push("venice"); }
    if (this.areAllies(faction, "hungary")) { f.push("hungary"); }
    if (this.areAllies(faction, "scotland")) { f.push("scotland"); }
    return f;
  }

  returnEnemies(faction, include_minor_powers=false) { 
    let f = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (this.areEnemies(faction, io[i])) { f.push(io[i]); }
      }
    }
    if (include_minor_powers) {
      if (this.areEnemies(faction, "hungary")) { f.push("hungary"); }
      if (this.areEnemies(faction, "scotland")) { f.push("scotland"); }
      if (this.areEnemies(faction, "venice")) { f.push("venice"); }
      if (this.areEnemies(faction, "genoa")) { f.push("genoa"); }
    }
    return f;
  }

  areAllies(faction1, faction2, count_minor_activated_factions=1) {
    if (faction1 == faction2) { return 1; }
    try { if (this.game.state.alliances[faction1][faction2].allies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.alliances[faction2][faction1].allies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction1].includes(faction2)) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction2].includes(faction1)) { return 1; } } catch (err) {}
    if (count_minor_activated_factions) {
      if (this.isMinorPower(faction1) || this.isMinorPower(faction2)) {
        let f1cp = this.returnControllingPower(faction1);
        let f2cp = this.returnControllingPower(faction2);
        try { if (this.game.state.alliances[f2cp][f1cp].allies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f1cp][f2cp].allies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f2cp][f1cp].allies == 1) { return 1; } } catch (err) {}
      }
    }
    return 0;
  }

  areEnemies(faction1, faction2, count_minor_activated_factions=1) {

    if (faction1 === faction2) { return 0; }
    try { if (this.game.state.alliances[faction1][faction2].enemies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.alliances[faction2][faction1].enemies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction1].includes(faction2)) { return 0; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction2].includes(faction1)) { return 0; } } catch (err) {}
    if (count_minor_activated_factions) {
      if (this.isMinorPower(faction1) || this.isMinorPower(faction2)) {
        let f1cp = this.returnControllingPower(faction1);
        let f2cp = this.returnControllingPower(faction2);
        try { if (this.game.state.alliances[f1cp][f2cp].enemies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f2cp][f1cp].enemies == 1) { return 1; } } catch (err) {}
      }
    }
    return 0;
  }

  setActivatedPower(faction, activated_power) {
    if (!this.game.state.activated_powers[faction].includes(activated_power)) { 
      this.game.state.activated_powers[faction].push(activated_power);
    }

    //
    // any units not belonging to this activated_power or the faction must be
    // relocated to their capital (if exists) or destroyed.
    //
    for (let key in this.game.spaces) {
      let space = this.game.spaces[key];
      if (space.political == activated_power || (space.political == "" && space.home == activated_power)) {
	for (let f in space.units) {
	  if (f !== faction && f !== activated_power) {
	    if (space.units[f].length > 0) {
	      this.moveFactionUnitsInSpaceToCapitalIfPossible(f, space.key);
	    }
	  }
	}
      }
    }
  }


  unsetActivatedPower(faction, activated_power) {

    if (this.game.state.activated_powers[faction].includes(activated_power)) {
      let x = [];
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
        if (this.game.state.activated_powers[faction][i] !== activated_power) {
          x.push(this.game.state.activated_powers[faction][i]);
        }
      }
      this.game.state.activated_powers[faction] = x;
    }

   
    //
    // any units not belonging to this activated_power must be
    // relocated to their capital (if exists) or destroyed.
    //
    for (let key in this.game.spaces) {
      let space = this.game.spaces[key];
      if (space.political == activated_power || (space.political == "" && space.home == activated_power)) {
        for (let f in space.units) {
          if (f !== faction && f !== activated_power) {
            if (space.units[f].length > 0) {
              this.moveFactionUnitsInSpaceToCapitalIfPossible(f, space.key);
            }
          }
        }
      }
    } 

  }

  isActivatedPower(faction, activated_power) {
    if (this.game.state.activated_powers[faction].includes(activated_power)) {
      return 1;
    }
    return 0;
  }


  setAllies(faction1, faction2, amp=1) {

    try { this.game.state.alliances[faction1][faction2].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].allies = 1; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].allies = 1; } catch (err) {}

    //
    // in the 2P game, Hapsburgs are an activated power for the Papacy
    //
    if (this.game.state.events.schmalkaldic_league == 1 && this.game.players.length == 2 && (faction1 == "papacy" || faction1 == "hapsburg") && (faction1 == "hapsburg" || faction2 == "papacy")) {
      if (!this.game.state.activated_powers["papacy"].includes("hapsburg")) {
        this.setActivatedPower("papacy", "hapsburg");
      }
    }

    if (amp == 1) {
      if (this.isMinorPower(faction1)) {
        if (!this.isMinorPower(faction2)) {
  	  this.activateMinorPower(faction2, faction1);
        }
      }
      if (this.isMinorPower(faction2)) {
        if (!this.isMinorPower(faction1)) {
	  this.activateMinorPower(faction1, faction2);
        }
      }
    }

    this.displayWarBox();

  }

  unsetAllies(faction1, faction2, amp=1) {

    //
    // hungary and hapsburgs locked-for-life
    //
    if (this.game.state.events.defeat_of_hungary_bohemia == 1 && (faction1 == "hapsburg" || faction2 == "hapsburg") && (faction1 == "hungary" || faction2 == "hungary")) {
      return 0;
    }

    //
    // some conditions prevent deactivating alliances
    //
    if (this.game.players.length == 2) { if (faction1 === "hapsburg" && faction2 === "papacy") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Papacy must remain allied in 2P game after Schmalkaldic League formed");
	return 1;
      }
    } } 
    if (this.game.players.length == 2) { if (faction2 === "hapsburg" && faction1 === "papacy") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Papacy must remain allied in 2P game after Schmalkaldic League formed");
	return 1;
      }
    } }

    //
    // and... no longer allies
    //
    try { this.game.state.alliances[faction2][faction1].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].allies = 0; } catch (err) {}


    //
    // remove activated powers if set
    //
    try {
      this.unsetActivatePower(faction1, faction2);
      this.unsetActivatePower(faction2, faction1);
    } catch (err) {}


    if (amp == 1) {
      if (this.isMinorPower(faction1)) {
        if (!this.isMinorPower(faction2)) {
  	  this.activateMinorPower(faction2, faction1);
        }
      }
      if (this.isMinorPower(faction2)) {
        if (!this.isMinorPower(faction1)) {
	  this.activateMinorPower(faction1, faction2);
        }
      }
    }

    this.displayWarBox();

  }

  setEnemies(faction1, faction2) {
    try { this.game.state.alliances[faction1][faction2].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].enemies = 1; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 1; } catch (err) {}
    this.displayWarBox();
  }

  unsetEnemies(faction1, faction2) {

    //
    // undo excommunication
    //
    if (faction1 == "papacy") {
      if (this.game.state.excommunicated_factions[faction2] == 1) {
	this.unexcommunicateFaction(faction2);
      }
    }
    if (faction2 == "papacy") {
      if (this.game.state.excommunicated_factions[faction1] == 1) {
	this.unexcommunicateFaction(faction1);
      }
    }

    if (this.game.players.length == 2) { if (faction1 === "hapsburg" && faction2 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction2 === "hapsburg" && faction1 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction1 === "papacy" && faction2 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Papacy and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction2 === "papacy" && faction1 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Papacy and Protestants must remain at war in 2P variant");
      }
    } }


    try { this.game.state.alliances[faction1][faction2].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 0; } catch (err) {}

    this.displayWarBox();

  }


  returnPlayerCommandingFaction(defender) {

    //
    // by default factions control themselves
    //

    //
    // maybe this is a minor power controlled by a larger one
    //
    if (defender == "venice" || defender == "independent" || defender == "genoa" || defender == "scotland" || defender == "hungary") {
      defender = this.returnControllingPower(defender);
    }

    //
    // defender now controlling power or itself
    //
    for (let p = 0; p < this.game.players.length; p++) {

      //
      // does player command this faction
      //
      let player_factions = this.returnPlayerFactions((p+1));

      let i_command_this_faction = false;
      for (let i = 0; i < player_factions.length; i++) { 
	if (player_factions[i] === defender) { 
	  return (p+1);
	}

        if (this.game.state.activated_powers[player_factions[i]].includes(defender)) { 
	  return (p+1);
	}
        for (let z = 0; z < this.game.state.activated_powers[player_factions[i]]; z++) {
          if (this.game.state.activated_powers[player_factions[i]][z] === defender) {
	    return (p+1);
	  }
        }
      }
    }

    //
    // no-one controls this faction
    //
    return 0;

  }



  isMajorPower(power) {
    if (power === "france" || power === "hapsburg" || power === "england" || power === "protestant" || power === "ottoman" || power === "papacy") { return true; }
    return false;
  }

  isMinorPower(power) {
    if (power === "genoa" || power === "hungary" || power === "scotland" || power === "venice") { return 1; }
    return 0;
  }

  isAlliedMinorPower(mp, faction) {
    if (faction === this.returnAllyOfMinorPower(mp)) { return true; }
    return false;
  }

  returnMinorPowers() {
    return ["genoa", "hungary", "scotland", "venice"];
  }

  returnControllingPower(power) {
    return this.returnAllyOfMinorPower(power);
  }

  returnAllyOfMinorPower(power) {
    if (this.isMajorPower(power)) { return power; }
    for (let key in this.game.state.activated_powers) {
      if (this.game.state.activated_powers[key].includes(power)) {
	return key;
      }
    }
    if (this.areAllies(power, "papacy", 0)) { return "papacy"; }
    if (this.areAllies(power, "protestant", 0)) { return "protestant"; }
    if (this.areAllies(power, "france", 0)) { return "france"; }
    if (this.areAllies(power, "england", 0)) { return "england"; }
    if (this.areAllies(power, "hapsburg", 0)) { return "hapsburg"; }
    if (this.areAllies(power, "ottoman", 0)) { return "ottoman"; }
    return power;
  }

  activateMinorPower(faction, power) {
    if (this.returnAllyOfMinorPower(power) != power) {
      this.deactivateMinorPower(this.returnAllyOfMinorPower(power), power);
    }
    this.setAllies(faction, power, 0);
    this.game.state.activated_powers[faction].push(power);
    this.game.state.minor_activated_powers.push(power);
    this.displayBoard();
    this.displayVictoryTrack();
  }

  deactivateMinorPower(faction, power) {
    this.unsetAllies(faction, power, 0);
    for (let key in this.game.state.activated_powers) {
      for (let i = 0; i < this.game.state.activated_powers[key].length; i++) {
        if (this.game.state.activated_powers[key][i] === power) {
  	  this.game.state.activated_powers[key].splice(i, 1);
        }
      }
    }
    for (let i = 0; i < this.game.state.minor_activated_powers.length; i++) {
      if (this.game.state.minor_activated_powers[i] === power) {
	this.game.state.minor_activated_powers.splice(i, 1);
      }
    }
    this.displayBoard();
    this.displayVictoryTrack();
  }

  canFactionDeactivateMinorPower(faction, power) {
    if (power == "genoa") { if (faction == "france" || faction == "hapsburg" || faction == "papacy") { return 1; } }
    if (power == "scotland") { if (faction == "england" || faction == "france") { return 1; } }
    if (power == "venice") { if (faction == "france" || faction == "hapsburg" || faction == "papacy") { return 1; } }
    return 0;
  }

  canFactionActivateMinorPower(faction, power) {
    if (power == "genoa") {
      if (faction == "france") { return 1; }
      if (faction == "hapsburg") { return 1; }
      if (faction == "papacy") { return 1; }
    }
    if (power == "hungary") {
      if (faction == "hapsburg") { return 1; }
    }
    if (power == "scotland") {
      if (faction == "france") { return 1; }
      if (faction == "england") { return 1; }
    }
    if (power == "venice") {
      if (faction == "france") { return 1; }
      if (faction == "hapsburg") { return 1; }
      if (faction == "papacy") { return 1; }
    }
    return 0;
  }

  isMinorActivatedPower(power) {
    for (let i = 0; i < this.game.state.minor_activated_powers.length; i++) {
      if (power === this.game.state.minor_activated_powers[i]) {
	return 1;
      }
    }
    return 0;
  }

  isMinorUnactivatedPower(power) {
    if (power === "genoa" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "scotland" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "hungary" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "venice" && this.isMinorActivatedPower(power) != 1) { return 1; }
    return 0;
  }


  onNewImpulse() {

    //
    // reset player last move
    //
    this.game.state.player_last_move = "";
    this.game.state.player_last_spacekey = "";

    //
    // remove foul weather
    //
    this.game.state.events.foul_weather = 0;
    this.game.state.events.foreign_recruits = "";
    this.game.state.spring_deploy_across_passes = [];
    this.game.state.spring_deploy_across_seas = [];
    this.game.state.foreign_wars_fought_this_impulse = [];
    this.game.state.events.spring_preparations = "";
    this.game.state.events.henry_petitions_for_divorce_grant = 0;
    this.game.state.spaces_assaulted_this_turn = [];
    this.game.state.events.cranmer_active = 0;
    this.game.state.events.more_executed_limits_debates = 0;
    this.game.state.events.more_bonus = 0;
    this.game.state.events.sack_of_rome = 0;

    //
    // reset impulse commits
    //
    this.game.state.debater_committed_this_impulse = {};
    this.game.state.assaulted_this_impulse = 0;

    // display cards left
    this.displayCardsLeft();

    //
    // remove gout
    //
    if (this.game.state.events.gout != 0) {
      for (let i in this.game.spaces) {
	let space = this.game.spaces[i];
        for (let f in space.units) {
          for (let z = space.units[f].length-1;  z >= 0; z--) {
	    space.units[f][z].gout = false; 
	    space.units[f][z].relief_force = 0;
  	  }
        }
      }
      this.game.state.events.gout = 0;    
    }

    //
    // remove temporary bonuses and modifiers
    //
    this.game.state.events.augsburg_confession = false;

    // allow stuff to move again
    this.resetLockedTroops();

  }

  onNewRound() {

    //
    // reset piracy markers
    //
    for (let key in this.game.navalspaces) {
      this.hidePiracyMarker(key);
    }

    //
    // reset variables that permit intervention
    //
    this.game.state.events.intervention_on_movement_possible = 0;
    this.game.state.events.intervention_on_events_possible = 0;
    this.game.state.events.intervention_on_assault_possible = 0;

    //
    // reset impulse commits
    //
    this.game.state.debater_committed_this_impulse = {};
    this.game.state.spaces_assaulted_this_turn = [];
    this.game.state.printing_press_active = 0;
    this.game.state.events.sack_of_rome = 0;
    this.game.state.events.julia_gonzaga_activated = 0;
    this.game.state.events.england_changed_rulers_this_turn = 0;
    this.game.state.events.smallpox = "";
    this.game.state.cards_evented = [];
    this.game.state.foreign_wars_fought_this_impulse = [];
    this.game.state.henry_viii_pope_approves_divorce = 0;

    this.game.state.may_explore['england'] = 1;
    this.game.state.may_explore['france'] = 1;
    this.game.state.may_explore['hapsburg'] = 1;
    this.game.state.may_conquer['england'] = 1;
    this.game.state.may_conquer['france'] = 1;
    this.game.state.may_conquer['hapsburg'] = 1;
    this.game.state.may_colonize['england'] = 1;
    this.game.state.may_colonize['france'] = 1;
    this.game.state.may_colonize['hapsburg'] = 1;

    this.game.state.events.ottoman_piracy_wartburg = 0;
    this.game.state.events.ottoman_piracy_attempts = 0;
    this.game.state.events.ottoman_piracy_seazones = [];

    this.game.state.events.intervention_on_movement_possible = 0;
    this.game.state.events.intervention_on_events_possible = 0;
    this.game.state.events.intervention_on_assault_possible = 0;

    this.game.state.tmp_reformations_this_turn = [];
    this.game.state.tmp_counter_reformations_this_turn = [];
    this.game.state.tmp_protestant_translation_bonus = 0;
    this.game.state.tmp_protestant_reformation_modifier = 0;
    this.game.state.tmp_protestant_reformation_bonus = 0;
    this.game.state.tmp_protestant_reformation_bonus_spaces = [];
    this.game.state.tmp_catholic_reformation_modifier = 0;
    this.game.state.tmp_catholic_reformation_bonus = 0;
    this.game.state.tmp_catholic_reformation_bonus_spaces = [];
            
    this.game.state.tmp_protestant_counter_reformation_modifier = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus_spaces = [];
    this.game.state.tmp_catholic_counter_reformation_modifier = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus_spaces = [];
    this.game.state.tmp_papacy_may_specify_debater = 0;
    this.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    this.game.state.impulse = 0;
    this.game.state.events.more_executed_limits_debates = 0;
    this.game.state.events.more_bonus = 0;
    this.game.state.events.unexpected_war = 0;
 
    this.game.state.newworld.results.colonies = [];
    this.game.state.newworld.results.explorations = [];
    this.game.state.newworld.results.conquests = [];

 
    //
    // allow stuff to move again
    //
    this.resetLockedTroops();
    this.removeBesiegedSpaces();

    this.displayCardsLeft();
    this.displayTurnTrack();

    try { document.querySelector(".crossing_atlantic").innerHTML = ""; } catch (err) {}

    this.displayNewWorld();
    this.displayVictoryTrack();

  }

  returnLoanedUnits() {
    for (let i in this.game.spaces) {
      space = this.game.spaces[i];
      for (let f in space.units) {
        for (let z = space.units[f].length-1;  z >= 0; z--) {
	  let unit = space.units[f][z];
	  if (unit.loaned != false) {
	    let lender = unit.loaned;
	    space.units[f].splice(z, 1);
	    space.units[lender].push(unit);
	  }
        }
      }
    }
    for (let i in this.game.navalspaces) {
      space = this.game.navalspaces[i];
      for (let f in space.units) {
        for (let z = space.units[f].length-1;  z >= 0; z--) {
	  let unit = space.units[f][z];
	  if (unit.loaned != false) {
	    let lender = unit.loaned;
	    space.units[f].splice(z, 1);
	    space.units[lender].push(unit);
	  }
        }
      }
    }
  }

  isCaptured(faction, unittype) {
    for (let i = 0; i < this.game.players.length; i++) {
      let p = this.game.state.players_info[i];
      for (let z = 0; z < p.captured.length; z++) {
        if (p.captured[z].type == unittype) { return 1; }
      }
    }
    return 0;
  }
  isSpaceBesieged(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let faction_with_units = "";
    let faction_in_control = this.returnFactionControllingSpace(space);
    if (space.besieged == 1 || space.besieged == 2 || space.besieged == true) {
      //
      // are we still besieged? will be unit
      //
      for (let f in space.units) {
        for (let i = 0; i < space.units[f].length; i++) {
  	  if (space.units[f][i].besieged == true || space.units[f][i].besieged == 1) {
	    //
	    // we are still besieged if there are any enemy units here
	    //
	    for (let zf in space.units) {
	      if (zf != f) {
		if (space.units[zf].length > 0) {
		  if (!this.areAllies(zf, f)) {
		    if (this.returnFactionLandUnitsInSpace(zf, space.key) > 0) { return true; }
		  }
		}
	      }
	    }

	    //
	    // no-one else is here, so I guess we aren't anymore
	    //
	    return false;
	  } else {
	    // if not independent (which won't attack) or allies, then someone must be besieged
	    if (f != "independent") {
	      if (!this.areAllies(f, faction_in_control)) { return true; }    
	    }
	  }
        }
      }

      return false; // everyone here is allied or independent and not-besieged
    }
    return false;
  }
  isBesieged(faction, unittype) {
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].besieged) {
	for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i].type == unittype) {
	    if (this.game.spaces[key].units[faction][i].besieged == true) {
	      return 1;
	    }
	  }
	}
      }
    }
    return 0;
  }

  captureLeader(winning_faction, losing_faction, space, unit = false) {
    if (!unit) { return; }
    if (unit.personage == false && unit.army_leader == false && unit.navy_leader == false && unit.reformer == false) { return; }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let winning_player = this.returnPlayerCommandingFaction(winning_faction);
    if (winning_player > 0) {
      let p = this.game.state.players_info[winning_player-1];
      let unitjson = JSON.stringify(unit);
      for (let z = 0; z < p.captured.length; z++) {
        if (JSON.stringify(p.captured[z]) === unitjson) { return; }
      }
      unit.capturing_faction = winning_faction;
      p.captured.push(unit);
    }
  }

  captureNavalLeader(winning_faction, losing_faction, space, unit) {
    if (unit.personage == false && unit.army_leader == false && unit.navy_leader == false && unit.reformer == false) { return; }
    this.game.state.naval_leaders_lost_at_sea.push(unit);
  }

  isPersonageOnMap(faction, personage) {
    for (let s in this.game.spaces) {
      if (this.game.spaces[s].units[faction].length > 0) {
	for (let i = 0; i < this.game.spaces[s].units[faction].length; i++) {
	  let unit = this.game.spaces[s].units[faction][i];
	  if (unit.key === personage) { return unit; }
	}
      }
    }
    return null;
  }

  addUnit(faction, space, type) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.newUnit(faction, type));
    this.updateOnBoardUnits();
  }

  removeUnit(faction, space, type) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = space.units[faction].length - 1; i >= 0; i--) {
      if (space.units[faction][i].type == type) {
        this.updateLog(this.returnFactionName(faction) + " removes " + type + " in " + space.name);
	space.units[faction].splice(i, 1);
        this.updateOnBoardUnits();
	return;
      }
    }
  }

  isLandUnit(unit) {
    if (unit.type === "regular") { return 1; }
    if (unit.type === "mercenary") { return 1; }
    if (unit.type === "cavalry") { return 1; }
    return 0;
  }

  addRegular(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "regular"));
    }
    this.updateOnBoardUnits();
  }

  addMercenary(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "mercenary"));
    }
    this.updateOnBoardUnits();
  }

  addCavalry(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "cavalry"));
    }
    this.updateOnBoardUnits();
  }

  addNavalSquadron(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "squadron"));
    }
    this.updateOnBoardUnits();
  }

  addCorsair(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "corsair"));
    }
  }

  //
  // figure out how many base points people have
  //
  calculateVictoryPoints() {

    let factions = {};

    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let ii = 0; ii < this.game.state.players_info[i].factions.length; ii++) {
        factions[this.game.state.players_info[i].factions[ii]] = {
	  faction : this.game.state.players_info[i].factions[ii] ,
	  vp_base : 0 ,
	  vp_bonus : 0 ,
	  vp_special : 0 ,
	  vp : 0 ,
	  keys : 0 ,
	  religious : 0 ,
	  victory : 0,	  
	  details : "",
	};
      }
    }
    //
    // let factions calculate their VP
    //
    for (let f in factions) {
      factions[f].vp_base = this.factions[f].calculateBaseVictoryPoints(this);
      factions[f].vp_bonus = this.factions[f].calculateBonusVictoryPoints(this);
      factions[f].vp_special = this.factions[f].calculateSpecialVictoryPoints(this);
      factions[f].vp = (factions[f].vp_base + factions[f].vp_bonus + factions[f].vp_special);
    }

    //
    // calculate keys controlled
    //
    for (let f in factions) {
      factions[f].keys = this.returnNumberOfKeysControlledByFaction(f);
      if (f === "protestant") {
	factions[f].religious = this.returnNumberOfProtestantSpacesInLanguageZone();
      }
    }

    //
    // military victory
    //
    if (factions['hapsburg']) {
      if (factions['hapsburg'].keys >= this.game.state.autowin_hapsburg_keys_controlled) {
        factions['hapsburg'].victory = 1;
        factions['hapsburg'].details = "military victory";
      }
    }
    if (factions['ottoman']) {
      if (factions['ottoman'].keys >= this.game.state.autowin_ottoman_keys_controlled) {
        factions['ottoman'].victory = 1;
        factions['ottoman'].details = "military victory";
      }
    }
    if (factions['france']) {
      if (factions['france'].keys >= this.game.state.autowin_france_keys_controlled) {
        factions['france'].victory = 1;
        factions['france'].details = "military victory";
      }
    }
    if (factions['england']) {
      if (factions['england'].keys >= this.game.state.autowin_england_keys_controlled) {
        factions['england'].victory = 1;
        factions['england'].details = "military victory";
      }
    }
    if (factions['papacy']) {
      if (factions['papacy'].keys >= this.game.state.autowin_papacy_keys_controlled) {
        factions['papacy'].victory = 1;
        factions['papacy'].details = "military victory";
      }
    }

    //
    // religious victory
    //
    if (factions['protestant']) {
      if (factions['protestant'].religious >= 50) {
        factions['papacy'].victory = 1;
        factions['papacy'].details = "religious victory";
      }
    }

    //
    // PROCESS BONUS VP
    //
    // Copernicus (2 VP) or Michael Servetus (1 VP) event
    if (this.game.state.events.michael_servetus) {
      factions[this.game.state.events.michael_servetus].vp_special++;
      factions[this.game.state.events.michael_servetus].vp++;
    }
    if (this.game.state.events.copernicus) {
      factions[this.game.state.events.copernicus].vp_special += parseInt(this.game.state.events.copernicus_vp);
      factions[this.game.state.events.copernicus].vp += parseInt(this.game.state.events.copernicus_vp);
    }

    //
    // War Winner VP
    //
    factions["protestant"].vp += parseInt(this.game.state.protestant_war_winner_vp);
    factions["papacy"].vp     += parseInt(this.game.state.papacy_war_winner_vp);
    try {
      factions["ottoman"].vp    += parseInt(this.game.state.ottoman_war_winner_vp);
      factions["hapsburg"].vp   += parseInt(this.game.state.hapsburg_war_winner_vp);
      factions["england"].vp    += parseInt(this.game.state.england_war_winner_vp);
      factions["france"].vp     += parseInt(this.game.state.france_war_winner_vp);
    } catch (err) {

    }

    //
    // New World
    //
    for (let key in this.game.state.newworld) {
      if (this.game.state.newworld[key].vp > 0) {
	if (this.game.state.newworld[key].faction) {	  
	  if (this.factions[this.game.state.newworld[key].faction]) {
	    factions[this.game.state.newworld[key].faction].vp += parseInt(this.game.state.newworld[key].vp);
	  }
	}
      }
    }

    //
    //• Bible translation completed (1 VP for each language)    ***
    // protestant faction class
    //• Protestant debater burned (1 per debate rating)         ***
    // protestant faction class
    //• Papal debater disgraced (1 per debate rating)           ***
    // protestant faction class

    //• JuliaGonzaga(1VP)followed by successful Ottoman piracy in Tyrrhenian Sea
    //• War Winner marker received during Peace Segment
    //• Master of Italy VP marker received during Action Phase


    //
    // domination victory (5 more vp than everyone else
    //
    let max_vp = 0;
    let runner_up_vp = 0;
    let lead_required = 5;
    let domination_round = 5;
    if (this.game.players.length == 2) { lead_required = 8; domination_round = 4; }

    let leaders = [];
    for (let key in factions) {
      if (factions[key].vp == max_vp) {
        leaders.push(key);
      }
      if (factions[key].vp > max_vp) {
	runner_up_vp = max_vp;
	max_vp = factions[key].vp;
	leaders = [];
        leaders.push(key);
      }
    }
    if (max_vp >= (runner_up_vp+lead_required) && this.game.state.round >= domination_round && this.game.players.length > 2) {
      if (leaders.length == 1) {
        factions[leaders[0]].victory = 1;
	factions[leaders[0]].reason = "Domination Victory";
      }
    }


    //
    // final victory if round 9
    //
    if (this.game.state.round >= 9) {
      for (let i = 0; i < leaders.length; i++) {
	factions[leaders[0]].victory = 1;
	factions[leaders[0]].reason = "Final Victory";
      }
    }

    //
    // 8 VP lead in 2P
    //
if (this.game.state.scenario != "is_testing") {
    if (this.game.players.length == 2 && this.game.state.round >= 4) {
      if ((factions["protestant"].vp - factions["papacy"].vp) >= 8) {
	factions["protestant"].victory = 1;
	factions["protestant"].reason = "Commanding 8 VP Lead";
      }
      if ((factions["papacy"].vp - factions["protestant"].vp) >= 8) {
	factions["papacy"].victory = 1;
	factions["papacy"].reason = "Commanding 8 VP Lead";
      }
    }
}

    //
    // tied at 25 VP or higher
    //
    let highest_vp = 0;
    let fs = [];
    if (this.game.state.round > 0) {
      while (this.game.state.vp.length < this.game.state.round) { this.game.state.vp.push({}); }
      for (let key in factions) {
        if (factions[key].vp == highest_vp) {
 	  fs.push(key);
        }
        if (factions[key].vp > highest_vp) {
	  fs = [];
	  fs.push(key);
  	  highest_vp = factions[key].vp;
        }
        this.game.state.vp[this.game.state.round-1][key] = factions[key].vp;
      }
      if (fs.length == 1 && highest_vp >= 25) {
        factions[fs[0]].victory = 1;
        factions[fs[0]].reason = "Standard Victory"; 
      }
      //
      // historical resolution -
      //
      if (fs.length > 1 && highest_vp >= 25) {
        for (let z = 0; z < fs.length; z++) {
          factions[fs[z]].victory = 1;
          factions[fs[z]].reason = "Score Tied";
        }
      }
    }

    return factions;

  }


  //
  // faction is papacy or (anything), since debaters aren't really owned by factions outside
  // papcy and protestants, even if they are tagged as would be historically appropriate
  //
  returnDebatersInLanguageZone(language_zone="german", faction="papacy", committed=-1) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].language_zone === language_zone || this.game.state.debaters[i].language_zone === "any") {
        if (this.game.state.debaters[i].faction === faction || (faction != "papacy" && this.game.state.debaters[i].faction != "papacy")) {
          if (this.game.state.debaters[i].committed === committed || committed == -1) {
	    num++;
          }
        }
      }
    }
    return num;
  }


  canProtestantsReformInLanguageZone(lang="german") {
    let access_spots = [];
    if (lang == "german") { access_spots = ["amsterdam","liege","metz","becanson","geneva","trent","trieste","agram","pressburg","brunn","prague","breslau","antwerp","calais","london","norwich","berwick","edinburgh"]; }
    if (lang == "italian") { access_spots = ["innsbruck","graz","geneva","grenoble","nice","agram","zara","bastia","ragusa","scutari","durazzo","corfu","nice"]; }
    if (lang == "spanish") { access_spots = ["bordeaux","toulouse","avignon","marseille","nice","bastia","palma","cagliari","tunis","algiers","oran","nantes","brest"]; }
    if (lang == "english") { access_spots = ["brest","rouen","boulogne","calais","antwerp","amsterdam","bremen","hamburg"]; }
    if (lang == "french") { access_spots = ["plymouth","portsmouth","london","calais","antwerp","cologne","trier","strasburg","basel","turin","genoa","bastia","palma","valencia","barcelona","navarre","corunna"]; }

    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion == "protestant") {
	if (access_spots.includes(key)) { return 1; }
      }
    }

    //
    // add access to any space with a reformer
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].language == lang) {
        for (let z = 0; z < this.game.spaces[key].units["protestant"].length; z++) {
	  let u = this.game.spaces[key].units["protestant"][z];
	  if (u.reformer == true) {
	    return 1;
	  }
	}
      }
    }

    return 0;
  }

  returnDiplomacyImpulseOrder(faction="") {
    if (faction == "ottoman") {
      return ["hapsburg","england","france","papacy","protestant"];
    }
    if (faction == "hapsburg") {
      return ["england","france","papacy","protestant"];
    }
    if (faction == "england") {
      return ["france","papacy","protestant"];
    }
    if (faction == "france") {
      return ["papacy","protestant"];
    }
    if (faction == "papacy") {
      return ["protestant"];
    }
    return [];
  }

  returnImpulseOrder() {
    return ["ottoman","hapsburg","england","france","papacy","protestant"];
  }

  returnNumberOfUncommittedDebaters(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].owner === faction && this.game.state.debaters[i].committed == 0) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfCommittedDebaters(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].owner === faction && this.game.state.debaters[i].committed == 1) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfUncommittedExplorers(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].owner === faction && this.game.state.explorers[i].committed == 0) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfCommittedExplorers(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].owner === faction && this.game.state.explorers[i].committed == 1) {
	num++;
      }
    }
    return num;
  }

  /////////////////////
  // Core Game State //
  /////////////////////
  returnState() {

    let state = {};

    state.skip_counter_or_acknowledge = 0; // don't skip

    state.scenario = "1517";
    if (this.game.options.scenario) { state.scenario = this.game.options.scenario; }
    state.round = 0;
    state.starting_round = 0; // if we start > 1, set this
    state.vp = [];
    state.newworld = this.returnNewWorld();
    state.impulse = 0;
    state.players = [];
    state.events = {};
    state.removed = []; // removed cards
    state.spaces_assaulted_this_turn = [];
    state.board_updated = new Date().getTime();
    state.board = {}; // units on board
    state.cards_evented = [];

    state.foreign_wars_fought_this_impulse = [];

    state.assaulted_this_impulse = 0;
    state.alliances = this.returnDiplomacyAlliance();
    state.diplomacy = [];

    // whose turn is it? (attacker)
    state.active_player = -1;

    // which ones are activated
    state.minor_activated_powers = [];

    state.naval_leaders_lost_at_sea = [];

    state.debater_committed_this_impulse = {};

    state.cards_left = {};

    state.activated_powers = {};
    state.activated_powers['ottoman'] = [];
    state.activated_powers['hapsburg'] = [];
    state.activated_powers['france'] = [];
    state.activated_powers['england'] = [];
    state.activated_powers['papacy'] = [];
    state.activated_powers['protestant'] = [];
    // following for safety
    state.activated_powers['venice'] = [];
    state.activated_powers['scotland'] = [];
    state.activated_powers['genoa'] = [];
    state.activated_powers['hungary'] = [];
    state.activated_powers['independent'] = [];

    state.events.potosi_silver_mines = "";

    state.translations = {};
    state.translations['new'] = {};
    state.translations['new']['german'] = 0;
    state.translations['new']['french'] = 0;
    state.translations['new']['english'] = 0;
    state.translations['full'] = {};
    state.translations['full']['german'] = 0;
    state.translations['full']['french'] = 0;
    state.translations['full']['english'] = 0;

    state.papacy_card_bonus = 0;
    state.protestant_card_bonus = 0;
    state.ottoman_card_bonus = 0;
    state.france_card_bonus = 0;
    state.england_card_bonus = 0;
    state.hapsburg_card_bonus = 0;


    state.protestant_war_winner_vp = 0;
    state.papacy_war_winner_vp = 0;
    state.ottoman_war_winner_vp = 0;
    state.hapsburg_war_winner_vp = 0;
    state.england_war_winner_vp = 0;
    state.france_war_winner_vp = 0;

    state.bonus_vp = {};
    state.bonus_vp['protestant'] = 0;
    state.bonus_vp['papacy'] = 0;
    state.bonus_vp['england'] = 0;
    state.bonus_vp['france'] = 0;
    state.bonus_vp['hapsburg'] = 0;
    state.bonus_vp['ottoman'] = 0;

    state.saint_peters_cathedral = {};
    state.saint_peters_cathedral['state'] = 0;
    state.saint_peters_cathedral['vp'] = 0;    

    state.papal_debaters_disgraced_vp = 0;
    state.protestant_debaters_burned_vp = 0;

    state.events.michael_servetus = "";  // faction that gets VP
    state.events.copernicus = "";        // faction that gets VP
    state.events.copernicus_vp = 0;     // 1 or 2 VP

    state.french_chateaux_vp = 0;

    state.tmp_reformations_this_turn = [];
    state.tmp_counter_reformations_this_turn = [];
    state.tmp_protestant_reformation_modifier = 0;
    state.tmp_protestant_reformation_bonus = 0;
    state.tmp_protestant_reformation_bonus_spaces = [];
    state.tmp_catholic_reformation_modifier = 0;
    state.tmp_catholic_reformation_bonus = 0;
    state.tmp_catholic_reformation_bonus_spaces = [];

    state.tmp_protestant_counter_reformation_modifier = 0;
    state.tmp_protestant_counter_reformation_bonus = 0;
    state.tmp_protestant_counter_reformation_bonus_spaces = [];
    state.tmp_catholic_counter_reformation_modifier = 0;
    state.tmp_catholic_counter_reformation_bonus = 0;
    state.tmp_catholic_counter_reformation_bonus_spaces = [];
    state.tmp_papacy_may_specify_debater = 0;
    state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    state.tmp_bonus_protestant_translation_german_zone = 0;
    state.tmp_bonus_protestant_translation_french_zone = 0;
    state.tmp_bonus_protestant_translation_english_zone = 0;
    state.tmp_bonus_papacy_burn_books = 0;

    state.events.mercators_map = "";
    state.events.england_changed_rulers_this_turn = 0;
    state.events.colonial_governor = "";

    state.raiders = {};
    state.raiders['protestant'] = 0;
    state.raiders['papacy'] = 0;
    state.raiders['france'] = 0;
    state.raiders['england'] = 0;
    state.raiders['ottoman'] = 0;
    state.raiders['hapsburg'] = 0;
    state.plantations = {};
    state.plantations['protestant'] = 0;
    state.plantations['papacy'] = 0;
    state.plantations['france'] = 0;
    state.plantations['england'] = 0;
    state.plantations['ottoman'] = 0;
    state.plantations['hapsburg'] = 0;

    // bonus cards
    state.new_world_bonus = {};
    state.new_world_bonus['england'] = 0;
    state.new_world_bonus['france'] = 0;
    state.new_world_bonus['hapsburg'] = 0;
    state.new_world_bonus['protestant'] = 0;
    state.new_world_bonus['ottoman'] = 0;
    state.new_world_bonus['papacy'] = 0;

    state.may_explore = {};
    state.may_explore['england'] = 1;
    state.may_explore['france'] = 1;
    state.may_explore['hapsburg'] = 1;
    state.may_explore['protestant'] = 0;
    state.may_explore['papacy'] = 0;
    state.may_explore['ottoman'] = 0;
    state.may_conquer = {};
    state.may_conquer['england'] = 1;
    state.may_conquer['france'] = 1;
    state.may_conquer['hapsburg'] = 1;
    state.may_conquer['protestant'] = 0;
    state.may_conquer['papacy'] = 0;
    state.may_conquer['ottoman'] = 0;
    state.may_colonize = {};
    state.may_colonize['england'] = 1;
    state.may_colonize['france'] = 1;
    state.may_colonize['hapsburg'] = 1;
    state.may_colonize['protestant'] = 0;
    state.may_colonize['papacy'] = 0;
    state.france_uncharted = 1;
    state.hapsburg_uncharted = 1;
    state.england_uncharted = 1;

    state.skip_next_impulse = [];

    //
    // foreign wars
    //
    state.events.war_in_persia = 0;
    state.events.revolt_in_ireland = 0;
    state.events.revolt_in_egypt = 0;

    state.augsburg_electoral_bonus = 0;
    state.mainz_electoral_bonus = 0;
    state.trier_electoral_bonus = 0;
    state.cologne_electoral_bonus = 0;
    state.wittenberg_electoral_bonus = 0;
    state.brandenburg_electoral_bonus = 0;

    state.galleons = {};
    state.galleons['french'] = 0;
    state.galleons['hapsburg'] = 0;
    state.galleons['england'] = 0;

    state.autowin_hapsburg_keys_controlled = 14;
    state.autowin_ottoman_keys_controlled = 11;
    state.autowin_papacy_keys_controlled = 7;
    state.autowin_france_keys_controlled = 11;
    state.autowin_england_keys_controlled = 9;

    state.military_leaders_removed_until_next_round = [];
    state.excommunicated_factions = {};
    state.already_excommunicated = [];
    state.excommunicated = [];
    state.burned = [];
    state.debaters = [];
    state.explorers = [];
    state.conquistadors = [];

    state.leaders = {};
    state.leaders.francis_i = 1;
    state.leaders.henry_viii = 1;
    state.leaders.charles_v = 1;
    state.leaders.suleiman = 1;
    state.leaders.leo_x = 1;
    state.leaders.luther = 1
    state.leaders.clement_vii = 0;
    state.leaders.paul_iii = 0;
    state.leaders.edward_vi = 0;
    state.leaders.henry_ii = 0;
    state.leaders.mary_i = 0;
    state.leaders.julius_iii = 0;
    state.leaders.elizabeth_i = 0;
    state.leaders.calvin = 0;

    state.spring_deploy_across_seas = [];
    state.spring_deploy_across_passes = [];

    state.henry_viii_marital_status = 0;
    state.henry_viii_healthy_edward = 0;
    state.henry_viii_sickly_edward = 0;
    state.henry_viii_add_elizabeth = 0;
    state.henry_viii_auto_reroll = 0;
    state.henry_viii_rolls = [];
    state.henry_viii_pope_approves_divorce = 0;

    state.knights_of_st_john = "";

    state.events.maurice_of_saxony = "";
    state.events.papacy_may_found_jesuit_universities = 0;
    state.events.edward_vi_born = 0;
    state.events.wartburg = 0;

    // mandatory events
    state.events.schmalkaldic_league = 0;
    state.events.clement_vii = 0;
    state.events.barbary_pirates = 0;
    state.events.paul_iii = 0;
    state.events.society_of_jesus = 0;

    state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance = 0;
    state.events.defeat_of_hungary_bohemia = 0;



    state.events.ottoman_piracy_enabled = 0;
    state.events.ottoman_corsairs_enabled = 0;
    state.events.ottoman_piracy_attempts = 0;
    state.events.ottoman_piracy_seazones = [];
    state.events.ottoman_piracy_vp = 0;

    //
    // {
    //    faction : faction
    //    round   : 0
    //  
    state.colonies = [];
    state.conquests = [];
    state.explorations = [];

    state.events.smallpox = "";
    state.events.cabot_england = 0;
    state.events.cabot_france = 0;
    state.events.cabot_hapsburg = 0;
    state.events.ottoman_julia_gonzaga_vp = 0;

    return state;

  }

  unexcommunicateFaction(faction="") {
    this.game.state.excommunicated_factions[faction] = 0;
    return;
  }

  excommunicateFaction(faction="") {
    this.game.state.already_excommunicated.push(faction);
    this.game.state.excommunicated_factions[faction] = 1;
    return;
  }


  returnJustificationForExcommunication(faction) {
    if (this.areEnemies(faction, "papacy")) { return "Wickedness against Saint Peter's Church and the Kingdom of Heaven"; }
    if (this.areAllies(faction, "ottoman")) { return "Providing Succor to the Enemies of Christendom"; }
    if (faction == "england") {
      if (this.game.state.leaders.henry_viii == 1) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == "england") {
	    if (this.game.spaces[key].religion == "protestant") { return "Tacit Support for the Protestant Sect in England"; }
	  }
	}
      }
    }
    return "";
  }


  canPapacyExcommunicateFaction(faction) {
    if (this.game.state.already_excommunicated.includes(faction)) { return 0; }
    if (this.areEnemies(faction, "papacy")) { return 1; }
    if (this.areAllies(faction, "ottoman")) { return 1; }
    if (faction == "england") {
      if (this.game.state.leaders.henry_viii == 1) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == "england") {
	    if (this.game.spaces[key].religion == "protestant") { return 1; }
	  }
	}
      }
    }
    return 0;
  }

  excommunicateReformer(reformer="") {

    this.game.state.already_excommunicated.push(reformer);
    if (reformer == "") { return; }
    if (this.returnSpaceOfPersonage("protestant", reformer) == "") { return; }

    //
    // debater
    //
    let debater = reformer.replace("-reformer", "-debater");
    let faction = "protestant";
    let s = this.returnSpaceOfPersonage("protestant", reformer);
    let idx = -1;

    if (s === "") { faction = "england"; s = this.returnSpaceOfPersonage("england", reformer); }
    if (s === "") { faction = "france"; s = this.returnSpaceOfPersonage("france", reformer); }

    if (s !== "") {
      idx = this.returnIndexOfPersonageInSpace(faction, reformer, s);
    }

    let obj = {};
    obj.space = s;
    obj.faction = faction;
    obj.idx = idx;
    obj.reformer = this.game.spaces[s].units[faction][idx];

    //
    // remove reformer
    //
    if (idx != -1) {
      this.game.spaces[s].units[faction].splice(idx, 1);
    }

    //
    // remove debater
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {
        obj.debater = this.game.state.debaters[i];
        this.game.state.debaters.splice(i, 1);
      }
    }

    //
    // add to excommunicated list
    //
    this.game.state.excommunicated.push(obj);

    return;

  }

  restoreDebaters() {

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      this.game.state.debaters[i].committed = 0;
    }

  }

  restoreReformers() {

    for (let i = 0; i < this.game.state.excommunicated.length; i++) {
      let obj = this.game.state.excommunicated[i];
      if (obj.reformer) {

        let reformer = obj.reformer;
        let debater = obj.debater;
	let s = obj.space;
        let faction = obj.faction;

	if (reformer) {
	  if (s) {
	    if (faction) {
	      this.game.spaces[s].units[faction].push(reformer);
	    }
	  }
	}

	if (obj.debater) {
	  // debater uncommitted for restoration
	  obj.debater.committed = 0;
          this.game.state.debaters.push(obj.debater);
	}


	this.game.state.excommunicated.splice(i, 1);
	i--;

        this.displaySpace(s);

      }
    }

  }
  restoreMilitaryLeaders() {

    for (let i = 0; i < this.game.state.military_leaders_removed_until_next_round.length; i++) {
      if (obj.leader) {

        let leader = obj.leader;
	let s = obj.space;
        let faction = obj.faction;

	if (leader) {
	  if (s) {
	    if (faction) {
	      this.game.spaces[s].units[faction].push(leader);
	    }
	  }
	}
      }
    }

  }

  returnPregnancyChart() {

    let chart = {};

    chart['1'] = {
      top : 1307,
      left : 4075,
    }

    chart['2'] = {
      top : 1220,
      left : 4075,
    }

    chart['3'] = {
      top : 1135,
      left : 4075,
    }

    chart['4'] = {
      top : 1051,
      left : 4075,
    }

    chart['5'] = {
      top : 963,
      left : 4075,
    }

    chart['1'] = {
      top : 850,
      left : 4075,
    }

    return chart;

  }

  returnColonies() {

    let colonies = {};

    colonies['1'] = {
      top : 1007,
      left : 55
    }
    colonies['2'] = {
      top : 1120,
      left : 55
    }
    colonies['3'] = {
      top : 1232,
      left : 55
    }
    colonies['4'] = {
      top : 1344,
      left : 55
    }
    colonies['5'] = {
      top : 1456,
      left : 55
    }
    colonies['6'] = {
      top : 1530,
      left : 55
    }
    colonies['7'] = {
      top : 1680,
      left : 55
    }

    return colonies;

  }


  returnNewWorld() {

    let nw = {};

    nw.results = {};
    nw.results.colonies = [];
    nw.results.explorations = [];
    nw.results.conquests = [];

    nw['england_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Roanoke.svg' ,
    }
    nw['england_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Jamestown.svg' ,
    }
    nw['france_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Charlesbourg.svg' ,
    }
    nw['france_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Montreal.svg' ,
    }
    nw['hapsburg_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/PuertoRico.svg' ,
    }
    nw['hapsburg_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Cuba.svg' ,
    }
    nw['hapsburg_colony3'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Hispaniola.svg' ,
    }
    nw['england_conquest1'] = {
      type : "conquest" ,
    }
    nw['england_conquest2'] = {
      type : "conquest" ,
    }
    nw['france_conquest1'] = {
      type : "conquest" ,
    }
    nw['france_conquest2'] = {
      top : 1340 ,
    }
    nw['hapsburg_conquest1'] = {
      type : "conquest" ,
    }
    nw['hapsburg_conquest2'] = {
      type : "conquest" ,
    }
    nw['hapsburg_conquest3'] = {
      type : "conquest" ,
    }
    nw['greatlakes'] = {
      img : "/his/img/vp/GreatLakes1VP.svg",
      type : "discovery" ,
      name : "Great Lakes" ,
      vp : 1
    }
    nw['stlawrence'] = {
      img : "/his/img/vp/StLawrenceRiver1VP.svg",
      type : "discovery" ,
      name : "St. Lawrence River" ,
      vp : 1
    }
    nw['mississippi'] = {
      img : "/his/img/vp/MississippiRiver1VP.svg",
      type : "discovery" ,
      name : "Mississippi" ,
      vp : 1
    }
    nw['aztec'] = {
      img : "/his/img/vp/Aztecs2VP.svg",
      type : "discovery" ,
      name : "Aztec" ,
      vp : 2
    }
    nw['maya'] = {
      img : "/his/img/vp/Maya1VP.svg",
      type : "discovery" ,
      name : "Maya" ,
      vp : 1
    }
    nw['amazon'] = {
      img : "/his/img/vp/AmazonRiver2VP.svg",
      type : "discovery" ,
      name : "Amazon River" ,
      vp : 2
    }
    nw['inca'] = {
      img : "/his/img/vp/Inca2VP.svg",
      type : "discovery" ,
      name : "Inca" ,
      vp : 2
    }
    nw['circumnavigation'] = {
      img : "/his/img/vp/Circumnavigation3VP.svg",
      type : "discovery" ,
      name : "Circumnavigation" ,
      vp : 3
    }
    nw['pacificstrait'] = {
      img : "/his/img/vp/PacificStraight1VP.svg",
      type : "discovery" ,
      name : "Pacific Strait" ,
      vp : 1
    }

    return nw;

  }


  returnConquest() {

    let conquest = {};

    conquest['1'] = {
      top : 1007,
      left : 178
    }
    conquest['2'] = {
      top : 1120,
      left : 178
    }
    conquest['3'] = {
      top : 1232,
      left : 178
    }
    conquest['4'] = {
      top : 1344,
      left : 178
    }
    conquest['5'] = {
      top : 1456,
      left : 178
    }
    conquest['6'] = {
      top : 1530,
      left : 178
    }
    conquest['7'] = {
      top : 1680,
      left : 178
    }

    return conquest;

  }

  returnVictoryPointTrack() {

    let track = {};

    track['0'] = {
      top : 2912,
      left : 2025
    }
    track['1'] = {
      top : 2912,
      left : 2138
    }
    track['2'] = {
      top : 2912,
      left : 2252
    }
    track['3'] = {
      top : 2912,
      left : 2366
    }
    track['4'] = {
      top : 2912,
      left : 2480
    }
    track['5'] = {
      top : 2912,
      left : 2594
    }
    track['6'] = {
      top : 2912,
      left : 2708
    }
    track['7'] = {
      top : 2912,
      left : 2822
    }
    track['8'] = {
      top : 2912,
      left : 2936
    }
    track['9'] = {
      top : 2912,
      left : 3050
    }
    track['10'] = {
      top : 3026,
      left : 884
    }
    track['11'] = {
      top : 3026,
      left : 998
    }
    track['12'] = {
      top : 3026,
      left : 1112
    }
    track['13'] = {
      top : 3026,
      left: 1226,
    }
    track['14'] = {
      top : 3026,
      left : 1340
    }
    track['15'] = {
      top : 3026,
      left : 1454
    }
    track['16'] = {
      top : 3026,
      left : 1569
    }
    track['17'] = {
      top : 3026,
      left : 1682
    }
    track['18'] = {
      top : 3026,
      left : 1796
    }
    track['19'] = {
      top : 3026,
      left : 1910
    }
    track['20'] = {
      top : 3026,
      left : 2024
    }
    track['21'] = {
      top : 3026,
      left : 2138
    }
    track['22'] = {
      top : 3026,
      left : 2252
    }
    track['23'] = {
      top : 3026,
      left : 2366
    }
    track['24'] = {
      top : 3026,
      left : 2480
    }
    track['25'] = {
      top : 3026,
      left : 2594
    }
    track['26'] = {
      top : 3026,
      left : 2708
    }
    track['27'] = {
      top : 3026,
      left : 2822
    }
    track['28'] = {
      top : 3026,
      left : 2936
    }
    track['29'] = {
      top : 3026,
      left : 3050
    }

    return track;
  }


  returnElectorateDisplay() {

    let electorates = {};

    electorates['augsburg'] = {
      top: 190,
      left: 3380,
    }
    electorates['trier'] = {
      top: 190,
      left: 3510,
    }
    electorates['cologne'] = {
      top: 190,
      left: 3642,
    }
    electorates['wittenberg'] = {
      top: 376,
      left: 3380,
    }
    electorates['mainz'] = {
      top: 376,
      left: 3510,
    }
    electorates['brandenburg'] = {
      top: 376,
      left: 3642,
    }

    return electorates;

  }


  returnDiplomacyAlliance() {

    let diplomacy 		= {};
    diplomacy["ottoman"] 	= {
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["england"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["france"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["papacy"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["protestant"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["hapsburg"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["venice"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["genoa"] 		= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["hungary"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["scotland"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
    };

    return diplomacy;
  }

  returnDiplomacyTable() {

    let diplomacy 		= {};
    diplomacy["ottoman"] 	= {};
    diplomacy["england"] 	= {};
    diplomacy["france"] 	= {};
    diplomacy["papacy"] 	= {};
    diplomacy["protestant"] 	= {};
    diplomacy["hapsburg"] 	= {};

    diplomacy["ottoman"]["hapsburg"] = {
        top 	:	170 ,
        left	:	4128 ,
    }
    diplomacy["hapsburg"]["ottoman"] = {
        top 	:	170 ,
        left	:	4128 ,
    }
    diplomacy["ottoman"]["england"] = {
        top 	:	170 ,
        left	:	4222 ,
    }
    diplomacy["england"]["ottoman"] = {
        top 	:	170 ,
        left	:	4222 ,
    }
    diplomacy["ottoman"]["france"] = {
        top 	:       170 ,
        left	:	4310 ,
    }
    diplomacy["france"]["ottoman"] = {
        top 	:       170 ,
        left	:	4310 ,
    }
    diplomacy["ottoman"]["papacy"] = {
        top 	:	170 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["ottoman"] = {
        top 	:	170 ,
        left	:	4400 ,
    }
    diplomacy["ottoman"]["protestant"] = {
        top 	:	170 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["ottoman"] = {
        top 	:	170 ,
        left	:	4490 ,
    }
    diplomacy["ottoman"]["genoa"] = {
        top 	:	170 ,
        left	:	4580 ,
    }
    diplomacy["ottoman"]["hungary"] = {
        top 	:	170 ,
        left	:	4670 ,
    }
    diplomacy["ottoman"]["scotland"] = {
        top 	:	170 ,
        left	:	4760 ,
    }
    diplomacy["ottoman"]["venice"] = {
        top 	:	170 ,
        left	:	4851 ,
    }

    diplomacy["hapsburg"]["england"] = {
        top 	:	260 ,
        left	:	4220 ,
    }
    diplomacy["england"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4220 ,
    }
    diplomacy["hapsburg"]["france"] = {
        top 	:	260 ,
        left	:	4310 ,
    }
    diplomacy["france"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4310 ,
    }
    diplomacy["hapsburg"]["papacy"] = {
        top 	:	260 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4400 ,
    }
    diplomacy["hapsburg"]["protestant"] = {
        top 	:	260 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4490 ,
    }
    diplomacy["hapsburg"]["genoa"] = {
        top 	:	260 ,
        left	:	4580 ,
    }
    diplomacy["hapsburg"]["hungary"] = {
        top 	:	260 ,
        left	:	4670 ,
    }
    diplomacy["hapsburg"]["scotland"] = {
        top 	:	260 ,
        left	:	4760 ,
    }
    diplomacy["hapsburg"]["venice"] = {
        top 	:	260 ,
        left	:	4851 ,
    }


    diplomacy["england"]["france"] = {
        top 	:	350 ,
        left	:	4310 ,
    }
    diplomacy["france"]["england"] = {
        top 	:	350 ,
        left	:	4310 ,
    }
    diplomacy["england"]["papacy"] = {
        top 	:	350 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["england"] = {
        top 	:	350 ,
        left	:	4400 ,
    }
    diplomacy["england"]["protestant"] = {
        top 	:	350 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["england"] = {
        top 	:	350 ,
        left	:	4490 ,
    }
    diplomacy["england"]["genoa"] = {
        top 	:	350 ,
        left	:	4580 ,
    }
    diplomacy["england"]["hungary"] = {
        top 	:	350 ,
        left	:	4670 ,
    }
    diplomacy["england"]["scotland"] = {
        top 	:	350 ,
        left	:	4760 ,
    }
    diplomacy["england"]["venice"] = {
        top 	:	350 ,
        left	:	4851 ,
    }

    diplomacy["france"]["papacy"] = {
        top     :       440 ,
        left    :       4400 ,    
    }
    diplomacy["papacy"]["france"] = {
        top     :       440 ,
        left    :       4400 ,    
    }
    diplomacy["france"]["protestant"] = {
        top     :       440 ,
        left    :       4490 ,    
    }
    diplomacy["protestant"]["france"] = {
        top     :       440 ,
        left    :       4490 ,    
    }
    diplomacy["france"]["genoa"] = {
        top     :       440 ,
        left    :       4580 ,    
    }
    diplomacy["france"]["hungary"] = {
        top     :       440 ,
        left    :       4670 ,    
    }
    diplomacy["france"]["scotland"] = {
        top     :       440 ,
        left    :       4760 ,    
    }
    diplomacy["france"]["venice"] = {
        top     :       440 ,
        left    :       4851 ,    
    }


    diplomacy["papacy"]["protestant"] = {
        top     :       530 ,
        left    :       4490 ,    
    }
    diplomacy["protestant"]["papacy"] = {
        top     :       530 ,
        left    :       4490 ,    
    }
    diplomacy["papacy"]["genoa"] = {
        top     :       530 ,
        left    :       4580 ,    
    }
    diplomacy["papacy"]["hungary"] = {
        top     :       530 ,
        left    :       4670 ,    
    }
    diplomacy["papacy"]["scotland"] = {
        top     :       530 ,
        left    :       4760 ,    
    }
    diplomacy["papacy"]["venice"] = {
        top     :       530 ,
        left    :       4851 ,    
    }

    diplomacy["protestant"]["genoa"] = {
        top     :       620 ,
        left    :       4580 ,    
    }
    diplomacy["protestant"]["hungary"] = {
        top     :       620 ,
        left    :       4670 ,    
    }
    diplomacy["protestant"]["scotland"] = {
        top     :       620 ,
        left    :       4760 ,    
    }
    diplomacy["protestant"]["venice"] = {
        top     :       530 ,
        left    :       4851 ,    
    }

    return diplomacy;

  }



  triggerDefeatOfHungaryBohemia() {

    if (this.areAllies("hapsburg", "hungary")) { return false; }
    if (this.game.state.events.defeat_of_hungary_bohemia == 1) { return false; }

    let does_this_trigger_the_defeat_of_hungary_bohemia = false;

    //
    // Hungary-Bohemia has been activated as a Hapsburg ally through Diplomatic Marriage 
    // and the Ottomans control two home keys of Hungary-Bohemia
    //
    let ottoman_controlled_hungarian_home_spaces = 0;
    let hungarian_regulars_remaining_on_map = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].home == "hungary") {
        ottoman_controlled_hungarian_home_spaces++;
      }
      for (let z = 0; z < this.game.spaces[key].units["hungary"].length; z++) {
	if (this.game.spaces[key].units["hungary"][z].type === "regular") {
	  hungarian_regulars_remaining_on_map++;
	}
      }
    }

    if (this.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance == 1 && ottoman_controlled_hungarian_home_spaces >= 2) { 
      does_this_trigger_the_defeat_of_hungary_bohemia = true;
    }

    if (hungarian_regulars_remaining_on_map < 5 && ottoman_controlled_hungarian_home_spaces >= 1) {
      does_this_trigger_the_defeat_of_hungary_bohemia = true;
    }

    if (does_this_trigger_the_defeat_of_hungary_bohemia) {

      this.game.state.events.defeat_of_hungary_bohemia = 1;

      //
      // best friends forever
      //
      if (!this.areAllies("hapsburg", "hungary")) {
        this.setAllies("hapsburg", "hungary");
      }

      //
      // natural ally intervention
      //
      if (this.areAllies("hapsburg", "ottoman")) {
	this.unsetAllies("hapsburg", "ottoman");
      }
      this.setEnemies("hapsburg", "ottoman");


      //
      // turks get control of more spaces
      //
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].home == "hungary") {
	  // ottoman gets the spaces, but not the keys
	  if (this.game.spaces[key].units["ottoman"].length > 0 && this.game.spaces[key].type != "key") {
	    this.game.spaces[key].units["hungary"] = [];
	    this.controlSpace("ottoman", key);
	  }
	}
      }

      //
      // Ottomans points for winning war
      //
      this.updateLog("Hungary-Bohemia are defeated, pulling the Hapsburgs into war with the Ottoman Empire");
      this.game.state.ottoman_war_winner_vp += 2;
      this.displayWarBox();
      this.displayVictoryTrack();

      // let's notify the player visually
      this.displayCustomOverlay("battle-of-mohacs");

      //
      // add war
      //
      for (let z = this.game.queue.length-1; z >= 0; z--) {
	let lmv = this.game.queue[z].split("\t");
	if (lmv[0] === "cards_left" || lmv[0] == "continue" || lmv[0] == "play" || lmv[0] == "action_phase" || lmv[0] == "discard") {
	  this.game.queue.splice(z, 0, `unexpected_war\thapsburg\tottoman`);
	  z = 0;
	  break;
	}
      }

    }
  }



  returnEventObjects() {

    let z = [];

    //
    // factions in-play
    //
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      if (this.factions[this.game.state.players_info[i].faction] != undefined) {
        z.push(this.factions[this.game.state.players_info[i].faction]);
      }
    }


    //
    // cards in the deck can modify gameloop
    //
    for (let key in this.deck) {
      z.push(this.deck[key]);
    }
    for (let key in this.diplomatic_deck) {
      z.push(this.diplomatic_deck[key]);
    }

    //
    // debaters have bonuses which modify gameplay
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      let d = this.game.state.debaters[i];
      let key = d.type;
      z.push(this.debaters[key]);
    }

    return z;

  }



  addEvents(obj) {

    ///////////////////////
    // game state events //
    ///////////////////////
    //
    // these events run at various points of the game. They are attached to objs
    // on object initialization, so that the objects can have these events 
    // triggered at various points of the game automatically.
    //
    //
    // 
    // 1 = fall through, 0 = halt game
    //
    if (obj.onCommit == null) {
      obj.onCommit = function(his_self, faction) { return 1; } // 1 means fall through
    }
    if (obj.onEvent == null) {
      obj.onEvent = function(his_self, player) { return 1; } // 1 means fall-through / no-stop
    }
    if (obj.canEvent == null) {
      obj.canEvent = function(his_self, faction) { return 0; } // 0 means cannot event
    }
    if (obj.handleGameLoop == null) {
      obj.handleGameLoop = function(his_self, qe, mv) { return 1; } // 1 means fall-through / no-stop
    }





    //
    // functions for convenience
    //
    if (obj.removeFromDeck == null) {
      obj.removeFromDeck = function(his_self, player) { return 0; } 
    }
    if (obj.menuOptionTriggers == null) {
      obj.menuOptionTriggers = function(his_self, stage, player, faction) { return 0; }
    }
    if (obj.menuOption == null) {
      obj.menuOption = function(his_self, stage, player, faction) { return 0; }
    }
    if (obj.menuOptionActivated == null) {
      obj.menuOptionActivated = function(his_self, stage, player, faction) { return 0; }
    }

    return obj;

  }



  //
  // Core Game Logic
  //
  async handleGameLoop() {

    let his_self = this;

    if (this.is_first_loop == undefined) {
      this.is_first_loop = 1;
    } else {
      this.is_first_loop = 0;
    }


    ///////////
    // QUEUE //
    ///////////
    if (this.game.queue.length > 0) {

        let qe = this.game.queue.length-1;
        let mv = this.game.queue[qe].split("\t");
	let z = this.returnEventObjects();
        let shd_continue = 1;

console.log("QUEUE: " + JSON.stringify(this.game.queue));
console.log("MOVE: " + mv[0]);

	//
	// entry point for every round in the game
	//
        if (mv[0] === "round") {

	  this.game.state.round++;

          //
          // TODO - sanity placement here as earlier did not catch everything
          // maybe eliminate redundancy in the future.
	  //
          this.returnOverstackedUnitsToCapitals();

this.updateLog(`###############`);
this.updateLog(`### Round ${this.game.state.round} ###`);
this.updateLog(`###############`);

	  this.game.state.cards_left = {};

	  this.onNewRound();
	  this.restoreReformers();
	  this.restoreMilitaryLeaders();

	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    this.resetPlayerRound((i+1));
          }

	  this.game.queue.push("victory_determination_phase");
	  this.game.queue.push("winter_phase");
	  this.game.queue.push("new_world_phase");
	  this.game.queue.push("ACKNOWLEDGE\tThe Advent of Winter");
	  this.game.queue.push("show_overlay\twinter_phase");
	  this.game.queue.push("action_phase");
	  this.game.queue.push("check_interventions"); // players check and report cards that need to trigger waiting/check
	  this.game.queue.push("RESETCONFIRMSNEEDED\tall");

if (this.game.options.scenario != "is_testing") {
	  this.game.queue.push("spring_deployment_phase");
	  this.game.queue.push("NOTIFY\tSpring Deployment is about to start...");
}

	  if (this.game.players.length == 2) {
	    this.game.queue.push("diplomacy_phase_2P");
	  } else {

	    if (this.game.state.starting_round != this.game.state.round) {

if (this.game.options.scenario != "is_testing") {
	      if (this.game.state.round > 1) {

  	        if (this.game.state.events.schmalkaldic_league) {
	          this.game.queue.push("make_declarations_of_war\tprotestant");
	        }
	        this.game.queue.push("make_declarations_of_war\tpapacy");
	        this.game.queue.push("make_declarations_of_war\tfrance");
	        this.game.queue.push("make_declarations_of_war\tengland");
	        this.game.queue.push("make_declarations_of_war\thapsburg");
	        this.game.queue.push("make_declarations_of_war\tottoman");
		if (this.game.state.excommunicated_factions["france"] == 1) {
	          this.game.queue.push("remove_excommunication\tfrance");
		}
		if (this.game.state.excommunicated_factions["england"] == 1) {
	          this.game.queue.push("remove_excommunication\tengland");
		}
		if (this.game.state.excommunicated_factions["hapsburg"] == 1) {
	          this.game.queue.push("remove_excommunication\thapsburg");
		}
	        this.game.queue.push("sue_for_peace\tpapacy");
	        this.game.queue.push("sue_for_peace\tfrance");
	        this.game.queue.push("sue_for_peace\tengland");
	        this.game.queue.push("sue_for_peace\thapsburg");
	        this.game.queue.push("sue_for_peace\tottoman");
	        this.game.queue.push("diplomacy_phase");

	        //this.game.queue.push("ACKNOWLEDGE\tProceed to Diplomatic Proposals");

		if (this.game.state.round > 1) {
  	          this.game.queue.push("card_draw_phase");
		}

		if (this.game.players.length == 2) {

		  this.game.queue.push("halted");
	          this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
		  let c = [this.game.players[this.returnPlayerOfFaction("papacy")-1]];
		  this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));

	        } else {

		  if (this.game.players.length == 3) {

		    let c = [this.game.players[this.returnPlayerOfFaction("england")-1],this.game.players[this.returnPlayerOfFaction("hapsburg")-1],this.game.players[this.returnPlayerOfFaction("ottoman")-1]];

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tprotestant");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tfrance");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tengland");
	            this.game.queue.push("winter_retreat_move_units_to_capital\thapsburg");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tottoman");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));

		  }

		  if (this.game.players.length == 4) {

		    let c = [this.game.players[this.returnPlayerOfFaction("protestant")-1],this.game.players[this.returnPlayerOfFaction("papacy")-1]];
		    let c2 = [this.game.players[this.returnPlayerOfFaction("france")-1],this.game.players[this.returnPlayerOfFaction("england")-1],this.game.players[this.returnPlayerOfFaction("hapsburg")-1], this.game.players[this.returnPlayerOfFaction("ottoman")-1]];

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tprotestant");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));
		    this.updateStatus("Other factions handling winter retreat...");

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tfrance");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tengland");
	            this.game.queue.push("winter_retreat_move_units_to_capital\thapsburg");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tottoman");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c2));
		    this.updateStatus("Other factions handling winter retreat...");

		  }

		  if (this.game.players.length == 5) {

		    let c = [this.game.players[this.returnPlayerOfFaction("protestant")-1]];
		    let c2 = [this.game.players[this.returnPlayerOfFaction("papacy")-1],this.game.players[this.returnPlayerOfFaction("france")-1],this.game.players[this.returnPlayerOfFaction("england")-1],this.game.players[this.returnPlayerOfFaction("hapsburg")-1], this.game.players[this.returnPlayerOfFaction("ottoman")-1]];

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tprotestant");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));
		    this.updateStatus("Other factions handling winter retreat...");

		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tfrance");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tengland");
	            this.game.queue.push("winter_retreat_move_units_to_capital\thapsburg");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tottoman");
		    this.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(c2));
		    this.updateStatus("Other factions handling winter retreat...");

		  }

		  if (this.game.players.length == 6) {
		    this.game.queue.push("halted");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tprotestant");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tfrance");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tengland");
	            this.game.queue.push("winter_retreat_move_units_to_capital\thapsburg");
	            this.game.queue.push("winter_retreat_move_units_to_capital\tottoman");
		    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
		    this.updateStatus("Other factions handling winter retreat...");
		  }

	        }

	        this.game.queue.push("retreat_to_winter_spaces");
	      }
}
	    }
	  }


	  //
	  // 1532 and testing need cards too!
	  //
	  if (this.game.state.round != 1 && (this.game.state.round == this.game.state.starting_round)) {
	    this.game.queue.push("card_draw_phase");
	  }


	  //
	  // start the game with the Protestant Reformation
	  //
	  if (this.game.state.round == 1) {

if (this.game.options.scenario == "is_testing") {
	    this.game.queue.push("is_testing");
	    this.game.queue.push("card_draw_phase");
} else {
	    if (this.game.players.length == 2) {
	      this.game.queue.push("show_overlay\tvp");
	    }

	    this.game.queue.push("hide_overlay\tdiet_of_worms");
	    this.game.queue.push("diet_of_worms");
	    this.game.queue.push("show_overlay\tdiet_of_worms");
	    this.game.queue.push("card_draw_phase");
	    this.game.queue.push("event\tprotestant\t008");
}

	  } else {

	    //
	    // round 2 - zwingli in zurich
	    //
	    if (this.game.state.round == 2) {
	      this.addDebater("protestant", "oekolampadius-debater");
	      this.addDebater("protestant", "zwingli-debater");
	      this.addReformer("protestant", "zurich", "zwingli-reformer");
	      this.addDebater("papacy", "contarini-debater");
	    }

	    //
	    // round 3
	    //
	    if (this.game.state.round == 3) {
	      this.addDebater("protestant", "bullinger-debater");
	    }

	    //
	    // round 4 - calvin in genoa
	    //
	    if (this.game.state.round == 4) {

	      //
	      // 1532 starts in R4
	      //
	      if (this.game.options.scenario === "1532") {
	        this.game.queue.push("is_1532");
	      }

	      this.addDebater("protestant", "farel-debater");
	      this.addDebater("protestant", "cop-debater");
	      this.addDebater("protestant", "olivetan-debater");
	      this.addDebater("protestant", "calvin-debater");
	      this.addReformer("protestant", "geneva", "calvin-reformer");

	      if (this.game.players.length == 2) {
	        //
	        // Henry VIII marries Anne Boleyn
	        //
	        this.game.state.henry_viii_marital_status = 2;
	      }
	    }

	    //
	    // round 5 - cranmer in london
	    //
	    if (this.game.state.round == 5) {
	      this.addDebater("protestant", "cranmer-debater");
	      this.addDebater("protestant", "latimer-debater");
	      this.addDebater("protestant", "coverdale-debater");
	      this.addReformer("protestant", "london", "cranmer-reformer");
	      this.addDebater("papacy", "pole-debater");
	      this.addDebater("papacy", "caraffa-debater");
	    }

	    //
	    // round 6 - maurice of saxony
	    //
	    if (this.game.state.round == 6) {
	      this.addDebater("protestant", "wishart-debater");
	      this.addDebater("protestant", "knox-debater");
	      this.game.queue.push("protestants-place-maurice-of-saxony-round-six");
	      this.addDebater("papacy", "loyola-debater");
	      this.addDebater("papacy", "faber-debater");
	      this.addDebater("papacy", "canisius-debater");
	    }

	    //
	    // round 6 or higher - England (Mary, Elizabeth and Edward)
	    //
	    // this logic is implemented in newCards
	    //
	    if (this.game.players.length == 2) {
	      if (this.game.state.round >= 6 ) {
                this.game.state.henry_viii_healthy_edward = 1;
                this.game.state.henry_viii_sickly_edward = 0;
                this.game.state.henry_viii_add_elizabeth = 0;
	      }
	    }

	    //
	    // round 7
	    //
	    if (this.game.state.round == 7) {
	      this.addDebater("papacy", "gardiner-debater");
	    }
	  }

	  //
	  // show all - will only trigger for relevant faction
	  //
	  if (this.game.state.round == 1 || (this.game.state.round == this.game.state.starting_round)) {
	    if (this.game.players.length == 2) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	    }
	    if (this.game.players.length == 3) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\tfrance_ottoman");
	      this.game.queue.push("show_overlay\twelcome\thapsburg_papacy");
	    }
	    if (this.game.players.length == 4) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\thapsburg_papacy");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
	    if (this.game.players.length == 5) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\thapsburg");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
	    if (this.game.players.length == 6) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	      this.game.queue.push("show_overlay\twelcome\thapsburg");
	      this.game.queue.push("show_overlay\twelcome\tengland");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
      	    this.game.queue.push("READY");
	  }

          return 1;
        }

        if (mv[0] == "init") {
          this.game.queue.splice(qe, 1);
	  return 1;
        }

	//
	// passing code uses this, it manually puts up ACKNOWLEDGE then restarts
	// so it also inserts this so that when we hit it we remove it and then
	// look for future moves
	//
	if (mv[0] === "unhalt_from_acknowledge_speedup") {

	  let msg = mv[1];
	  this.updateStatus(msg);

	  //
	  // once we get here we aren't halted any more
	  //
	  this.halted = 0;
	  this.is_halted = 0;

	  // do not splice out, because all players need to resolve
	  return 0;
	}

	if (mv[0] === "show_overlay") {

          this.game.queue.splice(qe, 1);

	  //
	  // hide any cardbox
	  //
	  this.cardbox.hide();

	  this.displayElectorateDisplay();
	  if (mv[1] === "winter_phase") {
	    this.winter_overlay.render("stage1"); 
	  }
	  if (mv[1] === "welcome") { 
	    let faction = mv[2];
	    let player = this.returnPlayerOfFaction(faction);
	    if (faction === "protestant_england") { player = this.returnPlayerOfFaction("protestant"); }
	    if (faction === "hapsburg_papacy") { player = this.returnPlayerOfFaction("hapsburg"); }
	    if (faction === "france_ottoman") { player = this.returnPlayerOfFaction("france"); }
	    if (this.game.player === player) { 
	      this.welcome_overlay.render(faction); 
	      this.game.queue.push("hide_overlay\twelcome");
	      if (faction === "protestant") { this.game.queue.push("ACKNOWLEDGE\tYou are the Protestants"); }
	      if (faction === "papacy") { this.game.queue.push("ACKNOWLEDGE\tYou are the Papacy"); }
	      if (faction === "hapsburg") { this.game.queue.push("ACKNOWLEDGE\tYou are the Hapsburgs"); }
	      if (faction === "ottoman") { this.game.queue.push("ACKNOWLEDGE\tYou are the Ottomans"); }
	      if (faction === "france") { this.game.queue.push("ACKNOWLEDGE\tYou are the French"); }
	      if (faction === "england") { this.game.queue.push("ACKNOWLEDGE\tYou are the English"); }
	      if (faction === "protestant_england") { this.game.queue.push("ACKNOWLEDGE\tYou are the Protestants and English"); }
	      if (faction === "france_ottoman") { this.game.queue.push("ACKNOWLEDGE\tYou are the French and Ottomans"); }
	      if (faction === "hapsburg_papacy") { this.game.queue.push("ACKNOWLEDGE\tYou are the Hapsburgs and Papacy"); }
	    }
	  }
	  if (mv[1] === "theses") { this.theses_overlay.render(); }
	  if (mv[1] === "diet_of_worms") { this.diet_of_worms_overlay.render(); }
	  if (mv[1] === "council_of_trent") { this.council_of_trent_overlay.render(); }
	  if (mv[1] === "winter") { this.winter_overlay.render(); }
	  if (mv[1] === "faction") { this.faction_overlay.render(mv[2]); }
	  if (mv[1] === "vp") { this.vp_overlay.render(); }
	  if (mv[1] === "zoom") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "burn_books") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "publish_treatise") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "theological_debate_and_debaters") { 
	    this.debate_overlay.render(his_self.game.state.theological_debate); 
            this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
            this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);
	  }
	  if (mv[1] === "theological_debate") { this.debate_overlay.render(his_self.game.state.theological_debate); }
	  if (mv[1] === "naval_battle") {
	    if (mv[2] === "post_naval_battle_attackers_win") { this.naval_battle_overlay.attackersWin(his_self.game.state.naval_battle); }
	    if (mv[2] === "post_naval_battle_defenders_win") { this.naval_battle_overlay.defendersWin(his_self.game.state.naval_battle); }
	  }
	  if (mv[1] === "field_battle") {
	    if (mv[2] === "post_field_battle_attackers_win") { this.field_battle_overlay.attackersWin(his_self.game.state.field_battle); }
	    if (mv[2] === "post_field_battle_defenders_win") { this.field_battle_overlay.defendersWin(his_self.game.state.field_battle); }
	  }

	  return 1;
	}
	if (mv[0] === "hide_overlay") {
	  this.displayElectorateDisplay();
	  if (mv[1] === "winter") { this.winter_overlay.pushHudUnderOverlay(); this.winter_overlay.hide(); }
	  if (mv[1] === "welcome") { this.welcome_overlay.pushHudUnderOverlay(); this.welcome_overlay.hide(); }
	  if (mv[1] === "faction") { this.faction_overlay.hide(); }
	  if (mv[1] === "theses") { this.theses_overlay.hide(); }
	  if (mv[1] === "zoom") { this.theses_overlay.hide(); }
	  if (mv[1] === "burn_books") { this.theses_overlay.hide(); }
	  if (mv[1] === "publish_treatise") { this.theses_overlay.hide(); }
	  if (mv[1] === "chateaux") { this.chateaux_overlay.hide(); }
	  if (mv[1] === "diet_of_worms") { this.diet_of_worms_overlay.hide(); }
	  if (mv[1] === "council_of_trent") { this.council_of_trent_overlay.hide(); }
	  if (mv[1] === "vp") { this.vp_overlay.hide(); }
	  if (mv[1] === "theological_debate") { this.debate_overlay.pushHudUnderOverlay(); this.debate_overlay.hide(); }
	  if (mv[1] === "field_battle") { this.field_battle_overlay.hide(); }
	  if (mv[1] === "siege") { this.assault_overlay.hide(); }
	  if (mv[1] === "assault") { this.assault_overlay.hide(); }
          this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "display_custom_overlay") {

          this.game.queue.splice(qe, 1);

          let card = mv[1];
	  let obj = "";
	  if (mv[2]) { obj = JSON.parse(mv[2]); }
	  let show_overlay = false;

	  //
	  // everyone shows
	  //
	  if (obj == "") {
	    show_overlay = true;
	  //
	  // object contains show / hide info
	  //
	  } else {
	    for (let i = 0; i < obj.show.length; i++) {
	      let f = obj.show[i];
	      if (f == "all" || this.game.player == this.returnPlayerCommandingFaction(f)) {
	        show_overlay = true;
	      }
	    }
	    for (let i = 0; i < obj.hide.length; i++) {
	      let f = obj.hide[i];
	      if (this.game.player == this.returnPlayerCommandingFaction(f)) {
	        show_overlay = false;
	      }
	    }
	  }

	  if (show_overlay) {
	    this.displayCustomOverlay(card);
	  }

	  return 1;
	}

	if (mv[0] === "cards_left") {

          let faction = mv[1];
          let cards_left = parseInt(mv[2]);
	  this.game.state.cards_left[faction] = cards_left;

	  //
	  // we don't send this if we aren't playing event or ops, so if cards_left > 0, we 
	  // do not trigger auto-passing. this "unsets" pass if we have passed earlier, allowing
	  // players to pass and then decide to continue later.
	  //
	  let player = this.returnPlayerCommandingFaction(faction);
          for (let z = 0; z < this.game.state.players_info[player-1].factions.length; z++) {
	    if (this.game.state.players_info[player-1].factions[z] == faction) {
	      this.game.state.players_info[player-1].factions_passed[z] = false;
	    }
	  }
	  this.displayCardsLeft();

          this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "pass") {
 
          let faction = mv[1];

	  let player = this.returnPlayerOfFaction(faction);
	  if (mv[2]) {
            let cards_left = parseInt(mv[2]);
	    this.game.state.cards_left[faction] = cards_left;
	  }

          for (let z = 0; z < this.game.state.players_info[player-1].factions.length; z++) {
	    if (this.game.state.players_info[player-1].factions[z] == faction) {
	      this.game.state.players_info[player-1].factions_passed[z] = true;
	    }
	  }

	  this.updateLog(this.returnFactionName(faction) + " passes");

	  //
	  // Henry VIII reroll on first pass after 3 roll on pregnancy chart
	  //
	  if (this.game.state.henry_viii_auto_reroll == 1) {
	    this.game.queue.push("advance_henry_viii_marital_status");
	    this.game.state.henry_viii_auto_reroll = 0;
	  }

          this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "build") {

	  let land_or_sea = mv[1];
	  let faction = mv[2];
	  let unit_type = mv[3];
	  let spacekey = mv[4];
          let player_to_ignore = parseInt(mv[5]);

	  this.updateLog(this.returnFactionName(faction) + " builds " + unit_type + " in " + this.returnSpaceName(spacekey), true);

	  //
	  // winterrrr retreat sometimes builds army leaders
	  //
	  if (unit_type == "renegade" || unit_type == "suleiman" || unit_type == "ibrahim-pasha" || unit_type == "charles-v" || unit_type == "duke-of-alva" || unit_type == "ferdinand" || unit_type == "henry-viii" || unit_type == "charles-brandon" || unit_type == "francis-i" || unit_type == "henry-ii" || unit_type == "montmorency" || unit_type == "andrea-doria" || unit_type == "maurice-of-saxony" || unit_type == "dudley" || unit_type == "john-frederick" || unit_type == "philip-hesse") {
	    if (this.game.player != player_to_ignore) {
	      this.addArmyLeader(faction, spacekey, unit_type);
	      this.displaySpace(spacekey);
	      this.game.queue.splice(qe, 1);
	    }
	    return 1;
	  }

	  //
	  // maybe it will try to move navy leaders too
	  //
	  if (unit_type == "barbarossa" || unit_type == "dragut" || unit_type == "andrea-doria") {
	    if (this.game.player != player_to_ignore) {
	      this.addNavyLeader(faction, spacekey, unit_type);
	      this.displaySpace(spacekey);
	      this.game.queue.splice(qe, 1);
	    }
	    return 1;
	  }


	  if (this.game.player != player_to_ignore) {
	    if (land_or_sea === "land") {
	      this.game.spaces[spacekey].units[faction].push(this.newUnit(faction, unit_type));
	    }
	    if (land_or_sea === "sea") {
	      this.game.navalspaces[spacekey].units[faction].push(this.newUnit(faction, unit_type));
	    }
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "activate_minor_power") {

	  let faction = mv[1];
	  let power = mv[2];

	  //
	  // does this trigger the defeat of Hungary-Bohemia? -- will only run once
	  //
          if (faction === "hapsburg" && power == "hungary" && his_self.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance == 1) {
            this.triggerDefeatOfHungaryBohemia();
	  }

	  this.activateMinorPower(faction, power);
	  this.updateLog(this.returnFactionName(faction) + " now controls " + this.returnFactionName(power));
	  this.displayBoard();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	if (mv[0] === "deactivate_minor_power") {

	  let faction = mv[1];
	  let power = mv[2];

	  this.deactivateMinorPower(faction, power);
	  this.updateLog(this.returnFactionName(faction) + " no longer controls " + this.returnFactionName(power));
	  this.displayBoard();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "remove_unit") {

	  let land_or_sea = mv[1];
	  let faction = mv[2];
	  let unit_type = mv[3];
	  let spacekey = mv[4];
          let player_to_ignore = parseInt(mv[5]);

	  if (this.game.player != player_to_ignore) {
	    if (land_or_sea === "land") {
	      this.removeUnit(faction, spacekey, unit_type);
	    }
	    if (land_or_sea === "sea") {
	      this.removeUnit(faction, spacekey, unit_type);
	    }
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}




	if (mv[0] === "winter_retreat_move_units_to_capital") {

	  let faction = mv[1];

	  this.game.queue.splice(qe, 1);

	  let p = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player == p) {
	    this.winter_overlay.hide();
	    this.playerReturnWinterUnits(faction);
	  } else {
	    //this.updateStatus(this.returnFactionName(faction) + " returning units to capital");
	  }

	  // simultaneous so pass-through and resolve clears HALTED
	  return 1;
	  //return 0;

	}


	if (mv[0] === "retreat_to_winter_spaces") {

	  let his_self = this;
	  let moves = [];

	  this.game.queue.splice(qe, 1);

	  for (let spacekey in this.game.spaces) {
	    for (let faction in this.game.spaces[spacekey].units) {

	      let space = this.game.spaces[spacekey];

	      let fluis = 0;
	      if (space.units[faction].length > 0 ) { fluis = this.returnFactionLandUnitsInSpace(faction, spacekey, 0); }

	      if (fluis > 0) {

		//
		// we need to retreat from these spaces
		//
		if (  
			((this.isSpaceFortified(spacekey) && !this.isSpaceControlled(spacekey, faction)) || (!this.isSpaceFortified(spacekey)))
			&&
			(!(space.religion == "protestant" && this.isSpaceElectorate(space.key) && this.game.state.events.schmalkaldic_league != 1))
		) {

		  //
		  // remove siege if needed so units not "besieged" when moved
		  //
		  this.removeSiege(space.key);

		  //
		  // for every unit that needs to be moved
		  //
		  for (let fluis_idx = 0; fluis_idx < fluis; fluis_idx++) {

		    if (fluis_idx < 0) { fluis_idx = 0; }

		    //
		    // find the nearest friendly fortified space w/ less than 4 units
		    //
		    let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(faction, spacekey, 4);

		    //
		    // if we cannot find any spaces to receive them
		    //
		    if (res.length == 0) {

		      //
		      // destroy stranded units in 2P version
		      //
		      if ((this.game.players.length == 2 && (faction != "protestant" && faction != "papacy")) || this.returnPlayerCommandingFaction(faction) == 0) {
		        for (let z = 0; z < this.game.spaces[spacekey].units[faction].length; z++) {
		          if (this.game.spaces[spacekey].units[faction][z].personage != true && this.game.spaces[spacekey].units[faction][z].reformer != true) {
			    this.game.spaces[spacekey].units[faction].splice(z, 1);
			    z--;
			    // we have moved one guy...
			    fluis--; fluis_idx--;
			  }
	 	        }
		        this.displaySpace(spacekey);

		      //
		      // otherwise attrition + return to capital
		      //
		      // TODO - attrition
		      //
		      } else {

 			let capitals = this.returnCapitals(faction);
			let unitlen = this.game.spaces[spacekey].units[faction].length;
		        for (let z = 0, y = 0, zz = 0; z < unitlen; z++, zz++) {
			  if (capitals[y]) {
		            if (this.game.spaces[spacekey].units[faction][z].reformer != true) {
			      this.game.spaces[capitals[y]].units[faction].push(this.game.spaces[spacekey].units[faction][z]);
			      this.game.spaces[spacekey].units[faction].splice(z, 1);
			      zz--;
			      // we have moved one guy...
			      fluis--; fluis_idx--;
			    }
			  }
			  y++;
			  if (!capitals[y]) { y = 0; }
			  unitlen = this.game.spaces[spacekey].units[faction].length;
			}
		      }

		    //
		    // res.length > 0, so there are nearby fortified spaces
		    //
		    } else {


		      //
		      // how much space do we have?
		      //
		      let options = [];
		      for (let b = 0; b < res.length; b++) {
		        let unit_limit = 4;
		        if (res[b].key == "paris" || res[b].key == "valladolid" || res[b].key == "london" || res[b].key == "vienna" || res[b].key == "istanbul" || res[b].key == "rome") { unit_limit = 1000; }
			options.push(unit_limit - this.returnFactionLandUnitsInSpace(faction, res[b].key));
		      }

		      //
		      // fill those spaces
		      //
		      for (let b = 0; b < res.length; b++) {
			for (let zz = 0; zz < options[b]; zz++) {
			  let unitlen = this.game.spaces[spacekey].units[faction].length;
		          for (let zzz = 0, zzy = 0; zzz < unitlen; zzz++, zzy++) {
		            if (this.game.spaces[spacekey].units[faction][zzy].reformer != true) {
			      this.game.spaces[res[b].key].units[faction].push(this.game.spaces[spacekey].units[faction][zzy]);
			      this.game.spaces[spacekey].units[faction].splice(zzy, 1);
			      zzy--;
			      // we have moved one guy...
			      fluis--; fluis_idx--;

			      //
			      // and show new unit!
			      //
			      this.displaySpace(res[b].key);

			    }
			    unitlen = this.game.spaces[spacekey].units[faction].length;
			  }
			} 
		      }
		    }
		  } // fluis_idx loop

		  //
		  // if the space is besieged undo that, and un-besiege defenders
		  //
		  if (space.besieged > 0) {
		    this.removeSiege(space.key);
		  }

		  this.displaySpace(spacekey);

		} // if we need to retreat
	      } // if there are units here
	    } // loop faction
	  } // loop spacekey

	  //
	  // prevents in-memory differences in processing resulting in a different
	  // queue order, resulting in divergent game processing.
	  //
	  moves.sort();
	  for (let i = 0; i < moves.length; i++) {
	    this.game.queue.push(moves[i]);
	  }

          //
          // fortified spaces - any units in excess of stacking limit returned to capital
          //
	  //this.returnOverstackedUnitsToCapitals();

	  return 1;
        }


        if (mv[0] === "decide_if_mary_i_subverts_protestantism_in_2P") {

	  this.game.queue.splice(qe, 1);

	  let num = this.returnNumberOfProtestantSpacesInLanguageZone("english", 1);
	  let p = this.returnPlayerOfFaction("papacy");
	  let fhand_idx = 0; // faction hand/pool is necessarily 0 in 2P

	  if (num > 0) {
	    this.game.queue.push("process_mary_i_subverts_protestantism_in_2P");
            this.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+"papacy"+"\t1"); // 1 = show overlay
            this.game.queue.push("DEAL\t1\t"+p+"\t"+1);
	  } else {
	    this.game.queue.push("NOTIFY\t"+this.popup("021") + ": no Catholic spaces in England");
	  }

	  return 1;
	}

        if (mv[0] === "process_mary_i_subverts_protestantism_in_2P") {

	  this.game.queue.splice(qe, 1);

	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.game.player == player) {

	    let card_pulled = this.game.deck[0].fhand[0][this.game.deck[0].fhand.length-1];
	    let ops_pulled = this.game.deck[0].cards[card_pulled].ops;

	    if (ops_pulled == 1 || ops_pulled == 2) {
	      this.addMove("mary_i_burn_books");
	    }

	    if (ops_pulled == 3 || ops_pulled == 4) {
	      this.addMove("mary_i_theological_debate");
	    }

	    if (ops_pulled == 5 || ops_pulled == 6) {
	      this.addMove("mary_i_burn_books");
	      this.addMove("mary_i_theological_debate");
	    }

	    this.addMove("ACKNOWLEDGE\tMary I pulls "+this.popup(card_pulled) + "("+this.game.deck[0].cards[card_pulled].ops+" ops)");

	    this.endTurn();
	  }

	  return 0;
	}

	if (mv[0] === "mary_i_burn_books") {

	  this.game.queue.splice(qe, 1);

	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.canPlayerBurnBooksMaryI(this, player, "papacy")) {
	    if (this.game.player == player) {
	      this.playerBurnBooksMaryI(this, player, "papacy");
	    }
	    return 0;
	  }

	  return 1;

	}

	if (mv[0] === "mary_i_theological_debate") {

	  this.game.queue.splice(qe, 1);

	  // thomas more's execution prevents theological debates
          if (this.game.state.events.more_executed_limits_debates == 1) { return 1; }

	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.canPlayerCallTheologicalDebateMaryI(this, player, "papacy")) {
	    if (this.game.player == player) {
	      this.playerCallTheologicalDebateMaryI(this, player, "papacy");
	    }
	    return 0;
	  }

	  return 1;
	}


        if (mv[0] === "mary_i_subverts_protestantism") {

	  this.game.queue.splice(qe, 1);
	  let card = mv[1];
	  let roll = mv[2];
	  let player = this.returnPlayerCommandingFaction("papacy");

	  this.updateLog(`Mary I rolls ${roll}`);

	  if (player == this.game.player) {
	    this.playerPlayMaryI(card, "papacy");
	  }

	  return 0;

	}


	if (mv[0] === "retreat_to_winter_spaces_player_select") {

	  this.game.queue.splice(qe, 1);

	  //
	  // make sure up-to-date
	  //
	  this.displayBoard();

	  let x = this.returnPlayerOfFaction(mv[1]);

	  if (this.game.player === x) {
	    this.winter_overlay.hide();
	    this.playerResolveWinterRetreat(mv[1], mv[2]);
	    return 0;
	  } else {
	    this.winter_overlay.render();
	    this.updateStatus(this.returnFactionName(mv[1]) + " handling winter retreat from " + this.returnSpaceName(mv[2]));
	    if (x > 0) { return 0; }
	  }

	  //
	  // non-player controlled factions skip winter retreat
	  //
	  return 1;

        }

        if (mv[0] === "protestants-place-maurice-of-saxony-round-six") {

	  this.game.queue.splice(qe, 1);

	  let player = this.returnPlayerOfFaction("protestant");

	  if (this.game.player === player) {

            if (0 == his_self.playerSelectSpaceWithFilter(

              "Select Protestant Electorate for Maurice of Saxony (army leader)",

              function(space) {
                if (space.type == "electorate" && space.political == "protestant") { return 1; }
  	        return 0;
              },

              function(spacekey) {
		his_self.updateStatus("Maurice of Saxony enters play...");
                his_self.addMove("add_army_leader\tprotestant\t"+spacekey+"\tmaurice-of-saxony");
                his_self.endTurn();
              },

	      null,

	      true

            )) {
	      his_self.addMove("NOTIFY\tNo valid electorates for Maurice of Saxony to enter - skipping");
	      his_self.endTurn();
	    };

	  } else {
	    this.updateStatus("Protestants placing Maurice of Saxony");
	  }

	  return 0;

	}

	if (mv[0] === "retreat_to_winter_spaces_resolve") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let from = mv[2];
	  let to = mv[3];

          for (let i = this.game.spaces[from].units[faction].length-1; i >= 0; i--) {
	    this.game.spaces[to].units[faction].push(this.game.spaces[from].units[faction][i]);
	    this.game.spaces[from].units[faction].splice(i, 1);
	  }

	  this.displaySpace(from);
	  this.displaySpace(to);

	  return 1;

        }




	if (mv[0] === "retreat_to_winter_ports") {

	  let moves = [];

	  //
	  // make sure board up-to-date
	  //
	  this.displayBoard();

	  this.winter_overlay.render("stage3");

	  this.game.queue.splice(qe, 1);

console.log("#");
console.log("#");
console.log("# retreat to winter ports");
console.log("#");
console.log("#");

	  for (let i in this.game.navalspaces) {
	    for (let key in this.game.navalspaces[i].units) {
	      if (this.game.navalspaces[i].units[key].length > 0) {
	        let faction = key;
	        let space = this.game.navalspaces[i];
if (faction == "ottoman") {
  console.log(" return nearest faction controlled ports!");
}
		let res = this.returnNearestFactionControlledPorts(faction, space);
		if (res.length == 1) {
      	          moves.push("move\t"+faction+"\tport\t"+i+"\t"+res[0].key);
		} else {
		  moves.push("retreat_to_winter_ports_player_select\t"+key+"\t"+space.key+"\t"+JSON.stringify(res));
		}
	      }
	    }
	  }

	  //
	  // prevents in-memory differences in processing resulting in a different
	  // queue order, resulting in divergent game processing.
	  //
	  moves.sort();
	  for (let i = 0; i < moves.length; i++) {
	    this.game.queue.push(moves[i]);
	  }

	  //
	  // anything left gets swept
	  //
	  this.returnOverstackedUnitsToCapitals();

	  return 1;
        }


	if (mv[0] === "retreat_to_winter_ports_player_select") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let navalspace = mv[2];
	  let ports = JSON.parse(mv[3]);
	  let x = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player === x) {
	    this.winter_overlay.hide();
	    this.playerResolveNavalWinterRetreat(faction, navalspace);
	  } else {
	    this.winter_overlay.render();
	    this.updateStatus(this.returnFactionName(mv[1]) + " winter port retreat from " + this.returnSpaceName(mv[2]));
	  }

	  return 0;

        }


	if (mv[0] === "retreat_to_winter_ports_resolve") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let from = mv[2];
	  let to = mv[3];

          for (let i = this.game.navalspaces[from].units[faction].length-1; i >= 0; i--) {
	    this.game.spaces[to].units[faction].push(this.game.navalspaces[from].units[faction][i]);
	    this.game.navalspaces[from].units[faction].splice(i, 1);
	  }

	  this.displayNavalSpace(from);
	  this.displaySpace(to);

	  return 1;

        }

	if (mv[0] === "add_army_leader") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let type = mv[3];

	  //
	  // remove if exists elsewhere
	  //
          let eak = his_self.returnSpaceOfPersonage(faction, type);
          let eak_idx = his_self.returnIndexOfPersonageInSpace(faction, type, eak);
	  if (eak != "") { this.game.spaces[spacekey].units[faction].splice(eak_idx, 1); }

	  this.addArmyLeader(faction, spacekey, type);
	  this.displaySpace(spacekey);

    	  this.game.queue.splice(qe, 1);

	  return 1;
	}




	if (mv[0] === "place_mercenaries") {

    	  this.game.queue.splice(qe, 1);

	  let faction_giving = mv[1];
	  let faction_placing = mv[2];
	  let num = parseInt(mv[3]);

	  if (faction_placing === "france") {
	    if (this.returnControlledCapitals("france").length > 0) {
	      this.addMercenary("france", "paris", num);
	    }
	    return 1;
	  }

	  if (faction_placing === "england") {
	    if (this.returnControlledCapitals("england").length > 0) {
	      this.addMercenary("england", "london", num);
	    }
	    return 1;
	  }

	  if (faction_placing === "hapsburg") {

	    if (this.returnControlledCapitals("hapsburg").length == 1) {
	      this.addMercenary("hapsburg", this.returnControlledCapitals("hapsburg")[0], num);
	      return 1;
	    }

	    if (this.game.player == this.returnPlayerOfFaction(faction_placing)) {

              let msg = "Hapsburg - Select Capital for Mercenaries";
              let html = '<ul>';
              html += `<li class="option" id="vienna">Vienna</li>`;
              html += `<li class="option" id="valladolid">Valladolid</li>`;
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let action2 = $(this).attr("id");

                his_self.updateStatus("acknowledge...");
		for (let z = 0; z < num; z++) {
	          his_self.addMove("build\tland\thapsburg\tmercenary\t"+action2);
		}
		his_self.endTurn();

  	      });
	    }

	    return 0;
	  }


	  if (faction_placing === "protestant") {

	    let es = this.returnProtestantElectorates();

	    if (es.length == 1) {
	      this.addMercenary("protestant", es[0], num);
	      return 1;
	    }

	    if (this.game.player == this.returnPlayerOfFaction(faction_placing)) {

              let msg = "Protestant - Select Electorate for Mercenaries";
              let html = '<ul>';
	      for (let i = 0; i < es.length; i++) {
                html += `<li class="option" id="${es[i]}">${this.returnSpaceName(es[i])}</li>`;
	      }
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let action2 = $(this).attr("id");

                his_self.updateStatus("acknowledge...");
		for (let z = 0; z < num; z++) {
	          his_self.addMove("build\tland\tprotestant\tmercenary\t"+action2);
		}
		his_self.endTurn();

  	      });
	    }

	    return 0;
	  }

	}

	if (mv[0] === "loan_squadron") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let source_spacekey = mv[2];
	  let faction_placing = mv[3];
	  let destination_spacekey = mv[4];

	  this.removeUnit(faction_giving, source_spacekey, "squadron");
	  this.addSquadron(faction_placing, destination_spacekey, "squadron");
	  let s = his_self.game.spaces[destination_spacekey];
	  let u = s.units[faction_placing][s.units[faction_placing].length-1];
	  u.owner = faction_giving;

	  return 1;

	}

	if (mv[0] === "give_squadron") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let faction_placing = mv[2];

	  let instructions = [];

	  if (this.game.player != this.returnPlayerOfFaction(faction_giving)) {
	    this.updateStatus(this.returnFactionName(faction_giving) + " selecting squadron to give");
	    return 0;
	  }

	  this.winter_overlay.hide();
	  let filter_find_spaces_with_squadrons = function(space) {
	    let s = his_self.game.spaces[spacekey];
	    for (let i = 0; i < s.units[faction_giving].length; i++) {
	      let u = s.units[faction_giving][i];
	      if (u.type == "squadron") { return 1; }
	    }
	    return 0;
	  }
	  let command_function_on_picking_a_space = function(source_spacekey) {

	    his_self.playerSelectSpaceWithFilter(
	      "Select Closest Valid Destination for Squadron",
	      (space) => {
	        if (space.ports.length > 0) {
		  if (his_self.isSpaceControlled(space.key, faction_placing)) {
		    return 1;
		  }
		}
		return 0;
	      },
	      (destination_spacekey) => {
		his_self.addMove("loan_squadron\t"+faction_giving+"\t"+source_spacekey+"\t"+faction_placing+"\t"+destination_spacekey);
	        his_self.winter_overlay.render();
		his_self.endTurn();
	      },
	      null,
	      true,
	    );
	  }

	  for (let z = 0; z < num; z++) {
	    await this.playerSelectSpaceWithFilter(
              "Select Squadron to Loan", 
	      filter_find_spaces_with_squadrons,
	      command_function_on_picking_a_space,
	      null,
	      true
	    );
	  }

	  return 0;

	}

	if (mv[0] === "give_mercenaries") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let faction_placing = mv[2];
	  let num = parseInt(mv[3]);

	  let instructions = [];

	  if (this.game.player != this.returnPlayerOfFaction(faction_giving)) {
	    this.updateStatus(this.returnFactionName(faction_giving) + " selecting mercenaries to give");
	    return 0;
	  }

	  this.winter_overlay.hide();
	  let filter_find_spaces_with_mercenaries = function(space) {
	    let s = his_self.game.spaces[spacekey];
	    for (let i = 0; i < s.units[faction_giving].length; i++) {
	      let u = s.units[faction_giving][i];
	      if (u.type == "mercenary") { return 1; }
	    }
	    return 0;
	  }
	  let command_function_on_picking_a_space = function(spacekey) {
	    this.removeUnit(faction_giving, spacekey, "mercenary");
	    instructions.push("remove_unit\tland\t"+faction_giving+"\tmercenary\t"+spacekey+"\t"+his_self.game.player);
	  }

	  for (let z = 0; z < num; z++) {
	    await this.playerSelectSpaceWithFilter(

              "Select Mercenary to Remove", 

	      filter_find_spaces_with_mecenaries,

	      command_function_on_picking_a_space,

	      null,

	      true
	    );
	  }

	  for (let z = instructions.length-1; z > 0; z--) {
	    this.addMove(instructions[z]);
	  }
	  this.endTurn();
	  this.winter_overlay.render();
	  return 0;

	}

	if (mv[0] === "add_navy_leader") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let type = mv[3];

	  //
	  // remove if exists elsewhere
	  //
          let eak = his_self.returnSpaceOfPersonage(faction, type);
          let eak_idx = his_self.returnIndexOfPersonageInSpace(faction, type, eak);
	  if (eak != "") { this.game.spaces[spacekey].units[faction].splice(eak_idx, 1); }

	  this.addNavyLeader(faction, spacekey, type);

    	  this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "remove_conquest") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.conquests.length; i++) {
	    if (this.game.state.round == this.game.state.conquests[i].round && this.game.state.conquests[i] == faction) {
	      this.game.state.conquests.splice(i, 1);
	    }
	  }
    	  this.game.queue.splice(qe, 1);
	  return 1;
	}
	if (mv[0] === "remove_exploration") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.explorations.length; i++) {
	    if (this.game.state.round == this.game.state.explorations[i].round && this.game.state.explorations[i].faction == faction) {
	      this.game.state.explorations.splice(i, 1);
	    }
	  }
    	  this.game.queue.splice(qe, 1);
	  return 1;
	}
	if (mv[0] === "remove_colony") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.colonies.length; i++) {
	    if (this.game.state.round == this.game.state.colonies[i].round && this.game.state.colonies[i].faction == faction) {
	      this.game.state.colonies.splice(i, 1);
	    }
	  }
    	  this.game.queue.splice(qe, 1);
	  return 1;
	}
	if (mv[0] === "colonize") {
	  let faction = mv[1];
	  this.game.state.colonies.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  this.updateLog(this.returnFactionName(faction) + " founds a colony");
	  this.displayCustomOverlay("colonize", faction);
          this.game.state.may_colonize[faction] = 0;
    	  this.game.queue.splice(qe, 1);
	  this.displayColony();
	  return 1;
	}
	if (mv[0] === "explore") {
	  let faction = mv[1];
	  this.game.state.explorations.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  this.updateLog(this.returnFactionName(faction) + " launches an expedition");
	  this.displayCustomOverlay("explore", faction);
          this.game.state.may_explore[faction] = 0;
    	  this.game.queue.splice(qe, 1);
	  this.displayExploration();
	  return 1;
	}
        if (mv[0] === "award_exploration_bonus") {

	  this.updateStatus("Determining New World Bonus...");

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let explorer = mv[2];
	  let idx = parseInt(mv[3]);
	  let results_idx = idx;
	  let bonus = mv[4];

	  if (bonus === 'stlawrence') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "St. Lawrence";
	    this.updateLog(this.returnFactionName(faction) + " discovers the St. Lawrence");
	    this.displayCustomOverlay("stlawrence", this.returnFactionName(faction));
	  }
	  if (bonus === 'greatlakes') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Great Lakes";
	    this.updateLog(this.returnFactionName(faction) + " discovers the Great Lakes");
	    this.displayCustomOverlay("greatlakes", this.returnFactionName(faction));
	  }
	  if (bonus === 'mississippi') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Mississippi";
	    this.updateLog(this.returnFactionName(faction) + " discovers the Mississippi");
	    this.displayCustomOverlay("mississippi", this.returnFactionName(faction));
	  }
	  if (bonus === 'pacificstrait') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 1;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Pacific Strait";
	    this.updateLog(this.returnFactionName(faction) + " discovers the Pacific Strait");
	    this.displayCustomOverlay("pacificstrait", this.returnFactionName(faction));
	  }
	  if (bonus === 'amazon') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 1;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Amazon";
	    this.updateLog(this.returnFactionName(faction) + " discovers the Amazon");;
	    this.displayCustomOverlay("amazon", this.returnFactionName(faction));
	  }
	  if (bonus === 'circumnavigation') {

	    //
	    // circumnavigation attempt requires another roll here to claim
	    //
	    let base_x = this.rollDice(6) + this.rollDice(6);
	    let x = base_x + this.game.state.explorations[results_idx].modifiers;

	    this.updateLog("Circumnavigation Roll: " + x + " (" + base_x + "+" + this.game.state.explorations[idx].modifiers +")");

	    if (x > 9) {

	      //
	      // if follow-on attempt from Pacific Strait, add new exploration
	      //
	      if (this.game.state.explorations[idx].prize == "Pacific Strait") {
	        this.game.state.explorations.push({
	          faction : faction,
	          resolved :  0 ,
	          round :   this.game.state.round,
		  base_roll : base_x ,
		  modified_roll : x ,
		  explorer : explorer ,
		  explorer_img : this.explorers[explorer].img ,
		  base : base_x ,
		  total_hits : x ,
		  modifiers : this.game.state.explorations[idx].modifiers ,
		  prize : "-" , 
	        });
		idx = this.game.state.explorations.length-1;
	      }

	      this.updateLog("Circumnavigation Attempt succeeds: " + x + " rolled");
	      this.game.state.explorations[idx].resolved = 1;
	      this.game.state.explorations[idx].explorer_lost = 1;
	      this.game.state.newworld[bonus].faction = faction;
	      this.game.state.newworld[bonus].claimed = 1;
	      this.game.state.explorations[idx].prize = "Circumnavigation";
	      this.updateLog(this.returnFactionName(faction) + " circumnavigates the Globe");
	      this.displayCustomOverlay("circumnavigation", this.returnFactionName(faction));

	    } else {

	      //
	      // if follow-on attempt from Pacific Strait, add new exploration
	      //
	      if (this.game.state.explorations[idx].prize == "Pacific Strait") {
	        this.game.state.explorations.push({
	          faction : faction,
	          resolved :  0 ,
	          round :   this.game.state.round,
		  base_roll: base_x ,
		  modified_roll: x ,
		  explorer : explorer ,
		  explorer_img : this.explorers[explorer].img ,
		  base: base_x ,
		  total_hits : base_x + this.game.state.explorations[idx].modifiers ,
		  modifiers : this.game.state.explorations[idx].modifiers ,
		  prize : "" ,
	        });
	        idx = this.game.state.explorations.length-1;
	      }

	      this.updateLog("Circumnavigation Attempt fails: " + x + " rolled");
	      this.game.state.explorations[idx].resolved = 1;
	      this.game.state.explorations[idx].explorer_lost = 1;
	      this.game.state.explorations[idx].prize = "lost at sea";
	      this.updateLog(this.returnFactionName(faction) + " fails at Circumnavigation ("+x+")");
	      if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	        this.displayCustomOverlay("lost-at-sea", this.returnFactionName(faction));
	      }
	    }
	  }

	  this.displayVictoryTrack();
	  this.displayNewWorld();

	  return 1;
	}

	if (mv[0] === "resolve_new_world_riches_rolls") {

	  this.updateStatus("Resolving New World Riches...");

	  //
	  // show overlay
	  //
	  this.winter_overlay.render("stage1");

	  this.updateLog("************************");
	  this.updateLog("*** New World Riches ***");
	  this.updateLog("************************");

	  // reset expected bonuses
	  this.game.state.new_world_bonus = {};
	  this.game.state.new_world_bonus['england'] = 0;
	  this.game.state.new_world_bonus['france'] = 0;
	  this.game.state.new_world_bonus['hapsburg'] = 0;
	  this.game.state.new_world_bonus['protestant'] = 0;
	  this.game.state.new_world_bonus['ottoman'] = 0;
	  this.game.state.new_world_bonus['papacy'] = 0;
	

	  //////////////
	  // COLONIES //
	  //////////////
	  for (let z = 0; z < this.game.state.colonies.length; z++) {

	    let c = this.game.state.colonies[z];
	    let x = this.rollDice(6) + this.rollDice(6);
	    c.base_roll = x;

	    if (this.game.state.plantations[c.faction] == 1) { x++; }
	    if (c.name === "Potosi Silver Mines") { x++; }

	    if (x <= 4) { 
	      c.prize = "destroyed";
	      c.destroyed = 1; 
	      this.game.state.newworld[c.colony].claimed = 0; 
	    }

	    if (x >= 8) { 
	      if (this.game.state.galleons[c.faction] == 1) { x++; }
	    }

	    if (x >= 9) { 
	      c.prize = "bonus card";
	      this.game.state.new_world_bonus[c.faction]++;
	    }

	    c.modified_roll = x;

	  }


	  ///////////////
	  // CONQUESTS //
	  ///////////////
	  for (let i = 0; i < this.game.state.conquests.length; i++) {
	    let c = this.game.state.conquests[i];

	    if (c.prize.indexOf("Maya") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 6) {
		c.depleted = 1;
	      }
	      if ((x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
	      }
	    }

	    if (c.prize.indexOf("Aztec") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 5) {
		c.depleted = 1;
	      }
	      if ((x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
	      }
	    }

	    if (c.prize.indexOf("Inca") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 5) {
		c.depleted = 1;
	      }
	      if (x == 6 || (x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
	      }
	    }

	  }

	  //
	  // huguenaut raiders
	  //
	  for (let i = 0; i < this.game.state.new_world_bonus["hapsburg"]; i++) {
	    let stolen = 0;
	    if (parseInt(his_self.game.state.raiders['france']) == 1) {
	      let x = rollDice(6);
	      his_self.updateLog("French Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("French Raiders eliminated");	
		his_self.game.state.raiders['france'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("French Raiders eliminated");	
		his_self.game.state.raiders['france'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("French Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("French Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['france'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['france']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("French Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['france']++;
		stolen = 1;
	      }
	    }
	    if (stolen == 0 && parseInt(his_self.game.state.raiders['england']) == 1) {
	      let x = rollDice(6);
	      his_self.updateLog("English Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("English Raiders eliminated");	
		his_self.game.state.raiders['england'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("English Raiders eliminated");	
		his_self.game.state.raiders['england'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("English Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("English Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['england'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['england']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("English Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['england']++;
		stolen = 1;
	      }
	    }
	    if (stolen == 0 && parseInt(his_self.game.state.raiders['protestant']) == 1) {
	      let x = rollDice(6);
	      his_self.updateLog("Protestant Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("Protestant Raiders eliminated");	
		his_self.game.state.raiders['protestant'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("Protestant Raiders eliminated");	
		his_self.game.state.raiders['protestant'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("Protestant Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("Protestant Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['protestant'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['protestant']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("Protestant Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['protestant']++;
		stolen = 1;
	      }
	    }
	  }

	  this.newworld_overlay.render("results");
    	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "resolve_new_world_conquests") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Resolving New World Conquests...");
	  return this.resolveConquests();
        }
	if (mv[0] === "resolve_new_world_colonies") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Establishing New World Colonies...");
	  return this.resolveColonies();
        }
	if (mv[0] === "resolve_new_world_explorations") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Resolving New World Exploration Attempts...");
	  return this.resolveExplorations();
        }

	if (mv[0] === "resolve_conquest") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let idx = parseInt(mv[1]);
	  let faction = this.game.state.conquests[idx].faction;
	  let conquistador = this.game.state.conquests[idx].conquistador;
	  let hits = this.game.state.conquests[idx].hits;
	  let unmodified_hits = hits;
	  this.game.state.conquests[idx].resolved = 1;

	  this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " rolls " + unmodified_hits);

	  if (hits <= 6) {
	    if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	      this.displayCustomOverlay("killed", faction);
	    }
	    this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " killed by natives");
	    this.game.state.conquests[idx].conquistador_lost = 1;
	    this.game.state.conquests[idx].prize = "killed";
	    this.game.state.conquests[idx].active = 0;
	  }
	  if (hits > 6 && hits <= 8) {
	    this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " makes no conquest");
	    this.game.state.conquests[idx].prize = "-";
	  }
	  if (hits >= 9) {
	    while (hits > 11) { hits--; }
	    if (hits >= 11) {
	      if (this.game.state.newworld['inca'].claimed != 1) {
	        this.game.state.newworld['inca'].claimed = 1;
	        this.game.state.newworld['inca'].faction = faction;
		this.game.state.conquests[idx].prize = "Incan Empire";
	        this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " conquers the Inca (2VP)");
	        this.displayCustomOverlay("inca", this.returnFactionName(faction));
	        this.game.state.conquests[idx].active = 1;
	      } else {
		while (hits > 10) { hits--; }
	      }
	    }
	    if (hits == 10) {
	      if (this.game.state.newworld['aztec'].claimed != 1) {
	        this.game.state.newworld['aztec'].claimed = 1;
	        this.game.state.newworld['aztec'].faction = faction;
		this.game.state.conquests[idx].prize = "Aztec Empire";
	        this.game.state.conquests[idx].active = 1;
	        this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " conquers the Aztec (2VP)");
	        this.displayCustomOverlay("aztec", this.returnFactionName(faction));
	      } else { 
		while (hits >= 10) { hits--; }
	      }
	    }
	    if (hits == 9) {
	      if (this.game.state.newworld['maya'].claimed != 1) {
	        this.game.state.newworld['maya'].claimed = 1;
	        this.game.state.newworld['maya'].faction = faction;
		this.game.state.conquests[idx].prize = "Mayan Empire";
	        this.game.state.conquests[idx].active = 1;
	        this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " conquers the Maya (1VP)");
	        this.displayCustomOverlay("maya", this.returnFactionName(faction));
	      } else {
		this.game.state.conquests[idx].prize = "-";
	        this.updateLog(this.returnFactionName(faction) + ": " + conquistador + " makes no conquest");
	      }
	    }
	  }

	  // conquests don't offer choice, so return for immediate execution
	  return 1;
        }


	if (mv[0] === "resolve_exploration") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let idx = parseInt(mv[1]);
	  let results_idx = 0;

	  let faction = this.game.state.explorations[idx].faction;
	  let explorer = this.game.state.explorations[idx].explorer;
	  let hits = this.game.state.explorations[idx].hits;
	  let prize = "";
	  this.game.state.explorations[idx].resolved = 1;

	  this.updateStatus("Resolving "+this.returnFactionName(faction) + " Exploration Attempt...");

	  if (hits <= 4) {
	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " lost at sea");
	    this.game.state.explorations[idx].prize = "lost at sea";
	    this.game.state.explorations[idx].explorer_lost = 1;

	    // remove Cabot if he dies at sea
	    if (explorer.indexOf("cabot") > -1) { this.removeCardFromGame("099"); }

	  }
	  if (hits > 4 && hits <= 6) {
	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	  }
	  if (hits > 6 && hits <= 9) {
	    if (hits == 9) {
	      if (this.game.state.newworld['mississippi'].claimed != 1) {
	        this.game.state.newworld['mississippi'].claimed = 1;
	        this.game.state.newworld['mississippi'].faction = faction;
	        this.game.state.explorations[idx].prize = "Mississippi";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Mississippi (1VP)");
		this.displayCustomOverlay("mississippi", this.returnFactionName(faction));
	      } else { 
		hits--;
	      }
	    }
	    if (hits == 8) {
	      if (this.game.state.newworld['greatlakes'].claimed != 1) {
	        this.game.state.newworld['greatlakes'].claimed = 1;
	        this.game.state.newworld['greatlakes'].faction = faction;
	        this.game.state.explorations[idx].prize = "Great Lakes";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Great Lakes (1VP)");
		this.displayCustomOverlay("greatlakes", this.returnFactionName(faction));
	      } else { 
		hits--;
	      }
	    }
	    if (hits == 7) { 
	      if (this.game.state.newworld['stlawrence'].claimed != 1) {
	        this.game.state.newworld['stlawrence'].claimed = 1;
	        this.game.state.newworld['stlawrence'].faction = faction;
	        this.game.state.explorations[idx].prize = "St. Lawrence";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the St. Lawrence (1VP)");
		this.displayCustomOverlay("stlawrence", this.returnFactionName(faction));
	      } else {
	        this.game.state.explorations[idx].prize = "-";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	      }
	    }
	  }

	  if (hits >= 10) {

	    //
	    // nope out if nothing to claim
	    //
	    if (this.game.state.newworld['stlawrence'].claimed == 1 && this.game.state.newworld['greatlakes'].claimed == 1 && this.game.state.newworld['mississippi'].claimed == 1 && this.game.state.newworld['amazon'].claimed == 1 && this.game.state.newworld['circumnavigation'].claimed == 1) {
	      this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	      this.game.state.explorations[idx].prize = "-";
	      return 1;
	    }

	    //
	    // otherwise we give the successful faction a manual choice
	    //
	    if (this.game.player == this.returnPlayerCommandingFaction(faction)) {

	      let msg = `${this.returnFactionName(faction)} - Choose Discovery:`;
	      let html = '<ul>';
	      if (this.game.state.newworld['stlawrence'].claimed != 1) {
		html += '<li class="option" id="stlawrence">St. Lawrence (1 VP)</li>';
	      }
	      if (this.game.state.newworld['greatlakes'].claimed != 1) {
		html += '<li class="option" id="greatlakes">The Great Lakes (1 VP)</li>';
	      }
	      if (this.game.state.newworld['mississippi'].claimed != 1) {
		html += '<li class="option" id="mississippi">The Mississippi (1 VP)</li>';
	      }
	      if (this.game.state.newworld['amazon'].claimed != 1) {
		html += '<li class="option" id="amazon">The Amazon (2VP, explorer retires)</li>';
	      }
	      if (this.game.state.newworld['circumnavigation'].claimed != 1) {
		let vp_at_stake = "2";
		if (this.game.state.newworld['pacificstrait'].claimed != 1) { vp_at_stake = "2-4"; }
		html += `<li class="option" id="circumnavigation">Attempt Circumnavigation (${vp_at_stake}VP, explorer retires)</li>`;
	      }

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {
                $('.option').off();
                his_self.updateStatus("acknowledge...");
                let action = $(this).attr("id");

                his_self.addMove("award_exploration_bonus\t"+faction+"\t"+explorer+"\t"+idx+"\t"+action);
		if (action == 'circumnavigation' && his_self.game.state.newworld['pacificstrait'].claimed != 1) {
                  his_self.addMove("award_exploration_bonus\t"+faction+"\t"+explorer+"\t"+idx+"\t"+'pacificstrait');
		}

                his_self.endTurn();
              });

	    }
	  
	    return 0;

	  }
	  return 1;
	}


	if (mv[0] === "conquer") {
	  let faction = mv[1];
	  this.game.state.conquests.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  this.updateLog(this.returnFactionName(faction) + " launches a conquest");
	  this.displayCustomOverlay("conquest", faction);
          this.game.state.may_conquer[faction] = 0;
    	  this.game.queue.splice(qe, 1);
	  this.displayConquest();
	  return 1;
	}


	if (mv[0] === "is_testing") {

	  // SCHMALKALDIC LEAGUE
	  let deck = this.returnDeck(true);
	  deck['013'].onEvent(this, "protestant");

//
// this should be handled in setup now
//
/***
	  if (this.game.players.length > 2) {
	    this.addCard("ottoman", "033");
	  }
          this.addCard("papacy", "035");
          this.addCard("papacy", "036");
          this.addCard("papacy", "032");
          this.addCard("papacy", "029");
          this.addCard("protestant", "026");
          this.addCard("protestant", "027");
          this.addCard("protestant", "033");
          this.addCard("protestant", "025");

	  this.controlSpace("papacy", "linz");
	  this.controlSpace("papacy", "vienna");
	  this.controlSpace("papacy", "graz");
	  this.controlSpace("papacy", "trieste");
	  this.controlSpace("papacy", "venice");
***/
    	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "is_1532") {

	  // SCHMALKALDIC LEAGUE
	  let deck = this.returnDeck(true);
	  deck['013'].onEvent(this, "protestant");

    	  this.game.queue.splice(qe, 1);
	  return 1;

	}


        
        if (mv[0] === "reshuffle_diplomacy_deck") {
          
          this.game.queue.splice(qe, 1);
          
          //
          // DECKRESTORE copies backed-up back into deck
          //
          this.game.queue.push("SHUFFLE\t2");
          this.game.queue.push("DECKRESTORE\t2");          

          for (let i = this.game.state.players_info.length; i > 0; i--) {
            this.game.queue.push("DECKENCRYPT\t2\t"+(i));
          } 
          for (let i = this.game.state.players_info.length; i > 0; i--) {
            this.game.queue.push("DECKXOR\t2\t"+(i));
          }
          
          //
          // re-add discards
          //  
          let discards = {};
          for (let i in this.game.deck[1].discards) {
            discards[i] = this.game.deck[1].cards[i];
            delete this.game.deck[1].cards[i];
          } 
          this.game.deck[1].discards = {};
        
          //  
          // our deck for re-shuffling
          //
          let reshuffle_cards = {};
          for (let key in discards) { reshuffle_cards[key] = discards[key]; }

console.log("----------------------------");
console.log("---SHUFFLING IN DISCARDS ---");
console.log("----------------------------");
          this.game.queue.push("DECK\t2\t"+JSON.stringify(reshuffle_cards));

          // backup any existing DECK #2
          this.game.queue.push("DECKBACKUP\t2");

        }



	if (mv[0] === "diplomacy_submit_proposal") {
	  let p = JSON.parse(mv[1]);
	  this.game.state.diplomacy.push(p);
	  this.game.queue.splice(qe, 1);
	  return 1;
	}


        if (mv[0] === "diplomacy_card_event") {

	  let faction = mv[1];
	  let card = mv[2];

	  this.updateStatus(this.returnFactionName(faction) + " plays " + this.popup(card));
          this.updateLog(this.returnFactionName(faction) + " plays " + this.popup(card));
          this.cardbox.hide();

	  this.game.queue.splice(qe, 1);

          let lqe = qe-1;
          if (lqe >= 0) {
            let lmv = this.game.queue[lqe].split("\t");
            if (lmv[0] == "diplomacy_card_event") {
	      this.game.queue.splice(lqe, 1);
	    }
	  }

	  if (!this.diplomatic_deck[card].onEvent(this, faction)) { return 0; }

	  return 1;

	}



        if (mv[0] === "event") {

	  let faction = mv[1];
	  let card = mv[2];

	  this.game.queue.splice(qe, 1);
          this.game.state.cards_evented.push(card);

          this.updateLog(this.returnFactionName(faction) + " triggers " + this.popup(card));

	  if (!this.deck[card].onEvent(this, faction)) { return 0; }

	  return 1;
	}


        if (mv[0] === "card") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let card = mv[2];

	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player === p) {
	    this.playerPlayCard(card, p, faction);
	  }

	  return 0;

	}

        if (mv[0] === "ops") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let card = mv[2];
	  let opsnum = parseInt(mv[3]);
 
          this.updateLog(this.returnFactionName(faction) + " plays " + this.popup(card) + " for ops");

	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player === p) {
	    this.playerPlayOps(card, faction, opsnum);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " playing ops");
	  }

	  return 0;

	}

        if (mv[0] === "lock") {

	  let faction = mv[1];
	  let source = mv[2];

	  this.game.queue.splice(qe, 1);

	  for (let i = 0; i < this.game.spaces[source].units[faction].length; i++) {
	    this.game.spaces[source].units[faction][i].locked = 1;
	  }

          return 1;

        }


        if (mv[0] === "move") {

	  let faction = mv[1];
	  let movetype = mv[2];
	  let source = mv[3];
	  let destination = mv[4];
	  let unitidx = parseInt(mv[5]);
	  let skip_avoid_battle = 0;
	  if (mv[6]) { skip_avoid_battle = parseInt(mv[6]); }
	  let is_this_an_interception = 0;
	  if (parseInt(mv[7]) > 0) { is_this_an_interception = 1; }


	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);

	  this.game.queue.splice(qe, 1);

	  if (this.game.state.active_player == this.returnPlayerCommandingFaction(faction)) {
	    this.game.state.attacker_comes_from_this_spacekey = mv[3];
	    this.game.state.player_last_move = "move";
	    this.game.state.player_last_spacekey = destination;
	  }

	  //
	  // winter retreat into port
	  //
	  if (movetype === "port") {

	    let units = this.game.navalspaces[source].units[faction];

	    for (let z = 0; z < units.length; z++) {
	      this.game.spaces[destination].units[faction].push(units[z]);
	    }

	    this.game.navalspaces[source].units[faction] = [];
	    this.displaySpace(source);
	    this.displaySpace(destination);

	  }

	  //
	  // movement at sea
	  //
	  if (movetype === "sea") {

	    //
	    // source = land, destination = sea
	    //
	    if (this.game.spaces[source] && this.game.navalspaces[destination]) {
	      let unit_to_move = this.game.spaces[source].units[faction][unitidx];
 	      unit_to_move.already_moved = 1;
              this.game.navalspaces[destination].units[faction].push(unit_to_move);
              this.game.spaces[source].units[faction].splice(unitidx, 1);
	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	      this.displaySpace(source);
	      this.displayNavalSpace(destination);
	    }

	    //
	    // source = sea, destination = sea
	    //
	    if (this.game.navalspaces[source] && this.game.navalspaces[destination]) {
	      let actual_unitidx = 0;
	      for (let i = 0; i < this.game.navalspaces[source].units[faction].length; i++) {
		if (this.game.navalspaces[source].units[faction][i].idx === unitidx) {
		  actual_unitidx = i;
		};
	      }

	      let unit_to_move = this.game.navalspaces[source].units[faction][actual_unitidx];
 	      unit_to_move.already_moved = 1;
              this.game.navalspaces[destination].units[faction].push(unit_to_move);
              this.game.navalspaces[source].units[faction].splice(actual_unitidx, 1);
	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	      this.displayNavalSpace(source);
	      this.displayNavalSpace(destination);
	    }

	    //
	    // source = sea, destination = land
	    //
	    if (this.game.navalspaces[source] && this.game.spaces[destination]) {

	      let actual_unitidx = 0;
	      for (let i = 0; i < this.game.navalspaces[source].units[faction].length; i++) {
		if (this.game.navalspaces[source].units[faction][i].idx === unitidx) {
		  actual_unitidx = i;
		};
	      }

	      let unit_to_move = this.game.navalspaces[source].units[faction][actual_unitidx];
 	      unit_to_move.already_moved = 1;
              this.game.spaces[destination].units[faction].push(unit_to_move);
              this.game.navalspaces[source].units[faction].splice(actual_unitidx, 1);
	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	      this.displayNavalSpace(source);
	      this.displaySpace(destination);
	    }

	    //
	    // do we have a jolly sea battle?
	    //
            let space;
	    if (this.game.spaces[destination]) {
	      space = this.game.spaces[destination];
	    }
	    if (this.game.navalspaces[destination]) {
	      space = this.game.navalspaces[destination];
	    }

            let anyone_else_here = 0;

	    //
	    // a single move might trigger multiple combat attempts, so we need to loop backwards and 
	    // run this check for each destination.
	    //
	    let current_destination = destination;
	    let current_faction = faction;
            if (qe > 0) {
              let lmv2 = this.game.queue[qe-1].split("\t");
              if (lmv2[0] == "naval_interception_check") {
	  
	        for (let lqe = qe-1; lqe >= 0; lqe--) {

                  let lmv = this.game.queue[lqe].split("\t");
                  if (lmv[0] == "naval_interception_check") {

		    current_faction = lmv[1];
		    current_destination = lmv[2];
		    current_source = lmv[3];

		    let cdest;
	            if (this.game.spaces[current_destination]) {
	              cdest = this.game.spaces[current_destination];
	            }
	            if (this.game.navalspaces[current_destination]) {
	              cdest = this.game.navalspaces[current_destination];
	            }

                    for (let f in cdest.units) {
                      if (cdest.units[f].length > 0 && f != faction) {
                        anyone_else_here = 1;
                      }
                      if (f !== faction && cdest.units[f].length > 0 && this.areEnemies(f, faction)) {
                        if (lqe-1 >= 0) {
                          // added in reverse order
                          if (skip_avoid_battle != 1) {
                            this.game.queue.splice(lqe, 0, "naval_retreat_check\t"+current_faction+"\t"+current_destination+"\t"+current_source);
                          }
                          this.game.queue.splice(lqe, 0, "RESETCONFIRMSNEEDED\tall");
                          this.game.queue.splice(lqe, 0, "counter_or_acknowledge\tNaval Battle is about to begin in "+this.returnSpaceName(current_destination) + "\tnaval_battle");
                          this.game.queue.splice(lqe, 0, "naval_battle\t"+current_destination+"\t"+faction);
                        }
                      }
                    }
                  } else {
                    //
                    // we only update the occupier of the space if the next move is not a "move"
                    // as we require interception check to find out if there are units here already.
                    //
                    if (lmv[0] !== "move" && lqe === (qe-1)) {
                      if (anyone_else_here == 0) {
                        space.occupier = faction;
                      }
		    }
	          }
	        }
	      }
	    }
	  }

	  //
	  // movement on land
	  //
	  if (movetype === "land") {

	    let unit_to_move = this.game.spaces[source].units[faction][unitidx];
 	    unit_to_move.already_moved = 1;
            this.game.spaces[destination].units[faction].push(unit_to_move);
            this.game.spaces[source].units[faction].splice(unitidx, 1);
	    this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	    this.displaySpace(source);
	    this.displaySpace(destination);

	    //
	    // if this space contains two non-allies, field-battle or siege must occur
	    //
	    let space = this.game.spaces[destination];
	    let anyone_else_here = 0;
	    let number_opposing_land_units = 0;

	    let lqe = qe-1;
	    if (lqe >= 0) {

	      let lmv = this.game.queue[lqe].split("\t");

	      //
	      // this space is not already besieged but it is possible that someone might
	      // intercept and trigger a field battle. This bit of code is confusing queue-management
	      // that screws around with the queue to ensure that commands are added only when 
	      // the last unit has moved into the space.
	      //

	      //
	      // we avoid the field battle and complicated nonsense if moving troops into a foreign war
	      //
	      if (space.key != "persia" && space.key != "egypt" && space.key != "ireland") {

		//
		// this is the last "move" that we will have to process, so this is the point
		// where we check to see if we have to have a field battle, etc. or whether 
		// we need to break the siege.
		//
	        if (lmv[0] == "interception_check" && space.besieged == 0) { // not already besieged

		  //
		  // do we need to break a seige in the place from which we are moving?
		  //
		  let source_space = this.game.spaces[source];
		  let hoiluis = this.returnHostileOrIndependentLandUnitsInSpace(faction, source_space);
		  let myluis = this.returnFactionLandUnitsInSpace(faction, source_space);
		  if (hoiluis > myluis && myluis > 0) {
		    let fac = this.returnFactionControllingSpace(source_space);
		    this.game.queue.push("ACKNOWLEDGE\t"+this.returnFactionName(faction) + " retreats after siege broken!");
	            this.game.queue.push("remove_siege\t"+source);
	            this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+faction+"\t"+fac+"\t"+source);
		    this.game.queue.push("player_evaluate_break_siege_retreat_opportunity\t"+faction+"\t"+source);
		  }


	          for (let f in space.units) {

		    // we check not only for NO units, but for NUM land units
	            if (space.units[f].length > 0 && f != faction) {
		      anyone_else_here = 1;
		      for (let z = 0; z < space.units[f].length; z++) {
		        let u = space.units[f][z];
		        if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") { number_opposing_land_units++; }
		      }
	            }

	            if (f !== faction && this.returnFactionLandUnitsInSpace(f, space) > 0 && !this.areAllies(f, faction)) {

		      if (lqe-1 >= 0) {

			//
		        // added in reverse order
			//
		        if (skip_avoid_battle != 1) {
			  //
		 	  // inactive faction indicates interception - neither retreat nor fortification
			  // should be offered because this movement invovles a player moving defensively
			  // into a space and this move is triggered by another active player, which means
			  // we need a field battle.
			  //
			  if (!is_this_an_interception) {
			    //
			    // active faction
			    //
	                    this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
			    if (space.besieged == 0) {
	                      this.game.queue.splice(lqe, 0, "fortification_check\t"+faction+"\t"+destination+"\t"+source);
			    } else {
			    }
			  } else {

			  }
		        }

		        //
		        // "move" is used by the intercept command, so we do not want intercepts to be changing the 
		        // software's concept of which faction is the attacker. for this reason, if the active player
		        // is present in the space, we treat them as the attacker.
		        //
		        if (this.returnFactionLandUnitsInSpace(this.game.state.active_faction, space.key) > 0) {
	                  this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+this.game.state.active_faction);
		        } else {
	                  this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+faction);
	                }
	              }
	            }
	          }

		  if ((anyone_else_here == 0 || number_opposing_land_units == 0) && (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress")) {
		    let f = this.returnFactionControllingSpace(space.key);

		    if (!this.areAllies(f, faction) && f !== faction) {
		      if (space.besieged != 1) { // not if already besieged
		        //
		        // besiege the defenders, and lock the attackers (preventing further movement)
		        //
		        for (let z = 0; z < space.units[f].length; z++) {
			  if (!space.units[f][z].reformer) { space.units[f][z].besieged = true; }
		        }
		        for (let z = 0; z < space.units[faction].length; z++) {
			  if (!space.units[faction][z].reformer) { space.units[faction][z].locked = 1; }
		        }
	 	        space.besieged = 2;
		        this.displaySpace(space.key);
		      }
		    }

	          }

	        } else {

		  //
		  // no-one is around to intercept, but is this assaultable
		  //
		  if (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress") {
		    let f = this.returnFactionControllingSpace(space.key);
		    if (this.returnFactionLandUnitsInSpace(f, space.key, 1) == 0) {
 		      if (!this.areAllies(f, faction) && f !== faction) {
		        if (space.besieged != 1) { // not if already besieged
	 	          space.besieged = 2;
		          this.displaySpace(space.key);
		        }
		      }
		    }
	          }

		  //
		  // on the very last move we check to see if there are any enemy factions in the 
		  // space and trigger a field battle, deciding first whether the existing forces
		  // are capable of retreating or fortifying.
		  //
		  if (lmv[0] !== "move") {
		    // occupier is antequated
		    space.occupier = faction;

		    let field_battle_triggered = false;

console.log("#");
console.log("#");
console.log("# no-one is around to intercept and we need to check for battle...");
console.log("# skip_avoid_battle: " + skip_avoid_battle);
console.log("#");

		    //
		    // relief forces showing up
		    //
		    for (let f in space.units) {
 		      if (!this.areAllies(f, faction, 1) && f !== faction) {
		        if (this.returnFactionLandUnitsInSpace(f, space.key, 1) > 0 && field_battle_triggered == false) {

			  //
			  // if all the units are besieged we skip field battle because attacker needs to assault
			  //
			  let is_anyone_not_besieged = false;
			  let is_anyone_besieged = false;
			  let is_defender_the_one_who_is_besieged = false;

			  for (let z = 0; z < space.units[f].length; z++) {
			    if (!space.units[f][z].besieged) {
			      is_anyone_not_besieged = true;
			    } else {
			      is_anyone_besieged = true;
			      if (!this.areAllies(f, faction)) { 
				is_defender_the_one_who_is_besieged = true;
			      }
			    }
			  }

			  if (is_anyone_not_besieged) {

console.log(" # --> is anyone not besieged");

			    field_battle_triggered = true;

			    //
			    // but maybe no-one is besieged, in which case we want to offer fortification option
			    // to the defender.
			    //
			    if (is_defender_the_one_who_is_besieged != true) {
	                      this.game.queue.splice(lqe, 0, "fortification_check\t"+faction+"\t"+destination+"\t"+source);
	                      this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
			    } else {

		              //
		              // someone else is here, so let's trigger a field battle
		              //
			      if (!is_this_an_interception) {
	                        this.game.queue.splice(lqe, 0, "relief_forces\t"+faction+"\t"+destination);
	                        this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
		              }

			    }


			    //
		            // "move" is used by the intercept command, so we do not want intercepts to be changing the 
		            // software's concept of which faction is the attacker. for this reason, if the active player
		            // is present in the space, we treat them as the attacker.
		            //
		            if (this.returnFactionLandUnitsInSpace(this.game.state.active_faction, space.key) > 0) {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+this.game.state.active_faction);
		            } else {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+faction);
	                    }
		          }
		        }
		      }
		    }
		  }
	        }
	      } // persia, egypt and irelance
	    }

	    //
	    // did moving remove a siege? check
	    //
	    if (!this.isSpaceBesieged(source)) {
	      this.removeSiege(source);
	    }

	    this.displaySpace(source);
	    this.displaySpace(destination);

	  }

          return 1;
	}




        if (mv[0] === "fortification_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];

	  his_self.game.state.attacker_comes_from_this_spacekey = mv[3];

	  let space = this.game.spaces[spacekey];

	  if (space.type !== "electorate" && space.type !== "key" && space.type !== "fortress") {
	    return 1;
	  }

	  //
	  // no units, no fortification check
	  //
	  let fluis = 0;
	  for (let f in this.game.spaces[spacekey].units) {
	    if (f !== attacker && !this.areAllies(this.game.state.active_faction, f, 1)) {
	      fluis += this.returnFactionLandUnitsInSpace(f, spacekey);
	    }
	  }
	  if (fluis == 0) { return 1; }


	  //
	  // whoever is being attacked can retreat into the fortification if they
	  // have 4 or less land units
	  //
	  for (let f in this.game.spaces[spacekey].units) {
	    if (f !== attacker && this.isSpaceControlled(spacekey, f) && !this.areAllies(this.game.state.active_faction, f, 1)) {

	      let fluis = this.returnFactionLandUnitsInSpace(f, spacekey);

	      if (fluis == 0) {
		//
		// no troops - skip
		//
	      } else {

	        if (fluis > 4) {

		  // must land battle

	        } else {

		  if (this.isMinorPower(f)) {

		    if (this.isMinorUnactivatedPower(f)) {

		      //
		      // auto-handled -- we retreat for siege
		      //
		      this.game.queue.push("fortification\t"+attacker+"\t"+f+"\t"+spacekey);

		    } else {

		      //
 		      // major power decides
		      //
		      let cf = "";
		      let mp = f;

		      if (this.game.state.activated_powers['ottoman'].includes(f)) { cf = "ottoman"; }
		      if (this.game.state.activated_powers['hapsburg'].includes(f)) { cf = "hapsburg"; }
		      if (this.game.state.activated_powers['france'].includes(f)) { cf = "france"; }
		      if (this.game.state.activated_powers['england'].includes(f)) { cf = "england"; }
		      if (this.game.state.activated_powers['papacy'].includes(f)) { cf = "papacy"; }
		      if (this.game.state.activated_powers['protestant'].includes(f)) { cf = "protestant"; }

		      let cp = this.returnPlayerCommandingFaction(cf);

		      this.game.queue.push("player_evaluate_fortification"+"\t"+attacker+"\t"+cp+"\t"+mp+"\t"+spacekey);

		    }

	          } else {

		    //
		    // major or independent power - some player decides
		    //
		    let cp = this.returnPlayerCommandingFaction(f);

		    if (cp != 0) {
		      this.game.queue.push("player_evaluate_fortification"+"\t"+attacker+"\t"+cp+"\t"+f+"\t"+spacekey);


		    } else {

	              //
		      // independent key
	              //
	              // non-player controlled, minor power or independent, so auto-handle
	              //
	              // If there are 4 or fewer land units in a space, they will always withdraw into
	              // the fortifications and try to withstand a siege if their space is entered.
	              // if there are 5 or more land units,they will hold their ground and fight a field
	              // battle. If they lose that field battle, do not retreat their units from the
	              // space as usual. Instead, they retain up to 4 units which withdraw into the
	              // fortifications; all other land units in excess of 4 are eliminated.
	              //
	              // fortify everything
	              //
	              his_self.game.queue.push("NOTIFY\t" + his_self.returnFactionName(f) + " fortifies in " + his_self.returnSpaceName(spacekey));
	              for (let i = 0; i < space.units[f].length; i++) {
	                his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+f+"\t"+JSON.stringify(space.units[f][i]));
	              }
		    }
	          }
	        }
	      }

	    } else {

	      //
	      // no land units (skip)
	      //

	    }
	  }

          return 1;

	}

        if (mv[0] === "post_field_battle_player_evaluate_fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let spacekey = mv[4];
          let space = this.game.spaces[spacekey];

	  //
	  // if no-one is left to fortify
	  //
	  if (this.game.state.field_battle.defender_land_units_remaining <= 0 && this.game.state.field_battle_attacker_land_units_remaining > 0) {
	    //
	    // immediately besiege if a key
	    //
	    if (space.type === "fortress" || space.type === "electorate" || space.type === "key") {
	      if (space.besieged != 1) { // not if already besieged
                space.besieged = 2; // 2 = cannot attack this round
                space.besieged_factions.push(faction);
	      }
	    }
	    this.displaySpace(spacekey);
	    return 1;
	  }

	  //
	  // if this is not a fortified space, clear and continue
	  //
	  if (space.type !== "fortress" && space.type !== "electorate" && space.type !== "key") {
	    return 1;
	  }

	  //
	  // this was a relief battle, but no formerly-besieged units survived
	  //
	  if (this.game.state.field_battle.relief_battle) {
	    let did_anyone_survive = false;
	    for (let key in space.units) {
	      for (let z = 0; z < space.units[key].length; z++) {
		if (space.units[key][z].relief_force == 1) { did_anyone_survive = true; }
	      }
	    }
	    if (!did_anyone_survive) {
	      return 1;
	    }
	  }

	  //
	  // otherwise, we have to evaluate fortifying
	  //
	  if (this.game.player == player) {
	    this.field_battle_overlay.renderFortification(this.game.state.field_battle);
	    this.playerEvaluateFortification(attacker, faction, spacekey, 1); // 1 = post battle
	  } else {
	    if (this.isPlayerControlledFaction(faction)) {
	      this.field_battle_overlay.renderFortification(this.game.state.field_battle);
	      this.field_battle_overlay.updateInstructions(faction + " considering fortification");
	      this.updateStatus(this.returnFactionName(faction) + " considering fortification");
	    } else {

	      //
	      // non-player controlled, minor power or independent, so auto-handle
	      //
	      // If there are 4 or fewer land units in a space, they will always withdraw into
	      // the fortifications and try to withstand a siege if their space is entered.
	      // if there are 5 or more land units,they will hold their ground and fight a field
	      // battle. If they lose that field battle, do not retreat their units from the
	      // space as usual. Instead, they retain up to 4 units which withdraw into the
	      // fortifications; all other land units in excess of 4 are eliminated.
      	      //
      	      // this only runs after we have had a battle, so we fortify everything if we still
	      // exist.
      	      //
	      //
	      // fortify everything
	      //
	      for (let i = 0; i < space.units[faction].length; i++) {
	        his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
	      }
	      return 1;
	    }
	  }

          return 0;

	}


        if (mv[0] === "player_publish_treatise") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (faction == "england") {
	    if (this.game.players.length == 2) { faction = "protestant"; }
	    if (this.game.player === this.returnPlayerCommandingFaction(faction)) {
	      this.playerPublishTreatise(this, this.game.player, "england");
	    }
	  }
	
	  return 0;

	}

	

        if (mv[0] === "player_evaluate_fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let spacekey = mv[4];
	  let space = this.game.spaces[spacekey];

	  let decider = this.returnPlayerCommandingFaction(faction);
	  if (decider > 0) {
	    if (this.game.player == decider) {
	      this.playerEvaluateFortification(attacker, faction, spacekey);
	    } else {
	      this.updateStatus(this.returnFactionName(faction) + " considering fortification");
	    }
	    return 0;
	  } else {
	    //
	    // non-player controlled, minor power or independent, so auto-handle
	    //
	    // If there are 4 or fewer land units in a space, they will always withdraw into
	    // the fortifications and try to withstand a siege if their space is entered.
	    // if there are 5 or more land units,they will hold their ground and fight a field
	    // battle. If they lose that field battle, do not retreat their units from the
	    // space as usual. Instead, they retain up to 4 units which withdraw into the
	    // fortifications; all other land units in excess of 4 are eliminated.
      	    //
      	    // this only runs after we have had a battle, so we fortify everything if we still
	    // exist.
      	    //
	    //
	    // fortify everything
	    //
	    for (let i = 0; i < space.units[faction].length; i++) {
	      his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
	    }
	    return 1;
	  }

	}


	if (mv[0] === "unfortify_unit_by_index") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let space = this.game.spaces[spacekey];

	  space.units[faction][unit_idx].relief_force = 0;
	  space.units[faction][unit_idx].besieged = 0;

	  this.displaySpace(spacekey);

	  return 1;

	}
	if (mv[0] === "fortify_unit_by_index") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let space = this.game.spaces[spacekey];

	  if (space.besieged != 1) { // not if already besieged
            space.besieged = 2; // 2 = cannot attack this round
            space.besieged_factions.push(faction);
	  }
	  space.units[faction][unit_idx].besieged = 1;

	  this.displaySpace(spacekey);

	  return 1;

	}

	if (mv[0] === "fortify_unit") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let units = JSON.parse(mv[3]);
	  let space = this.game.spaces[spacekey];

	  if (space.besieged != 1) { // not if already besieged
            space.besieged = 2; // 2 = cannot attack this round
            space.besieged_factions.push(faction);
	  }
	  for (let i = 0; i < space.units[faction].length; i++) {
	    space.units[faction][i].besieged = 1;
	  }

	  this.displaySpace(spacekey);

	  return 1;

        }



        if (mv[0] === "relief_forces_join_battle") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[spacekey];

	  //
	  // mark relief forces - anyone friendly who is still there
	  //
	  for (let key in space.units) {
	    if (key === faction || this.areAllies(key, faction)) {
	      for (let z = 0; z < space.units[key].length; z++) {
		space.units[key][z].relief_force = 1;
	      }
	    }
	  }

	  let player = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player === player) {
	    this.playerReliefForcesJoinBattle(faction, spacekey);
	  } else {
	    this.updateLog(this.returnFactionName(faction) + " deciding whether besieged units join battle");
	    this.updateStatus(this.returnFactionName(faction) + " deciding whether besieged units join battle");
	  }

	  this.displaySpace(spacekey);

          return 0;

        }



        if (mv[0] === "fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let faction = mv[2];
	  let spacekey = mv[3];
	  let post_battle = 0;
	  if (mv[4]) { post_battle = parseInt(mv[4]); }
	  let space = this.game.spaces[spacekey];

	  let faction_map = this.returnFactionMap(space, attacker, faction);
	  let player = this.returnPlayerCommandingFaction(faction);


	  if (player > 0) {
	    if (this.game.player === player) {
	      this.playerFortifySpace(faction, attacker, spacekey, post_battle);
	    } else {
	      this.updateLog(this.returnFactionName(faction) + " fortifies in " + this.returnSpaceName(spacekey));
	      this.updateStatus(this.returnFactionName(faction) + " fortifying in " + this.returnSpaceName(spacekey));
	    }
	  } else {

	    //
	    // non-player controlled, minor power or independent, so auto-handle
	    //
	    // If there are 4 or fewer land units in a space, they will always withdraw into
	    // the fortifications and try to withstand a siege if their space is entered.
	    // if there are 5 or more land units,they will hold their ground and fight a field
	    // battle. If they lose that field battle, do not retreat their units from the
	    // space as usual. Instead, they retain up to 4 units which withdraw into the
	    // fortifications; all other land units in excess of 4 are eliminated.
      	    //
	    if (space.units[faction].length <= 4) {
	      // fortify everything
	      for (let i = 0; i < space.units[faction].length; i++) {
	        his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
	      }
	    } else {
		//
		// go into field battle or next step
		//
	    }
	    this.displaySpace(spacekey);
	    return 1;
	  }

	  this.displaySpace(spacekey);

          return 0;

	}

	if (mv[0] === "remove_siege") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let space = this.game.spaces[spacekey];

	  //
	  // remove siege record from units/space
	  //
	  space.besieged = 0;
	  for (let f in space.units) {
	    for (let i = 0; i < space.units[f].length; i++) {
	      space.units[f][i].relief_force = 0;
	      space.units[f][i].besieged = 0;
	    }
	  }
	  this.displaySpace(spacekey);

	  return 1;

	}

	if (mv[0] === "break_siege") {

	  this.game.queue.splice(qe, 1);

	  let faction_map      = his_self.game.state.assault.faction_map;
	  let attacker_faction = his_self.game.state.assault.attacker_faction;
	  let defender_faction = his_self.game.state.assault.defender_faction;
	  let spacekey         = his_self.game.state.assault.spacekey;
	  let space 	       = his_self.game.spaces[spacekey];
	  let neighbours       = space.neighbours;

	  //
	  // remove siege record from units/space
	  //
	  space.besieged = 0;
	  for (let f in space.units) {
	    for (let i = 0; i < space.units[f].length; i++) {
	      space.units[f][i].relief_force = 0;
	      space.units[f][i].besieged = 0;
	    }
	  }
	  this.displaySpace(spacekey);

	  for (let zz = 0; zz < neighbours.length; zz++) {
            let fluis = this.canFactionRetreatToSpace(attacker_faction, neighbours[zz]);
	    if (fluis) {
              this.game.queue.push("player_evaluate_break_siege_retreat_opportunity\t"+attacker_faction+"\t"+spacekey);
	      zz = neighbours.length+1;
	    }
	  }

	  return 1;

	}


	if (mv[0] === "relief_forces") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[spacekey];
	
	  let player = this.returnPlayerCommandingFaction(faction);

	  //
	  // if the player is the attacker, not the defender we want
	  // to skip this completely.
	  //
	  let anyone_besieged = 0;
	  for (let z = 0; z < space.units[faction].length; z++) {
	    if (space.units[faction][z].besieged > 0) { anyone_besieged = 1; }
	  }
	  //
	  // pass through if attacker (not besieged)
	  //
	  if (anyone_besieged == 0) { return 1; }

	  if (this.game.player == player) {
	    this.playerEvaluateReliefForce(faction, spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " handling besieged units");
	  }

	  return 0;
	}


        if (mv[0] === "retreat_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  this.game.state.attacker_comes_from_this_spacekey = mv[3];


	  let space = this.game.spaces[spacekey];
	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0, 0); // 0 cannot intercept across passes or seas
	  let attacking_player = this.returnPlayerOfFaction(attacker);

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_faction_retreat = 0;
	    let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	    if (player_of_faction != attacking_player && player_of_faction > 0) {
  	      if (io[i] !== attacker && (io[i] != this.game.state.active_faction && !this.areAllies(this.game.state.active_faction, io[i], 1))) {
	        let units_in_space = this.returnFactionLandUnitsInSpace(io[i], spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToSpace(io[i], neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
	              let x = "player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i];
		      if (this.game.queue[this.game.queue.length-1] !== x) {
	                this.game.queue.push("player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i]);
		        zz = neighbours.length;
		      }
	            }
	          }
	        }
	      }
	    }

	    for (let zz = 0; zz < this.game.state.activated_powers[io[i]].length; zz++) {
	      let ap = this.game.state.activated_powers[io[i]][zz];
	      if (ap !== attacker && !io.includes(ap) && io[i] != attacker && !this.areAllies(this.game.state.active_faction, ap)) {
	        let units_in_space = this.returnFactionLandUnitsInSpace(ap, spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToSpace(ap, neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
		      let x = "player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap;
		      if (this.game.queue[this.game.queue.length-1] !== x) {
		        this.game.queue.push("player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap);
		        zz = neighbours.length;
	              }
	            }
	          }
	        }
	      }
	    }
	  }

          return 1;

	}

        if (mv[0] === "naval_retreat_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  this.game.state.attacker_comes_from_this_spacekey = mv[3];
	  let space = "";
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }      
	  if (this.game.navalspaces[spacekey]) { space = this.game.spaces[spacekey]; }      

	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0); // 0 cannot intercept across passes
	  let attacking_player = this.returnPlayerOfFaction(attacker);

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_faction_retreat = 0;
	    let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	    if (player_of_faction != attacking_player && player_of_faction > 0) {
  	      if (io[i] !== attacker) {
	        let units_in_space = this.returnFactionSeaUnitsInSpace(io[i], spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToNavalSpace(io[i], neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
	              this.game.queue.push("player_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i]);
		      zz = neighbours.length;
	            }
	          }
	        }
	      }
	    }

	    for (let zz = 0; zz < this.game.state.activated_powers[io[i]].length; zz++) {
	      let ap = this.game.state.activated_powers[io[i]][zz];
	      if (ap != attacker && this.returnControllingPower(ap) != this.returnControllingPower(attacker)) {
	        let units_in_space = this.returnFactionSeaUnitsInSpace(ap, spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToNavalSpace(ap, neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
		      this.game.queue.push("player_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap);
		      zz = neighbours.length;
	            }
	          }
	        }
	      }
	    }
	  }

	  this.displaySpace(spacekey);
          return 1;

	}





        if (mv[0] === "player_evaluate_break_siege_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];

	  let player_factions = this.returnPlayerFactions(this.game.player)

	  // if no-one survived, let's skip the formalities
	  let survivors = this.returnHostileLandUnitsInSpace(attacker, spacekey);
	  if (survivors == 0) { return 1; }

	  if (player_factions.includes(attacker) || this.returnPlayerCommandingFaction(attacker) == this.game.player) {
	    this.playerEvaluateBreakSiegeRetreatOpportunity(attacker, spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(attacker) + " considering retreat");
	  }

	  return 0;

	}



        if (mv[0] === "player_evaluate_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = mv[4];
          let space = this.game.spaces[spacekey];

          //
          // you cannot retreat if besieged, so check if besieged, and one besieged unit 
          // means the whole stack is besieged
          //
          if (space.besieged > 0) {
            for (let x = 0; x < space.units[defender].length; x++) {
              if (space.units[defender][x].besieged == 1) { return 1; }
            }
          }


	  let player_factions = this.returnPlayerFactions(this.game.player)

	  if (player_factions.includes(defender) || this.returnPlayerCommandingFaction(defender) == this.game.player) {
	    this.playerEvaluateRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering retreat");
	  }

	  return 0;

	}



        if (mv[0] === "player_evaluate_naval_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = mv[4];

	  //
	  // cannot proactively retreat from port
	  //
	  if (this.game.spaces[spacekey]) { return 1; }

	  if (this.returnPlayerCommandingFaction(defender) == this.game.player) {
	    this.playerEvaluateNavalRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering retreat");
	  }

	  return 0;

	}


	if (mv[0] === "naval_retreat") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source_spacekey = mv[2];
	  let destination_spacekey = mv[3];

	  let source;
	  if (this.game.spaces[source_spacekey]) { source = this.game.spaces[source_spacekey]; }
	  if (this.game.navalspaces[source_spacekey]) { source = this.game.navalspaces[source_spacekey]; }

	  let destination;
	  if (this.game.spaces[destination_spacekey]) { destination = this.game.spaces[destination_spacekey]; }
	  if (this.game.navalspaces[destination_spacekey]) { destination = this.game.navalspaces[destination_spacekey]; }


	  for (let i = source.units[faction].length-1; i >= 0; i--) {
	    let u = source.units[faction][i];
	    if (u.land_or_sea == "sea" || u.land_or_sea == "both") {
	      destination.units[faction].push(u);
	      source.units[faction].splice(i, 1);
	    }
	  }

	  this.displaySpace(source_spacekey);
	  this.displayNavalSpace(source_spacekey);
	  this.displaySpace(destination_spacekey);
	  this.displayNavalSpace(destination_spacekey);

	  return 1;

	}



        if (mv[0] === "retreat") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let from = mv[2];
	  let to = mv[3];

	  this.updateLog(this.returnFactionName(faction) + " retreats from " + this.returnSpaceName(from) + " to " + this.returnSpaceName(to));

	  let source = this.game.spaces[from];
	  let destination = this.game.spaces[to];

	  for (let i = source.units[faction].length-1; i >= 0; i--) {
	    let u = source.units[faction][i];
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.army_leader == true || u.navy_leader == true) {
	      source.units[faction][i].locked = 1;
	      source.units[faction][i].already_moved = true;
	      if (source.units[faction][i].besieged != 1) {
	        destination.units[faction].push(source.units[faction][i]);
	        source.units[faction].splice(i, 1);
	      }
	    }
	  }

	  this.displaySpace(from);
	  this.displaySpace(to);

          return 1;

	}


        if (mv[0] === "interception_check") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let includes_cavalry = parseInt(mv[3]);

	  let space = this.game.spaces[spacekey];
	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0); // 0 cannot intercept across passes
	  let attacking_player = this.returnPlayerCommandingFaction(faction);

	  let already_asked = [];

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_this_faction_enter = false;
	    if (this.areEnemies(io[i], faction)) {
	      let fac = this.returnFactionControllingSpace(spacekey);
	      if (fac != faction && fac != io[i]) {
	        if (this.areAllies(io[i], fac)) { can_this_faction_enter = true; }
	      } else {
		can_this_faction_enter = true;
	      }
	    }


	    if (this.areEnemies(io[i], faction)) {

	      let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	      if (player_of_faction != attacking_player && player_of_faction != 0) {
  	        if (io[i] !== faction) {

		  let player_needs_adding = 0;

	          for (let zz = 0; zz < neighbours.length; zz++) {
		    if (neighbours[zz] != spacekey) {
	              let fluis = this.returnFactionLandUnitsInSpace(io[i], neighbours[zz]);
	              if (fluis > 0) {
		        if (!already_asked.includes(his_self.returnPlayerCommandingFaction(io[i])) && !already_asked.includes(neighbours[zz])) {
	                  this.game.queue.push("player_evaluate_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+includes_cavalry+"\t"+io[i]+"\t"+neighbours[zz]);
	  	          already_asked.push(neighbours[zz]);
		          player_needs_adding = 1;
		        }
	              }
	            }
	          }
		  if (player_needs_adding) {
	  	    already_asked.push(his_self.returnPlayerCommandingFaction(io[i]));
	          }
	        }
	      }
	    }

	    for (let zzz = 0; zzz < this.game.state.activated_powers[io[i]].length; zzz++) {
	      let ap = this.game.state.activated_powers[io[i]][zzz];
	      if (this.areEnemies(ap, faction)) {
	        if (ap != faction && !already_asked.includes(ap)) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
		    if (neighbours[zz] != spacekey) {
	              let fluis = this.returnFactionLandUnitsInSpace(ap, neighbours[zz]);
	              if (fluis > 0) {
		        if (!already_asked.includes(his_self.returnPlayerCommandingFaction(ap)) && !already_asked.includes(neighbours[zz])) {
	                  this.game.queue.push("player_evaluate_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+"0"+"\t"+ap+"\t"+neighbours[zz]);
	  	          already_asked.push(neighbours[zz]);
	                }
	              }
	            }
	          }
	        }
	  	already_asked.push(ap);
	      }
	    }
	  }
          return 1;
	}


        if (mv[0] === "naval_interception_check") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];

	  let neighbours = this.returnNavalAndPortNeighbours(spacekey);
	  let attacking_player = this.returnPlayerCommandingFaction(faction);

	  //
	  // interception at port is not possible
	  //
	  if (this.game.spaces[spacekey]) {
	    console.log("INTERCEPTIONS INVOLVING PORTS NOT SUPPORTED YET");
	  }

	  //
	  //
	  //
	  if (this.game.navalspaces[spacekey]) {

	    let io = this.returnImpulseOrder();
	    for (let i = io.length-1; i>= 0; i--) {
	      if (this.areEnemies(io[i], faction)) {
	        let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	        if (player_of_faction != attacking_player && player_of_faction != 0) {
  	          if (io[i] !== faction) {
	            for (let zz = 0; zz < neighbours.length; zz++) {
	              let fluis = this.returnFactionSeaUnitsInSpace(io[i], neighbours[zz]);
	              if (fluis > 0) {
	                this.game.queue.push("player_evaluate_naval_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+"\t"+io[i]+"\t"+neighbours[zz]);
	              }
	            }
	          }
	        }
	      }

	      for (let z = 0; z < this.game.state.activated_powers[io[i]].length; z++) {
	        let ap = this.game.state.activated_powers[io[i]][z];
	        if (this.areEnemies(ap, faction)) {
	          if (ap != faction) {
	            for (let zz = 0; zz < neighbours.length; zz++) {
	              let fluis = this.returnFactionSeaUnitsInSpace(ap, neighbours[zz]);
	              if (fluis > 0) {
	                this.game.queue.push("player_evaluate_naval_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+"\t"+ap+"\t"+neighbours[zz]);
	              }
	            }
	          }
	        }
	      }
	    }
	  }
          return 1;
	}


        if (mv[0] === "player_evaluate_naval_interception_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = mv[3];
	  let defender_spacekey = mv[4];

          let controller_of_defender = this.returnPlayerCommandingFaction(defender);
                
          if (controller_of_defender == 0) { return 1; }
            
          if (this.game.player == controller_of_defender) {
	    this.playerEvaluateNavalInterceptionOpportunity(attacker, spacekey, defender, defender_spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering naval interception from " + this.returnSpaceName(defender_spacekey));
	  }

	  return 0;

	}


        if (mv[0] === "player_evaluate_interception_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_includes_cavalry = mv[3];
	  let defender = mv[4];
	  let defender_spacekey = mv[5];
	  let controller_of_defender = this.returnPlayerCommandingFaction(defender);
	  let controller_of_attacker = this.returnPlayerCommandingFaction(attacker);
	  let invaded_space = this.game.spaces[spacekey];
	  let defender_space = this.game.spaces[defender_spacekey];

	  //
	  // you cannot intercept if besieged, so check if besieged, and one besieged unit
	  // means the whole stack is besieged
	  //
	  if (defender_space.besieged > 0) {
	    for (let x = 0; x < defender_space.units[defender].length; x++) {
	      if (defender_space.units[defender][x].besieged == 1) { return 1; }
	    }
	  }

	  //
	  // you cannot intercept if the space contains independent units
	  //
	  if (invaded_space.units["independent"].length > 0) { return 1; }

	  //
	  // you cannot intercept if the land units in the space belong to a power
	  // that is not allied to you. an example is Haps being at war with France
	  // and being invited to intercept if the French invade a space with 
	  // British regulars, but England and Haps are not allies.
	  //
	  for (let f in invaded_space.units) {
	    if (this.returnFactionLandUnitsInSpace(f, invaded_space.key) > 0) {
	      if (!this.areAllies(f, attacker) && f != attacker) {
		if (!this.areAllies(f, defender) && f != defender) { 
return 1; }
	      }
	    }
	  }

	  //
	  // you cannot intercept if the space is controlled by non-ally and non-enemy
	  //
	  let fcs = this.returnFactionControllingSpace(invaded_space.key);
	  if (!this.areAllies(fcs, defender, 1) &&  !this.areEnemies(fcs, defender, 1)) { return 1; }

	  //
	  // protestants can't intercept before the League forms
	  //
	  if (defender === "protestant" && this.game.state.events.schmalkaldic_league != 1) {
	    return 1;
	  }

	  if (controller_of_defender == 0) { return 1; }
	  if (controller_of_defender == controller_of_attacker) { return 1; }

	  if (this.game.player == controller_of_defender) {
	    this.playerEvaluateInterceptionOpportunity(attacker, spacekey, attacker_includes_cavalry, defender, defender_spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering interception from " + this.returnSpaceName(defender_spacekey));
	  }

	  return 0;

	}


        if (mv[0] === "intercept") {

	  this.game.queue.splice(qe, 1);

	  //
	  // in case we had it open to intercept
	  //
	  this.movement_overlay.hide();

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_includes_cavalry = parseInt(mv[3]);
	  let defender = mv[4];
	  let defender_spacekey = mv[5];
	  let units_to_move_idx = JSON.parse(mv[6]); // is actually obj now
	  let units_to_move = [];

	  //
	  // load actual units to examine them for cavalry, leaders
	  //
	  let s = this.game.spaces[defender_spacekey];
          for (let i = 0; i < units_to_move_idx.length; i++) {
	    units_to_move.push(s.units[units_to_move_idx[i].faction][units_to_move_idx[i].idx]);
	  }

	  if (units_to_move.length == 0) {
	    this.updateLog("no units sent to intercept...");
	    return 1;
	  }

	  let hits_on = 9;
	  let defender_has_cavalry = 0;
	  let defender_highest_battle_rating = 0;

	  for (let i = 0; i < units_to_move.length; i++) {
	    if (units_to_move[i].type === "cavalry") { defender_has_cavalry = 1; }
	    if (units_to_move[i].battle_rating > defender_highest_battle_rating) {
	      defender_highest_battle_rating = units_to_move[i].battle_rating;
	    }
	  }

	  this.updateLog(this.returnFactionName(defender) + " moves to intercept from " + this.returnSpaceName(defender_spacekey));

	  if (attacker === "ottoman" && attacker_includes_cavalry) {
	    this.updateLog("Ottoman +1 cavalry bonus");
	    hits_on++;
	  }
	  if (defender === "ottoman" && defender_has_cavalry) {
	    this.updateLog("Ottoman -1 cavalry bonus");
	    hits_on--;
	  }
	  if (defender_highest_battle_rating > 0) {
	    this.updateLog(this.returnFactionName(defender) + " gains " + defender_highest_battle_rating + " bonus from formation leader");
	  }

	  let d1 = this.rollDice(6);
	  let d2 = this.rollDice(6);
	  let dsum = d1+d2;

	  this.updateLog("Interception roll #1: " + d1);
	  this.updateLog("Interception roll #2: " + d2);

//
// IS_TESTING -- ALL INTERCEPTIONS SUCCEED
//
//this.updateLog("IS_TESTING - HITS ON 2");
//hits_on = 2;

	  if (dsum >= hits_on) {

	    try { salert(`${this.returnFactionName(defender)} Interception Succeeds!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Interception Succeeds!`);

	    //
	    // insert at end of queue by default
	    //
	    let index_to_insert_moves = this.game.queue.length-1;

	    //
	    // BUT NO OTHER POWER CAN INTERCEPT, SO CLEAN OUT GAME QUEUE
	    //
	    for (let i = this.game.queue.length-1; i >= 0; i--) {
	      let lqe = this.game.queue[i];
	      let lmv = lqe.split("\t");
	      if (lmv[0] !== "player_evaluate_interception_opportunity") {
	        index_to_insert_moves = i;
		break;
	      } else {
	        if (lmv[4] !== defender) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		}
	      }
	    }

	    //
	    // SUCCESS - move and continue to evaluate interception opportunities
	    //
	    let factions = {};
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      factions[units_to_move_idx[i].faction] = [];
	      for (let z = 0; z < 100; z++) { factions[units_to_move_idx[i].faction][z] = ""; }
	    }
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      let m = "move\t"+units_to_move_idx[i].faction+"\tland\t"+defender_spacekey+"\t"+spacekey+"\t"+units_to_move_idx[i].idx+"\t1\t1"; // 1 = skip avoid battle, 1 = is interception
	      factions[units_to_move_idx[i].faction][units_to_move_idx[i].idx] = m;
	    }

	    for (let f in factions) {
	      for (let z = 99; z >= 0; z--) {
		if (factions[f][z] != "") {
	          his_self.game.queue.splice((index_to_insert_moves+1), 0, factions[f][z]);
		}
	      }
	    }

	    let m = "lock\t"+defender+"\t"+spacekey; // 1 = skip avoid battle
	    his_self.game.queue.splice((index_to_insert_moves+1), 0, m);
	    his_self.game.queue.splice((index_to_insert_moves+1), 0, ("field_battle\t"+spacekey+"\t"+attacker));

	  } else {
	    try { salert(`${this.returnFactionName(defender)} Interception Fails!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Interception Fails!`);
	  }

	  return 1;

	}




        if (mv[0] === "naval_intercept") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = mv[3];
	  let defender_spacekey = mv[4];
	  let units_to_move_idx = JSON.parse(mv[5]);
	  let units_to_move = [];

	  //
	  // load actual units to examine them for squadrons, corsairs, navy leaders
	  //
	  let s;
	  if (this.game.spaces[defender_spacekey]) {
	    s = this.game.spaces[defender_spacekey];
	  }
	  if (this.game.navalspaces[defender_spacekey]) {
	    s = this.game.navalspaces[defender_spacekey];
	  }

          for (let i = 0; i < units_to_move_idx.length; i++) {
	    units_to_move.push(s.units[defender][units_to_move_idx[i].idx]);
	  }

	  if (units_to_move.length == 0) {
	    this.updateLog("no units sent to intercept...");
	    return 1;
	  }

	  let hits_on = 9;
	  let defender_highest_battle_rating = 0;

	  for (let i = 0; i < units_to_move.length; i++) {
	    if (units_to_move[i].battle_rating > defender_highest_battle_rating) {
	      defender_highest_battle_rating = units_to_move[i].battle_rating;
	    }
	  }

	  this.updateLog(this.returnFactionName(defender) + " navy moves to intercept from " + this.returnSpaceName(defender_spacekey));
	  if (defender_highest_battle_rating > 0) {
	    this.updateLog(this.returnFactionName(defender) + " gains " + defender_highest_battle_rating + " bonus from navy leader");
	  }

	  let d1 = this.rollDice(6);
	  let d2 = this.rollDice(6);
	  let dsum = d1+d2;

	  this.updateLog("Interception roll #1: " + d1);
	  this.updateLog("Interception roll #2: " + d2);

	  // IS_TESTING
	  if (dsum >= hits_on) {

	    try { salert(`${this.returnFactionName(defender)} Naval Interception Succeeds!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Naval Interception Succeeds!`);

	    //
	    // insert at end of queue by default
	    //
	    let index_to_insert_moves = this.game.queue.length-1;

	    //
	    // BUT NO OTHER POWER CAN INTERCEPT, SO CLEAN OUT GAME QUEUE FOR THIS DESTINATION
	    //
	    for (let i = this.game.queue.length-1; i >= 0; i--) {
	      let lqe = this.game.queue[i];
	      let lmv = lqe.split("\t");
	      if (lmv[0] !== "player_evaluate_naval_interception_opportunity") {
	        index_to_insert_moves = i;
		break;
	      } else {
	        if (lmv[2] != spacekey) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		  i--; // queue is 1 shorter
	          index_to_insert_moves = i;
		  break;
		}
	        if (lmv[3] !== defender) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		  i--; // queue is 1 shorter
	        }
	      }
	    }


	    //
	    // SUCCESS - move and continue to evaluate interception opportunities
	    //
	    let factions = {};
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      factions[units_to_move_idx[i].faction] = [100];
	    }
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      let m = "move\t"+units_to_move_idx[i].faction+"\tland\t"+defender_spacekey+"\t"+spacekey+"\t"+units_to_move_idx[i].idx+"\t"+1; // 1 = skip avoid battle
	      factions[units_to_move_idx[i].faction][units_to_move_idx[i].idx] = m;
	    }
	    for (let f in factions) {
	      for (let z = 100; z >= 0; z--) {
		if (factions[f][z]) {
	          his_self.game.queue.splice((index_to_insert_moves+1), 0, factions[f][z]);
		}
	      }
	    }


	  } else {
	    try { salert(`${this.returnFactionName(defender)} Naval Interception Fails!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Naval Interception Fails!`);
	  }

	  return 1;

	}

        if (mv[0] === "diet_of_worms_hapsburgs") {

	  this.factionbar.setActive("hapsburg");

	  let game_self = this;
	  let x = [];
          let fhand_idx = 0;
          if (this.game.player == this.returnPlayerCommandingFaction("hapsburg")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "hapsburg");
	  }
	  for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (this.game.deck[0].cards[this.game.deck[0].fhand[fhand_idx][i]].type === "mandatory") {} else { x.push(this.game.deck[0].fhand[fhand_idx][i]); }
	  }

	  if (this.game.player != this.returnPlayerCommandingFaction("hapsburg")) {
            this.updateStatusAndListCards("Hapsburgs Selecting Card for the Diet of Worms", x);
	  } else {
            this.updateStatusAndListCards("Hapsburgs - Select Card to indicate your Commitment to Debate", x);
            this.attachCardboxEvents(async function(card) {
	      game_self.game_help.hide();
              game_self.updateStatus("You picked: " + game_self.deck[card].name);
              game_self.addMove("discard\thapsburg\t"+card);
              game_self.addMove("diet_of_worms_hapsburg_resolve\t"+card);
              game_self.endTurn();

            });
	  }

	  this.game.queue.splice(qe, 1);
          return 0;

	}

        if (mv[0] === "diet_of_worms_hapsburg_resolve") {

	  let card = mv[1];
	  this.game.state.sp.push(card);
	  this.game.queue.splice(qe, 1);
          return 1;

	}

        if (mv[0] === "diet_of_worms") {

	  this.factionbar.setActive(["protestant","papacy"]);

	  let game_self = this;
	  let my_faction = "";

  this.game_help.render(TutorialTemplate, {
    help : `Diet of Worms` ,
    content : `

	The Diet of Worms was an Imperial Assembly convened by the Hapsburg Emperor in 1521 in the Free Imperial City of Worms. Its focus of discussion was on Martin Luther's critique of the Catholic Church and the question of whether he would recant. Luther refused to recant and the assembly ended with him fleeing Worms under the protection of Frederick III of Saxony before being condemned as a heretic by the religious and political establishment.

	<p></p>

	In simulating this event, the Protestant and Papacy both pick a card to reflect their level of commitment to the debate. In the two player game, the Protestants add +4 to the value of the card selected, while the Papacy pulls a card from the deck and adds its value. In all other games, the Hapsburg player contributes the second card for the Papacy.

	<p></p>

	Both players roll the appropriate number of dice and hit on all rolls of 5 or 6. The winner flips the difference in hits to the Protestant or Catholic faith.

    `,
    img : "/his/img/backgrounds/diet_of_worms.jpeg",
    line1 : "diet",
    line2 : "of worms?",
    fontsize : "2.1rem" ,
  });



	  // first time it happens, lets update menu
	  this.displayCardsLeft();

          game_self.game.queue.push("resolve_diet_of_worms");

	  //
	  // papacy controls haps in 3P / 4P
	  //
	  if (this.game.players.length > 2) {
            game_self.game.queue.push("diet_of_worms_hapsburgs");
	  }

	  //
	  // or we flip hapsburg card from deck if 2-player game
	  //
	  if (game_self.game.players.length == 2) {
	    // hapsburg card goes to pool
            game_self.game.queue.push("POOLDEAL\t1\t1\t1"); // deck 1
            game_self.game.queue.push("POOL\t1"); // deck 1
	  }

          //
          // remove mandatory events from both hands
	  //
	  let x = [];
          let fhand_idx = 0;
          if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "papacy");
	    my_faction = "Papacy";
	  }
          if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "protestant");
	    my_faction = "Protestants";
	  }
	  for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (this.game.deck[0].cards[this.game.deck[0].fhand[fhand_idx][i]].type === "mandatory") {} else { x.push(this.game.deck[0].fhand[fhand_idx][i]); }
	  }

	  if (this.game.player != this.returnPlayerCommandingFaction("papacy") && this.game.player != this.returnPlayerCommandingFaction("protestant")) {

            this.updateStatusAndListCards("Protestants and Papacy assemble at the Diet of Worms", x);

            let hash1 = game_self.app.crypto.hash("");    // my card
            let hash2 = game_self.app.crypto.hash(Math.random().toString());  // my secret
            let hash3 = game_self.app.crypto.hash(hash2 + hash1);             // combined hash

	    let privateKey = await game_self.app.wallet.getPrivateKey();

            let card_sig = game_self.app.crypto.signMessage("", privateKey);
            let hash2_sig = game_self.app.crypto.signMessage(hash2, privateKey);
            let hash3_sig = game_self.app.crypto.signMessage(hash3, privateKey);

            game_self.game.spick_card = "";
            game_self.game.spick_hash = hash2;
 
            game_self.addMove("SIMULTANEOUS_PICK\t"+game_self.game.player+"\t"+hash3+"\t"+hash3_sig);
            game_self.endTurn();

	  } else {

            this.updateStatusAndListCards(my_faction + " - Select Card to indicate your Commitment to Debate", x);
            this.attachCardboxEvents(async function(card) {

  	      //
	      // hide triangular help if game start -- papacy and other factions
	      //
	      game_self.game_help.hide();

              game_self.updateStatus("You picked: " + game_self.deck[card].name);

              let hash1 = game_self.app.crypto.hash(card);    // my card
              let hash2 = game_self.app.crypto.hash(Math.random().toString());  // my secret
              let hash3 = game_self.app.crypto.hash(hash2 + hash1);             // combined hash

	      let privateKey = await game_self.app.wallet.getPrivateKey();

              let card_sig = game_self.app.crypto.signMessage(card, privateKey);
              let hash2_sig = game_self.app.crypto.signMessage(hash2, privateKey);
              let hash3_sig = game_self.app.crypto.signMessage(hash3, privateKey);

              game_self.game.spick_card = card;
              game_self.game.spick_hash = hash2;
 
              game_self.addMove("SIMULTANEOUS_PICK\t"+game_self.game.player+"\t"+hash3+"\t"+hash3_sig);
              game_self.endTurn();

            });
	  }

	  this.game.queue.splice(qe, 1);
          return 0;
        }

	if (mv[0] === "resolve_diet_of_worms") {

	  this.game.queue.splice(qe, 1);

	  let protestant = this.returnPlayerOfFaction("protestant");
	  let papacy = this.returnPlayerOfFaction("papacy");
	  let protestant_arolls = [];
	  let papacy_arolls = [];

	  let all_players_but_protestant = [];
	  let all_players_but_papacy = [];
          for (let i = 1; i <= this.game.players.length; i++) {
	    if (i != protestant) { all_players_but_protestant.push(i); }
	    if (i != papacy) { all_players_but_papacy.push(i); }
	  }

	  let protestant_card = this.game.deck[0].cards[this.game.state.sp[protestant-1]];
	  let papacy_card = this.game.deck[0].cards[this.game.state.sp[papacy-1]];
	  let hapsburg_card = "";
	  if (this.game.players.length == 2) {
	    hapsburg_card = this.game.pool[0].hand[0];
	  } else {
	    hapsburg_card = this.game.state.sp[this.game.state.sp.length-1]; // hapsburgs added to last slot
	  }

	  this.updateLog("*************************");
	  this.updateLog("*** The Diet of Worms ***");
	  this.updateLog("*************************");
	  this.updateLog("Protestants select: " + this.popup(this.game.state.sp[protestant-1]));
	  this.updateLog("Papacy selects: " + this.popup(this.game.state.sp[papacy-1]));
	  this.updateLog("Hapsburgs select: " + this.popup(hapsburg_card));

	  //
	  // show card in overlay
	  //
	  this.diet_of_worms_overlay.render();
	  this.diet_of_worms_overlay.addCardToCardfan(this.game.state.sp[protestant-1], "protestant");
	  this.diet_of_worms_overlay.addCardToCardfan(this.game.state.sp[papacy-1], "catholic");
	  this.diet_of_worms_overlay.addCardToCardfan(hapsburg_card, "catholic");

	  //
	  // discard the selected cards
	  //
	  this.game.queue.push("discard\tprotestant\t"+this.game.state.sp[protestant-1]);
	  this.game.queue.push("discard\tpapacy\t"+this.game.state.sp[papacy-1]);
	  this.game.queue.push("discard\tall\t"+hapsburg_card);



	  //
	  // 3. roll protestant dice: The Protestant player adds 4 to the CP value of his card.
	  // This total represents the number of dice he now rolls. Each roll of a “5” or a “6”
	  // is considered to be a hit.
	  //
	  // 4. roll papal and Hapsburg dice: The Papal player rolls a num- ber of dice equal to
	  // the CP value of his card. The Hapsburg player does the same. Each roll of a “5” or a
	  // “6” is considered to be a hit. These two powers combine their hits into a Catholic total.
	  //
	  // 5. protestant victory: If the number of Protestant hits exceeds the number of Catholic
	  // hits, the Protestant power flips a number of spaces equal to the number of extra hits he
	  // rolled to Protestant influence. All spaces flipped must be in the German language zone.
	  // Spaces flipped must be adjacent to another Protestant space; spaces that were just
	  // flipped in this step can be used as the required adjacent Protestant space.
	  //
	  // 6. Catholic Victory: If the number of Catholic hits exceeds the number of Protestant hits,
	  // the Papacy flips a number of spaces equal to the number of extra hits he rolled to Catholic
	  // influence. All spaces flipped must be in the German language zone. Spaces flipped must be
	  // adjacent to another Catholic space; spaces that were just flipped in this step can be used
	  // as the required adjacent Catholic space.
	  //

	  let protestant_rolls = protestant_card.ops + 4;
	  let protestant_hits = 0;

	  for (let i = 0; i < protestant_rolls; i++) {
	    let x = this.rollDice(6);
	    protestant_arolls.push(x);
	    if (x >= 5) { protestant_hits++; }
	  }

	  let papacy_rolls = papacy_card.ops;
	  let papacy_hits = 0;

	  for (let i = 0; i < papacy_rolls; i++) {
	    let x = this.rollDice(6);
	    papacy_arolls.push(x);
	    if (x >= 5) { papacy_hits++; }
	  }

 	  if (this.game.deck[0].cards[hapsburg_card].type != "mandatory") {
	    for (let i = 0; i < this.game.deck[0].cards[hapsburg_card].ops; i++) {
	      papacy_rolls++;
	      let x = this.rollDice(6);
	      papacy_arolls.push(x);
	      if (x >= 5) { papacy_hits++; }
	    }
	  } else {
	    for (let i = 0; i < 2; i++) {
	      papacy_rolls++;
	      let x = this.rollDice(6);
	      papacy_arolls.push(x);
	      if (x >= 5) { papacy_hits++; }
	    }
	  }

	  this.updateLog("Protestants ("+protestant_hits+") vs. Catholics ("+papacy_hits+")");


	  if (protestant_hits > papacy_hits) {
	    this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "protestant" , difference : (protestant_hits - papacy_hits) , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	    this.game.queue.push("hide_overlay\ttheses");
	    let total_conversion_attempts = protestant_hits - papacy_hits;
	    for (let i = 1; i <= total_conversion_attempts && i <= this.returnNumberOfCatholicSpacesInLanguageZone("", 1); i++) {
	      this.game.queue.push("select_for_protestant_conversion\tprotestant\tgerman");
	    }
  	    this.game.queue.push("STATUS\tProtestants selecting towns to convert...\t"+JSON.stringify(all_players_but_protestant));
  	    this.game.queue.push("show_overlay\ttheses");
  	    this.game.queue.push("ACKNOWLEDGE\tProtestants win Diet of Worms");
	  } else {
	    if (protestant_hits < papacy_hits) {
	      this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "papacy" , difference : (papacy_hits - protestant_hits) , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	      this.game.queue.push("hide_overlay\ttheses");
	      let total_conversion_attempts = papacy_hits - protestant_hits;
	      for (let i = 1; i <= total_conversion_attempts && i <= this.returnNumberOfProtestantSpacesInLanguageZone("", 1); i++) {
	        this.game.queue.push("select_for_catholic_conversion\tpapacy\tgerman");
	      }
  	      this.game.queue.push("STATUS\tPapacy selecting towns to convert...\t"+JSON.stringify(all_players_but_papacy));
  	      this.game.queue.push("show_overlay\ttheses");
  	      this.game.queue.push("ACKNOWLEDGE\tPapacy wins Diet of Worms");
	    } else {
  	      //
              // report results
              //
	      this.updateLog("Diet of Worms ends in tie.");
	      this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "none" , difference : 0 , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	      this.game.queue.push("ACKNOWLEDGE\tDiet of Worms ends in a Stalemate");
	    }
	  }

          return 1;

	}

	//
	// this does not auto-remove, it needs to be preceded by a RESETCONFIRMSNEEDED
	// for however many people need to have the opportunity to counter or acknowledge.
	//
	if (mv[0] === "insert_before_counter_or_acknowledge") {

          this.game.queue.splice(qe, 1);

	  let insert = "";
	  for (let i = 1; i < mv.length; i++) {
	    if (i > 1) { insert += "\t"; }
	    insert += mv[i];
	  }

	  for (let i = this.game.queue.length-1; i >= 0; i--) {
	    let lqe = this.game.queue[i];
	    let lmv = lqe.split("\t");
	    if (lmv[0] === "counter_or_acknowledge") {
	      this.game.queue.splice(i, 0, insert);
	      i = 0;
	    }
	  }

	  return 1;

        }

	//
	// exists to be removed by counter_or_acknowledge
	//
	if (mv[0] === "halted") {
	  // in order to avoid hangs, we auto-broadcast our RESOLVE again
	  // if we reach this...
	  if (this.is_first_loop == 1) {
alert("workaround bug-fix: if you see this error the game is attempting to unlock a potentially frozen situation. this may cause issues, please flag for dev team if game does not recover");
	    this.addMove("RESOLVE\t"+this.publicKey);
	    this.endTurn();
	  }
	  return 0;
	}
	if (mv[0] === "counter_or_acknowledge") {

	  //
	  // hide any cardbox
	  //
	  this.cardbox.hide();

	  //
	  // if i have already confirmed, we only splice and pass-through if everyone else has confirmed
	  // otherwise we will set ack to 0 and return 0 which halts execution. so we should never clear 
	  // splice anything out except here...
	  //
	  if (this.game.confirms_needed[this.game.player-1] == 0) {

	    let ack = 1;

	    for (let i = 0; i < this.game.confirms_needed.length; i++) {
	      if (this.game.confirms_needed[i] >= 1) { ack = 0; }
	    }
	    //
	    // if everyone has returned, splice out counter_or_acknowledge
 	    // and continue to the next move on the game queue
	    //
	    if (ack == 1) { 
	      this.game.queue.splice(qe, 1);
	    }

	    this.updateStatus("acknowledged");
	    return ack;
	  }

	  //
	  // if we get this far i have not confirmed and others may or may
	  // not have confirmed, but we want at least to check to see wheter
	  // i want to just click ACKNOWLEDGE or take an action that might
	  // affect future gameplay (such as playing a card)....
	  //
	  let msg = mv[1];
	  let stage = "";
	  if (mv[2]) { stage = mv[2]; }
	  let extra = "";
	  if (mv[3]) { extra = mv[3]; }

	  //
	  // this is run when players have the opportunity to counter
	  // or intercede in a move made by another player. we cannot
	  // automatically handle without leaking information about
	  // game state, so we let players determine themselves how to
	  // handle. if they are able to, they can respond. if not they
	  // click acknowledge and the msg counts as notification of an
	  // important game development.
	  //
	  let his_self = this;

	  let html = '<ul>';

	  let menu_index = [];
	  let menu_triggers = [];
	  let attach_menu_events = 0;

    	  html += '<li class="option" id="ok">acknowledge</li>';

          let z = this.returnEventObjects();
	  for (let i = 0; i < z.length; i++) {

	    //
	    // maybe event has been removed, will fail
	    //
	    try {

	    if (z[i].key !== this.game.state.active_card) {
              if (z[i].menuOptionTriggers(this, stage, this.game.player, extra) == 1) {
                let x = z[i].menuOption(this, stage, this.game.player, extra);
		if (x.html) {
                  html += x.html;
	          z[i].faction = x.faction; // add faction
	          menu_index.push(i);
	          menu_triggers.push(x.event);
	          attach_menu_events = 1;
	        }
	      }
	    }

	    } catch (err) {}

	  }
	  html += '</ul>';

	  //
	  // skipping, and no options for active player -- skip completely
	  //
	  if (this.game.state.skip_counter_or_acknowledge == 1) {
	    if (attach_menu_events == 0) {
	      //
	      // replaces so we do not sent 2x
	      //
	      his_self.game.queue[his_self.game.queue.length-1] = "halted";
//if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
	      his_self.game.confirms_needed[his_self.game.player-1] = 1;
              his_self.addMove("RESOLVE\t"+his_self.publicKey);
//}
              his_self.endTurn();
	      his_self.updateStatus("skipping acknowledge...");
	      return 0;
	    }
	  }


	  //
	  // in faster_play mode, we will switch to HALTED if there are 
	  // no other options. this halts OUR game but allows others to continue
	  // to play more rapidly, which helps speed-up games where network connections
	  // can be a little slow, at the cost of leaking a small amount of information
	  // about player hands from the speed of the response (i.e. a fast response 
	  // likely means an automatic response, which likely means no cards permitting
	  // intervention are in-hand.
	  //
	  if (this.faster_play == 1 && menu_index.length == 0 && attach_menu_events != 1 && this.isGameHalted() != 1) {

	    //
	    // we don't need to HALT the game because the game will not progress
	    // until all players have hit RESOLVE anyway. 
	    //
            let my_specific_game_id = his_self.game.id;
	    his_self.is_halted = 1;
	    his_self.halted = 1;
            his_self.game.queue[his_self.game.queue.length-1] = "HALTED\tWaiting for Game to Continue\t"+his_self.publicKey;
            his_self.hud.back_button = false;

      	    let html = '<ul><li class="option" id="ok">acknowledge</li></ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              $('.option').off();
              let action = $(this).attr("id");

              his_self.game = his_self.loadGame(my_specific_game_id);

	      // tell game engine we can move
	      his_self.is_halted = 0;
	      his_self.halted = 0;
	      his_self.gaming_active = 0;

              his_self.updateStatus('continuing...');

              //
              // our own move will have been ticked into the future queue, along with
	      // anyone else's so we skip restartQueue() which will freeze if it sees
	      // that we have moves still pending, but should clear if it now finds 
	      // UNHALT is the latest instruction and this resolve is coming from us!
              //
	      his_self.processFutureMoves();

	    });

//if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
            his_self.addMove("RESOLVE\t"+his_self.publicKey);
            his_self.endTurn();
//}
            return 0;

	  }

	  this.updateStatusWithOptions(msg, html);
	  let deck = his_self.returnDeck(true);

	  $('.option').off();
	  $('.option').on('mouseover', function() {
            let action2 = $(this).attr("id");
	    if (deck[action2]) {
	      his_self.cardbox.show(his_self.returnCardImage(action2));
	    }
	    if (his_self.debaters[action2]) {
	      his_self.cardbox.show(action2);
	    }
	    if (his_self.game.deck[0].cards[action2]) {
	      his_self.cardbox.show(action2);
	    }
          });
	  $('.option').on('mouseout', function() {
            let action2 = $(this).attr("id");
	    if (deck[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	    if (his_self.debaters[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	    if (his_self.game.deck[0].cards[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	  });
          $('.option').on('click', async function () {

            let action2 = $(this).attr("id");

	    //
	    // prevent blocking
	    //
	    his_self.cardbox.hide();

            //
            // events in play
            //
            if (attach_menu_events == 1) {
              for (let i = 0; i < menu_triggers.length; i++) {
                if (action2 == menu_triggers[i]) {
                  $(this).remove();
		  his_self.updateStatus("acknowledged...");
	          // manually add, to avoid re-processing
	          if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
	            //his_self.game.confirms_needed[his_self.game.player-1] = 2;
                    his_self.prependMove("RESOLVE\t"+his_self.publicKey);
		    z[menu_index[i]].menuOptionActivated(his_self, stage, his_self.game.player, z[menu_index[i]].faction);
                  }
                  return 0;
                }
              }
            }

            if (action2 == "ok") {
	      //
	      // this ensures we clear regardless of choice
	      //
	      // manually add, to avoid re-processing
	      if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
                his_self.prependMove("RESOLVE\t"+his_self.publicKey);
	        his_self.updateStatus("acknowledged");
                his_self.endTurn();
              }
	      return 0;
            }

          });

	  return 0;

	}



	if (mv[0] === "naval_battle") {

	  //
	  // people are still moving stuff in
	  //
	  if (qe > 0) {
	    let lmv = "";
	    for (let i = qe-1; i > 0; i--) {
	      lmv = this.game.queue[i].split("\t");
	      if (lmv[0] === "naval_battle" && lmv[1] == mv[1]) {
          	this.game.queue.splice(qe, 1);
		return 1;
	      }
	    }
	  }
 
          this.game.queue.splice(qe, 1);

	  //
	  // we will create this object dynamically
	  //
	  this.game.state.naval_battle = {};

	  //
	  // calculate rolls
	  //
          let calculate_rolls = function(faction) {
	    let rolls = 0;
	    let units = [];
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].personage == false) {
		if (space.units[faction][i].land_or_sea === "sea" || space.units[faction][i].land_or_sea === "both") {
	          rolls++;
		  if (space.units[faction][i].type === "squadron") {
	            rolls++;
		  }
	          units.push(space.units[faction][i].key);
	        }
	      }
	    }
	    return { rolls : rolls , units : units };
          }
	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].battle_rating > 0) {
	        if (highest_battle_rating < space.units[faction][i].battle_rating) {
		  highest_battle_rating = space.units[faction][i].battle_rating;
		}
	      }
	    }
	    return highest_battle_rating;
          }
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }

	  //
	  // this is run when a naval battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a nearby sea or port if 
	  // possible. as such, the rest of this function simply handles
	  // the battle on the high-seas.
	  //
	  let his_self = this;
	  let space = "";
	  let spacekey = mv[1];
	  let is_battle_in_port = false;

	  //
	  // either in port
	  //
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; is_battle_in_port = true; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }
	  let attacker = mv[2];
	  let stage = "naval_battle";


          //
          // stop naval battle if only attacker is left (retreat)
          //
          let fluis = 0;
          let attacker_fluis = this.returnFactionNavalUnitsInSpace(attacker, spacekey);
          for (let f in space.units) {
            if (!this.areAllies(attacker, f, 1)) {
              fluis += this.returnFactionNavalUnitsInSpace(f, spacekey);
            }
          }
          if (fluis == 0 || attacker_fluis == 0) {
            return 1;
          }



	  //
	  // who is here?
	  //
	  // in sea battles an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);

 	  let attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerOfFaction(defender_faction);
	  let is_janissaries_possible = false;


	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnNavalFactionMap(space, attacker_faction, defender_faction);

	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {

	    //
	    // check for janissaries in this loop
	    //
	    if (f === "ottoman" && space.units["ottoman"].length > 0) {
	      if (!his_self.game.deck[0].discards['001']) {
	        if (!this.game.queue.includes("discard\tottoman\t001")) { is_janissaries_possible = true; }
	      }
	    }


	    if (f !== attacker_faction && faction_map[f] === attacker_faction) {
try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p && ap) {
	        if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
} catch (err) {}
	    }
	    if (f !== defender_faction && faction_map[f] === attacker_faction) {
try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(defender_faction)-1];
	      let dp = his_self.game.state.players_info[defender_player-1];
	      if (p && dp) {
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
} catch (err) {}
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_rolls = 0;
	  let defender_rolls = 0;
	  if (is_battle_in_port) { defender_rolls++; }
	  let attacker_units = [];
	  let defender_units = [];
	  if (is_battle_in_port) { defender_units.push('port defense'); }
	  let attacker_units_faction = [];
	  let defender_units_faction = [defender_faction];
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;
	  let attacker_highest_battle_rating_figure = "";
	  let defender_highest_battle_rating_figure = "";

	  for (let f in faction_map) {
	    if (faction_map[f] === attacker_faction) {

	      let x = calculate_rolls(f);

	      attacker_rolls += x.rolls;
	      attacker_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { attacker_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	    if (faction_map[f] === defender_faction) {

	      let x = calculate_rolls(f);
	      defender_rolls += x.rolls;
	      defender_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { defender_units_faction.push(f); }

	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // add rolls for highest battle ranking
	  //
	  for (let z = 0; z < attacker_highest_battle_rating; z++) {
	    attacker_rolls++;
	  }
	  for (let z = 0; z < defender_highest_battle_rating; z++) {
	    defender_rolls++;
	  }

	  //
	  // add bonus rolls
	  //
	  if (attacker_player.tmp_roll_bonus) {
  	    attacker_rolls += parseInt(attacker_player.tmp_roll_bonus);
	  }
	  if (defender_player.tmp_roll_bonus) {
            defender_rolls += parseInt(defender_player.tmp_roll_bonus);
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  //
	  // modify rolls as needed
	  //
	  let attacker_modified_rolls = attacker_results;
	  let defender_modified_rolls = attacker_results;
  	  if (his_self.game.state.naval_battle.attacker_player > 0) {
	    attacker_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.naval_battle.attacker_player-1], attacker_results);
	  }
  	  if (his_self.game.state.naval_battle.defender_player > 0) {
 	    defender_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.naval_battle.defender_player-1], defender_results);
	  }

	  for (let i = 0; i < attacker_modified_rolls; i++) {
	    if (attacker_modified_rolls[i] >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_modified_rolls; i++) {
	    if (defender_modified_rolls[i] >= 5) { defender_hits++; }
	  }

	  //
	  // we have now rolled all of the dice that we need to roll at this stage
	  // and the results have been pushed into the naval_battle object. but there
	  // is still the possibility that someone might want to intervene...
	  //
	  // things get extra messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue via counter/acknowledge. those independent
	  // functions can then manipulate the naval_battle object directly before
	  // permitting it to fall-through..
	  //

	  //
	  // save battle state
	  //
          his_self.game.state.naval_battle.spacekey = mv[1];
          his_self.game.state.naval_battle.spacekey = mv[1];
	  his_self.game.state.naval_battle.attacker_units = attacker_units;
	  his_self.game.state.naval_battle.defender_units = defender_units;
	  his_self.game.state.naval_battle.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.naval_battle.defender_units_faction = defender_units_faction;
	  his_self.game.state.naval_battle.attacker_rolls = attacker_rolls;
	  his_self.game.state.naval_battle.defender_rolls = defender_rolls;
	  his_self.game.state.naval_battle.attacker_modified_rolls = attacker_modified_rolls;
	  his_self.game.state.naval_battle.defender_modified_rolls = defender_modified_rolls;
	  his_self.game.state.naval_battle.attacker_hits = attacker_hits;
	  his_self.game.state.naval_battle.defender_hits = defender_hits;
	  his_self.game.state.naval_battle.attacker_units_destroyed = [];
	  his_self.game.state.naval_battle.defender_units_destroyed = [];
	  his_self.game.state.naval_battle.attacker_results = attacker_results;
	  his_self.game.state.naval_battle.defender_results = defender_results;
	  his_self.game.state.naval_battle.attacker_faction = attacker_faction;
	  his_self.game.state.naval_battle.defender_faction = defender_faction;
	  his_self.game.state.naval_battle.attacker_player = his_self.returnPlayerCommandingFaction(attacker_faction);
	  his_self.game.state.naval_battle.defender_player = his_self.returnPlayerCommandingFaction(defender_faction);
	  his_self.game.state.naval_battle.attacker_highest_battle_rating = attacker_highest_battle_rating;
	  his_self.game.state.naval_battle.defender_highest_battle_rating = defender_highest_battle_rating;
	  his_self.game.state.naval_battle.defender_hits_first = 0;
	  his_self.game.state.naval_battle.attacker_hits_first = 0;
	  his_self.game.state.naval_battle.defender_hits_first = 0;
	  his_self.game.state.naval_battle.faction_map = faction_map;
	  his_self.game.state.naval_battle.is_battle_in_port = is_battle_in_port;

	  let ap = {};
	  let dp = {};

	  if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
	  if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

	  //
	  // ottomans may play Janissaries, and some players may attack before each other, so
	  // we take conditional action and move to COUNTER_OR_ACKNOWLEDGE based on the details
	  // of how the battle should execute. the most important division is if one player
	  // "goes first" in which case they knock away from potential hits from the other
	  // side.
	  //
	  his_self.game.queue.push(`naval_battle_continue\t${mv[1]}`);

	  if (ap.tmp_roll_first == 1 && dp.tmp_roll_first != 1) {
	    his_self.game.state.naval_battle.attacker_hits_first = 1;
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.defender_faction);
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.attacker_faction);
	    his_self.game.queue.push("ACKNOWLEDGE\tProceed to Hits Assignment");
	  } else if (ap.tmp_roll_first != 1 && dp.tmp_roll_first == 1) {
	    his_self.game.state.naval_battle.defender_hits_first = 1;
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.attacker_faction);
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.defender_faction);
	    his_self.game.queue.push("ACKNOWLEDGE\tProceed to Hits Assignment");
	  } else {
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.attacker_faction);
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.defender_faction);
	    his_self.game.queue.push("ACKNOWLEDGE\tProceed to Hits Assignment");
	  }

	  //
	  // this should stop execution while we are looking at the pre-naval battle overlay
	  //
	  his_self.game.queue.push("naval_battle_assign_hits_render");
          if (is_janissaries_possible) {
            his_self.game.queue.push("counter_or_acknowledge\tOttomans considering playing Janissaries\tjanissaries_naval\t"+space.key); 
            his_self.game.queue.push("RESETCONFIRMSNEEDED\tall");
          }
	  his_self.game.queue.push("counter_or_acknowledge\tNaval Battle commences in "+space.name + "\tpre_naval_battle_rolls\t"+space.key);
          his_self.game.queue.push("RESETCONFIRMSNEEDED\tall");
          
          
          his_self.naval_battle_overlay.renderPreNavalBattle(his_self.game.state.naval_battle);
          his_self.naval_battle_overlay.pullHudOverOverlay();

	  return 1;

        }



	if (mv[0] === "field_battle") {

	  //
	  // people are still moving stuff in
	  //
	  if (qe > 0) {
	    let lmv = "";
	    for (let i = qe-1; i > 0; i--) {
	      lmv = this.game.queue[i].split("\t");
	      if (lmv[0] === "field_battle" && lmv[1] == mv[1]) {
          	this.game.queue.splice(qe, 1);
		return 1;
	      }
	    }
	  }
 
          this.game.queue.splice(qe, 1);

	  //
	  // we will create this object dynamically
	  //
	  this.game.state.field_battle = {};

	  //
	  // calculate rolls
	  //
          let calculate_rolls = function(faction) {
	    let rolls = 0;
	    let units = [];
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].personage == false && space.units[faction][i].besieged == 0) {
		if (space.units[faction][i].land_or_sea === "land" || space.units[faction][i].land_or_sea === "both") {
	          rolls++;
		  units.push(space.units[faction][i].key);
	        }
	      }
	    }
	    return { rolls : rolls , units : units };
          }
	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].battle_rating > 0 && space.units[faction][i].besieged == 0) {
	        if (highest_battle_rating < space.units[faction][i].battle_rating) {
		  highest_battle_rating = space.units[faction][i].battle_rating;
		}
	      }
	    }
	    return highest_battle_rating;
          }
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }

	  //
	  // this is run when a field battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a fortress if available. as
	  // such, the rest of this function moves to to handle the on-the-
	  // ground conflict.
	  //
	  let his_self = this;
	  let spacekey = mv[1];
	  let attacker = mv[2];
	  let space = this.game.spaces[spacekey];
	  let stage = "field_battle";


          //
          // if there is no-one here but the attacker, we want to stop the field battle 
	  // because it is pointless...
          //
          let fluis = 0;
          for (let f in this.game.spaces[spacekey].units) {
            if (f !== attacker && !this.areAllies(this.game.state.active_faction, f, 1)) {
              fluis += this.returnFactionLandUnitsInSpace(f, spacekey);
            }
          }
          if (fluis == 0) { 

	    //
	    // if key or fortress or electorate, we may need to besiege first
	    //
	    if (this.game.spaces[spacekey].type == "fortress" || this.game.spaces[spacekey].type == "electorate" || this.game.spaces[spacekey].type == "key") {
	      let fac = this.returnFactionControllingSpace(spacekey);
	      if (fac != attacker) {
		this.game.spaces[spacekey].besieged = 2;
                this.game.spaces[spacekey].besieged_factions.push(fac);
	      }
	    }

	    this.displaySpace(spacekey);
	    return 1; 

	  }


	  //
	  // the first thing we check is whether the land units that control the space have
	  // withdrawn into fortifications, as if that is the case then land battle is avoided
	  // note that besieged 2 means it is the same turn that the place was put under siege
	  //
	  if (space.besieged == 2) {
	    //
	    // we can hit this point if there is an intercept from the player that controls the 
	    // space, moving into a space that was undefended and was put under siege when the 
	    // opponent moved in. in order to guard against this, we check to see if there are
	    // any units that have withdrawn into the space..
	    //
	    let anyone_home = false;
	    for (let f in this.game.spaces[spacekey].units) {
	      for (let z = 0; z < this.game.spaces[spacekey].units[f].length; z++) {
		if (this.game.spaces[spacekey].units[f][z].besieged != 0) { anyone_home = true; }
	      }
	    }

	    if (anyone_home == true) {
	      this.updateLog("Field Battle avoided by defenders withdrawing into fortifications");
	      this.game.queue.push("ACKNOWLEDGE\tField Battle avoided by defenders retreating into fortification");
	      //
	      // and redraw
	      //
	      this.displaySpace(space.key);
	      return 1;
	    } else {
	      this.game.queue.push(`field_battle\t${spacekey}\t${attacker}`);
	      this.game.queue.push(`fortification_check\t${attacker}\t${spacekey}\t${his_self.game.state.attacker_comes_from_this_spacekey}`);
	      return 1;
	    }

	  }

	  //
	  // otherwise -- who the hell is here?
	  //
	  // an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);
	  let is_janissaries_possible = false;

 	  let attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerOfFaction(defender_faction);

	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnFactionMap(space, attacker_faction, defender_faction);

	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {

	    //
	    // check for janissaries in this loop
	    //
	    if (f === "ottoman" && space.units["ottoman"].length > 0) {
	      if (!his_self.game.deck[0].discards['001']) {
	        is_janissaries_possible = true;
	      }
	    }

	    if (f !== attacker_faction && faction_map[f] === attacker_faction) {
	      let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p && ap) {
	        if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	    }
	    if (f !== defender_faction && faction_map[f] === attacker_faction) {
	      let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1];
	      let dp = his_self.game.state.players_info[defender_player-1];
	      if (p && dp) {
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //
	  // we can how start building the field_battle object, which will contain
	  // the information, die rolls, modified die rolls, needed to carry out the
	  // conflict.
	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_rolls = 0;
	  let defender_rolls = 1;
	  let attacker_units = [];
	  let defender_units = ['defender'];

	  //
	  // no defender bonus in foreign wars
	  //
	  if (space.key === "persia" || space.key === "egypt" || space.key === "ireland") {
	    defender_rolls = 0;
	    defender_units = [];
	  }

	  let attacker_units_faction = [];
	  let defender_units_faction = [defender_faction];
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;
	  let attacker_highest_battle_rating_figure = "";
	  let defender_highest_battle_rating_figure = "";

	  let unbesieged_defender_units = 0;

	  for (let f in faction_map) {
	    if (faction_map[f] === attacker_faction) {
	      let x = calculate_rolls(f);
	      attacker_rolls += x.rolls;
	      attacker_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { attacker_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	    if (faction_map[f] === defender_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		let u = space.units[f][z];
		if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") {
		  if (u.besieged == 0) { unbesieged_defender_units++; }
		}
	      }
	      let x = calculate_rolls(f);
	      defender_rolls += x.rolls;
	      defender_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { defender_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // if the defender has no units in the space and this is a fortified space
	  // we don't want to go into hits assignment because we cannot actually have
	  // a field battle, so we just nope out and put the space immediately under 
	  // siege.
	  //
 	  // <= 1 because defenders get that bonus hit
	  //
	  let no_defender_units = false;
	  if (defender_units.length < 1) { no_defender_units = true; } else {
	    if (defender_units[0] == "defender") {
 	      if (defender_units.length == 1) { no_defender_units = true; }
	    }
	  }
	  if (no_defender_units == true && (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress")) {
	    if (space.besieged != 1) { // not if already besieged
	      space.besieged = 2;
	      this.updateLog(space.name + " put under siege.");
	    }
	    this.displaySpace(space.key);
	    return 1;	    
	  }

	  //
	  // no unbesieged defender units
	  //
	  if (unbesieged_defender_units == 0) {
	    this.displaySpace(space.key);
	    return 1;
	  }


	  //
	  // if the defender has no units (retreat?) then we just exit the field battle
	  // immediately since there is no battle at all. note that we have already handled
	  // edge-cases with siege/assault above.
	  //
	  if (no_defender_units == true) {
	    this.displaySpace(space.key);
	    return 1;	    
	  }

	  //
	  // add rolls for highest battle ranking
	  //
	  for (let z = 0; z < attacker_highest_battle_rating; z++) {
	    attacker_rolls++;
	  }
	  for (let z = 0; z < defender_highest_battle_rating; z++) {
	    defender_rolls++;
	  }

	  //
	  // add bonus rolls
	  //
	  if (attacker_player.tmp_roll_bonus) {
  	    attacker_rolls += parseInt(attacker_player.tmp_roll_bonus);
	  }
	  if (defender_player.tmp_roll_bonus) {
            defender_rolls += parseInt(defender_player.tmp_roll_bonus);
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  //
	  // modify rolls as needed
	  //
	  let attacker_modified_rolls = attacker_results;
	  let defender_modified_rolls = defender_results;
  	  if (his_self.game.state.field_battle.attacker_player > 0) {
	    attacker_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.field_battle.attacker_player-1], attacker_results);
	  }

  	  if (his_self.game.state.field_battle.defender_player > 0) {
 	    defender_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.field_battle.defender_player-1], defender_results);
	  }

	  for (let i = 0; i < attacker_modified_rolls; i++) {
	    if (attacker_modified_rolls[i] >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_modified_rolls; i++) {
	    if (defender_modified_rolls[i] >= 5) { defender_hits++; }
	  }

	  //
	  // we have now rolled all of the dice that we need to roll at this stage
	  // and the results have been pushed into the field_battle object. but there
	  // is still the possibility that someone might want to intervene...
	  //
	  // things get extra messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue via counter/acknowledge. those independent
	  // functions can then manipulate the field_battle object directly before
	  // permitting it to fall-through..
	  //
          his_self.game.state.field_battle.spacekey = mv[1];
	  his_self.game.state.field_battle.attacker_units = attacker_units;
	  his_self.game.state.field_battle.defender_units = defender_units;
	  his_self.game.state.field_battle.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.field_battle.defender_units_faction = defender_units_faction;
	  his_self.game.state.field_battle.attacker_rolls = attacker_rolls;
	  his_self.game.state.field_battle.defender_rolls = defender_rolls;
	  his_self.game.state.field_battle.attacker_modified_rolls = attacker_modified_rolls;
	  his_self.game.state.field_battle.defender_modified_rolls = defender_modified_rolls;
	  his_self.game.state.field_battle.attacker_hits = attacker_hits;
	  his_self.game.state.field_battle.defender_hits = defender_hits;
	  his_self.game.state.field_battle.attacker_units_destroyed = [];
	  his_self.game.state.field_battle.defender_units_destroyed = [];
	  his_self.game.state.field_battle.attacker_results = attacker_results;
	  his_self.game.state.field_battle.defender_results = defender_results;
	  his_self.game.state.field_battle.attacker_faction = attacker_faction;
	  his_self.game.state.field_battle.defender_faction = defender_faction;
	  his_self.game.state.field_battle.attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
	  his_self.game.state.field_battle.defender_player = his_self.returnPlayerOfFaction(defender_faction);
	  his_self.game.state.field_battle.attacker_highest_battle_rating = attacker_highest_battle_rating;
	  his_self.game.state.field_battle.defender_highest_battle_rating = defender_highest_battle_rating;
	  his_self.game.state.field_battle.defender_hits_first = 0;
	  his_self.game.state.field_battle.attacker_hits_first = 0;
	  his_self.game.state.field_battle.defender_hits_first = 0;
	  his_self.game.state.field_battle.faction_map = faction_map;

	  let ap = {};
	  let dp = {};

	  if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
	  if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

	  //
	  // ottomans may play Janissaries, and some players may attack before each other, so
	  // we take conditional action and move to COUNTER_OR_ACKNOWLEDGE based on the details
	  // of how the battle should execute. the most important division is if one player
	  // "goes first" in which case they knock away from potential hits from the other
	  // side.
	  //
	  his_self.game.queue.push(`field_battle_continue\t${mv[1]}`);

	  if (ap.tmp_roll_first == 1 && dp.tmp_roll_first != 1) {
	    his_self.game.state.field_battle.attacker_hits_first = 1;
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	  } else if (ap.tmp_roll_first != 1 && dp.tmp_roll_first == 1) {
	    his_self.game.state.field_battle.defender_hits_first = 1;
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	  } else {
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	  }
	  //
	  // this should stop execution while we are looking at the pre-field battle overlay
	  //
	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(space.key);
if (from_whom.includes(this.game.players[this.game.player-1])) {
	  his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
}
	  his_self.game.queue.push("field_battle_assign_hits_render");
	  if (is_janissaries_possible) {
	    his_self.game.queue.push("counter_or_acknowledge\tOttomans considering playing Janissaries\tjanissaries\t"+space.key);
            his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
	  }
	  his_self.game.queue.push("counter_or_acknowledge\tField Battle is about to begin in "+space.name + "\tpre_field_battle_rolls\t"+space.key);
          his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
          his_self.field_battle_overlay.renderPreFieldBattle(his_self.game.state.field_battle);
          his_self.field_battle_overlay.pullHudOverOverlay();

	  return 1;

        }


        if (mv[0] === "field_battle_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies, but they have
	  // to split hits, with a random roll used to determine who takes the extra
	  // hit ON DEFENSE. the active power assigns hits independently to any land
	  // units who attack.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.field_battle.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // we auto-assign the hits to independent, non-player controlled units
	  // this function handles that.
	  //
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;
	    let faction_map = his_self.game.state.field_battle.faction_map;

	    if (faction === "independent") {
	      max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(faction, space);
	    } else {
	      //
	      // max hits to assign are the faction land units
	      //
	      for (let f in his_self.game.state.faction_map) {
	        if (faction_map[f] === faction) {
	      	  max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	        }
	      }
	    }

	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }

	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

console.log("testing...");

	      let number_of_targets = 0;

	      //
	      // first we calculate starting faction targets
	      //
	      if (faction != "independent") {
	        for (let f in faction_map) {
	          if (faction_map[f] === faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      } else {
		number_of_targets = 1;
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] === faction || (f == "independent" && faction == "independent")) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "mercenary"; }
		        if (zzz == 1) { cannon_fodder = "regular"; }
		        if (zzz == 2) { cannon_fodder = "cavalry"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type === cannon_fodder && space.units[f][i].besieged == 0) {

			    //
			    // and remove from field battle unit
			    //
		            if (faction === his_self.game.state.field_battle_attacker_faction) {
			      for (let z = 0; z < his_self.game.state.field_battle.attacker_units.length; z++) {
			        let u = his_self.game.state.field_battle.attacker_units[z];
			        if (u.type === cannon_fodder) {
			          if (!his_self.game.state.field_battle.attacker_units_destroyed.includes(z)) {
			            his_self.game.state.field_battle.attacker_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }
		            if (faction === his_self.game.state.field_battle_defender_faction) {
			      for (let z = 0; z < his_self.game.state.field_battle.defender_units.length; z++) {
			        let u = his_self.game.state.field_battle.defender_units[z];
			        if (u.type === cannon_fodder) {
			          if (!his_self.game.state.field_battle.defender_units_destroyed.includes(z)) {
			            his_self.game.state.field_battle.defender_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }

		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] === faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "mercenary"; }
                    if (zzz == 1) { cannon_fodder = "regular"; }
                    if (zzz == 2) { cannon_fodder = "cavalry"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type === cannon_fodder && space.units[selected_faction][ii].besieged == 0) {

			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
	  		his_self.game.state.field_battle.attacker_units_destroyed = [];
	  		his_self.game.state.field_battle.defender_units_destroyed = [];

                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }


	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {
	    if (faction === this.game.state.field_battle.attacker_faction) {
	      assign_hits(faction, this.game.state.field_battle.defender_hits);
	    } else {
	      assign_hits(faction, this.game.state.field_battle.attacker_hits);
	    }
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.updateInstructions("Independent Hits Assigned");
	    return 1;
	  }


	  //
	  // no hits assignment if no hits
	  //
	  //
	  if (faction === this.game.state.field_battle.attacker_faction) {
	    if (this.game.state.field_battle.defender_hits == 0) { return 1; }
	  } else {
	    if (this.game.state.field_battle.attacker_hits == 0) { return 1; }
	  }


	  //
	  // if we hit this point we need manual intervention to assign the hits.
	  // the attacker can assign hits however they prefer if others join them
	  // in the attack, but if two major powers share defense then the hits
	  // are divided evenly among them.
	  //
          let hits_to_assign = this.game.state.field_battle.attacker_hits;
          let defending_factions = [];
          let defending_factions_count = 0;
          let defending_major_powers = 0;
          let defending_factions_hits = [];
	  let units_capable_of_taking_hits = 0;
	  for (let f in this.game.state.field_battle.faction_map) {
	    if (this.game.state.field_battle.faction_map[f] == faction || f == faction) {
	      units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.field_battle.spacekey);
	      if (this.isMajorPower(f)) {
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
	    }
          }
	  //
	  // this can happen if only minor powers, but controlled by major power
	  //
	  if (defending_factions_hits.length == 0) {
	    for (let f in this.game.state.field_battle.faction_map) {
	      if (this.game.state.field_battle.faction_map[f] == faction || f == faction) {
	        units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.field_battle.spacekey);
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
            }
          }

	  // this is needed, but we shouldn't hit it
	  //if (defending_faction_hits.length == 0) {
	  //  return 1;
	  //}

	  if (units_capable_of_taking_hits == 0) {
	    return 1;
	  }

	  //
	  // every gets shared hits
	  //

console.log("hits to assign: " + hits_to_assign);
console.log("defending factions hits: " + defending_factions_hits);

	  while (hits_to_assign > defending_factions_hits.length) {
console.log(hits_to_assign + " > " + defending_factions_hits.length);
	    for (let i = 0; i < defending_factions_hits.length; i++) { defending_factions_hits[i]++; }
	    hits_to_assign -= defending_factions_hits.length;
	  }

	  //
	  // randomly assign remainder
	  //
	  let already_punished = [];
	  for (let i = 0; i < hits_to_assign; i++) {
	    let unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	    while (already_punished.includes(unlucky_faction)) {
console.log("unlucky faction spinout...");
	      unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	    }
	    defending_factions_hits[unlucky_faction]++;
	    already_punished.push(unlucky_faction);
	  }

	  //
	  // defending major powers
	  //
	  if (defending_major_powers > 0 && this.game.state.field_battle.faction_map[faction] == this.game.state.field_battle.defender_faction) {
	    for (let i = 0; i < defending_factions_hits.length; i++) {
  	      this.game.queue.push(`field_battle_manually_assign_hits\t${defending_factions[i]}\t${defending_factions_hits[i]}`);
	    }
	    return 1;
	  }

console.log("about to assign hits directly...");

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.assignHits(his_self.game.state.field_battle, faction);
	  } else {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
	    his_self.updateStatus(this.returnFactionName(faction) + " Assigning Hits");
            his_self.field_battle_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;

	}



        if (mv[0] === "naval_battle_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space;
	  let is_battle_in_port = false;
	  if (this.game.spaces[this.game.state.naval_battle.spacekey]) { is_battle_in_port = true; space = this.game.spaces[this.game.state.naval_battle.spacekey]; }
	  if (this.game.navalspaces[this.game.state.naval_battle.spacekey]) { is_battle_in_port = true; space = this.game.navalspaces[this.game.state.naval_battle.spacekey]; }

          this.game.queue.splice(qe, 1);

	  //
	  // this auto-assigns hits to squadrons...
	  //
	  let assign_hits = function(faction, hits) {
	    for (let z = space.units[faction].length-1; assign_hits >= 2 && z >= 0; z--) {
	      if (space.units[faction][z].type == "squadron") {
		space.units[faction].splice(z, 1);
		assign_hits-=2;
	      }
	    }
	  }

	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {
	    if (faction == this.game.state.naval_battle.attacker_faction) {
	      if (this.game.state.naval_battle.defender_hits > 0) {
	        assign_hits(faction, this.game.state.naval_battle.defender_hits);
	      }
	    } else {
	      if (this.game.state.naval_battle.attacker_hits > 0) {
	        assign_hits(faction, this.game.state.naval_battle.attacker_hits);
	      }
	    }

            his_self.naval_battle_overlay.renderNavalBattle(his_self.game.state.naval_battle);
            his_self.naval_battle_overlay.updateInstructions("Independent Hits Assigned");

	    return 1;

	  } else {

            his_self.naval_battle_overlay.renderNavalBattle(his_self.game.state.naval_battle);
	    if (his_self.game.player == this.returnPlayerCommandingFaction(faction)) {
	      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(his_self.game.state.naval_battle.attacker_faction)) {
	        if (this.game.state.naval_battle.defender_hits > 0) {
                  his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
	        } else {
		  his_self.endTurn();
		}
	      } else {
	        if (this.game.state.naval_battle.attacker_hits > 0) {
                  his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
	        } else {
		  his_self.endTurn();
		}
	      }
	    } else {
	      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(this.game.state.naval_battle.attacker_faction)) {
	        if (this.game.state.naval_battle.defender_hits > 0) {
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Assigning Hits");
	        } else {
		  his_self.updateStatus(his_self.returnFactionName(faction) + " - Fleet Survives Intact");
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Unscathed - click to continue");
		}
	      } else {
	        if (this.game.state.naval_battle.attacker_hits > 0) {
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Assigning Hits");
	        } else {
		  his_self.updateStatus(his_self.returnFactionName(faction) + " - Fleet Survives Intact");
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Unscathed - click to continue");
		}
	      }
	    }
	  }

	  return 0;

	}





        if (mv[0] === "assault_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies, but they have
	  // to split hits, with a random roll used to determine who takes the extra
	  // hit ON DEFENSE. the active power assigns hits independently to any land
	  // units who attack.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.assault.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // we auto-assign the hits to independent, non-player controlled units
	  // this function handles that.
	  //
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;
	    let faction_map = his_self.game.state.assault.faction_map;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	      }
	    }

	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }

	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "mercenary"; }
		        if (zzz == 1) { cannon_fodder = "regular"; }
		        if (zzz == 2) { cannon_fodder = "cavalry"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {

			    //
			    // and remove from field battle unit
			    //
		            if (faction == his_self.game.state.assault_attacker_faction) {
			      for (let z = 0; z < his_self.game.state.assault.attacker_units.length; z++) {
			        let u = his_self.game.state.assault.attacker_units[z];
			        if (u.type == cannon_fodder) {
			          if (!his_self.game.state.assault.attacker_units_destroyed.includes(z)) {
			            his_self.game.state.assault.attacker_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }
		            if (faction == his_self.game.state.assault_defender_faction) {
			      for (let z = 0; z < his_self.game.state.assault.defender_units.length; z++) {
			        let u = his_self.game.state.assault.defender_units[z];
			        if (u.type == cannon_fodder) {
			          if (!his_self.game.state.assault.defender_units_destroyed.includes(z)) {
			            his_self.game.state.assault.defender_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }

		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "mercenary"; }
                    if (zzz == 1) { cannon_fodder = "regular"; }
                    if (zzz == 2) { cannon_fodder = "cavalry"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {

			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
	  		his_self.game.state.assault.attacker_units_destroyed = [];
	  		his_self.game.state.assault.defender_units_destroyed = [];

                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }

	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {

	    if (faction == this.game.state.assault.attacker_faction) {
	      assign_hits(faction, this.game.state.assault.defender_hits);
	    } else {
	      assign_hits(faction, this.game.state.assault.attacker_hits);
	    }

            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.updateInstructions("Independent Hits Assigned");
	    his_self.assault_overlay.pullHudOverOverlay();

	    return 1;
	  }

	  //
	  // no hits assignment if no hits
	  //
	  //
	  if (faction == this.game.state.assault.attacker_faction) {
	    if (this.game.state.assault.defender_hits == 0) { return 1; }
	  } else {
	    if (this.game.state.assault.attacker_hits == 0) { return 1; }
	  }

	  //
	  // if we hit this point we need manual intervention to assign the hits.
	  // the attacker can assign hits however they prefer if others join them
	  // in the attack, but if two major powers share defense then the hits
	  // are divided evenly among them.
	  //
          let hits_to_assign = this.game.state.assault.attacker_hits;
	  if (faction == this.game.state.assault.attacker_faction) {
            hits_to_assign = this.game.state.assault.defender_hits;
	  }

          let defending_factions = [];
          let defending_factions_count = 0;
          let defending_major_powers = 0;
          let defending_factions_hits = [];
	  let major_power = false;
	  let multiple_major_powers = false;
	  let defender_units_capable_of_taking_hits = 0;
	  for (let f in this.game.state.assault.faction_map) {
	    if (this.game.state.assault.faction_map[f] == faction) {
	      defender_units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.assault.spacekey);
	      if (this.isMajorPower(f)) {
		if (major_power) { multiple_major_powers = true; }
	        defending_factions.push(f);
                defending_factions_hits.push(0);
		major_power = true;
		defending_major_powers++;
	      } else {
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
	    }
	  }

	  //
	  // no-one to take hits
	  //
	  if (defender_units_capable_of_taking_hits == 0) { return 1; }

	  //
	  // every gets shared hits
	  //
	  if (multiple_major_powers) {
  	    if (defending_factions_hits.length > 0) {
	      while (major_power == true && hits_to_assign > defending_factions_hits.length) {
	        for (let i = 0; i < defending_factions_hits.length; i++) { defending_factions_hits[i]++; }
	        hits_to_assign -= defending_factions_hits.length;
	      }
	    }

	    //
	    // randomly assign remainder
	    //
	    let already_punished = [];
	    if (defending_factions_hits.length > 0 && hits_to_assign > 0) {
	      for (let i = 0; i < hits_to_assign; i++) {
	        let unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	        while (already_punished.includes(unlucky_faction)) {
	          unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	        }
	        defending_factions_hits[unlucky_faction]++;
	        already_punished.push(unlucky_faction);
	      }
	      hits_to_assign = 0;
	    }

	    //
	    // defending major powers
	    //
	    for (let i = 0; i < defending_factions_hits.length; i++) {
  	      this.game.queue.push(`assault_manually_assign_hits\t${defending_factions[i]}\t${defending_factions_hits[i]}`);
	    }
	    return 1;
	  }

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.assignHits(his_self.game.state.assault, faction);
	  } else {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
	    his_self.updateStatus(this.returnFactionName(faction) + " Assigning Hits");
            his_self.assault_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;

	}

        //
        // variant of above when major powers have to split hits assignments
        //
	if (mv[0] === "field_battle_manually_assign_hits") {

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let player = this.returnPlayerOfFaction(faction);
	  let space = this.game.spaces[this.game.state.field_battle.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.assignHitsManually(his_self.game.state.field_battle, faction, hits);
	  } else {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;
        }

        //
        // variant of above when major powers have to split hits assignments
        //
	if (mv[0] === "assault_manually_assign_hits") {

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let player = this.returnPlayerOfFaction(faction);
	  let space = this.game.spaces[this.game.state.assault.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.assignHitsManually(his_self.game.state.assault, faction, hits);
	  } else {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;
        }

        if (mv[0] === "assault_show_hits_render") {
          this.game.queue.splice(qe, 1);
          this.assault_overlay.render(his_self.game.state.assault);
          this.assault_overlay.pullHudOverOverlay();
          return 1;
        }
          
	if (mv[0] === "assault_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.assault_overlay.render(his_self.game.state.assault);
          this.assault_overlay.pullHudOverOverlay();
	  return 1;
	}

	if (mv[0] === "naval_battle_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.naval_battle_overlay.render(his_self.game.state.naval_battle);
	  return 1;
	}

	if (mv[0] === "field_battle_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.field_battle_overlay.render(his_self.game.state.field_battle);
          this.field_battle_overlay.pullHudOverOverlay();
	  return 1;
	}


	if (mv[0] === "destroy_faction_units_in_spacekey") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = null;

          this.game.queue.splice(qe, 1);

	  try { if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; } } catch (err) {}
	  try { if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; } } catch (err) {}

	  let is_processed = false;

	  if (this.game.state.field_battle) {
	    if (this.game.state.field_battle.spacekey == spacekey) {
	      for (let f in this.game.state.field_battle.faction_map) {
	        if (this.game.state.field_battle.faction_map[f] == faction) {
	          is_processed = true;
		  for (let z = 0; z < space.units[f].length; z++) {
		    let u = space.units[f][z];
		    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
		      space.units[f].splice(z, 1);
		      z--;
		    }
		  }
		}
	      }
	    }
	  }
	  if (is_processed == false && this.game.state.assault) {
	    if (this.game.state.assault.spacekey == spacekey) {
	      for (let f in this.game.state.assault.faction_map) {
	        if (this.game.state.assault.faction_map[f] == faction) {
		  is_processed = true;
		  for (let z = 0; z < space.units[f].length; z++) {
		    let u = space.units[f][z];
		    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
		      space.units[f].splice(z, 1);
		      z--;
		    }
		  }
	        }
	      }
	    }
	  }

	  if (is_processed == false) {
	    for (let z = space.units[faction].length-1; z >= 0; z--) {
	      let u = space.units[faction][z];
	      if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
	        space.units[faction].splice(z, 1);
	      }
	    }
	  }

          this.refreshBoardUnits();
	  this.displaySpace(spacekey);

	  return 1;
	}




 	if (mv[0] === "siege_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

          this.game.queue.splice(qe, 1);

	  let space = this.game.spaces[spacekey];
	  let unit_destroyed = false;

	  for (let i = 0; i < space.units[faction].length && unit_destroyed == false; i++) {
	    if (space.units[faction][i].type == unit_type) {
	      if (this.game.state.assault.faction_map[faction] == this.game.state.assault.attacker_faction) {
		for (let z = 0; z < this.game.state.assault.attacker_units_units.length; z++) {
		  if (this.game.state.assault.attacker_units_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.assault.attacker_units_destroyed.includes(z)) {
		      this.game.state.assault.attacker_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      } else {
		for (let z = 0; z < this.game.state.assault.defender_units_units.length; z++) {
		  if (this.game.state.assault.defender_units_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.assault.defender_units_destroyed.includes(z)) {
		      this.game.state.assault.defender_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      }
	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	    }
	  }

	  return 1;

	}

 	if (mv[0] === "field_battle_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

          this.game.queue.splice(qe, 1);

	  let space = this.game.spaces[spacekey];
	  let unit_destroyed = false;

	  for (let i = 0; i < space.units[faction].length && unit_destroyed == false; i++) {
	    if (space.units[faction][i].type == unit_type) {
	      if (this.game.state.field_battle.faction_map[faction] == this.game.state.field_battle.attacker_faction) {
		for (let z = 0; z < this.game.state.field_battle.attacker_units.length; z++) {
		  if (this.game.state.field_battle.attacker_units[z] == space.units[faction][i].type) {
		    if (!this.game.state.field_battle.attacker_units_destroyed.includes(z)) {
		      this.game.state.field_battle.attacker_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      } else {
		for (let z = 0; z < this.game.state.field_battle.defender_units.length; z++) {
		  if (this.game.state.field_battle.defender_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.field_battle.defender_units_destroyed.includes(z)) {
		      this.game.state.field_battle.defender_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      }
	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	    }
	  }

	  return 1;

	}



 	if (mv[0] === "naval_battle_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

          this.game.queue.splice(qe, 1);

	  let space;
          if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
          if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }
	  let unit_destroyed = false;

	  for (let i = 0; i < space.units[faction].length && unit_destroyed == false; i++) {
	    if (space.units[faction][i].type == unit_type) {
	      if (this.game.state.naval_battle.faction_map[faction] == this.game.state.naval_battle.attacker_faction) {
		for (let z = 0; z < this.game.state.naval_battle.attacker_units.length; z++) {
		  if (this.game.state.naval_battle.attacker_units[z] == space.units[faction][i].type) {
		    if (!this.game.state.naval_battle.attacker_units_destroyed.includes(z)) {
		      this.game.state.naval_battle.attacker_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      } else {
		for (let z = 0; z < this.game.state.naval_battle.defender_units.length; z++) {
		  if (this.game.state.naval_battle.defender_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.naval_battle.defender_units_destroyed.includes(z)) {
		      this.game.state.naval_battle.defender_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      }
	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	    }
	  }

	  return 1;

	}


	if (mv[0] === "foreign-war-cleanup") {

          this.game.state.foreign_wars_fought_this_impulse.push(spacekey);

          this.game.queue.splice(qe, 1);
	  let faction = "ottoman";
	  let spacekey = mv[1];
	  if (spacekey == "ireland") { faction = "england"; }

	  //
	  // no need for cleanup unless battle is over
	  //
	  if (!this.doesSpaceHaveNonFactionUnits(spacekey, faction)) {

	    if (spacekey == "ireland") { this.updateLog("Revolt in Ireland finishes, English forces return to London"); }
	    if (spacekey == "persia") { this.updateLog("War in Persia finishes, Turkish forces return to Istanbul"); }
	    if (spacekey == "egypt") { this.updateLog("Revolt in Egypt finishes, Turkish forces return to Istanbul"); }

	    //
	    // move all soldiers back to capital (if controlled)
	    //
	    let s = this.game.spaces[spacekey];
	    if (faction == "england") {
	      for (let i = 0; i < s.units[faction].length; i++) {
	        this.game.spaces["london"].units["england"].push(s.units[faction][i]);
	      }
	      s.units[faction] = [];
	    }

	    if (faction == "ottoman") {
	      for (let i = 0; i < s.units[faction].length; i++) {
	        this.game.spaces["istanbul"].units["ottoman"].push(s.units[faction][i]);
	      }
	      s.units[faction] = [];
	    }

	    //
	    // remove -1 war effect
	    //
	    if (spacekey == "ireland") {
	      this.game.state.england_war_winner_vp++;
              this.game.state.events.revolt_in_ireland = 0;
              this.hideIreland();
	    }
	    if (spacekey == "persia") {
	      this.game.state.ottoman_war_winner_vp++;
              this.game.state.events.war_in_persia = 0;
              this.hidePersia();
	    }
	    if (spacekey == "egypt") {
	      this.game.state.ottoman_war_winner_vp++;
              this.game.state.events.revolt_in_egypt = 0;
              this.hideEgypt();
	    }
	  }

	  return 1;

	}

	if (mv[0] === "field_battle_continue") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space = this.game.spaces[mv[1]];

	  //
	  // foreign wars handle their own post-battle clean-up
	  //
	  if (mv[1] == "persia" || mv[1] == "ireland" || mv[1] == "egypt") {
	    his_self.game.queue.push("foreign-war-cleanup\t"+mv[1]);
	    return 1;
	  }

	  //
	  // hits assignment happens here
	  //
	  his_self.updateLog("Attacker Modified: " + JSON.stringify(his_self.game.state.field_battle.attacker_modified_rolls));
	  his_self.updateLog("Defender Modified: " + JSON.stringify(his_self.game.state.field_battle.defender_modified_rolls));
	  his_self.updateLog("Attacker Hits: " + his_self.game.state.field_battle.attacker_hits);
	  his_self.updateLog("Defender Hits: " + his_self.game.state.field_battle.defender_hits);

	  this.field_battle_overlay.renderFieldBattle(this.game.state.field_battle);

	  //
	  // who won ?
	  //
	  let winner = his_self.game.state.field_battle.defender_faction;
	  if (his_self.game.state.field_battle.attacker_hits > his_self.game.state.field_battle.defender_hits) {
	    winner = his_self.game.state.field_battle.attacker_faction;
	  }

	  //
	  // calculate units remaining
	  //
          his_self.game.state.field_battle.attacker_land_units_remaining = his_self.game.state.field_battle.attacker_units.length - his_self.game.state.field_battle.defender_hits;
	  let du = 0;
	  for (let i = 0; i < his_self.game.state.field_battle.defender_units.length; i++) {
	    if (his_self.game.state.field_battle.defender_units[i] != "defender") { du++; }
	  }
	  his_self.game.state.field_battle.defender_land_units_remaining = du - his_self.game.state.field_battle.attacker_hits;

	  if (his_self.game.state.field_battle.attacker_land_units_remaining == 0 && his_self.game.state.field_battle.defender_land_units_remaining == 0) {
	    if (his_self.game.state.field_battle.attacker_rolls > his_self.game.state.field_battle.defender_rolls) {
	      his_self.updateLog("Attacker adds 1 regular");
	      his_self.addRegular(his_self.game.state.field_battle.attacker_faction, space);
	    } else {
	      his_self.updateLog("Defender adds 1 regular");
	      his_self.addRegular(his_self.game.state.field_battle.defender_faction, space);
	    }
	  }


	  //
	  // capture stranded leaders
	  //
	  if (his_self.game.state.field_battle.attacker_land_units_remaining == 0) {
	    for (let f in his_self.game.state.field_battle.faction_map) {
	      if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(his_self.game.state.field_battle.defender_faction, his_self.game.state.field_battle.attacker_faction, mv[1], space.units[f][i]);
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }
	  if (his_self.game.state.field_battle.defender_land_units_remaining == 0) {
	    for (let f in his_self.game.state.field_battle.faction_map) {
	      if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(his_self.game.state.field_battle.attacker_faction, his_self.game.state.field_battle.defender_faction, mv[1], space.units[f][i]);
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }


	  //
	  // sack of rome exits
	  //
	  if (this.game.state.events.sack_of_rome == 1) {
	    return 1;
	  }

	  //
	  // unexpected war -- everyone retreats or gets destroyed
	  //
	  if (his_self.game.state.events.unexpected_war == 1) {
            for (let f in his_self.game.state.field_battle.faction_map) {
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	        this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
              }
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
              }
	    }
            this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
            this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	    this.displaySpace(space.key);
	    return 1;
	  }


          //
          // conduct retreats
          //
          if (winner === his_self.game.state.field_battle.defender_faction) {

	    this.game.queue.push("show_overlay\tfield_battle\tpost_field_battle_defenders_win");

	    //
	    // do any attacking units remain
	    //
	    let do_any_attacker_units_remain = false;
	    for (let f in his_self.game.state.field_battle.faction_map) {
	      if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
		if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) { do_any_attacker_units_remain = true; break; }
	      }
	    }

            //
            // if the space is besieged and the attacker controls it, this was a field battle triggered by the 
	    // defender putting it under siege earlier, in which case we want to permit the attacker to re-fortify
	    // IF there are any attacker units that survived...
	    //
            if (this.isSpaceControlled(space.key, his_self.game.state.field_battle.attacker_faction) && space.besieged > 0 && his_self.game.state.active_faction == his_self.game.state.attacker_faction) {
	      // attacker and defender oddly reversed
	      if (do_any_attacker_units_remain) {
                this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
                this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.defender_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.attacker_faction)+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	      }

            } else {

              for (let f in his_self.game.state.field_battle.faction_map) {
                let can_faction_retreat = 0;
                if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
		  if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) {
                    for (let z = 0; z < space.neighbours.length; z++) {
		      //
		      // attacker must retreat into space it entered from -- if controlled by ally
		      //
		      if (space.neighbours[z] == this.game.state.attacker_comes_from_this_spacekey) {
		        let fac = this.returnFactionControllingSpace(space.neighbours[z]);
		        if (fac == f || this.areAllies(fac, f)) { can_faction_retreat = 1; }
		      }
                    }
                    if (can_faction_retreat == 1) {
                      this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	  	      if (his_self.game.state.field_battle.attacker_land_units_remaining > 0) {
                        this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+f+"\t"+space.key);
                      }
                    }
	            if (can_faction_retreat == 0) {
                      this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	            }
		  } else {
                    this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
		  }
                }
	      }
	      if (this.isSpaceControlled(space.key, his_self.game.state.field_battle.attacker_faction)) {
		// attacker here means "not me", since "I'm fortifying"
                this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.defender_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.attacker_faction)+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	      }
	    }
          }

          if (winner == his_self.game.state.field_battle.attacker_faction) {

            for (let f in his_self.game.state.field_battle.faction_map) {
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
                this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	      }
	    }

	    this.game.queue.push("show_overlay\tfield_battle\tpost_field_battle_attackers_win");

            for (let f in his_self.game.state.field_battle.faction_map) {
              let can_faction_retreat = 0;
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) {
                  for (let z = 0; z < space.neighbours.length; z++) {
                    let fluis = this.canFactionRetreatToSpace(f, space.neighbours[z], his_self.game.state.attacker_comes_from_this_spacekey);
                    if (fluis > 0) {
                      can_faction_retreat = 1;
                    }
                  }
                  if (can_faction_retreat == 1) {
                    this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		    if (his_self.game.state.field_battle.defender_land_units_remaining > 0) {
		      this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+f+"\t"+space.key);
                    }
                  }
		  if (space.units[f].length > 0) {
		    if (his_self.isSpaceControlled(space.key, his_self.game.state.field_battle.defender_faction)) {
                      this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.attacker_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.defender_faction)+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	            }
	          }
	        } else {
		  // no retreat possible
                  this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		}
              }
            }

        
            //
            // if the space is besieged and is friendly to the attacker, un-besiege defenders
            // 
            if (this.isSpaceFriendly(his_self.game.state.field_battle.spacekey, his_self.game.state.field_battle.attacker_faction) && space.besieged > 0) {
              space.besieged = 0;
              for (let key in space.units) {
                for (let ii = 0; ii < space.units[key].length; ii++) {
                  space.units[key][ii].besieged = 0;
                }
              }
            }

	    //
	    // if the space does not belong to the attacker and is a key, we put it under seige
	    //
	    if (!this.isSpaceFriendly(his_self.game.state.field_battle.spacekey, his_self.game.state.field_battle.attacker_faction) && space.besieged == 0 && (space.type == "key" || space.type == "electorate" || space.type == "fortress")) {
	      this.game.queue.push("besiege_space\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	    }


	    let defender_player = this.returnPlayerCommandingFaction(his_self.game.state.field_battle.defender_faction);
	    let attacker_player = this.returnPlayerCommandingFaction(his_self.game.state.field_battle.attacker_faction);

	    //
	    // if the defender is the active player AND controls the space, they can fortify
	    //
	    if (defender_player == this.game.state.active_player && this.isSpaceControlled(his_self.game.state.field_battle.spacekey, his_self.game.state.field_battle.defender_faction)) {
              this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.attacker_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.defender_faction)+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	    // otherwise they need to retreat
	    } else {
              for (let f in his_self.game.state.field_battle.faction_map) {
                let can_faction_retreat = 0;
                if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
                  for (let z = 0; z < space.neighbours.length; z++) {
                    let fluis = this.canFactionRetreatToSpace(f, space.neighbours[z], "");
                    if (fluis > 0) {
                      can_faction_retreat = 1;
                    }
                  }
                  if (can_faction_retreat == 1) {
                    this.game.queue.push("purge_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		    if (his_self.game.state.field_battle.defender_land_units_remaining > 0) {
                      this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+f+"\t"+space.key);
                    }
                  }
	          if (can_faction_retreat == 0) {
                    this.game.queue.push("purge_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	          }
                }
              }
	    }
          }


          //
          // redisplay
          //
          his_self.displaySpace(space.key);

	  //
	  // show field battle overlay
	  //
          his_self.field_battle_overlay.renderPostFieldBattle(his_self.game.state.field_battle);
          his_self.field_battle_overlay.pullHudOverOverlay();

	  //
	  // reset
	  //
	  his_self.game.state.field_battle.relief_force = 0;

          return 1;

        }


	if (mv[0] === "besiege_space") {

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[spacekey];

	  if (space) {
	    if (space.besieged == 0) {
              space.besieged = 2;
              for (let key in space.units) {
	        if (!this.areAllies(key, attacker)) {
                  for (let ii = 0; ii < space.units[key].length; ii++) {
                    space.units[key][ii].besieged = 1;
                  }
                }
              }
            }
          }

          this.game.queue.splice(qe, 1);
	  return 1;
	}


 	if (mv[0] === "destroy_unit_by_type") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

	  if (this.game.spaces[spacekey]) {
	    for (let i = 0; i < this.game.spaces[spacekey].units[faction].length; i++) {
	      if (this.game.spaces[spacekey].units[faction][i].type == unit_type) {
	        this.game.spaces[spacekey].units[faction].splice(i, 1);
		i = this.game.spaces[spacekey].units[faction].length + 10;
		break;
	      }
	    }
	  }
	  if (this.game.navalspaces[spacekey]) {
	    for (let i = 0; i < this.game.navalspaces[spacekey].units[faction].length; i++) {
	      if (this.game.navalspaces[spacekey].units[faction][i].type == unit_type) {
	        this.game.navalspaces[spacekey].units[faction].splice(i, 1);
		i = this.game.navalspaces[spacekey].units[faction].length + 10;
		break;
	      }
	    }
	  }

	  this.updateLog(this.returnFactionName(faction) + " " + unit_type + " destroyed in " + this.returnSpaceName(spacekey));
	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);
          this.game.queue.splice(qe, 1);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();

	  return 1;

        }
 	if (mv[0] === "destroy_unit_by_index") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_idx = parseInt(mv[3]);

	  if (this.game.spaces[spacekey]) {
	    this.game.spaces[spacekey].units[faction].splice(unit_idx, 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();


          this.game.queue.splice(qe, 1);
	  return 1;

	}

 	if (mv[0] === "destroy_units") {

          this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let units_to_destroy = JSON.parse(mv[3]);

	  let space;

	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }

	  units_to_destroy.sort();
	  if (units_to_destroy[0] < units_to_destroy[units_to_destroy.length-1]) {
	    units_to_destroy.reverse();
	  }

	  //
	  // remove from max to minimum to avoid index-out-of-array errors
	  //
	  for (let i = 0; i < units_to_destroy.length; i++) {
	    space.units[faction].splice(i, 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displayBoard();

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();


	  return 1;

	}



	if (mv[0] === "piracy") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;

	  let faction = mv[1];
	  let target_navalspace = mv[2];
	  let target_port = mv[3];
	  let target_faction = "";


	  let anti_piracy_rolls = [];
	  let anti_piracy_faction = [];
	  let anti_piracy_unittype = [];
	  let piracy_rolls = [];
	  let piracy_faction = [];
	  let piracy_unittype = [];

	  let dragut = false;
      	  let barbarossa = false;

          this.game.state.events.ottoman_piracy_seazones.push(target_navalspace);
	  this.showPiracyMarker(target_navalspace);

      	  let target_space = this.game.navalspaces[target_navalspace];
      	  let adjacent_spaces = [];
	  let ports = [];

 	  let io = this.returnImpulseOrder();
 	  let factions_at_war_with_ottoman = his_self.returnEnemies("ottoman", true); // true = include minor powers

    	  for (let i = 0; i < target_space.neighbours.length; i++) {
    	    adjacent_spaces.push(his_self.game.navalspaces[target_space.neighbours[i]]);
    	  } 
    	  for (let i = 0; i < target_space.ports.length; i++) {
    	    adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
    	  } 

          ports = target_space.ports;
    	  for (let i = 0; i < target_space.units[faction].length; i++) {
    	    if (target_space.units[faction][i].type == "dragut") { dragut = true; }
    	    if (target_space.units[faction][i].type == "barbarossa") { barbarossa = true; }
    	  } 
          
          target_faction = this.game.spaces[target_port].political;
          if (target_faction == "") { target_faction = this.game.spaces[target_port].home; }
          if (!factions_at_war_with_ottoman.includes(target_faction)) { factions_at_war_with_ottoman.push(target_faction); }
          let opponent_dice = 0;


          //
          // targetted player dice
          // 2 dice per naval squadron in sea zone
          //
          for (let z = 0; z < target_space.units[target_faction].length; z++) {
            if (target_space.units[target_faction][z].type == "squadron") {
	      opponent_dice += 2;
	      anti_piracy_faction.push(target_faction);
	      anti_piracy_unittype.push("squadron");
	      anti_piracy_faction.push(target_faction);
	      anti_piracy_unittype.push("squadron");
	    }
          }

          //
          // 1 dice for their own or at-war-with-ottoman power (incl. minor) in port or adjacent sea-zone
          //
          for (let i = 0; i < adjacent_spaces.length; i++) {
            for (let k = 0; k < factions_at_war_with_ottoman.length; k++) {
              for (let z = 0; z < adjacent_spaces[i].units[factions_at_war_with_ottoman[k]].length; z++) {
                let u = adjacent_spaces[i].units[factions_at_war_with_ottoman[k]][z];
                if (u.type == "squadron") {
                  opponent_dice++;
	          anti_piracy_faction.push(factions_at_war_with_ottoman[k]);
	          anti_piracy_unittype.push("squadron");
                }
              }
            }
          }

          //
          // 1 dice for each fortres controlled by target, power at war, or St. John -- fortress adjacent
          //
          if (target_space.key == "atlantic" || target_space.key == "barbary") {
            let x = his_self.returnFactionControllingSpace("gibraltar");
            if (factions_at_war_with_ottoman.includes(x)) { 
	      anti_piracy_faction.push("gibraltar");
	      anti_piracy_unittype.push("fortress");
	      opponent_dice++;
	    }
          }
          if (target_space.key == "africa" || target_space.key == "ionian") {
            let x = his_self.returnFactionControllingSpace("malta");
            if (factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("malta");
	      anti_piracy_unittype.push("fortress");
	      opponent_dice++;
            }
          }
          if (target_space.key == "africa" || target_space.key == "aegean") {
            let x = his_self.returnFactionControllingSpace("corfu");
            if (factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("corfu");
	      anti_piracy_unittype.push("fortress");
	      opponent_dice++;
	    }
          }
          if (target_space.key == "adriatic" || target_space.key == "ionian") {
            let x = his_self.returnFactionControllingSpace("candia");
            if (factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("candia");
	      anti_piracy_unittype.push("fortress");
	      opponent_dice++;
	    }
          }
          if (his_self.game.state.knights_of_st_john != "") {
            let indspace = his_self.game.spaces[his_self.game.state.knights_of_st_john];
            if (indspace.unrest == 0 && indspace.besieged == 0) {
              for (let b = 0; b < indspace.ports.length; b++) {
                if (indspace.ports[b] == target_space.key) {
	          anti_piracy_faction.push(indspace.ports[b]);
	          anti_piracy_unittype.push("fortress");
                  opponent_dice++;
                }
              }
            }
          }

	  his_self.updateLog("Anti-Piracy Dice: " + opponent_dice);

          //
          // eliminate 1 corsair for each hit of 5 or 6
          //
          let hits = 0;
          for (let i = 0; i < opponent_dice; i++) {
	    let x = his_self.rollDice(6);
	    anti_piracy_rolls.push(x);
	    if (x >= 5) { hits++; }
          }

	  his_self.updateLog("Anti-Piracy Dice: " + opponent_dice);
	  his_self.updateLog("Anti-Piracy Rolls: " + JSON.stringify(anti_piracy_rolls));

	  if (hits > 0) {
	    for (let z = 0; hits > 0 && z < target_space.units["ottoman"].length; z++) {
	      let u = target_space.units["ottoman"][z];
	      if (u.type == "corsair") {
		target_space.units["ottoman"].splice(z, 1);
	        hits--;
		z--;
	      }
	    }
	  }

	  //
	  // how many corsairs left
	  //
	  let corsairs_remaining = 0;
	  for (let z = 0; z < target_space.units["ottoman"].length; z++) {
	    if (target_space.units["ottoman"][z].type == "corsair") {
	      corsairs_remaining++;
	    }
	  }

	  //
	  // how many target ports
	  //
	  let targetted_ports = 0;
	  for (let z = 0; z < target_space.ports.length; z++) {
	    if (his_self.returnFactionControllingSpace(target_space.ports[z]) == target_faction) {
	      targetted_ports++;
	    }
	  }


	  let piracy_dice = 0;

	  if (corsairs_remaining > 0) {
	    if (targetted_ports == 1) {
	      piracy_dice = 1;
	      piracy_unittype.push("corsairs");
	      piracy_faction.push("targetting single port");
	    } else {
	      if (corsairs_remaining == 1) {
	 	piracy_dice = 1;
	        piracy_unittype.push("corsairs");
	        piracy_faction.push("targeting multiple ports");
	      } else {
	 	if (corsairs_remaining > 1) {
		  piracy_dice = 2;
	          piracy_unittype.push("corsairs");
	          piracy_unittype.push("corsairs");
	          piracy_faction.push("targetting multiple ports");
	          piracy_faction.push("targetting multiple ports");
		}
	      }
	    }
	  }

	  if (piracy_dice == 0) {
	    his_self.updateLog("No corsairs remaining - piracy cancelled");
	    return 1;
	  }

	  if (barbarossa) {
	    piracy_dice += 1;
	    piracy_unittype.push("barbarossa");
	    piracy_faction.push("pirate leader");
	  }
	  if (dragut) {
	    piracy_dice += 2;
	    piracy_unittype.push("dragut");
	    piracy_faction.push("pirate leader");
	    piracy_unittype.push("dragut");
	    piracy_faction.push("pirate leader");
	  }

	  his_self.updateLog("Piracy dice: " + piracy_dice);

	  let piracy_hits = 0;
	  piracy_rolls = [];
	  for (let i = 0; i < piracy_dice; i++) {
	    let x = his_self.rollDice(6);
	    piracy_rolls.push(x);
	    if (x >= 5) { piracy_hits++; }
	  }

	  his_self.updateLog("Piracy rolls: " + JSON.stringify(piracy_rolls));



	  //
	  // create piracy object foroverlay
	  //
	  let pobj = {
	    anti_piracy_rolls : anti_piracy_rolls,
	    anti_piracy_faction : anti_piracy_faction,
	    anti_piracy_unittype : anti_piracy_unittype,
	    piracy_rolls : piracy_rolls,
	    piracy_faction : piracy_faction,
	    piracy_unittype : piracy_unittype,
	  };


	  this.piracy_overlay.render(pobj);

	  if (piracy_hits > 0) {
            if (his_self.game.state.events.julia_gonzaga_activated == 1 && target_navalspace == "tyrrhenian") {
              his_self.game.queue.push("SETVAR\tstate\tevents\tottoman_julia_gonzaga_vp\t1");
	    }
	    his_self.game.queue.push("piracy_hits\t"+target_faction+"\t"+piracy_hits+"\t"+target_port+"\t"+target_navalspace);
	  }

	  return 1;

	}



	// Machiavelli, Defeat of Hungary a
	// Three Event cards (Schmalkaldic League, Machiavelli: “The Prince”, and Six Wives of Henry VIII) create a state of war 
	// during the Action Phase. The Ottoman defeat of Hungary may trigger a state of war with the Hapsburg during the Action 
	// Phase (Section 22.5). Finally, the activation of a minor power can create a state of war between major powers 
	// (Section 22.2). Add an appropriate marker to the Diplomatic Status Display when any of these five events occurs.
	// If naval units of the two powers now at war occupy the same sea zone, fight an immediate naval battle between the 
	// two powers. If the number of hits is equal, both sides must retreat (an exception to the usual naval combat rule)
	//
	if (mv[0] === "unexpected_war") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction1 = mv[1];
	  let faction2 = mv[2];

          his_self.game.queue.push("SETVAR\tstate\tevents\tunexpected_war\t0");

	  for (let key in his_self.game.navalspaces) {
	    let faction1_present = 0;
	    let faction2_present = 0;
	    let space = his_self.game.navalspaces[key];
	    for (let f in space.units) {
	      if (space.units[f].length > 0) {
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction1)) {
		  faction1_present = 1;
	        }
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction2)) {
		  faction2_present = 1;
	        }
	      }
	    }
	    if (faction1_present == 1 && faction2_present == 1) {
              his_self.game.queue.push("naval_battle\t"+key+"\t"+faction1);
	    }
	  }

	  for (let key in his_self.game.spaces) {
	    let faction1_present = 0;
	    let faction2_present = 0;
	    let space = his_self.game.spaces[key];
	    for (let f in space.units) {
	      if (space.units[f].length > 0) {
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction1)) {
		  faction1_present = 1;
	        }
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction2)) {
		  faction2_present = 1;
	        }
	      }
	    }
	    if (faction1_present == 1 && faction2_present == 1) {
	      if (!his_self.isSpaceBesieged(key)) {
		// attacker will be one that does not control the space
		let fac = his_self.returnFactionControllingSpace(key);
		if (his_self.areAllies(fac, faction1)) {
                  his_self.game.queue.push("field_battle\t"+key+"\t"+faction2);
		} else {
                  his_self.game.queue.push("field_battle\t"+key+"\t"+faction1);
		}
	      }
	    }
	  }

          his_self.game.queue.push("SETVAR\tstate\tevents\tunexpected_war\t1");
	  return 1;

	}


	if (mv[0] === "piracy_hits") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let target_port = mv[3];
	  let target_navalspace = mv[4];
	  let hits_given = 0;
          let squadron_count = 0;
          let card_count = 0;
	  let vp_count = 0;

	  let squadrons_offered = 0;
	  let cards_offered = 0;
	  let vp_offered = 0;

	  let options = ["eliminate","card","vp"];
	  let issued = [];

	  //
	  // cannot choose an option with no benefits, and must choose all possible
	  // options before giving one a second time. in order to know how many times
	  // we can issue a card or sacrifice a squadron, we need to know how many
	  // of those exist.
	  //
	  // first count squadrons that can be removed
	  //
          let target_space = this.game.spaces[target_port];
          target_navalspace = this.game.navalspaces[target_navalspace];
          let adjacent_spaces = [];

          for (let i = 0; i < target_navalspace.ports.length; i++) {
            adjacent_spaces.push(target_navalspace.ports[i]);
          }
	  adjacent_spaces.push(mv[4]);
          for (let i = 0; i < target_navalspace.neighbours.length; i++) {
            adjacent_spaces.push(target_navalspace.neighbours[i]);
          }
          for (let p = 0; p < adjacent_spaces.length; p++) {
	    let ts = adjacent_spaces[p];
	    let s = null;
	    if (this.game.spaces[ts]) { s = this.game.spaces[ts]; }
	    if (this.game.navalspaces[ts]) { s = this.game.navalspaces[ts]; }

            for (let key in s.units) {
	      if (this.returnControllingPower(key) == faction) {
	        for (let i = 0; i < s.units[key].length; i++) {
		  if (s.units[key][i].type == "squadron") {
		    squadron_count++;
		  }
		}
	      }
	    }
	  }

          //let squadron_count = 0;
          //let card_count = 0;
	  //let vp_count = 0;
	  //let squadrons_offered = 0;
	  //let cards_offered = 0;
	  //let vp_offered = 0;

	  let total_vp_issuable = 10 - this.game.state.events.ottoman_piracy_vp;
	  let total_cards_issuable = 0;
	  let total_squadrons_issuable = squadron_count;

	  let vp_issuable = true;
	  let cards_issuable = true;
	  let squadrons_issuable = true;

	  if (total_vp_issuable == 0) { vp_issuable = false; }
	  if (total_cards_issuable == 0) { cards_issuable = false; }
	  if (total_squadrons_issuable == 0) { squadrons_issuable = false; }

	  let selectPiracyRewards = function(selectPiracyRewards) {

            let msg = `Offer the Ottoman Empire which Reward (${(hits_given+1)} of ${hits})? `;
            let html = '<ul>';

	    if (total_vp_issuable > vp_count) {
	      if (!(vp_count > card_count && cards_issuable == true) && !(vp_count > squadron_count && squadrons_issuable == true)) {
                html += `<li class="option" id="vp">give vp</li>`;
	      }	
	    }	
	    if (total_cards_issuable > card_count) {
	      if (!(card_count > vp_count && vp_issuable == true) && !(card_count > squadron_count && squadrons_issuable == true)) {
                html += `<li class="option" id="card">give card draw</li>`;
	      }	
	    }	
	    if (total_squadrons_issuable > squadron_count) {
	      if (!(squadron_count > card_count && cards_issuable == true) && (squadron_count > vp_count && vp_issuable == true)) {
                html += `<li class="option" id="squadron">destroy squadron</li>`;
	      }	
	    }	
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);
            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
              $('.option').off();
	      hits_given++;

	      if (action == "vp") {
		vp_count++;
		his_self.addMove("piracy_reward_vp");
	      }
	      if (action == "card") {
		card_count++;
		his_self.addMove("piracy_reward_card\t"+faction);
	      }
	      if (action == "squadron") {
		his_self.addMove("piracy_reward_squadron\t"+faction+"\t"+mv[4]);
		squadron_count++;
	      }

	      if (hits_given < hits) {
	        selectPiracyRewards(selectPiracyRewards);
	      } else {
                his_self.updateStatus("acknowledge...");
	        his_self.endTurn();
	      }
	    });
          }

          if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

            let fhand_idx = this.returnFactionHandIdx(his_self.game.player, faction);
	    let card_count = this.game.deck[0].fhand[fhand_idx].length;
	    if (faction == "hapsburg" && !this.game.deck[0].discards['002']) { card_count--; }
	    if (faction == "england" && !this.game.deck[0].discards['003']) { card_count--; }
	    if (faction == "france" && !this.game.deck[0].discards['004']) { card_count--; }
	    if (faction == "papacy" && !this.game.deck[0].discards['005']) { card_count--; }
	    if (faction == "papacy" && !this.game.deck[0].discards['006']) { card_count--; }
	    if (faction == "protestant" && !this.game.deck[0].discards['007']) { card_count--; }
	    total_cards_issuable = card_count;
	    if (total_cards_issuable > 0) { cards_issuable = true; }

            selectPiracyRewards(selectPiracyRewards);

          } else {
            his_self.updateStatus(his_self.returnFactionName(faction) + " issuing Piracy Rewards");
          }

	  return 0;

	}

	if (mv[0] === "piracy_reward_vp") {
          this.game.queue.splice(qe, 1);
	  this.game.state.events.ottoman_piracy_vp++;
	  his_self.updateLog("Ottoman Empire earns VP from Piracy");
	  return 1;
	}

	if (mv[0] === "piracy_reward_card") {
          this.game.queue.splice(qe, 1);
	  this.game.queue.push("pull_card\tottoman\t"+mv[1]);
	  his_self.updateLog("Ottoman Empire earns Bonus Card from Piracy");
	  return 1;
	}

	if (mv[0] === "piracy_reward_squadron") {
          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let target_navalspace = mv[2];
	  let squadron_rich_targets = [];
          let target_space = this.game.navalspaces[target_navalspace];
          let adjacent_spaces = [];
          for (let i = 0; i < target_space.ports.length; i++) {
            adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
          }
	  adjacent_spaces.push(target_navalspace);
          for (let i = 0; i < target_space.neighbours.length; i++) {
            adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
          }
          for (let p = 0; p < adjacent_spaces.length; p++) {
	    let ts = adjacent_spaces[p];
	    let s = null;
	    if (this.game.spaces[ts]) { s = this.game.spaces[ts]; }
	    if (this.game.navalspaces[ts]) { s = this.game.navalspaces[ts]; }
            for (let key in s.units) {
	      if (this.returnControllingPower(key) == faction) {
	        for (let i = 0; i < s.units[key].length; i++) {
		  if (s.units[key][i].type == "squadron") {
		    if (!squadron_rich_targets.includes(key)) {
		      squadron_rich_targets.push(key);
		    }
		  }
		}
	      }
	    }
	  }

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            let msg = "Destroy Squadron: ";
            let html = '<ul>';
	    for (let i = 0; i < squadron_rich_targets.length; i++) {
	      html += `<div class="option" id="${squadron_rich_targets[i]}">${his_self.returnPlaceName(squadron_rich_targets[i])}</div>`;
	    }
	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);
            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
              $('.option').off();

	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " destroys squadron in " + his_self.returnSpaceName(action));
	      his_self.addMove("destroy_unit_by_type\t"+faction+"\t"+action+"\t"+"squadron");
	      his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " destroying squadron...");
	  }

	  return 0;

	}


 	if (mv[0] === "destroy_naval_units") {
          this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let units_to_destroy = JSON.parse(mv[3]);

	  let space;

	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

	  units_to_destroy.sort();
	  if (units_to_destroy[0] < units_to_destroy[units_to_destroy.length-1]) {
	    units_to_destroy.reverse();
	  }

	  //
	  // remove from max to minimum to avoid index-out-of-array errors
	  //
	  for (let i = 0; i < units_to_destroy.length; i++) {
	    space.units[faction].splice(i, 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displayBoard();

	  return 1;

	}


	if (mv[0] === "naval_battle_continue") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space;
	  if (this.game.spaces[mv[1]]) {
	    space = this.game.spaces[mv[1]];
	  }
	  if (this.game.navalspaces[mv[1]]) {
	    space = this.game.navalspaces[mv[1]];
	  }

	  //
	  // calculate hits
	  //
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }
          let calculate_hits = function(player, roll_array) {
            let hits = 0;
            for (let i = 0; i < roll_array.length; i++) {
              if (roll_array[i] >= 5) {
                hits++;
              }
            }
            return hits;
          }
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionSeaUnitsInSpace(f, space);
	      }
	    }

	    //
	    //
	    //
	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }


	    while (are_hits_all_assigned == 0 && hits_to_assign > 1) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 1) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 2; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "corsair"; }
		        if (zzz == 1) { cannon_fodder = "squadron"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {
		  	    space.units[f].splice(i, 1);
			    hits_to_assign -= 2;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 1) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 2; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "corsair"; }
                    if (zzz == 1) { cannon_fodder = "squadron"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {
			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " sunk");
                        space.units[selected_faction].splice(ii, 1);
                        hits_to_assign -= 2;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction sea units next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }

	  }

	  let faction_map       = his_self.game.state.naval_battle.faction_map;
	  let attacker_faction  = his_self.game.state.naval_battle.attacker_faction;
	  let defender_faction  = his_self.game.state.naval_battle.defender_faction;
          let attacker_player   = his_self.returnPlayerOfFaction(attacker_faction);
          let defender_player   = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_results  = his_self.game.state.naval_battle.attacker_results;
	  let defender_results  = his_self.game.state.naval_battle.defender_results;
	  let attacker_rolls    = his_self.game.state.naval_battle.attacker_rolls;
	  let defender_rolls    = his_self.game.state.naval_battle.defender_rolls;
	  let attacker_units    = his_self.game.state.naval_battle.attacker_units;
	  let defender_units    = his_self.game.state.naval_battle.defender_units;
	  let is_battle_in_port = his_self.game.state.naval_battle.is_battle_in_port;

	  let winner	        = defender_faction;
	  let attacker_hits     = 0;
	  let defender_hits     = 0;

	  //
	  // assign hits simultaneously
	  //
	  if (attacker_player > 0) {
	    let ap = his_self.game.state.players_info[attacker_player-1];
	    his_self.game.state.naval_battle.attacker_modified_rolls = modify_rolls(ap, attacker_results);
	  }

	  if (defender_player > 0) {
	    let dp = his_self.game.state.players_info[defender_player-1];
	    his_self.game.state.naval_battle.defender_modified_rolls = modify_rolls(dp, defender_results);
	  }

	  attacker_hits = calculate_hits(attacker_player, attacker_results);
	  defender_hits = calculate_hits(defender_player, defender_results);

	  if (attacker_player == 0) {
	    assign_hits(attacker_faction, defender_hits);
          }
	  if (defender_player == 0) {
	    assign_hits(defender_faction, attacker_hits);
          }

	  his_self.game.state.naval_battle.attacker_hits = attacker_hits;
	  his_self.game.state.naval_battle.defender_hits = defender_hits;

	  //
	  // who won?
	  //
	  if (attacker_hits > defender_hits) {
	    winner = attacker_faction;
	  }

	  his_self.updateLog("Winner: " + winner);
	  his_self.updateLog("Attacker Hits: " + attacker_hits);
	  his_self.updateLog("Defender Hits: " + defender_hits);
	  his_self.updateLog("Attacker Modified: " + JSON.stringify(his_self.game.state.naval_battle.attacker_modified_rolls));
	  his_self.updateLog("Defender Modified: " + JSON.stringify(his_self.game.state.naval_battle.defender_modified_rolls));


	  //
	  // calculate units remaining
	  //
	  let attacker_sea_units_remaining = 0;
	  let defender_sea_units_remaining = 0;
	  for (let z = 0; z < space.units[attacker_faction].length; z++) {
	    let u = space.units[attacker_faction][z];
   	    if (u.type == "squadron" || u.type == "corsair") {
	      attacker_sea_units_remaining++;
	    }
	  }
	  for (let z = 0; z < space.units[defender_faction].length; z++) {
	    let u = space.units[defender_faction][z];
   	    if (u.type == "squadron" || u.type == "corsair") {
	      defender_sea_units_remaining++;
	    }
	  }

          his_self.game.state.naval_battle.attacker_sea_units_remaining = attacker_sea_units_remaining;
          his_self.game.state.naval_battle.defender_sea_units_remaining = defender_sea_units_remaining;

	  if (attacker_sea_units_remaining <= 0 && defender_sea_units_remaining <= 0) {
	    if (attacker_rolls > defender_rolls) {
	      his_self.updateLog("Attacker adds 1 squadron");
	      his_self.addNavalSquadron(attacker_faction, space);
	    } else {
	      his_self.updateLog("Defender adds 1 squadron");
	      his_self.addNavalSquadron(defender_faction, space);
	    }
	  }

	  //
	  // capture stranded leaders
	  //
	  if (attacker_sea_units_remaining <= 0) {
	    let f = attacker_faction;
	    for (let i = space.units[f].length-1; i >= 0; i--) {
	      his_self.captureLeader(defender_faction, attacker_faction, mv[1], space.units[f][i]);
	      space.units[f].splice(i, 1);
	    }
	  }
	  if (defender_sea_units_remaining <= 0) {
	    let f = defender_faction;
	    for (let i = space.units[f].length-1; i >= 0; i--) {
	      his_self.captureLeader(attacker_faction, defender_faction, mv[1], space.units[f][i]);
	      space.units[f].splice(i, 1);
	    }
	  }

          //          
          // unexpected war -- everyone retreats or gets destroyed
          //   
          if (his_self.game.state.events.unexpected_war == 1) {
            for (let f in his_self.game.state.naval_battle.faction_map) {
              if (his_self.game.state.naval_battle.faction_map[f] == his_self.game.state.naval_battle.attacker_faction) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.naval_battle.defender_faction+"\t"+space.key);
              }     
              if (his_self.game.state.naval_battle.faction_map[f] == his_self.game.state.naval_battle.defender_faction) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.naval_battle.attacker_faction+"\t"+space.key);
              }       
            }
	    if (attacker_sea_units_remaining > 0) {
              this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+his_self.game.state.naval_battle.attacker_faction+"\t"+space.key);
	    }
	    if (defender_sea_units_remaining > 0) {
              this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+his_self.game.state.naval_battle.defender_faction+"\t"+space.key);
	    }

	    this.displaySpace(space.key);
	    this.displayNavalSpace(space.key);
            return 1;
          }           

	  this.displaySpace(space.key);
	  this.displayNavalSpace(space.key);

	  this.updateLog("Winner: "+this.returnFactionName(winner));
	  this.updateLog("Attacker Units Remaining: "+attacker_sea_units_remaining);
	  this.updateLog("Defender Units Remaining: "+defender_sea_units_remaining);


          //
          // conduct retreats
          //
	  if (this.game.spaces[space.key]) {

	    //
	    // attacker always retreats from ports
	    //
            this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+attacker_faction+"\t"+space.key);

	  } else {

	    //
	    // loser retreats on open seas
	    //
            if (winner == defender_faction) {
	      if (attacker_sea_units_remaining > 0) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+attacker_faction+"\t"+space.key);
                this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+attacker_faction+"\t"+space.key);
	      }
	    } else {
	      if (defender_sea_units_remaining > 0) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+defender_faction+"\t"+space.key);
                this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+defender_faction+"\t"+space.key);
	      }
	    }

	  }

          //
          // redisplay
          //
	  if (this.game.spaces[space.key]) {
            his_self.displaySpace(space.key);
	  } else {
            his_self.displayNavalSpace(space.key);
	  }

          return 1;

        }


	if (mv[0] === "assault") {

          this.game.queue.splice(qe, 1);
	  this.game.state.assault = {};
          this.game.state.assaulted_this_impulse = 1;

	  //
	  // calculate rolls
	  //
          let calculate_units = function(faction, space) {
	    let num = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].type != "cavalry" && space.units[faction][i].personage == false) { num++; }
	    }
	    return num;
          }

	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].battle_rating > 0) {
	        if (space.units[faction][i].gout != true) {
	          if (highest_battle_rating < space.units[faction][i].battle_rating) {
		    highest_battle_rating = space.units[faction][i].battle_rating;
		  }
		}
	      }
	    }
	    return highest_battle_rating;
          }


	  //
	  // this is run when a field battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a fortress if available. as
	  // such, this handles the conflict.
	  //
	  let his_self = this;
	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[mv[2]];
	  let stage = "assault";

	  //
	  // keep track of assaulted spaces
	  //
 	  this.game.state.spaces_assaulted_this_turn.push(spacekey);

	  //
	  // prevent from being assaulted again
	  //
          space.besieged == 2;

	  //
	  // otherwise -- who the hell is here?
	  //
	  // an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);

	  //
	  // defender-identification can backfire if the attacker is the only faction
	  // in the space. so we want to safeguard against this and set the defender
	  // to whomever is controlling the space in the event that we cannot find
	  // anyone but the attacker here.
	  //
	  if (defender_faction == attacker_faction) {
	    defender_faction = his_self.returnFactionControllingSpace(space);
	  }

 	  let attacker_player = his_self.returnPlayerCommandingFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerCommandingFaction(defender_faction);

	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnFactionMap(space, attacker_faction, defender_faction);


	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {
	    if (f !== attacker_faction && faction_map[f] == attacker_faction) {
	      try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	      if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	      if (p.tmp_roll_modifiers.length > 0) {
		for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	          ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	        }
	      }
	      } catch (err) {}
	    }
	    if (f !== defender_faction && faction_map[f] == defender_faction) {
	      try {
	      if (defender_player > 0) {
	        let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1];
	        let dp = his_self.game.state.players_info[defender_player-1];
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	   	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	      } catch (err) {}
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //

	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_units = 0;
	  let defender_units = 0;
	  let attacker_rolls = 0;
	  let defender_rolls = 1;
          let attacker_units_units = [];
          let defender_units_units = [];
          let attacker_units_faction = [];
          let defender_units_faction = [defender_faction];
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;

	  for (let f in faction_map) {
	    if (faction_map[f] == attacker_faction) {
	      let x = his_self.returnFactionLandUnitsInSpace(f, space);
	      attacker_units += x;
	      for (let i = 0; i < space.units[f].length; i++) {
		if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary" || space.units[f][i].type == "cavalry") {
		  attacker_units_units.push(space.units[f][i]);
	        }
	      }
	      for (let i = 0; i < x; i++) { attacker_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	    if (faction_map[f] == defender_faction) {
	      let x = his_self.returnFactionLandUnitsInSpace(f, space);
	      defender_units += x;
	      for (let i = 0; i < space.units[f].length; i++) {
		if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary" || space.units[f][i].type == "cavalry") {
		  defender_units_units.push(space.units[f][i]);
	        }
	      }
	      for (let i = 0; i < x; i++) { defender_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // calculate how many rolls attacker and defender get in this situation
	  //
	  if (defender_units == 0) {
	    attacker_rolls = attacker_units;
	    attacker_rolls += attacker_highest_battle_rating;
	    defender_rolls = 1 + defender_highest_battle_rating;
	  } else {
	    for (let i = 0; i < attacker_units; i++) {
	      if (i%2 === 0) { attacker_rolls++; }
	    }
	    attacker_rolls += attacker_highest_battle_rating;
	    defender_rolls = 1 + defender_units + defender_highest_battle_rating;
	  }

	  if (attacker_player > 0) {
	    if (his_self.game.state.players_info[attacker_player-1].tmp_roll_bonus) {
	      attacker_rolls += parseInt(his_self.game.state.players_info[attacker_player-1].tmp_roll_bonus);
	    }
	  }
	  if (defender_player > 0) {
	    if (his_self.game.state.players_info[defender_player-1].tmp_roll_bonus) {
	      defender_rolls += parseInt(his_self.game.state.players_info[defender_player-1].tmp_roll_bonus);
	    }
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  //
	  // PRINT OUT INFO TO LOG
	  //
	  for (let i = 0; i < attacker_results.length; i++) {
	    this.updateLog(" ...: " + attacker_results[i]);
          }
	  this.updateLog("Attackers: " + attacker_rolls + " rolls");
	  for (let i = 0; i < defender_results.length; i++) {
	    this.updateLog(" ...: " + defender_results[i]);
          }
	  this.updateLog("Defenders: " + defender_rolls + " rolls");
	  this.updateLog("************************");
	  this.updateLog("******** Assault *******");
	  this.updateLog("************************");


	  //
	  // things get messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue.
	  //

	  //
	  // save battle state
	  //
	  his_self.game.state.assault.attacker_units = attacker_units;
	  his_self.game.state.assault.defender_units = defender_units;
	  his_self.game.state.assault.attacker_units_units = attacker_units_units;
	  his_self.game.state.assault.defender_units_units = defender_units_units;
	  his_self.game.state.assault.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.assault.defender_units_faction = defender_units_faction;
	  his_self.game.state.assault.attacker_rolls = attacker_rolls;
	  his_self.game.state.assault.defender_rolls = defender_rolls;
	  his_self.game.state.assault.attacker_results = attacker_results;
	  his_self.game.state.assault.defender_results = defender_results;
	  his_self.game.state.assault.attacker_faction = attacker_faction;
	  his_self.game.state.assault.defender_faction = defender_faction;
	  his_self.game.state.assault.faction_map = faction_map;
	  his_self.game.state.assault.spacekey = spacekey;
	  his_self.game.state.assault.attacker_player = attacker_player;
	  his_self.game.state.assault.defender_player = defender_player;
	  his_self.game.state.assault.attacker_modified_rolls = attacker_rolls;
	  his_self.game.state.assault.defender_modified_rolls = defender_rolls;
          his_self.game.state.assault.attacker_hits = attacker_hits;
          his_self.game.state.assault.defender_hits = defender_hits;
          his_self.game.state.assault.attacker_units_destroyed = [];
          his_self.game.state.assault.defender_units_destroyed = [];
          his_self.game.state.assault.attacker_hits_first = 0;
          his_self.game.state.assault.defender_hits_first = 0;
          
	  his_self.game.queue.push(`assault_continue\t${mv[1]}\t${mv[2]}`);

          let ap = {};
          let dp = {};

          if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
          if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

          //
          // we stop here for intercession by cards that need to execute before the die rolls
	  // are assigned but after they have been rolled.
          //
          if (ap.tmp_roll_first == 1 && dp.tmp_roll_first != 1) {
            his_self.game.state.assault.attacker_hits_first = 1;
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
          } else if (ap.tmp_roll_first != 1 && dp.tmp_roll_first == 1) {
            his_self.game.state.field_battle.defender_hits_first = 1;
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
          } else {
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
            his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
          }

          //
          // this should stop execution while we are looking at the pre-field battle overlay
          //
	  his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(space.key);
          his_self.game.queue.push("assault_assign_hits_render");
          his_self.game.queue.push("assault_show_hits_render");
          his_self.game.queue.push("counter_or_acknowledge\tAssault is about to begin in "+space.name + "\tpre_assault_rolls");
          //his_self.game.queue.push("RESETCONFIRMSNEEDED\tall");
          his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));

          his_self.assault_overlay.renderPreAssault(his_self.game.state.assault);
          his_self.assault_overlay.pullHudOverOverlay();

          return 1;

        }


	if (mv[0] === "assault_continue") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space = this.game.spaces[mv[2]];

	  //
	  // calculate hits
	  //
          let modify_rolls = function(player, roll_array) {

	    if (!player.tmp_roll_modifiers) {
	      return roll_array;
	    }

	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                } else {
                  modified_rolls.push(modded_roll);
		}
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                } else {
                  modified_rolls.push(roll_array[i]);
	        }
              }
            }
	    return modified_rolls;
          }
          let calculate_hits = function(player, roll_array) {
            let hits = 0;
            for (let i = 0; i < roll_array.length; i++) {
              if (roll_array[i] >= 5) {
                hits++;
              }
            }
            return hits;
          }
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	      }
	    }

	    //
	    //
	    //
	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }


	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0 && number_of_targets > 0) {

	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "cavalry"; }
		        if (zzz == 1) { cannon_fodder = "mercenary"; }
		        if (zzz == 2) { cannon_fodder = "regular"; }

			let units_len = space.units[f].length;

  	     	        for (let i = 0; i < units_len; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {
		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = units_len + 1;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "cavalry"; }
                    if (zzz == 1) { cannon_fodder = "mercenary"; }
                    if (zzz == 2) { cannon_fodder = "regular"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {
			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 0);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }

	  let faction_map      = his_self.game.state.assault.faction_map;
	  let attacker_faction = his_self.game.state.assault.attacker_faction;
	  let defender_faction = his_self.game.state.assault.defender_faction;
	  let ap = his_self.returnPlayerOfFaction(attacker_faction);
	  let dp = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_player = {};
	  let defender_player = {};
	  if (ap > 0) { attacker_player  = his_self.game.state.players_info[ap-1]; }
          if (dp > 0) { defender_player  = his_self.game.state.players_info[dp-1]; }
	  let attacker_results = his_self.game.state.assault.attacker_results;
	  let defender_results = his_self.game.state.assault.defender_results;
	  let attacker_rolls   = his_self.game.state.assault.attacker_rolls;
	  let defender_rolls   = his_self.game.state.assault.defender_rolls;
	  let attacker_units   = his_self.game.state.assault.attacker_units;
	  let defender_units   = his_self.game.state.assault.defender_units;


	  let winner	       = defender_faction;
	  let attacker_hits    = 0;
	  let defender_hits    = 0;

	  //
	  // attacker goes first
	  //
          if (attacker_player.tmp_rolls_first == 1 && defender_player.tmp_rolls_first != 1) {

	    //
 	    // assign attacker hits
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    attacker_hits = calculate_hits(attacker_player, his_self.game.state.assault.attacker_modified_rolls);
	    assign_hits(defender_player, attacker_hits);

	    for (let i = 0; i < attacker_hits; i++) {
	      if (defender_results.length > 0) {
		defender_rolls.splice(defender_rolls.length-1, 1);
		defender_results.splice(defender_rolls.length-1, 1);
	      }
	    }

	    //
	    // assign defender hits
	    //
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    defender_hits = calculate_hits(defender_player, his_self.game.state.assault.defender_modified_rolls);
	    assign_hits(attacker_player, defender_hits);

	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          //
          // defender goes first
          //
          } else if (attacker_player.tmp_rolls_first != 1 && defender_player.tmp_rolls_first == 1) {

	    //
 	    // assign defender hits
	    //
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    defender_hits = calculate_hits(defender_player, his_self.game.state.assault.defender_modified_rolls);
	    assign_hits(attacker_player, defender_hits);

	    for (let i = 0; i < defender_hits; i++) {
	      if (attacker_results.length > 0) {
		attacker_rolls.splice(attacker_rolls.length-1, 1);
		attacker_results.splice(attacker_rolls.length-1, 1);
	      }
	    }

	    //
	    // check if we can continue
	    //

	    //
	    // assign attacker hits
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    attacker_hits = calculate_hits(attacker_player, his_self.game.state.assault.attacker_modified_rolls);
	    assign_hits(defender_player, attacker_hits);

	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          } else {

	    //
	    // assign hits simultaneously
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    attacker_hits = calculate_hits(attacker_player, attacker_results);
	    defender_hits = calculate_hits(defender_player, defender_results);
	    assign_hits(defender_player, attacker_hits);
	    assign_hits(attacker_player, defender_hits);
	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          }

	  //
	  // who won?
	  //
	  if (attacker_hits > defender_hits) {
	    winner = attacker_faction;
	  }

	  //
	  // calculate units remaining
	  //
	  let attacker_land_units_remaining = attacker_units - defender_hits;
	  let defender_land_units_remaining = defender_units - attacker_hits;

          his_self.game.state.assault.attacker_land_units_remaining = attacker_land_units_remaining;
          his_self.game.state.assault.defender_land_units_remaining = defender_land_units_remaining;

	  //
	  // attacker and defender both wiped out
	  //
	  if (attacker_land_units_remaining <= 0 && defender_land_units_remaining >= 0) {

	    space.besieged = 0;
	    space.unrest = 0;

	    //
	    // remove besieged
	    //
	    for (let key in space.units) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        space.units[key][i].besieged = 0;
	      }
	    }
	    //
	    // updarte log
	    //
	    this.updateLog("Winner: "+this.returnFactionName(defender_faction));
	  }

	  //
	  // mutually assured destruction
	  //
	  if (attacker_land_units_remaining <= 0 && defender_land_units_remaining <= 0) {

	    //
	    // no-one survived, so just end siege
	    //
	    this.removeSiege(space.key);
	    space.unrest = false;
	    this.updateLog("Siege in " + this.returnSpaceName(space.key) + " ends");

	  }

	  //
	  // capture stranded leaders
	  //
	  if (attacker_land_units_remaining <= 0) {
	    for (let f in faction_map) {
	      if (faction_map[f] == attacker_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(defender_faction, attacker_faction, mv[1], space.units[f][i]);
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }

	  if (defender_land_units_remaining <= 0 && attacker_hits > 0) {
	    for (let f in faction_map) {
	      if (faction_map[f] == defender_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(attacker_faction, defender_faction, mv[1], space.units[f][i]);
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }

          //
          // conduct retreats
          //
          if (defender_land_units_remaining < attacker_land_units_remaining) {

	    //
	    // no land units remain
	    //
	    if (defender_land_units_remaining <= 0 && attacker_land_units_remaining > 0 && attacker_hits > 0) {
	      this.removeSiege(space.key);
	      space.unrest = 0;
	      this.controlSpace(attacker_faction, space.key);
	      this.updateLog(this.returnFactionName(attacker_faction) + " wins seige, controls " + this.returnSpaceName(space.key));
	    }

          } else {

            if (attacker_land_units_remaining == 0) {
	      this.removeSiege(space.key);
	      space.unrest = 0;
	      this.updateLog(this.returnFactionName(defender_faction) + " breaks seige, controls " + this.returnSpaceName(space.key));
	    } else {
	      his_self.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+attacker_faction+"\t"+defender_faction+"\t"+space.key);
              his_self.game.queue.push("break_siege");
              his_self.game.queue.push("hide_overlay\tassault");
	    }
	  }

          //
          // redisplay
          //
	  his_self.refreshBoardUnits();
          his_self.displaySpace(space.key);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();


          return 1;

        }



	if (mv[0] === "purge_units_and_capture_leaders_if_unbesieged") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];

	  let space = this.game.spaces[spacekey];

	  if (space.units[loser].length > 0) {
	    for (let z = 0; z < space.units[loser].length; z++) {
	      if (space.units[loser][z].army_leader == 1) {
	        this.captureLeader(loser, winner, spacekey, space.units[loser][z]);
	      } else {
	        if (space.units[loser][z].besieged == 0) { space.units[loser].splice(z, 1); z--; }
	      }
	    }
	  }

	  return 1;

	}


	if (mv[0] === "purge_units_and_capture_leaders") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];

	  let space = this.game.spaces[spacekey];

	  if (space.units[loser].length > 0) {
	    this.updateLog(this.returnFactionName(loser) + " eliminated in " + this.returnSpaceName(spacekey));
	  }

	  for (let i = 0; i < space.units[loser].length; i++) {
	    this.captureLeader(loser, winner, spacekey, space.units[loser][i]);
	  }

	  space.units[loser] = [];

	  return 1;

	}


	if (mv[0] === "purge_naval_units_and_capture_leaders") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];

	  let space;
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

	  if (space.units[loser].length > 0) {
	    this.updateLog(this.returnFactionName(loser) + " eliminated in " + this.returnSpaceName(spacekey));
	  }

	  for (let i = 0; i < space.units[loser].length; i++) {
	    this.captureNavalLeader(loser, winner, spacekey, space.units[f][i]);
	  }

	  space.units[loser] = [];

	  this.displaySpace(space.key);
	  this.displayNavalSpace(space.key);

	  return 1;

	}


        if (mv[0] === "player_evaluate_post_naval_battle_retreat") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let spacekey = mv[2];

	  let commanding_player = this.returnPlayerCommandingFaction(loser);
	  if (commanding_player == 0) { return 1; }

          if (this.game.player == commanding_player) {
            this.playerEvaluateNavalRetreatOpportunity(loser, spacekey, "", loser, true);
          } else {
            this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat at sea");
          }

          return 0;

        }


        if (mv[0] === "post_field_battle_player_evaluate_retreat") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let spacekey = mv[2];

	  //
	  // auto-skip if there are < 4 loser units and they are fortified
	  //
	  let unfortified_units = 0;
	  let fortified_units = 0;
	  for (let i = 0; i < this.game.spaces[spacekey].units[loser].length; i++) {
	    if (this.game.spaces[spacekey].units[loser][i].besieged == 0) {
	      unfortified_units++;
	    }
	  }
	  if (unfortified_units == 0) {
	    // disabled MAR 26 -- splicing is above
	    //this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // auto-skip if loser cannot retreat because they have no land units
	  //
	  let loser_can_retreat = false;
	  for (let i = 0; i < this.game.spaces[spacekey].units[loser].length; i++) {
	    if (["regular", "mercenary", "calvary"].includes(this.game.spaces[spacekey].units[loser][i].type)) { loser_can_retreat = true; }
	  }
	  if (loser_can_retreat == false) { return 1; }

          let faction_map = his_self.game.state.field_battle.faction_map;
          let attacker_faction = his_self.game.state.field_battle.attacker_faction;
          let defender_faction = his_self.game.state.field_battle.defender_faction;
          let ap = his_self.returnPlayerOfFaction(attacker_faction);
          let dp = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_player = {};
	  let defender_player = {};
          if (ap > 0) { attacker_player  = his_self.game.state.players_info[his_self.returnPlayerOfFaction(attacker_faction)-1]; }
	  if (dp > 0) { defender_player  = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1]; }
          let attacker_results = his_self.game.state.field_battle.attacker_results;
          let defender_results = his_self.game.state.field_battle.defender_results;
          let attacker_rolls   = his_self.game.state.field_battle.attacker_rolls;
          let defender_rolls   = his_self.game.state.field_battle.defender_rolls;
          let attacker_units   = his_self.game.state.field_battle.attacker_units;
          let defender_units   = his_self.game.state.field_battle.defender_units;
          let attacker_land_units_remaining = his_self.game.state.field_battle.attacker_land_units_remaining;
          let defender_land_units_remaining = his_self.game.state.field_battle.defender_land_units_remaining;
          let attacker_comes_from_this_spacekey = his_self.game.state.attacker_comes_from_this_spacekey; // from state

          //
          // fortification has already happened. if the loser is the attacker, they have to retreat
          //
          if (loser === attacker_faction) {
	    let winning_faction = defender_faction;
	    if (this.game.player == this.returnPlayerCommandingFaction(loser)) {
	      if (this.game.state.field_battle.relief_battle) {
		this.playerEvaluateBreakSiegeRetreatOpportunity(loser, spacekey);
	      } else {
	        this.playerEvaluatePostBattleRetreatOpportunity(loser, winning_faction, attacker_faction, spacekey, this.game.state.attacker_comes_from_this_spacekey);
	      }
            } else {
              this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat");
            }
          } else {
	    let winning_faction = attacker_faction;
	    if (this.game.player == this.returnPlayerCommandingFaction(loser)) {
	      if (this.game.state.field_battle.relief_battle) {
		this.playerEvaluateBreakSiegeRetreatOpportunity(loser, spacekey);
	      } else {
	        this.playerEvaluatePostBattleRetreatOpportunity(loser, winning_faction, attacker_faction, spacekey, this.game.state.attacker_comes_from_this_spacekey);
	      }
            } else {
              this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat");
            }
          }

          return 0;

        }



        if (mv[0] === "found_jesuit_university") {

	  let spacekey = mv[1];

	  this.game.queue.splice(qe, 1);

	  this.updateLog("Jesuit University founded in " + this.game.spaces[spacekey].name);
	  this.game.spaces[spacekey].university = 1;
	  this.displaySpace(spacekey);

	  return 1;

	}



	if (mv[0] === "pick_second_round_debaters") {

	  let attacker = this.game.state.theological_debate.attacker;
	  let defender = this.game.state.theological_debate.defender;
	  let committed = this.game.state.theological_debate.committed;
	  // 2nd round defaults to uncommitted
	  let language_zone = this.game.state.theological_debate.language_zone;
	  this.game.state.theological_debate.round++;
	  let prohibited_protestant_debater = this.game.state.theological_debate.prohibited_protestant_debater;

          this.game.state.theological_debate.attacker_debater = ""; // resetting
          this.game.state.theological_debate.defender_debater = "";

	  let x = 0;

	  let attacker_enters_uncommitted = 1;

          let ad = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (this.game.state.debaters[i].owner == attacker) {
              if (this.game.state.debaters[i].committed == 0) {
                if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                  ad++;
                }
              }
            }
          }
          if (ad == 0) {
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker) {
                if (this.game.state.debaters[i].committed == 1) {
                  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                    ad++;
                    attacker_enters_uncommitted = 0;
                  }
                }
              }
            }
          }

	  x = this.rollDice(ad) - 1;
          ad = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (this.game.state.debaters[i].owner == attacker) {
              if ((attacker_enters_uncommitted == 1 && this.game.state.debaters[i].committed == 0) || (attacker_enters_uncommitted == 0 && this.game.state.debaters[i].committed == 1)) {
                if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                  if (x == ad) {
                    this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.attacker_debater_entered_uncommitted = attacker_enters_uncommitted;
                  }
                  ad++;
                }
              }
            }
          }


          //
          // defender chosen randomly from uncommitted if available
          //
	  let uncommitted_defender = 1;
          let dd = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
              if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
                dd++;
              }
            }
          }
	  if (dd == 0) {
	    uncommitted_defender = 0;
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
                  dd++;
                }
              }
            }
	  }

          x = this.rollDice(dd) - 1;
          dd = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
              if (uncommitted_defender == 0) {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
                  if (x === dd) {
                    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
                  }
                  dd++;
                }
              } else {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
                  if (x === dd) {
                    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.defender_debater_entered_uncommitted = 1;
                    this.game.state.theological_debate.defender_debater_bonus++;
                  }
                  dd++;
                }
              }
            }
          }

	  //
	  // it is possible that we fall through because there are no eligible debaters. in this case
	  // we simply grab a committed debater in a follow-up random sweep.
	  //
	  if (this.game.state.theological_debate.defender_debater === "") {
	    dd = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	          dd++;
	        }
	      }
	    }
	    x = this.rollDice(dd) - 1;
	    for (let i = 0, j = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	          if (x === j) {
		    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	            this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	          }
		  j++;
	        }
	      }
	    }
	  }
          if (this.game.state.theological_debate.attacker_debater === "") {
            dd = 0;
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker && this.game.state.debaters[i].committed == 1) {
                dd++;
              }
            }
            x = this.rollDice(dd) - 1;
            for (let i = 0, j = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker && this.game.state.debaters[i].committed == 1) {
                if (x === j) {
                  this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
                  this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
                  this.game.state.theological_debate.attacker_debater_entered_uncommitted = 0;
                }
                j++;
              }
            }
          }

          this.game.state.theological_debate.round2_attacker_debater = this.game.state.theological_debate.attacker_debater;
          this.game.state.theological_debate.round2_defender_debater = this.game.state.theological_debate.defender_debater;

	  this.updateLog(this.game.state.theological_debate.attacker_debater + " vs. " + this.game.state.theological_debate.defender_debater);

	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "pick_first_round_debaters") {

	  let attacker = mv[1];
	  let defender = mv[2];
	  let language_zone = mv[3];
	  let committed = mv[4];
	  if (parseInt(mv[4]) === 1) { committed = "committed"; };
	  if (parseInt(mv[4]) === 0) { committed = "uncommitted"; };
	  let selected_papal_debater = "";
	  if (mv[5]) { selected_papal_debater = mv[5]; }
	  let prohibited_protestant_debater = "";
	  if (mv[6]) { prohibited_protestant_debater = mv[6]; }

	  this.updateLog(this.returnFactionName(attacker) + " targets " + committed + " debater");

	  this.game.state.theological_debate = {};
	  this.game.state.theological_debate.attacker_rolls = 0;
	  this.game.state.theological_debate.defender_rolls = 0;
	  this.game.state.theological_debate.adice = [];
	  this.game.state.theological_debate.ddice = [];
	  this.game.state.theological_debate.attacker = mv[1];
	  this.game.state.theological_debate.defender = mv[2];
	  this.game.state.theological_debate.language_zone = mv[3];
	  this.game.state.theological_debate.committed = committed;
	  this.game.state.theological_debate.round = 1;
	  this.game.state.theological_debate.round1_attacker_debater = "";
	  this.game.state.theological_debate.round1_defender_debater = "";
	  this.game.state.theological_debate.round2_attacker_debater = "";
	  this.game.state.theological_debate.round2_defender_debater = "";
	  this.game.state.theological_debate.attacker_debater = "";
	  this.game.state.theological_debate.defender_debater = "";
	  this.game.state.theological_debate.attacker_debater_entered_uncommitted = 0;
	  this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	  this.game.state.theological_debate.attacker_debater_power = 0;
	  this.game.state.theological_debate.defender_debater_power = 0;
	  this.game.state.theological_debate.attacker_debater_bonus = 3;
	  this.game.state.theological_debate.defender_debater_bonus = 1;
	  this.game.state.theological_debate.selected_papal_debater = "";
	  this.game.state.theological_debate.prohibited_protestant_debater = "";
	  this.game.state.theological_debate.attacker_faction = attacker;
	  this.game.state.theological_debate.defender_faction = defender;

	  let x = 0;

	  let attacker_enters_uncommitted = 1;

	  //
	  // Henry Petitions for Divorce pre-selects 
	  //
	  if (this.game.state.events.henry_petitions_for_divorce_grant == 1) {
	    selected_papal_debater = "campeggio-debater";
	  }

	  //
	  // papacy can select their attacker, or attacker picks debater at random from uncommitted
	  //
	  if (selected_papal_debater != "") {
	    this.game.state.theological_debate.attacker_debater = selected_papal_debater;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (selected_papal_debater == this.game.state.debaters[i].type) {
  	        this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
		if (!this.game.state.debaters[i].committed) {
	          this.game.state.theological_debate.attacker_debater_entered_uncommitted = 1;
		}
	      }
	    }
	  } else {
            let ad = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].owner == attacker) {
	        if (this.game.state.debaters[i].committed == 0) {
		  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	            ad++;
	          }
	        }
	      }
	    }

	    if (ad == 0) {
	      for (let i = 0; i < this.game.state.debaters.length; i++) {
	        if (this.game.state.debaters[i].owner == attacker) {
	          if (this.game.state.debaters[i].committed == 1) {
		    if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	              ad++;
	  	      attacker_enters_uncommitted = 0;
	            }
	          }
	        }
	      }
	    }

	    x = this.rollDice(ad) - 1;
	    ad = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].owner == attacker) {
		if ((attacker_enters_uncommitted == 1 && this.game.state.debaters[i].committed == 0) || (attacker_enters_uncommitted == 0 && this.game.state.debaters[i].committed == 1)) {
		  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	            if (x == ad) {
	  	      this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
		      this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
	              this.game.state.theological_debate.attacker_debater_entered_uncommitted = attacker_enters_uncommitted;
	            }
	            ad++;
	          }
	        }
	      }
	    }
	  }

	  //
	  // defender chosen randomly from type committed / uncommitted
	  //
	  let dd = 0;
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.theological_debate.committed == "committed") {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	            dd++;
	          }
	        } else {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed != 1) {
	            dd++;
	          }
	        }
	      }
	    }
	  }

	  x = this.rollDice(dd) - 1;

	  dd = 0;
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.theological_debate.committed == "committed") {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	            if (x === dd) {
		      this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		      this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	              this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	            }
	            dd++;
	          }
	        } else {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
	            if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	              if (x === dd) {
		        this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		        this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	                this.game.state.theological_debate.defender_debater_entered_uncommitted = 1;
	                this.game.state.theological_debate.defender_debater_bonus++;
		      }
	              dd++;
		    }
	          }
	        }
	      }
	    }
	  }


	  this.updateLog(this.game.state.theological_debate.attacker_debater + " vs. " + this.game.state.theological_debate.defender_debater);

          this.game.state.theological_debate.round1_attacker_debater = this.game.state.theological_debate.attacker_debater;
          this.game.state.theological_debate.round1_defender_debater = this.game.state.theological_debate.defender_debater;

	  //
	  // and show it...
	  //
	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  this.game.queue.splice(qe, 1);

	  return 1;

	}


        if (mv[0] === "commit") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let debater = mv[2];
	  let activate_it = 0;

	  this.updateLog(this.returnFactionName(faction) + " commits " + this.popup(debater));

	  if (parseInt(mv[3]) > 0) { activate_it = parseInt(mv[3]); }
	  this.commitDebater(faction, debater, activate_it);

	  return 1;

        }

	if (mv[0] === "player_call_theological_debate") {
	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  if (this.game.player == player) {
	    this.playerCallTheologicalDebate(this, player, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " calling theological debate");
	  }
	  return 0;
	}

        if (mv[0] === "theological_debate") {

	  let attacker = this.game.state.theological_debate.attacker;
	  let defender = this.game.state.theological_debate.defender;
	  let language_zone = this.game.state.theological_debate.language_zone;
	  let committed = this.game.state.theological_debate.committed;
	  let attacker_idx = 0;
	  let defender_idx = 0;
	  let was_defender_uncommitted = 0;

	  this.game.queue.splice(qe, 1);

	  //
	  // commit attacker if uncommitted
	  //
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.attacker_debater) {
	      attacker_idx = i;
	      if (!this.isCommitted(this.game.state.theological_debate.attacker_debater)) {
		this.commitDebater(this.game.state.theological_debate.attacker, this.game.state.theological_debate.attacker_debater, 0);
	      }
	    }
	  }

	  //
	  // defender power and bonus check is complicated because of Here I Stand
	  //
	  let defender_debater_power = 1;
	  let defender_debater_bonus = 0;

	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.defender_debater) {
	      defender_idx = i;
	      defender_debater_power = this.game.state.debaters[defender_idx].power;
	      if (!this.isCommitted(this.game.state.theological_debate.defender_debater)) {
	        was_defender_uncommitted = 1;
		this.commitDebater(this.game.state.theological_debate.defender, this.game.state.theological_debate.defender_debater, 0);
	      }
	    }
	  }
	  for (let i = 0; i < this.game.state.excommunicated.length; i++) {
	    if (this.game.state.excommunicated[i].debater) {
	      if (this.game.state.excommunicated[i].debater.type === this.game.state.theological_debate.defender_debater) {
	        defender_debater_power = this.game.state.excommunicated[i].debater.power;
	        if (this.game.state.excommunicated[i].debater.committed == 0) {
	          was_defender_uncommitted = 1;
	  	  this.game.state.excommunicated[i].debater.committed = 1;
	        }
	      }
	    }
	  }


	  let attacker_debater_power = 1;
	  let attacker_debater_bonus = 3;

	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.attacker_debater) {
	      attacker_idx = i;
	      attacker_debater_power = this.game.state.debaters[attacker_idx].power;
	      if (this.game.state.debaters[i].committed == 0) {
		this.commitDebater(this.game.state.theological_debate.attacker, this.game.state.theological_debate.attacker_debater, 0);
	      }
	    }
	  }
	  for (let i = 0; i < this.game.state.excommunicated.length; i++) {
	    if (this.game.state.excommunicated[i].debater) {
	      if (this.game.state.excommunicated[i].debater.type === this.game.state.theological_debate.attacker_debater) {
	        attacker_debater_power = this.game.state.excommunicated[i].debater.power;
	        if (this.game.state.excommunicated[i].debater.committed == 0) {
	  	  this.game.state.excommunicated[i].debater.committed = 1;
	        }
	      }
	    }
	  }

	  //
	  // even Luther gets 3 if invoked w/ Here I Stand as attacker
	  //
	  let attacker_rolls = attacker_debater_power + 3;
	  //
	  // defender_debater_power handled above - Luther because may be excommunicated
	  //
	  defender_debater_bonus = 1 + was_defender_uncommitted;
	  let defender_rolls = defender_debater_power + 1 + was_defender_uncommitted;

	  //
	  // papal inquisition
	  //
	  if (attacker === "papacy" && this.game.state.events.papal_inquisition_debate_bonus == 1) {
	    attacker_rolls += 2;
	  }

	  //
	  // thomas more
	  //
	  if (this.game.state.events.more_bonus == 1) {
	    attacker_rolls += 1;
	    if (language_zone == "english") {
	      attacker_rolls += 2;
	    }
	  }

	  //
	  // eck-debator bonus
	  //
	  if (attacker === "papacy" && this.game.state.theological_debate.attacker_debater === "eck-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) {
	    attacker_rolls++;
	  }

	  //
	  // gardiner-debater bonus
	  //
	  if (attacker === "papacy" && this.game.state.theological_debate.attacker_debater === "gardiner-debater" && this.game.state.theological_debate.language_zone === "english" && this.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
	    attacker_rolls++;
	  }

	  //
	  // augsburg confession
	  //
	  if (attacker === "papacy" && this.game.state.events.augsburg_confession == 1) {
	    attacker_rolls--;
	  }

	  let attacker_hits = 0;
	  let defender_hits = 0;
	  let adice = [];
	  let ddice = [];

	  for (let i = 0; i < attacker_rolls; i++) {
	    let x = this.rollDice(6);
	    adice.push(x);
	    if (x >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let x = this.rollDice(6);
	    ddice.push(x);
	    if (x >= 5) { defender_hits++; }
	  }

	  this.updateLog(this.popup(this.game.state.theological_debate.attacker_debater) + " vs " + this.popup(this.game.state.theological_debate.defender_debater) + ` [${attacker_hits}/${defender_hits}]`);

	  //
	  //
	  //
	  this.game.state.theological_debate.attacker_rolls = attacker_rolls;
	  this.game.state.theological_debate.defender_rolls = defender_rolls;
	  this.game.state.theological_debate.adice = adice;
	  this.game.state.theological_debate.ddice = ddice;
	  this.game.state.theological_debate.attacker_debater_power = attacker_debater_power;
	  this.game.state.theological_debate.defender_debater_power = defender_debater_power;
	  this.game.state.theological_debate.attacker_debater_bonus = attacker_debater_bonus;
	  this.game.state.theological_debate.defender_debater_bonus = defender_debater_bonus;

	  if (attacker_hits == defender_hits) {
	    this.game.state.theological_debate.status = "Inconclusive - Second Round";
	  } else {
	    if (attacker_hits > defender_hits) {
	      this.game.state.theological_debate.status = this.returnFactionName(this.game.state.theological_debate.attacker_faction) + " Wins";
	    } else {
	      this.game.state.theological_debate.status = this.returnFactionName(this.game.state.theological_debate.defender_faction) + " Wins";
	    }
	  }

	  //
	  // open theological debate UI
	  //
	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  if (attacker_hits == defender_hits) {

	    //
	    // first round of debate moves into second
	    //
	    this.game.state.theological_debate.round++;
	    if (this.game.state.theological_debate.round > 2) {

	      this.game.queue.push("counter_or_acknowledge\tTie - Debate Ends Inconclusively");
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    } else {

	      this.game.queue.push("theological_debate");
	      this.game.queue.push("counter_or_acknowledge\tTheological Debate: 2nd Round\tdebate\t" + language_zone);
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate_and_debaters");
	      this.game.queue.push("pick_second_round_debaters");
	      this.game.queue.push("counter_or_acknowledge\tThe Debate is Tied - Progress to 2nd Round");
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    }

	  } else {

	    let bonus_conversions = 0;

	    //
	    // if aleander is in play, flip extra space
	    //
	    if ((this.game.state.theological_debate.attacker_debater === "aleander-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) || (this.game.state.theological_debate.defender_debater === "aleander-debater")) {
	      this.updateLog(this.popup("aleander-debater") + " bonus: +1 conversion");
	      bonus_conversions = 1;
	    }

	    if (attacker_hits > defender_hits) {

	      let total_spaces_to_convert = attacker_hits - defender_hits;
	      let unaltered_total_spaces_to_convert = total_spaces_to_convert;
	      let total_spaces_overall = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      if (total_spaces_to_convert > total_spaces_overall) { total_spaces_to_convert = total_spaces_overall; }
	      let total_spaces_in_zone = this.returnNumberOfProtestantSpacesInLanguageZone(language_zone, 1);
	      if (defender === "papacy") { total_spaces_in_zone = this.returnNumberOfCatholicSpacesInLanguageZone(language_zone, 1); }

	      //
	      // if campeggio is the debater, we have 1/3 chance of ignoring result
	      //

	      if (this.game.state.theological_debate.defender_debater === "campeggio-debater" && this.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
		let roll = this.rollDice(6);
	        if (roll >= 5) {
	          this.updateLog(this.popup("campeggio-debater") + " rolls: " + roll + " debate loss discarded");
		  total_spaces_to_convert = 0;
		  bonus_conversions = 0;
	        } else {
	          this.updateLog(this.popup("campeggio-debater") + " rolls: " + roll + " debate loss sustained");
	 	}
	      }

	      if ((bonus_conversions+total_spaces_to_convert) == 1) {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
	      }


	      //
	      // reduce number of convertible spaces to total available to convert
	      //
	      let flip_this_number = total_spaces_to_convert + bonus_conversions;
	      if (this.game.state.theological_debate.attacker_faction == "papacy" && this.returnNumberOfProtestantSpacesInLanguageZone("", 1) < flip_this_number) {
	        this.updateLog("Protestants only have " + this.returnNumberOfProtestantSpacesInLanguageZone("", 1) + " spaces to flip");
	        flip_this_number = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      }


	      //
	      // attacker has more hits, is defender burned?
	      //
	      if (unaltered_total_spaces_to_convert > this.game.state.theological_debate.defender_debater_power) {
		if (this.game.state.theological_debate.attacker_faction === "papacy") {
		  this.burnDebater(this.game.state.theological_debate.defender_debater);
		} else {
		  this.disgraceDebater(this.game.state.theological_debate.defender_debater);
		}
	      }

	      this.game.queue.push("hide_overlay\tzoom\t"+language_zone);


	      for (let i = flip_this_number; i >= 1; i--) {
	        if (i > (total_spaces_in_zone+bonus_conversions)) {
		  if (attacker === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy");
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant");
		  }
		} else {
		  if (attacker === "papacy") {
  		    this.game.queue.push("select_for_catholic_conversion\tpapacy\t"+language_zone);
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant\t"+language_zone);
		  }
		}
	      }
	      //
	      this.game.queue.push("show_overlay\tzoom\t"+language_zone);
	      this.game.queue.push("hide_overlay\ttheological_debate");
	      if ((total_spaces_to_convert+bonus_conversions) == 1) {
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${(total_spaces_to_convert+bonus_conversions)} Space`);
	      } else { 
	        this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${(total_spaces_to_convert+bonus_conversions)} Spaces`);
              }
	      this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    //
	    // defender has more hits than attacker
	    //
	    } else {

	      let total_spaces_to_convert = defender_hits - attacker_hits;
	      let unaltered_total_spaces_to_convert = total_spaces_to_convert;
defender_hits - attacker_hits;
	      let total_spaces_overall = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      if (total_spaces_to_convert > total_spaces_overall) { total_spaces_to_convert = total_spaces_overall; }
	      let total_spaces_in_zone = this.returnNumberOfProtestantSpacesInLanguageZone(language_zone, 1);
	      if (attacker === "papacy") { total_spaces_in_zone = this.returnNumberOfCatholicSpacesInLanguageZone(language_zone, 1); }

	      //
	      // if campeggio is the debater, we have 1/3 chance of ignoring result
	      //
	      if (this.game.state.theological_debate.attacker_debater === "campeggio-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) {
		let roll = this.rollDice(6);
	        if (roll >= 5) {
	          this.updateLog("Campeggio rolls: " + roll + " debate loss discarded");
		  total_spaces_to_convert = 0;
		  bonus_conversions = 0;
	        } else {
	          this.updateLog("Campeggio rolls: " + roll + " debate loss sustained");
	 	}
	      }


	      if ((total_spaces_to_convert+bonus_conversions) == 1) {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
	      }

	      //
	      // reduce number of convertible spaces to total available to convert
	      //
	      let flip_this_number = total_spaces_to_convert + bonus_conversions;

	      if (this.game.state.theological_debate.defender_faction == "papacy" && this.returnNumberOfProtestantSpacesInLanguageZone("", 1) < flip_this_number) {
	        this.updateLog("Protestants only have " + this.returnNumberOfProtestantSpacesInLanguageZone("", 1) + " spaces to flip");
	        flip_this_number = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      }

	      //
	      // defender has more hits, is attacker burned?
	      //
	      if (unaltered_total_spaces_to_convert > this.game.state.theological_debate.attacker_debater_power) {
	        if (this.game.state.theological_debate.attacker_faction === "protestant") {
		  this.burnDebater(this.game.state.theological_debate.attacker_debater);
	 	} else {
		  this.disgraceDebater(this.game.state.theological_debate.attacker_debater);
		}
	      }

	      this.game.queue.push("hide_overlay\tzoom\t"+language_zone);

	      for (let i = flip_this_number; i >= 1; i--) {
	        if (i > total_spaces_in_zone) {
		  if (defender === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy");
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant");
		  }
		} else {
		  if (defender === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy\t"+language_zone);
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant\t"+language_zone);
		  }
		}
	      }
	      this.game.queue.push("show_overlay\tzoom\t"+language_zone);
	      this.game.queue.push("hide_overlay\ttheological_debate");
	      if ((total_spaces_to_convert+bonus_conversions) == 1) { 
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
              }
	      this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");
	    }
	  }

	  return 1;

	}



        if (mv[0] === "translation") {

	  let zone = mv[1];
	  let ops = 1;
	  if (mv[2]) { if (parseInt(mv[2]) > ops) { ops = parseInt(mv[2]); } }
          let player = this.returnPlayerOfFaction("protestant");

	  this.game.queue.splice(qe, 1);

	  for (let z = 0; z < ops; z++) {
	    if (zone === "german") {
	      if (this.game.state.translations['new']['german'] >= 6) {
	        this.updateLog("Protestants translate Old Testament (german)");
	        this.game.state.translations['full']['german']++;
		if (this.game.state.translations['full']['german'] == 10) {
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.state.german_bible_translation_bonus = 1;
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing German Bible");
		}
	        if (this.game.state.translations['full']['german'] > 10) { this.game.state.translations['full']['german'] = 10; }
  	      } else {
	        this.updateLog("Protestants translate New Testament (german)");
	        this.game.state.translations['new']['german']++;
		if (this.game.state.translations['new']['german'] == 6) {
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	    if (zone === "french") {
	      if (this.game.state.translations['new']['french'] >= 6) {
	        this.updateLog("Protestants translate Old Testament (french)");
	        this.game.state.translations['full']['french']++;
		if (this.game.state.translations['full']['french'] == 10) {
		  // protestant gets 1 roll bonus at start
	          his_self.game.state.french_bible_translation_bonus = 1;
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing French Bible");
		}
	        if (this.game.state.translations['full']['french'] > 10) { this.game.state.translations['full']['french'] = 10; }
	      } else {
	        this.updateLog("Protestants translate New Testament (french)");
	        this.game.state.translations['new']['french']++;
		if (this.game.state.translations['new']['french'] == 6) {
		  // protestant gets 1 roll bonus at start
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	    if (zone === "english") {
	      if (this.game.state.translations['new']['english'] >= 6) { 
	        this.updateLog("Protestants translate Old Testament (english)");
	        this.game.state.translations['full']['english']++;
		if (this.game.state.translations['full']['english'] == 10) {
		  // protestant gets 1 roll bonus at start
	          his_self.game.state.english_bible_translation_bonus = 1;
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing English Bible");
		}
	        if (this.game.state.translations['full']['english'] > 10) { this.game.state.translations['full']['english'] = 10; }
	      } else {
	        this.updateLog("Protestants translate New Testament (english)");
	        this.game.state.translations['new']['english']++;
		if (this.game.state.translations['new']['english'] == 6) {
		  // protestant gets 1 roll bonus at start
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	  }

	  his_self.faction_overlay.render("protestant");
	  his_self.faction_overlay.updateNotice("Protestants advance in Bible Translation");

	  return 1;
        }


	if (mv[0] === "build_saint_peters_with_cp") {

	  let ops = parseInt(mv[1]);

	  this.game.queue.splice(qe, 1);

          for (let i = 0; i < ops; i++) {
            his_self.game.queue.push("build_saint_peters");
          }

	  return 1;

	}

        if (mv[0] === "build_saint_peters") {

	  this.game.queue.splice(qe, 1);

	  if (this.game.state.saint_peters_cathedral['vp'] < 5) {
	    this.updateLog("Papacy builds St. Peter's Basilica");
	    this.game.state.saint_peters_cathedral['state'] += 1;
	    if (this.game.state.saint_peters_cathedral['state'] >= 5) {
	      this.game.state.saint_peters_cathedral['state'] = 0;
	      this.updateLog(this.returnFactionName("papacy") + " +1 VP from St. Peter's Basilica");
	      this.game.state.saint_peters_cathedral['vp'] += 1;
	    }
	  }

	  his_self.faction_overlay.render("papacy");
	  his_self.faction_overlay.updateNotice("Papacy progresses with Saint Peter's Construction");

	  return 1;

	}

        if (mv[0] === "victory_determination_phase") {

	  this.game.queue.splice(qe, 1);

	  let f = this.calculateVictoryPoints();

	  for (let faction in f) {
	    if (f[faction].victory == 1) {
	      //
	      // show scoring points - situation
	      //
	      this.vp_overlay.render();

	      this.updateLog(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	      this.updateStatus(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	      return 0;
	    }
	  }

          return 1;

        }




        if (mv[0] === "new_world_phase") {

	  this.game.queue.splice(qe, 1);


	  //
	  // new world phase only in > 2P games
	  //
	  if (this.game.players.length > 2) {
	    this.game.queue.push("resolve_new_world_riches_rolls");
	    this.game.queue.push("resolve_new_world_colonies");
	    this.game.queue.push("resolve_new_world_conquests");
	    this.game.queue.push("resolve_new_world_explorations");
	  }

	  //
	  // phase otherwise removed entirely for 2P
	  //
          return 1;

        }
        if (mv[0] === "winter_phase") {

	  this.factionbar.setActive();

	  // show the winter overlay to let people know WTF is happening
	  this.winter_overlay.render("stage2");

	  // unset any sieges
	  this.removeSieges();

	  // Remove loaned naval squadron markers
	  this.returnLoanedUnits();

	  // Flip all debaters to their uncommitted (white) side, and
	  this.restoreDebaters();

	  // unset alliances
	  let powers = ["hapsburg","ottoman","england","france","papacy","protestant"];
	  for (let i = 0; i < powers.length; i++) {
	    for (let z = 0; z < powers.length; z++) {	    
	      if (i != z) {
		this.unsetAllies(powers[i], powers[z]);
	      }
	    }
	  }

	  // remove Renegade Leader if in play
	  let rl_f = "";
	  let rl_s = "";
	  rl_s = his_self.returnSpaceOfPersonage("hapsburg", "renegade");
          if (rl_s) { rl_f = "hapsburg"; }
	  rl_s = his_self.returnSpaceOfPersonage("papacy", "renegade");
          if (rl_s) { rl_f = "papacy"; }
	  rl_s = his_self.returnSpaceOfPersonage("england", "renegade");
          if (rl_s) { rl_f = "england"; }
	  rl_s = his_self.returnSpaceOfPersonage("france", "renegade");
          if (rl_s) { rl_f = "france"; }
	  rl_s = his_self.returnSpaceOfPersonage("ottoman", "renegade");
          if (rl_s) { rl_f = "ottoman"; }
	  rl_s = his_self.returnSpaceOfPersonage("protestant", "renegade");
          if (rl_s) { rl_f = "protestant"; }
	  if (rl_f != "") {
	    for (let key in his_self.game.spaces) {
	      for (let z = 0; z < his_self.game.spaces[key].units[rl_f].length; z++) {
		if (his_self.game.spaces[key].units[rl_f][z].type == "renegade") {
		  his_self.game.spaces[key].units[rl_f].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }

	  // Remove major power alliance markers
	  this.unsetAllies("hapsburg", "papacy");
	  this.unsetAllies("hapsburg", "england");
	  this.unsetAllies("hapsburg", "france");
	  this.unsetAllies("hapsburg", "ottoman");
	  this.unsetAllies("hapsburg", "protestant");
	  this.unsetAllies("papacy", "england");
	  this.unsetAllies("papacy", "france");
	  this.unsetAllies("papacy", "ottoman");
	  this.unsetAllies("papacy", "protestant");
	  this.unsetAllies("england", "france");
	  this.unsetAllies("england", "ottoman");
	  this.unsetAllies("england", "protestant");
	  this.unsetAllies("france", "ottoman");
	  this.unsetAllies("france", "protestant");
	  this.unsetAllies("ottoman", "protestant");

	  // Add 1 regular to each friendly-controlled capital
	  if (this.isSpaceControlled("rome", "papacy")) { this.game.queue.push("build\tland\tpapacy\tregular\trome\t0"); }
	  // only to non-papacy if > 2P game
	  if (this.game.players.length > 2) {
	    if (this.isSpaceControlled("london", "england")) { this.game.queue.push("build\tland\tengland\tregular\tlondon\t0"); }
	    if (this.isSpaceControlled("paris", "france")) { this.game.queue.push("build\tland\tfrance\tregular\tparis\t0"); }
	    if (this.isSpaceControlled("valladolid", "hapsburg")) { this.game.queue.push("build\tland\thapsburg\tregular\tvalladolid\t0"); }
	    if (this.isSpaceControlled("vienna", "hapsburg")) { this.game.queue.push("build\tland\thapsburg\tregular\tvienna\t0"); }
	    if (this.isSpaceControlled("istanbul", "ottoman")) { this.game.queue.push("build\tland\tottoman\tregular\tistanbul\t0"); }
	  }

	  // Remove all piracy markers
	  // ResolvespecificMandatoryEventsiftheyhavenotoccurred by their “due date”.

	  //
	  // Clement VII takes the Papacy by the end of round two
	  //
	  if (this.game.state.round == 2 && this.game.state.events.clement_vii != 1) {
	    this.game.queue.push("display_custom_overlay\t010");
	    this.game.queue.push("remove\tpapacy\t010");
	    this.game.queue.push("event\tpapacy\t010");
	  }
	  //
	  // Paul III takes the Papacy by the end of round 4
	  //
	  if (this.game.state.round == 4 && this.game.state.events.paul_iii != 1) {
	    this.game.queue.push("display_custom_overlay\t014");
	    this.game.queue.push("remove\tpapacy\t014");
	    this.game.queue.push("event\tpapacy\t014");
	  }
	  //
	  // Barbary Pirates form by end of round 3 (not in 2P game)
	  //
	  if (this.game.players.length > 2 && this.game.state.round == 3 && this.game.state.events.barbary_pirates != 1) {
	    this.game.queue.push("display_custom_overlay\t009");
	    this.game.queue.push("remove\tottoman\t009");
	    this.game.queue.push("event\tottoman\t009");
	  }
	  //
	  // Society of Jesus forms by end of round 6
	  //
	  if (this.game.state.round == 6 && this.game.state.events.society_of_jesus != 1) {
	    this.game.queue.push("ACKNOWLEDGE\tTurn 6: Society of Jesus Forms");
	    this.game.queue.push("remove\tprotestant\t015");
	    this.game.queue.push("event\tprotestant\t015");
	  }
	  //
	  // form Schmalkaldic League if unformed by end of round 4
	  //
	  if (this.game.state.round == 4 && this.game.state.events.schmalkaldic_league != 1) {
	    this.game.queue.push("ACKNOWLEDGE\tTurn 4: Schmalkaldic League Forms");
	    this.game.queue.push("remove\tprotestant\t013");
	    // custom overlay is shown here
	    this.game.queue.push("event\tprotestant\t013");
	  }

	  // Return naval units to the nearest port
	  this.game.queue.push("retreat_to_winter_ports");

	  // Return leaders and units to fortified spaces (suffering attrition if there is no clear path to such a space)
	  this.game.queue.push("retreat_to_winter_spaces");

	  this.game.queue.splice(qe, 1);
          return 1;
        }


	// must be removed by RESOLVES -- but handled automatically
	if (mv[0] === "check_interventions") {

	  this.updateStatus("preparing for Action Phase...");

	  if (this.game.confirms_needed[this.game.player-1] == 1) {

	    //
	    // we do not want to run this command multiple times, sending 
	    // extra RESOLVES because we receive another RESOLVE before 
	    // ours, so we swap out this for a HALTED command.
	    //
	    this.game.queue[his_self.game.queue.length-1] = "halted";
	    this.addMove("RESOLVE\t"+this.publicKey);

	    //
	    // Wartburg permits intervention in events
	    //
	    if (this.game.player == this.returnPlayerOfFaction("protestant")) {
              let fhand_idx = this.returnFactionHandIdx(this.game.player, "protestant");
	      for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	        if (this.game.deck[0].fhand[fhand_idx][i] == "037") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t1");
		  i == this.game.deck[0].fhand[fhand_idx].length+1;
	        };
	      }
	    }

	    //
	    // Gout and Foul Weather block moves
	    //
	    for (let z = 0; z < this.game.deck[0].fhand.length; z++) {
	      for (let i = 0; i < this.game.deck[0].fhand[z].length; i++) {
	        if (this.game.deck[0].fhand[z][i] == "032" || this.game.deck[0].fhand[z][i] == "031") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t1");
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t1");
		  i = this.game.deck[0].fhand[z].length+1;
	        };
	      }
	    }

	    this.endTurn();

	  }

          return 0;

	}



        if (mv[0] === "action_phase") {

	  this.winter_overlay.hide();

	  this.game.state.impulse++;

	  let targs = {
      	    line1 : "new to", 
    	    line2 : "game",
    	    fontsize : "2.1rem" ,
	  }

//
// Game Help Menu first Turn
//
if (this.game.state.round == 1 && this.game.state.impulse == 1) {
          if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
	    targs.line2 = "protestants";
            this.game_help.renderCustomOverlay("protestant", targs);
          } else {
            if (this.game.player == this.returnPlayerCommandingFaction("ottoman")) {
	      targs.line2 = "ottomans";
              this.game_help.renderCustomOverlay("ottoman", targs);
            } else {
              if (this.game.player == this.returnPlayerCommandingFaction("hapsburg")) {
	        targs.line2 = "hapsburgs";
                this.game_help.renderCustomOverlay("hapsburg", targs);
              } else {
                if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
	          targs.line2 = "papacy";
                  this.game_help.renderCustomOverlay("papacy", targs);
                } else {
                  if (this.game.player == this.returnPlayerCommandingFaction("england")) {
	            targs.line2 = "england";
                    this.game_help.renderCustomOverlay("england", targs);
                  } else {
                    if (this.game.player == this.returnPlayerCommandingFaction("france")) {
	              targs.line2 = "france";
                      this.game_help.renderCustomOverlay("france", targs);
                    } else {
                    }
                  }
                }
              }
            }
          }
}

	  //
	  // check if we are really ready for a new round, or just need another loop
	  // until all of the players have passed. note that players who have passed 
	  // and have more than their admin_rating (saved cards) are forced to eventually
	  // stop passing and play....
	  //
	  let factions_in_play = [];
	  let factions_force_pass = [];


	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	      let faction = this.game.state.players_info[i].factions[z];
	      if (this.game.state.players_info[i].factions_passed[z] == false) {
		if (!this.game.state.skip_next_impulse.includes(this.game.state.players_info[i].factions[z])) {
		  factions_in_play.push(this.game.state.players_info[i].factions[z]);
		} else {
		  for (let ii = 0; ii < this.game.state.skip_next_impulse.length; ii++) {
		    if (this.game.state.skip_next_impulse[ii] === this.game.state.players_info[i].factions[z]) {
		      this.game.state.skip_next_impulse.splice(ii, 1);
		      factions_force_pass.push(this.game.state.players_info[i].factions[z]);
		    }
		  }
		}
	      } else {
		// they passed but maybe they have more cards left than their admin rating?
		let far = this.factions[faction].returnAdminRating(this);
	        if (far < this.game.state.cards_left[faction]) {
		  factions_in_play.push(this.game.state.players_info[i].factions[z]);
	        }
	      }
	    }
	  }

	  //
	  // if anyone is left to play, everyone with cards left needs to pass again
	  //
          if (factions_in_play.length > 0) {
	    for (let i = 0; i < this.game.state.players_info.length; i++) {
	      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	        let f = this.game.state.players_info[i].factions[z];
	        if (!factions_in_play.includes(f) && !factions_force_pass.includes(f)) {

		  let is_activated_power = false;
	          let io = this.returnImpulseOrder();
		  for (let y = 0; y < io.length; y++) {
		    if (this.game.state.activated_powers[io[y]].includes(f)) { is_activated_power = true; }
		  }
		  if (!is_activated_power) {
	    	    factions_in_play.push(f);
		  }
	        }
	      }
	    }
	  }


	  //
	  // players still to go...
	  //
	  if (factions_in_play.length > 0) {


	    //
	    // add save instruction!
	    //
	    this.game.queue.push("SAVE");

	    let io = this.returnImpulseOrder();
	    for (let i = io.length-1; i >= 0; i--) {
	      for (let k = 0; k < factions_in_play.length; k++) {
	        if (factions_in_play[k] === io[i]) {
	          this.game.queue.push("play\t"+io[i]);
		  k = factions_in_play.length+2;
	        }
	      }
	      for (let k = 0; i < factions_force_pass.length; k++) {
	        if (factions_force_pass[k] === io[i]) {
	          this.game.queue.push("skipturn\t"+io[i]);
		  k = factions_force_pass.length+2;
	        }
	      }
	    }
	    return 1;
	  }

	  //
	  // move past action phase if no-one left to play
	  //
	  this.game.queue.splice(qe, 1);
          return 1;
        }

        if (mv[0] === "spring_deployment_phase") {

	  this.game.queue.splice(qe, 1);

	  //
	  // hide winter overlay
	  //
	  this.game_help.hide();
	  this.winter_overlay.hide();


//
// hide any other help (scoring!);
//
if (this.game.state.round > 1) {
  this.game_help.hide();
}
//
//
//
if (this.game.player == this.returnPlayerCommandingFaction("papacy") && this.round == 1) {
  this.game_help.render(TutorialTemplate, {
    help : `Spring Deployment` ,
    content : `
	Spring Deployment takes place at the start of every round. It allows players
 	to move units from their capital to any space connected to it via a line of 
	uninterrupted control.
	<p></p>
	The Papacy normally skips Spring Deployment in the first round. Later in the game
	it often uses Spring Deployment to move troops north into Europe to assist with
	Counter-Reformation attempts.
    `,
    line1 : "spring" ,
    line2 : "deployment" ,
    fontsize : "2.1rem" ,
    img : `/his/img/backgrounds/tutorials/spring_deployment.jpeg`,
  });
}


	  if (this.game.players.length === 2) {
	    // only papacy moves units
	    this.game.queue.push("spring_deployment\tpapacy");
	  } else {
	    // all players can move units
	    let io = this.returnImpulseOrder();
	    for (let i = io.length-1; i >= 0; i--) {
	      if (this.isFactionInPlay(io[i])) {
		this.game.queue.push("spring_deployment\t"+io[i]);
	      }
	    }
	  }

          return 1;
        }
        if (mv[0] === "spring_deployment") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  if (faction === "protestant") { return 1; }
	  if (player == 0) { return 1; }

	  if (this.game.player == player) {
	    this.playerPlaySpringDeployment(faction, player);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " Spring Deployment");
	  }

	  return 0;

	}

	//
	// this is a 3P++ game
	//
        if (mv[0] === "diplomacy_reject") {
	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];

	  let idx = parseInt(mv[2]);
	  let proposal = this.game.state.diplomacy[idx];
	  let terms = this.convertTermsToText(idx);
	  for (let i = terms.length-1; i >= 0; i--) { this.updateLog("  "+terms[i]); }
	  this.updateLog(this.returnFactionName(faction) + " rejects " + this.returnFactionName(proposal.proposer) + " offer:");
	  this.game.state.diplomacy.splice(idx, 1);
	  return 1;

	}
        if (mv[0] === "diplomacy_accept") {

	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let idx = parseInt(mv[2]);

	  let proposal = this.game.state.diplomacy[idx];
	  let terms = this.convertTermsToText(proposal);
	  for (let i = terms.length-1; i >= 0; i--) { this.updateLog("  "+terms[i]); }
	  this.updateLog(this.returnFactionName(faction) + " accepts " + this.returnFactionName(proposal.proposer) + " offer:");

	  for (let i = 0; i < proposal.parties.length; i++) { 
	    if (!proposal.confirms) { proposal.confirms = []; }
	    if (proposal.confirms.length < (i+1)) { proposal.confirms.push(0); }
	    if (proposal.parties[i] === faction || proposal.parties[i] === proposal.proposer) {
	      proposal.confirms[i] = 1;
	    }
	  }

	  let all_confirmed = true;
	  for (let i = 0; i < proposal.confirms.length; i++) { 
	    if (proposal.confirms[i] != 1) {
	     all_confirmed = false;
	    }
	  }

	  if (all_confirmed == true) {
	    this.updateLog(this.returnFactionName(proposal.proposer) + " offer takes effect.");
	    for (let i = proposal.terms.length-1; i >= 0; i--) {
	      this.game.queue.push(proposal.terms[i]);
	    }
	    this.game.state.diplomacy.splice(idx, 1);
	    this.diplomacy_propose_overlay.purgeProposals();
	  }

	  return 1;

	}
        if (mv[0] === "diplomacy_phase") {

	  this.game.queue.splice(qe, 1);

if (this.game.state.round == 1) {
this.game_help.render(TutorialTemplate, {
  help : `What is the Diplomacy Phase?` ,
    content : `       
        
In the Diplomacy Phase, factions propose and accept binding agreements in Impulse Order, starting with the Ottoman Empire, Hapsburg Empire, England, France, Papacy and finishing with the Protestants. Proposals cannot be offered by a later faction to an earlier faction, so if a later faction desires an agreement with the Ottomans they must propose it.

	<p></p>

Players are allowed to communicate in secret during this phase. The most commonly negotiated terms are Alliances, which permit factions to move through spaces controlled by their allies, join forces to fight common enemies and retreat into allied spaces if defeated in battle. Factions can also "spring deploy" through allied territory as if it is their own. Factions can also agree to terminate a war, offer bonus cards, or yield strategic keys.

	<p></p>

If this is your first game, it is usually fine to skip the diplomacy phase until you have a better sense of how the game plays.

    `,              
    img : "/his/img/backgrounds/tutorials/diplomacy.jpg",
    line1 : "what is", 
    line2 : "diplomacy?",
    fontsize : "2.1rem" ,
});  
}
	  this.game.state.diplomacy = [];

	  if (this.game.players.length == 2) {
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\tprotestant");
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\tpapacy");
	    return 1;
	  }

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\t"+io[i]);
	  }

	  return 1;

	}

	if (mv[0] === "confirm_diplomatic_proposal") {

	  let faction = mv[1];
	  let proposal_idx = parseInt(mv[2]);
	  let proposal = this.game.state.diplomacy[proposal_idx];
	  let player = this.returnPlayerOfFaction(faction);

	  if (this.game.player == player) {
	    this.diplomacy_confirm_overlay.render(faction, proposal_idx);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " reviewing diplomatic proposal...");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}

	if (mv[0] === "confirm_and_propose_diplomatic_proposals") {

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  this.winter_overlay.render("stage6");

	  //
	  // first, if there are any outstanding proposals that
	  // involve this faction, we need to ask them one-by-one
	  // if they agree or disagree. if they agree and are the
	  // last to agree, it will immediately execute.
	  //
	  let anything_to_review = false;
	  for (let i = 0; i < this.game.state.diplomacy.length; i++) {
	    if (this.game.state.diplomacy[i].parties.includes(faction)) {
	      for (let z = 0; z < this.game.state.diplomacy[i].parties.length; z++) {
		if (this.game.state.diplomacy[i].parties[z] == faction && this.game.state.diplomacy[i].confirms[z] != 1) {
	          this.game.queue.push("confirm_diplomatic_proposal\t"+faction+"\t"+i);
	          anything_to_review = true;
	        }
	      }
	    }
	  }
	  if (anything_to_review) { 
	    // we have pushed to the queue, so will return and pass-
	    // through when all proposals are fine.
	    return 1;
	  }

	  //
	  // protestants cannot make new proposals....
	  //
	  if (faction === "protestant") {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // there are no proposals left
	  //
	  if (player === this.game.player) {
	    // makes sure old data purged from last faction we did
	    this.diplomacy_propose_overlay.purgeProposals();
	    this.diplomacy_propose_overlay.render(faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering diplomatic proposals");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}



	if (mv[0] === "remove_excommunication") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];

          if (this.game.state.excommunicated_factions[faction] != 1) { return 1; }

	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.playerManuallyRemoveExcommunication(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering Removing Excommunication");
	  }

	  return 0;

	}




	if (mv[0] === "sue_for_peace") {

	  this.game.queue.splice(qe, 1);

	  this.winter_overlay.render("stage7");

	  let faction = mv[1];
	  let can_faction_sue_for_peace = this.canFactionSueForPeace(faction);

	  if (can_faction_sue_for_peace.length == 0) { return 1; }


	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.playerSueForPeace(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering Peace Suit");
	  }

	  return 0;

	}



	if (mv[0] === "make_declarations_of_war") {

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  this.winter_overlay.render("stage8");

	  if (this.game.player == player) {
	    this.playerMakeDeclarationsOfWar(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering Declarations of War");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}



        if (mv[0] === "diplomacy_phase_2P") {

	  //
	  // hide winter overlay
	  //
	  this.winter_overlay.hide();

	  // removed besieged spaces
	  this.removeBesiegedSpaces();

	  //
	  // remove french, hapsburg and ottoman army leaders
	  //
	  let rf = ["hapsburg", "france", "ottoman"];
	  for (let key in this.game.spaces) {
	    for (let z = 0; z < rf.length; z++) {
	      let f = rf[z];
	      for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
		let u = this.game.spaces[key].units[f][i];
		if (u.army_leader || u.navy_leader) {
		  this.game.spaces[key].units[f].splice(i, 1);
		  i--;
		  this.displaySpace(key);
		}
	      }
	    }
	  }

//
// Papacy 
//
/***********
if (this.game.state.round == 2) {
  this.game_help.render(TutorialTemplate, {
    help : `Diplomacy Phase` ,
    content : `
	In the two-player version of Here I Stand, the Diplomatic Stage starts with the Papacy having the option
	to end any wars it is in with third powers such as France or the Ottomans. Terminating any war will give 
	the Protestants a "War Winner" VP.
	</p></p>
	Both players are then dealt two cards from a special Diplomatic Deck and must choose one to event. These
	cards trigger actions affecting the other factions on the board.
	<p></p>
	If diplomatic events put a player at war with either the Papacy or the Protestants, that faction can be 
	controlled by the opposing faction during their turn. Once the Schmalkaldic League has formed, for instance,
	the Papacy also controls the Hapsburgs.
    `,
    line1 : "learn" ,
    line2 : "diplomacy" ,
    fontsize : "2.1rem" ,
    img : `/his/img/backgrounds/tutorials/the_ambassadors_depart.png`,
  });
}
******/     


	  //
	  // multiplayer has diplomacy phase
	  //
	  if (this.game.players.length > 2) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // no diplomacy phase round 1
	  //
	  if (this.game.state.round == 1 || (this.game.state.round <= this.game.state.starting_round)) {

            this.game.queue.push("SHUFFLE\t2");
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKENCRYPT\t2\t"+(i));
	    }
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKXOR\t2\t"+(i));
	    }

	    let new_cards = this.returnNewDiplomacyCardsForThisTurn(this.game.state.round);
    	    this.game.queue.push("DECK\t2\t"+JSON.stringify(new_cards));

	    this.game.queue.splice(qe, 1);
	    return 1;

	  }

	  //
	  // 2-player game? both players play a diplomacy card
	  // AFTER they have been dealt on every turn after T1
	  //
	  if (this.game.state.round > 1) {
    	    this.game.queue.push("play_diplomacy_card\tprotestant");
    	    this.game.queue.push("play_diplomacy_card\tpapacy");
	  }

	  //
	  // 2-player game? Diplomacy Deck
	  //
	  if (this.game.players.length == 2) {

	    let cards_to_deal = 2;
	    if (this.game.state.round > 2) { cards_to_deal = 1; }

	    for (let i = this.game.state.players_info.length-1; i >= 0; i--) {
	      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
    	        this.game.queue.push("DEAL\t2\t"+(i+1)+"\t"+cards_to_deal);
	      }
	    }
            this.game.queue.push("SHUFFLE\t2");
            this.game.queue.push("DECKRESTORE\t2");
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKENCRYPT\t2\t"+(i));
	    }
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKXOR\t2\t"+(i));
	    }
	    let new_cards = this.returnNewDiplomacyCardsForThisTurn(this.game.state.round);
    	    this.game.queue.push("DECK\t2\t"+JSON.stringify(new_cards));
            this.game.queue.push("DECKBACKUP\t2");
	  }

	  //
	  // The Papacy may end a war they are fighting by playing Papal Bull or by suing for peace. -- start of diplomacy phase
	  //
          let is_papacy_at_war = false;
          let factions = ["genoa","venice","scotland","ottoman","france","england","hungary","hapsburg"];
          for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { is_papacy_at_war = true; } }
          if (is_papacy_at_war == true) {
            this.game.queue.push("papacy_diplomacy_phase_special_turn");
            this.game.queue.push("counter_or_acknowledge\tPapacy Special Diplomacy Phase");
  	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
          }

	  this.game.queue.splice(qe, 1);
          return 1;

        }


	if (mv[0] === "war_loser_regain_leaders_for_vp_or_cards") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];
	
	  let p2 = this.returnPlayerCommandingFaction(winner);
          let target_leaders = 0;

          for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
            if (his_self.game.state.players_info[p2-1].captured[z].faction == loser) {
              target_leaders++;
            }
          }

	  if (target_leaders == 0) { return 1; }
	
	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainLeadersForVPOrCards(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Leaders");
	  }

          return 0;

        }


	if (mv[0] === "war_loser_regain_spaces_for_vp_or_cards") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];

          let target_spaces = his_self.countSpacesWithFilter(
            function(space) {
              if (space.home == loser && space.political == winner) { return 1; }
	      return 0;
	    }
          );

	  if (target_spaces < 2) { return 1; }
 
	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainSpacesForVPOrCards(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Home Keys");
	  }

          return 0;

        }

	if (mv[0] === "war_loser_regain_keys_for_vp") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];

	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainKeysForVP(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Home Keys");
	  }

          return 0;

        }

	if (mv[0] === "player_play_papacy_regain_spaces_for_vp") {

	  this.game.queue.splice(qe, 1);

          let enemies = [];
	  let factions = ["genoa","venice","scotland","ottoman","france","england","hungary","hapsburg"];
	  for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { enemies.push(factions[i]); } }

	  if (this.game.player == this.returnPlayerOfFaction("papacy")) {
	    this.playerPlayPapacyRegainSpacesForVP();
	  } else {
	    this.updateStatus("Papacy Considering Regaining Spaces");
	  }

          return 0;

	}


	if (mv[0] === "papacy_diplomacy_phase_special_turn") {

	  this.game.queue.splice(qe, 1);

	  let is_papacy_at_war = false;
          let enemies = [];
	  let factions = ["ottoman","france","england","hapsburg"];
	  for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { enemies.push(factions[i]); is_papacy_at_war = true; } }

	  if (is_papacy_at_war == false) {
	    this.updateLog("Papacy is not at War, skipping special pre-diplomacy stage...");
	    return 1;
	  }

	  if (this.game.player == this.returnPlayerOfFaction("papacy")) {
	    this.playerPlayPapacyDiplomacyPhaseSpecialTurn(enemies);
	  } else {
	    this.updateStatus("Papacy Considering Diplomatic Options to End War");
	  }

          return 0;

        }

	if (mv[0] === "unset_enemies") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetEnemies(f1, f2);
	  this.game.queue.splice(qe, 1);

	  this.displayWarBox();

	  return 1;
	  
	}
        if (mv[0] === "unset_allies") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetAllies(f1, f2);
	  this.game.queue.splice(qe, 1);

	  this.displayWarBox();

	  return 1;
	  
	}

	if (mv[0] === "display_vp_track") {
	
	  this.displayVictoryTrack();
	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "display_new_world") {
	  this.game.queue.splice(qe, 1);
	  this.displayNewWorld();
	  return 1;
	}


	if (mv[0] === "war") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let locale = mv[2];

	  this.game.queue.push("field_battle\t"+locale+"\t"+faction);

	  return 1;

	}

	if (mv[0] === "natural_ally_intervention") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let natural_ally = mv[2];
	  let enemy = mv[3];
	  let cost = parseInt(mv[4]);
	  let reason = mv[5];
	  let his_self = this;

	  let p = this.returnPlayerOfFaction(faction);
	  if (p == 0) { return 1; }

	  if (this.game.player == p) {

	    if (!this.canPlayerSelectOps(faction, cost)) {
	      his_self.endTurn();
	      return 0;
	    }

	    if (p === this.game.player) {

              let msg = "Intervene for " + this.returnFactionName(natural_ally) + " against " + this.returnFactionName(enemy);
	      if (cost > 0) { msg += " (cost: "+cost+")"; }
              let html = '<ul>';
              html += `<li class="option" id="yes">declare war</li>`;
              html += `<li class="option" id="no">do not intervene</li>`;
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                his_self.updateStatus("acknowledge...");
                let action = $(this).attr("id");

	        if (action === "yes") {
	  	  if (cost > 0) {
		    his_self.playerSelectOps(faction, cost, (card) => {
		      his_self.addMove("discard\t"+faction+"\t"+card);
	              his_self.addMove("unexpected_war\t"+faction+"\t"+enemy);
		      his_self.addMove("declare_war\t"+faction+"\t"+enemy);
		      his_self.addMove("set_allies\t"+faction+"\t"+natural_ally);
		      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" declares war");
		      his_self.endTurn();
		    });
		  } else {
	            his_self.addMove("unexpected_war\t"+faction+"\t"+enemy);
		    his_self.addMove("declare_war\t"+faction+"\t"+enemy);
		    his_self.addMove("set_allies\t"+faction+"\t"+natural_ally);
		    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" declares war");
		    his_self.endTurn();
		  }
	        }

	        if (action === "no") {
		  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" defers to intervene");
		  his_self.endTurn();
	        }

	      });	
	    }	
	  } else {
            this.updateStatus(this.returnFactionName(faction) + " considering intervening for " + this.returnFactionName(natural_ally) + " against " + this.returnFactionName(enemy));
	  }

	  return 0;

	}


	if (mv[0] === "declare_peace" || mv[0] === "set_peace" || mv[0] === "end_war") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetEnemies(f1, f2);
	  this.game.queue.splice(qe, 1);

	  this.displayWarBox();

	  return 1;

	}

	if (mv[0] === "declare_war" || mv[0] === "set_enemies") {

	  this.game.queue.splice(qe, 1);

	  let f1 = mv[1];
	  let f2 = mv[2];
	  let skip_natural_ally_intervention = 0;
	  if (parseInt(mv[3])) { skip_natural_ally_intervention = 1; }

	  this.updateLog(this.returnFactionName(f1) + " declares war on " + this.returnFactionName(f2));

  	  this.setEnemies(f1, f2);

	  if (!skip_natural_ally_intervention) {
	    if (f2 == "scotland") {
	      his_self.game.queue.push(`natural_ally_intervention\tfrance\tscotland\t${f1}\t2\t${this.returnFactionName(f1)} declares war on Scotland`);
	    }
	    if (f2 == "venice") {
	      his_self.game.queue.push(`natural_ally_intervention\tpapacy\tvenice\t${f1}\t2\t${this.returnFactionName(f1)} declares war on Venice`);
	    }
	  }


	  this.displayWarBox();

	  return 1;

	}

	if (mv[0] === "declare_alliance" || mv[0] === "set_allies") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.setAllies(f1, f2);
	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "unset_activated_power") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetActivatedPower(f1, f2);
	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "set_activated_power" || mv[0] === "set_activated_powers") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.setActivatedPower(f1, f2);
	  this.game.queue.splice(qe, 1);

	  return 1;

	}



	//
	// this checks we have not been dealt a removed card (can happen if Clement VII is floating 
	// around the undealt cards and removed. and asks for a new one if this is the case.
	//
	if (mv[0] === "check_replacement_cards") {

	  this.game.queue.splice(qe, 1);
	  faction = mv[1];

	  let num = 0;
	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player == p) {

	    this.updateStatus("checking "+this.returnFactionName(faction)+" has no removed cards...");

            let fhand_idx = this.returnFactionHandIdx(p, faction);
	
	    if (fhand_idx == -1) {

	      //
	      // TESTING can trigger but we are good - continue!
	      //
	      this.endTurn();
	      return;

	    }

  	    while (this.game.deck[0].fhand.length < (fhand_idx+1)) { this.game.deck[0].fhand.push([]); }
	    for (let zz = 0; zz < this.game.deck[0].fhand[fhand_idx].length; zz++) {
	      let c = this.game.deck[0].fhand[fhand_idx][zz];
	      if (this.game.state.removed.includes(c)) {
	        this.game.deck[0].fhand[fhand_idx].splice(zz, 1);
		num++;
		zz--;
	      }
	    }

	    //
	    // we need a new/replacement card
	    //
	    if (num > 0) {

	      //
	      // not good - deal another!
	      //
	      this.addMove("check_replacement_cards\t"+faction);
    	      this.addMove("hand_to_fhand\t1\t"+p+"\t"+faction);
    	      this.addMove("DEAL\t1\t"+p+"\t"+(num));
	      this.endTurn();

	    } else {

	      //
	      // we are good - continue!
	      //
	      this.endTurn();
	    }

	  } else {
	    this.updateStatus("checking "+this.returnFactionName(faction)+" has no removed cards...");
	  }

	  return 0;

	}

        if (mv[0] === "card_draw_phase") {

	  if (this.game.state.round > 1) {
	    this.winter_overlay.render("stage5");
	  }


	  //
	  // deal cards and add home card
	  //
	  for (let i = this.game.state.players_info.length-1; i >= 0; i--) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {

	      //
	      // sanity check we are major power
	      //
	      let f = this.game.state.players_info[i].factions[z];

	      if (f === "protestant" || f === "hapsburg" || f === "papacy" || f === "england" || f === "ottoman" || f === "france") {

                let cardnum = this.factions[this.game.state.players_info[i].factions[z]].returnCardsDealt(this);

		//
		// is_testing
		//
		if (this.game.options.scenario == "is_testing") { cardnum = 5; }

	        //
	        // fuggers card -1
	        //
                if (this.game.state.events.fuggers === this.game.state.players_info[i].factions[z]) {
		  cardnum--;
	  	  this.game.state.events.fuggers = "";
	        }

	        //
	        // war in persia
	        //
                if (this.game.state.events.war_in_persia == 1 && f === "ottoman") {
		  this.updateLog("Ottomans penalized -1 card for War in Persia");
		  cardnum--;
	        }

	        //
	        // war in egypt
	        //
                if (this.game.state.events.revolt_in_egypt == 1 && f === "ottoman") {
		  this.updateLog("Ottomans penalized -1 card for Revolt in Egypt");
		  cardnum--;
	        }

	        //
	        // war in egypt
	        //
                if (this.game.state.events.revolt_in_ireland == 1 && f === "england") {
		  this.updateLog("Ottomans penalized -1 card for Revolt in Ireland");
		  cardnum--;
	        }

		//
		// new world card bonus
		//
	  	if (f == "england" && this.game.state.new_world_bonus['england'] > 0) { cardnum += this.game.state.new_world_bonus['england']; }
	  	if (f == "france" && this.game.state.new_world_bonus['france'] > 0) { cardnum += this.game.state.new_world_bonus['france']; }
	  	if (f == "hapsburg" && this.game.state.new_world_bonus['hapsburg'] > 0) { cardnum += this.game.state.new_world_bonus['hapsburg']; }
	  	if (f == "ottoman" && this.game.state.new_world_bonus['ottoman'] > 0) { cardnum += this.game.state.new_world_bonus['ottoman']; }
	  	if (f == "papacy" && this.game.state.new_world_bonus['papacy'] > 0) { cardnum += this.game.state.new_world_bonus['papacy']; }
	  	if (f == "protestant" && this.game.state.new_world_bonus['protestant'] > 0) { cardnum += this.game.state.new_world_bonus['protestant']; }

		//
		// sanity check
		//
		if (cardnum < 0) { cardnum = 0; }

//cardnum = 1;
//if (f == "papacy") { cardnum = 0; }
//if (f == "hapsburg") { cardnum = 0; }

    	        this.game.queue.push("check_replacement_cards\t"+this.game.state.players_info[i].factions[z]);
    	        this.game.queue.push("hand_to_fhand\t1\t"+(i+1)+"\t"+this.game.state.players_info[i].factions[z]);
    	        this.game.queue.push("add_home_card\t"+(i+1)+"\t"+this.game.state.players_info[i].factions[z]);
    	        this.game.queue.push("DEAL\t1\t"+(i+1)+"\t"+(cardnum));

		//
	        // try to update cards_left
		//
	        if (!this.game.state.cards_left[this.game.state.players_info[i].factions[z]]) {
	          this.game.state.cards_left[this.game.state.players_info[i].factions[z]] = 0;
	        }
	        this.game.state.cards_left[this.game.state.players_info[i].factions[z]] += cardnum;

		//
		// and display cards left
		//
		this.displayCardsLeft();

	      }
	    }
	  }

	  //
	  // DECKRESTORE copies backed-up back into deck
	  //
          this.game.queue.push("SHUFFLE\t1");
          this.game.queue.push("DECKRESTORE\t1");

	  for (let i = this.game.state.players_info.length; i > 0; i--) {
    	    this.game.queue.push("DECKENCRYPT\t1\t"+(i));
	  }
	  for (let i = this.game.state.players_info.length; i > 0; i--) {
    	    this.game.queue.push("DECKXOR\t1\t"+(i));
	  }

	  //
	  // re-add discards
	  //
	  let discards = {};
	  for (let i in this.game.deck[0].discards) {
      	    discards[i] = this.game.deck[0].cards[i];
      	    delete this.game.deck[0].cards[i];
    	  }
	  for (let i in this.game.deck[0].removed) {
      	    delete this.game.deck[0].cards[i];
      	    delete discards[i];
    	  }
	  //
	  // remove any removed cards again for sanity sake (i.e. Clement VII)
	  //
	  for (let z = 0; z < this.game.state.removed.length; z++) {
      	    delete this.game.deck[0].cards[this.game.state.removed[z]];
      	    delete discards[this.game.state.removed[z]];
	  }
    	  this.game.deck[0].discards = {};

	  //
	  // our deck for re-shuffling
	  //
	  let reshuffle_cards = {};
	  for (let key in discards) {
	    if (key !== "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
	      reshuffle_cards[key] = discards[key];
	    }
	  }


	  //
	  // remove home cards 
	  //
	  if (this.game.deck[0].cards['001']) { delete this.game.deck[0].cards['001']; }
	  if (this.game.deck[0].cards['002']) { delete this.game.deck[0].cards['002']; }
	  if (this.game.deck[0].cards['003']) { delete this.game.deck[0].cards['003']; }
	  if (this.game.deck[0].cards['004']) { delete this.game.deck[0].cards['004']; }
	  if (this.game.deck[0].cards['005']) { delete this.game.deck[0].cards['005']; }
	  if (this.game.deck[0].cards['006']) { delete this.game.deck[0].cards['006']; }
	  if (this.game.deck[0].cards['007']) { delete this.game.deck[0].cards['007']; }
	  if (this.game.deck[0].cards['008']) { delete this.game.deck[0].cards['008']; }


	  //
	  // new cards this turn
	  //
	  if (this.game.state.starting_round >= this.game.state.round && this.game.state.starting_round > 1) {
	    this.game.state.round = 0;
	    for (let i = this.game.state.round; i < this.game.state.starting_round; i++) {
	      this.game.state.round++;
	      let deck_to_deal = this.returnNewCardsForThisTurn(this.game.state.round);

console.log("#");
console.log("#");
console.log("#");
console.log("#");
console.log("return new cards for this turn: " + this.game.state.round);

	      for (let key in deck_to_deal) { 
	        if (key !== "001" && key !== "002" && key !== "003" && key !== "004" && key !== "005" && key !== "006" && key !== "007" && key !== "008") {
	          reshuffle_cards[key] = deck_to_deal[key]; 
	        }
	      }
	    }
	  } else {
	    let deck_to_deal = this.returnNewCardsForThisTurn(this.game.state.round);
	    for (let key in deck_to_deal) { 
	      if (key !== "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
	        reshuffle_cards[key] = deck_to_deal[key]; 
	      }
	    }
	  }


console.log("----------------------------");
console.log("---SHUFFLING IN DISCARDS ---");
console.log("----------------------------");
console.log(JSON.stringify(reshuffle_cards));

    	  this.game.queue.push("restore_home_cards_to_deck");
    	  this.game.queue.push("DECK\t1\t"+JSON.stringify(reshuffle_cards));

	  // backup any existing DECK #1
          this.game.queue.push("DECKBACKUP\t1");


	  //
	  // remove any card bonuses
	  //
  	  this.game.state.papacy_card_bonus = 0;
  	  this.game.state.protestant_card_bonus = 0;
  	  this.game.state.ottoman_card_bonus = 0;
  	  this.game.state.france_card_bonus = 0;
  	  this.game.state.england_card_bonus = 0;
  	  this.game.state.hapsburg_card_bonus = 0;


	  this.game.queue.splice(qe, 1);
          return 1;

        }

        if (mv[0] === "restore_home_cards_to_deck") {

	  let d = this.returnDeck();
	  this.deck['008'] = d['008'];
	  this.game.deck[0].cards['001'] = d['001'];
	  this.game.deck[0].cards['002'] = d['002'];
	  this.game.deck[0].cards['003'] = d['003'];
	  this.game.deck[0].cards['004'] = d['004'];
	  this.game.deck[0].cards['005'] = d['005'];
	  this.game.deck[0].cards['006'] = d['006'];
	  this.game.deck[0].cards['007'] = d['007'];
	  this.game.deck[0].cards['008'] = d['008'];
	  this.game.queue.splice(qe, 1);
          return 1;
	}

	// removes from game
	if (mv[0] === "remove") {

	  let faction = mv[1];
	  let card = mv[2];

	  this.game.queue.splice(qe, 1);

	  if (!this.game.state.removed.includes(card)) { 
	    this.updateLog(this.popup(card) + " removed from deck");
	  }
	  this.removeCardFromGame(card);

	  return 1;

	}


	// pull card
	if (mv[0] === "pull_card") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let home_card_permitted = 0;
	  if (parseInt(mv[3]) > 0) { home_card_permitted = 1; }

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p2) {
            let fhand_idx = this.returnFactionHandIdx(p2, faction_giving);
	    let roll = this.rollDice(this.game.deck[0].fhand[fhand_idx].length) - 1;

            let is_this_home_card = 0;
            let pulled = this.game.deck[0].fhand[fhand_idx][roll];
            if (pulled == "001" || pulled == "002" || pulled == "003" || pulled == "004" || pulled == "005" || pulled == "006" || pulled == "007") {
              is_this_home_card = 1;
            }

	    let looped_once = false;
            if (home_card_permitted == 0 && is_this_home_card == 1) {
              while (roll >= 0 && is_this_home_card == 1) {
                is_this_home_card = 0;
                roll--;
                if (roll < 0) {
		  if (looped_once == false) { 
		    looped_once = true;
		    roll = this.game.deck[0].fhand[fhand_idx].length-1;
		  } else {
                    this.addMove("NOTIFY\t"+this.returnFactionName(faction)+ " has no non-home cards to pull");
                    this.endTurn();
                    return 0;
	          }
                }
                let pulled = this.game.deck[0].fhand[fhand_idx][roll];
                if (pulled == "001" || pulled == "002" || pulled == "003" || pulled == "004" || pulled == "005" || pulled == "006" || pulled == "007") {
                  is_this_home_card = 1;
                }
              }
            }

	    let card = this.game.deck[0].fhand[fhand_idx][roll];
	    this.addMove("give_card\t"+faction_taking+"\t"+faction_giving+"\t"+card);
	    this.endTurn();
	  } else {
	    this.rollDice();
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

        }

	// requestreveal hand
	if (mv[0] === "request_reveal_hand") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p2) {
            let fhand_idx = this.returnFactionHandIdx(p2, faction_giving);
	    this.addMove("reveal_hand\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
	    this.endTurn();
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

        }

	// reveal hand
	if (mv[0] === "reveal_hand") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let cards = JSON.parse(mv[3]);

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p1) {
	    for (let i = 0; i < cards.length; i++) {
	      this.updateLog(" * " + this.popup(cards[i]));
	    }
	    this.updateLog(this.returnFactionName(faction_giving) + " Hand: ");
	  }

	  //
	  // does this show our cards
	  //
	  this.deck_overlay.render("hand", cards);

	  this.game.queue.splice(qe, 1);
	  return 1;

        }

	// give card
	if (mv[0] === "give_card") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let card = mv[3];

	  if (card == "undefined") { 
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  this.updateLog(this.returnFactionName(faction_taking) + " pulls " + this.popup(card));

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);
	  this.game.state.last_pulled_card = card;


	  //
	  // update cards left
	  //
	  this.game.state.cards_left[faction_taking] += 1;
	  this.game.state.cards_left[faction_giving] -= 1;
	  if (this.game.state.cards_left[faction_giving] < 0) { 
	    this.game.state.cards_left[faction_taking] -= 1;
	    this.game.state.cards_left[faction_giving] = 0;
	  }
	  this.displayCardsLeft();


	  if (this.game.player == p2) {
	    for (let i = 0; i < this.game.deck[0].fhand.length; i++) {
	      for (let z = 0; z < this.game.deck[0].fhand[i].length; z++) {
		if (this.game.deck[0].fhand[i][z] === card) {
		  this.game.deck[0].fhand[i].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }

	  if (this.game.player == p1) {
            let fhand_idx = this.returnFactionHandIdx(p1, faction_taking);
	    this.game.deck[0].fhand[fhand_idx].push(card);
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

        }

	// fortify a spacekey
	if (mv[0] === "fortify") {

	  let spacekey = mv[1];
	  this.game.spaces[spacekey].fortified = 1;
	  if (this.game.spaces[spacekey].type != "electorate" && this.game.spaces[spacekey].type != "key") { this.game.spaces[spacekey].type = "fortress"; }
	  this.game.queue.splice(qe, 1);

	  this.displaySpace(spacekey);

	  return 1;

	}



	if (mv[0] === "discard_diplomacy_card") {

	  let faction = mv[1];
	  let card = mv[2];
	  let player_of_faction = this.returnPlayerOfFaction(faction);

	  //
	  // move into discards
	  //
	  this.game.deck[1].discards[card] = this.game.deck[1].cards[card];

	  //
	  // and remove from hand
	  //
	  if (this.game.player === player_of_faction) {
	    for (let i = 0; i < this.game.deck[1].hand.length; i++) {
	      if (this.game.deck[1].hand[i] === card) {
		this.game.deck[1].hand.splice(i, 1);
	      }
	    }
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "select_and_discard") {

	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
          let fhand_idx = this.returnFactionHandIdx(player, faction);
	  let cards = [];

	  if (player == this.game.player) {

	    cards = this.game.deck[0].fhand[fhand_idx];
	    if (mv[2]) { cards = JSON.parse(mv[2]); }

            let msg = "Select Card to Discard:";
            let html = '<ul>';
	    let any_choice = false;
	    for (let i = 0; i < cards.length; i++) {
              if (his_self.game.deck[0].cards[cards[i]].type != "mandatory" && parseInt(cards[i]) > 7) {
		any_choice = true;
                html += `<li class="option showcard" id="${cards[i]}">${his_self.game.deck[0].cards[cards[i]].name}</li>`;
              }
            }
            html += '</ul>';

	    if (any_choice == false) { his_self.endTurn(); return; }

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {
              $('.option').off();
              his_self.updateStatus("acknowledge...");
              let action = $(this).attr("id");
              his_self.addMove("discard\t"+faction+"\t"+action);
              his_self.endTurn();
            });
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " selecting discard");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}

        //
        // use "discard" when the card being discarded is known 
        //
	if (mv[0] === "discard") {

	  let faction = mv[1];
	  let card = mv[2];
	  let player_of_faction = this.returnPlayerOfFaction(faction);
	  let already_discarded = false;

	  if (this.game.deck[0].discards[card]) { already_discarded = true; }
	  //
	  // move into discards
	  //
	  this.game.deck[0].discards[card] = this.game.deck[0].cards[card];

	  //
	  // and remove from hand
	  //
	  if (this.game.player === player_of_faction) {
            let fhand_idx = this.returnFactionHandIdx(player_of_faction, faction);
	    for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	      if (this.game.deck[0].fhand[fhand_idx][i] === card) {
		this.game.deck[0].fhand[fhand_idx].splice(i, 1);
	      }
	    }
	  }

	  //
	  // and update cards left
	  //
          if (already_discarded == false && this.game.state.cards_left[faction]) {
            if (this.game.state.cards_left[faction] > 0) {
	      this.game.state.cards_left[faction]--;
	      this.displayCardsLeft();
	    }
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	// skip next impulse
	if (mv[0] === "skip_next_impulse") {

	  let target_faction = mv[1];

	  this.game.state.skip_next_impulse.push(target_faction);

	  this.game.queue.splice(qe, 1);
          return 1;
        }


	if (mv[0] === "unexcommunicate_faction") {

	  let faction = mv[1];
	  this.unexcommunicateFaction(faction);
	  this.game.queue.splice(qe, 1);

          return 1;

	}

	// discards N cards from faction hand
	if (mv[0] === "excommunicate_faction") {

	  let faction = mv[1];
	  this.excommunicateFaction(faction);
	  this.displayCustomOverlay("excommunication", faction);
	  this.game.queue.splice(qe, 1);

          return 1;

	}

	// discards N cards from faction hand
	if (mv[0] === "excommunicate_reformer") {

	  let reformer = mv[1];

	  this.game.queue.splice(qe, 1);

	  this.excommunicateReformer(reformer);
	  this.displayBoard();

          return 1;
        }


	//
	// discards N cards from faction hand
	//
	// this cannot pick the home card
	//
	if (mv[0] === "discard_random") {

	  let faction = mv[1];
	  let home_card_permitted = 0;
	  if (parseInt(mv[2]) > 0) { home_card_permitted = parseInt(mv[2]); }
	  let num = 1;

	  let player_of_faction = this.returnPlayerOfFaction(faction);

	  this.game.queue.splice(qe, 1);

	    if (this.game.player == player_of_faction) {

              let fhand_idx = this.returnFactionHandIdx(player_of_faction, faction);
	      let num_cards = this.game.deck[0].fhand[fhand_idx].length;
	      if (num_cards == 0) {
		this.rollDice(6);
		this.addMove("NOTIFY\t"+this.returnFactionName(faction)+ " has no cards to discard");
		this.endTurn();
		return 0;
	      }

	      let discards = [];
	      if (num_cards < num) { num = num_cards; }
	      let roll = this.rollDice(num_cards) - 1;
	      let is_this_home_card = 0;
	      let pulled = this.game.deck[0].fhand[fhand_idx][roll];
	      if (pulled === "001" || pulled === "002" || pulled === "003" || pulled === "004" || pulled === "005" || pulled === "006" || pulled === "007") {
		is_this_home_card = 1;
	      }

	      if (home_card_permitted == 0 && is_this_home_card == 1) {
		let is_looped = false;
	        while (roll >= 0 && is_this_home_card == 1) {
		  is_this_home_card = 0;
		  roll--;
		  if (roll == -1) {
		    if (is_looped == true) {
		      this.addMove("NOTIFY\t"+this.returnFactionName(faction)+ " has no non-home cards to discard");
		      this.endTurn();
		      return 0;
		    } else {
		      is_looped = true;
		      roll = this.game.deck[0].fhand[fhand_idx].length-1;
		    }
		  }
	      	  let pulled = this.game.deck[0].fhand[fhand_idx][roll];
	      	  if (pulled === "001" || pulled === "002" || pulled === "003" || pulled === "004" || pulled === "005" || pulled === "006" || pulled === "007") {
		    is_this_home_card = 1;
		  }
		}
	      }

	      discards.push(roll);
	      discards.sort();
	      for (let zz = 0; zz < discards.length; zz++) {
	        this.addMove("discard\t"+faction+"\t"+this.game.deck[0].fhand[fhand_idx][discards[zz]]);
	        this.addMove("NOTIFY\t"+this.returnFactionName(faction)+" discards "+this.popup(this.game.deck[0].fhand[fhand_idx][discards[zz]]));
	      }
	      this.endTurn();

	    } else {
	      this.rollDice(6);
	    }


	  return 0;

	}

	if (mv[0] === "skipturn") {

	    this.game.queue.splice(qe, 1);
	    return 1;
	}

        if (mv[0] === "play") {

	  let faction = mv[1];

	  this.factionbar.setActive(faction);

	  let player = this.returnPlayerOfFaction(faction);

	  // update board display
	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
          this.displayBoard();
	  this.displayCardsLeft();

	  //
	  // if everyone has passed, we can avoid this
	  //
	  let everyone_has_passed = true;
	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	      if (this.game.state.players_info[i].factions_passed[z] != true) { everyone_has_passed = false; }
	    }
	  }
	  if (everyone_has_passed == true) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // new impulse
	  //
          this.resetBesiegedSpaces();
          this.onNewImpulse();

	  //
	  // hide unneeded overlays
	  //
	  this.debate_overlay.hide();
	  this.theses_overlay.hide();

	  this.game.state.active_card = "";
	  this.game.state.active_player = player;
	  this.game.state.active_faction = faction;

	  // skip factions not-in-play
	  if (player == -1) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // skip turn if required
	  //
	  if (this.game.state.skip_next_impulse.includes(faction)) {
	    for (let i = 0; i < this.game.state.skip_next_impulse.length; i++) {
	      if (this.game.state.skip_next_impulse[i] == faction) {
		this.game.state.skip_next_impulse.splice(i, 1);
	      }
	    }
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // reset player/state vars and set as active player
	  //
	  this.resetPlayerTurn(player);

	  if (this.game.player == player) {
	    this.playerTurn(faction);
	  } else {
	    let f = this.game.state.players_info[this.game.player-1].factions[0];
	    let fhand_idx = 0;
	    try {
	      f = this.game.state.players_info[this.game.player-1].active_faction;
	      fhand_idx = this.game.state.players_info[this.game.player-1].active_faction_idx;
	    } catch (err) {
	    }
	    this.updateStatusAndListCards(`${this.returnFactionName(f)} - Opponent Turn: `, this.game.deck[0].fhand[fhand_idx], () => {});
	  }

	  this.game.queue.splice(qe, 1);
          return 0;
        }
	if (mv[0] === "continue") {

	  let player = mv[1];
	  let faction = mv[2];
	  let card = mv[3];
	  let ops = parseInt(mv[4]);
	  let limit = "";
	  if (mv[5]) { limit = mv[5]; }

	  //
	  // no ops, just continue
	  //
	  if (ops == 0) { return 1; }

	  //
	  // cache our last move, as we will sometimes show a sub-menu if
	  // there is another obvious move and we want to allow the player
	  // to avoid wandering through the menu to make progress on their
	  // turn.
	  //
	  let player_last_move = this.game.state.player_last_move;
	  let player_last_spacekey = this.game.state.player_last_spacekey;

	  //
	  // now reset them so we have a "clean slate" for our next move
	  //
	  this.game.state.player_last_move = "";
	  this.game.state.player_last_spacekey = "";


	  this.game.queue.splice(qe, 1);

	  let player_turn = -1;

	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    if (this.game.state.players_info[i].factions.includes(faction)) {
	      player_turn = i+1;
	    }
	  }

	  //
	  // hide unneeded overlays
	  //
	  this.debate_overlay.hide();
	  this.theses_overlay.hide();

          this.displayBoard();

	  // no-one controls this faction, so skip
	  if (player_turn === -1) {
	    return 1;
	  }

	  // let the player who controls play turn
	  if (this.game.player === player_turn) {

	    let mycallback = [];

	    if (player_last_move == "move") {
	      if (player_last_spacekey != "") {
		if (this.game.spaces[player_last_spacekey]) {
		  if (!this.isSpaceBesieged(this.game.spaces[player_last_spacekey])) {
 	            mycallback.push({ text : "continue move" , mycallback : () => {this.playerContinueToMoveFormationInClear(his_self, this.game.player, faction, player_last_spacekey, 1, (ops)); }});
	            if (!this.isSpaceControlled(faction, player_last_spacekey) && this.game.spaces[player_last_spacekey].type == "town" && !this.areAllies(faction, this.returnFactionControllingSpace(player_last_spacekey))) {
 	              mycallback.push({ text : "control town" , mycallback : () => {
		        if (ops > 1) {
                          his_self.addMove(`continue\t${mv[1]}\t${mv[2]}\t${mv[3]}\t${ops-1}\t${mv[5]}`);
                          his_self.game.queue.push("SETVAR\tstate\tplayer_last_move\tmove");
                          his_self.game.queue.push("SETVAR\tstate\tplayer_last_spacekey\t"+player_last_spacekey);
		        }
                        his_self.addMove("pacify\t"+faction+"\t"+player_last_spacekey);
                        his_self.endTurn();
	 	      }});
	            }
	          }
	        }
	      }
	    }
 	    mycallback.push({ text : "back to menu" , mycallback : () => { this.playerPlayOps(card, faction, ops, limit); }});
	    this.playerAcknowledgeNotice(`You have ${ops} OPS remaining...`, mycallback);
	  } else {
	    this.hideOverlays();
	    this.updateStatusAndListCards("Opponent Turn", his_self.game.deck[0].fhand[0], () => {});
	  }

          return 0;
        }


	if (mv[0] === "place_protestant_debater") {

	  this.game.queue.splice(qe, 1);

	  let name = mv[3];
	  let location = mv[4];

	  this.updateLog(unitname + " enters at " + location);
	  this.addDebater("protestant", location, name);
	  if (this.game.spaces[space].religion != "protestant") {
	    this.game.spaces[space].religion = "protestant";
	    this.updateLog(this.returnSpaceName(location) + " converts Protestant");
	  }
	  this.displaySpace(location);

	  return 1;

	}

	if (mv[0] === "select_for_catholic_conversion") {

	  let faction = mv[1];
	  let zone = "";
	  let force_in_zone = false;
	  if (mv[2]) { zone = mv[2]; }
	  if (mv[3]) { force_in_zone = true; }

	  this.game.queue.splice(qe, 1);

	  let available_spaces = this.returnNumberOfProtestantSpacesInLanguageZone(zone, 1);
	  if (available_spaces == 0) {
	    if (force_in_zone) { 
	      return 1; 
	    } else { 
	      zone = ""; 
	    }
	  }
	  if (1 > this.returnNumberOfProtestantSpacesInLanguageZone(zone, 1)) {
	    return 1;
	  }

	  if (this.theses_overlay.visible) { this.theses_overlay.pushHudUnderOverlay(); }

	  let player = this.returnPlayerOfFaction(faction);
	  if (this.game.player == player) {

	    this.playerSelectSpaceWithFilter(
              "Select Town to Convert Catholic",

              //
              // catholic spaces adjacent to protestant
              //
              function(space) {
                if (
                  space.religion === "protestant" &&
		  (
                    his_self.isSpaceAdjacentToReligion(space, "catholic")
                    ||
                    his_self.isSpaceAPortInTheSameSeaZoneAsACatholicPort(space)
		  )
                ) {
		  if (space.language == zone || zone == "" || zone == "all") {
                    return 1;
                  }
                }
                return 0;
              },

              function(spacekey) {
    	        his_self.updateStatusWithOptions(`Converting ${his_self.returnSpaceName(spacekey)}`);
                his_self.addMove("convert\t"+spacekey+"\tcatholic");
                his_self.endTurn();
              },

              null,

	      true

            );

          } else {
	    this.updateStatus("Player selecting space to convert Catholic");
	  }
	  this.displayVictoryTrack();
	  return 0;

        }

	if (mv[0] === "select_for_protestant_conversion") {

	  let faction = mv[1];
	  let zone = "";
	  let force_in_zone = false;
	  if (mv[2]) { zone = mv[2]; }
	  if (mv[3]) { force_in_zone = true; }

	  this.game.queue.splice(qe, 1);

	  let available_spaces = this.returnNumberOfCatholicSpacesInLanguageZone(zone, 1);
	  if (available_spaces == 0) {
	    if (force_in_zone) { 
	      return 1; 
	    } else { 
	      zone = ""; 
	    }
	  }
	  if (1 > this.returnNumberOfCatholicSpacesInLanguageZone(zone, 1)) {
	    return 1;
	  }

	  if (this.theses_overlay.visible) { this.theses_overlay.pushHudUnderOverlay(); }

	  let player = this.returnPlayerOfFaction(faction);
	  if (this.game.player == player) {
	    this.playerSelectSpaceWithFilter(
              "Select Town to Convert Protestant",

              //
              // catholic spaces adjacent to protestant
              //
              function(space) {
                if (
                  space.religion === "catholic" &&
		  (
                        his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
                        ||
                        his_self.isSpaceAdjacentToReligion(space, "protestant")
                        ||
                        his_self.doesSpaceContainProtestantReformer(space)
                        ||
                        his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
		  )
                ) {
		  if (space.language == zone || zone == "" || zone == "all") {
                    return 1;
                  }
                }
                return 0;
              },

              function(spacekey) {
    	        his_self.updateStatusWithOptions(`Reforming ${his_self.returnSpaceName(spacekey)}`);
                his_self.addMove("convert\t"+spacekey+"\tprotestant");
                his_self.endTurn();
              },

              null,

	      true

            );
          } else {
	    this.updateStatus("Player selecting space to convert Protestant");
	  }

	  this.displayVictoryTrack();
	  return 0;

        }



	if (mv[0] === "assault") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let space = mv[2];

	  this.displayVictoryTrack();

	  return 1;

	}


 	if (mv[0] === "unrest") {

	  let spacekey = mv[1];
	  this.game.spaces[spacekey].unrest = 1;
	  this.updateLog(this.returnSpaceName(spacekey) + " enters unrest");
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

 	if (mv[0] === "remove_unrest") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  this.game.spaces[spacekey].unrest = 0;
	  this.updateLog(this.returnSpaceName(spacekey) + " out of unrest");
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


 	if (mv[0] === "player_add_unrest") {

	  let faction = mv[1];
	  let zone = mv[2];
	  let religion = mv[3];
	  let player = this.returnPlayerOfFaction(faction);


	  if (this.game.player == player) {
	    this.playerAddUnrest(this, faction, zone, religion);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " stirring unrest");
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "withdraw_to_nearest_fortified_space") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source_spacekey = mv[2];
	  let source_space = this.game.spaces[source_spacekey];

	  //
	  // move the units here
	  //
          let land_units = [];
          let naval_units = [];

	  for (let i = 0; i < source_space.units[faction].length; i++) {
	    let u = source_space.units[faction][i];
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.army_leader == true) {
	      land_units.push(u);
	      source_space.units[faction].splice(i, 1);
	      i--;
	    } else {
	      // navy leaders that are army leaders treated as army leaders primarily
	      if (u.type == "squadron" || u.type == "corsair" || u.navy_leader == true) {
	        naval_units.push(u);
	        source_space.units[faction].splice(i, 1);
	        i--;
	      }
	    }
	  }

	  //
	  // find nearest fortified unit
	  //
	  let not_these_land_spaces = [];
	  let not_these_naval_spaces = [];
	  let all_land_units_repositioned = false;
	  let all_naval_units_repositioned = false;

	  //
	  // land units
	  //
	  while (all_land_units_repositioned == false) {
            let found_space = his_self.returnNearestSpaceWithFilter(
	      source_spacekey ,
              function(spacekey) {
                if ( !not_these_land_spaces.includes(spacekey) && his_self.game.spaces[spacekey].home == faction && (his_self.isSpaceFortified(spacekey) || his_self.game.spaces[spacekey].type == "key" || his_self.game.spaces[spacekey].type == "electorate" || his_self.game.spaces[spacekey].type == "fortress")) {
		  if (his_self.returnFactionLandUnitsInSpace(faction, spacekey) < 4) { return 1; }
		}
                return 0;
              },
              function(propagation_filter) {
                return 1;
              },
              0,
              1,
            );
	    let loop_limit = land_units.length;
	    for (let i = 0; i < loop_limit; i++) {
	      if (his_self.returnFactionLandUnitsInSpace(faction, found_space[0].key) < 4) {
		his_self.game.spaces[found_space[0].key].units[faction].push(land_units[i]);
		land_units.splice(i, 1);
		i--;
	        loop_limit = land_units.length;
	      }
	      his_self.displaySpace(found_space[0].key);
	    }
	    if (land_units.length == 0) { all_land_units_repositioned = true; }
	  }

	  //
	  // naval units
	  //
	  while (all_naval_units_repositioned == false) {
            let found_space = his_self.returnNearestSpaceWithFilter(
	      source_spacekey ,
              function(spacekey) {
                if (his_self.game.spaces[spacekey].ports.length > 0 && his_self.game.spaces[spacekey].home == faction && (his_self.isSpaceFortified(spacekey) || his_self.game.spaces[spacekey].type == "key" || his_self.game.spaces[spacekey].type == "electorate" || his_self.game.spaces[spacekey].type == "fortress")) {
		  return 1;
		}
                return 0;
              },
              function(propagation_filter) {
                return 1;
              },
              0,
              1,
            );
	    if (found_space.length > 0) {
	      for (let z = 0; z < naval_units.length; z++) {
	        his_self.game.spaces[found_space[0].key].units[faction].push(naval_units[z]);
	      }
	      naval_units = [];
	      his_self.displaySpace(found_space[0].key);
	    }
	    all_naval_units_repositioned = true;
	  }

	  return 1;

	}

	if (mv[0] === "pacify" || mv[0] === "control") {

	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let space = mv[2];
	  let religion = this.game.spaces[space].religion;

	  this.game.spaces[space].unrest = 0;

	  //
	  // 2P restriction on which keys can 
	  //
	  if (this.game.players.length == 2) {
	    if (space != "metz" && space != "liege" && this.game.spaces[space].language != "german" && this.game.spaces[space].language != "italian") { 
	      this.updateLog("NOTE: only Metz, Liege and German and Italian spaces may change control in the 2P game");
	    } else {
	      this.updateLog(this.returnFactionName(faction) + " controls " + this.returnSpaceName(space));
	      this.game.spaces[space].political = faction;
	    }
	  } else {
	    this.updateLog(this.returnFactionName(faction) + " controls " + this.returnSpaceName(space));
	    this.game.spaces[space].political = faction;
	  }


	  //
	  // capture any leaders
	  //
	  for (let f in this.game.spaces[space].units) {
	    if (!this.areAllies(f, faction)) {
	      for (let z = 0; z < this.game.spaces[space].units[f].length; z++) {
	        his_self.captureLeader(faction, f, space, this.game.spaces[space].units[f][z]);
	      };
	    }
	  }

	  this.game.spaces[space].political = faction;

	  //
	  // post schmalkaldic_league
	  //
	  if (faction === "protestant") {
            if (space === "augsburg" && religion === "protestant" && this.game.state.augsburg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['augsburg'].units['protestant'].push();
              this.addRegular("protestant", "augsburg", 2);
              this.game.state.augsburg_electoral_bonus = 1;
            }
            if (space === "mainz" && religion === "protestant" && this.game.state.mainz_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['mainz'].units['protestant'].push();
              this.addRegular("protestant", "mainz", 1);
              this.game.state.mainz_electoral_bonus = 1;
            }
            if (space === "trier" && religion === "protestant" && this.game.state.trier_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['trier'].units['protestant'].push();
              this.addRegular("protestant", "trier", 1);
              this.game.state.trier_electoral_bonus = 1;
            }
            if (space === "cologne" && religion === "protestant" && this.game.state.cologne_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['cologne'].units['protestant'].push();
              this.addRegular("protestant", "cologne", 1);
              this.game.state.cologne_electoral_bonus = 1;
            }
            if (space === "wittenberg" && religion === "protestant" && this.game.state.wittenberg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['wittenberg'].units['protestant'].push();
              this.addRegular("protestant", "wittenberg", 2);
              this.game.state.wittenberg_electoral_bonus = 1;
            }
            if (space === "brandenburg" && religion === "protestant" && this.game.state.brandenburg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['brandenburg'].units['protestant'].push();
              this.addRegular("protestant", "brandenburg", 1);
              this.game.state.brandenburg_electoral_bonus = 1;
            }
          }



	  this.displaySpace(space);
	  this.displayVictoryTrack();


          //
          // military victory
          //
	  let keys = this.returnNumberOfKeysControlledByFaction(faction);
	  if (faction === "hapsburg" && keys >= this.game.state.autowin_hapsburg_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "ottoman" && keys >= this.game.state.autowin_ottoman_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "france" && keys >= this.game.state.autowin_france_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "england" && keys >= this.game.state.autowin_england_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "papacy" && keys >= this.game.state.autowin_papacy_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }

	  return 1;

	}




	if (mv[0] === "convert") {

	  this.game.queue.splice(qe, 1);

	  let space = mv[1];
	  let religion = mv[2];

	  if (religion == "protestant") {
	    this.updateLog(this.returnSpaceName(space) + " converts Protestant");
	    this.updateStatus(this.returnSpaceName(space) + " converts Protestant");
	  } else {
	    this.updateLog(this.returnSpaceName(space) + " converts Catholic");
	    this.updateStatus(this.returnSpaceName(space) + " converts Catholic");
	  }

	  if (space === "augsburg" && religion === "protestant" && this.game.state.augsburg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "augsburg", 2);
	    this.game.state.augsburg_electoral_bonus = 1;
	  }
	  if (space === "mainz" && religion === "protestant" && this.game.state.mainz_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "mainz", 1);
	    this.game.state.mainz_electoral_bonus = 1;
	  }
	  if (space === "trier" && religion === "protestant" && this.game.state.trier_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "trier", 1);
	    this.game.state.trier_electoral_bonus = 1;
	  }
	  if (space === "cologne" && religion === "protestant" && this.game.state.cologne_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "cologne", 1);
	    this.game.state.cologne_electoral_bonus = 1;
	  }
	  if (space === "wittenberg" && religion === "protestant" && this.game.state.wittenberg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "wittenberg", 2);
	    this.game.state.wittenberg_electoral_bonus = 1;
	  }
	  if (space === "brandenburg" && religion === "protestant" && this.game.state.brandenburg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "brandenburg", 1);
	    this.game.state.brandenburg_electoral_bonus = 1;
	  }

	  this.game.spaces[space].religion = religion;
	  this.displaySpace(space);
	  this.displayElectorateDisplay();
	  this.displayVictoryTrack();

	  //
	  // check for victory condition
	  //
          if (this.returnNumberOfProtestantSpacesInLanguageZone() >= 50) {
	    let player = this.returnPlayerOfFaction("protestant");
	    this.sendGameOverTransaction([this.game.players[player-1]], "Religious Victory");
	    return 0;
	  }

	  return 1;

	}

	if (mv[0] === "add_home_card") {

	  let player = parseInt(mv[1]);
 	  let faction = mv[2];
 	  let hc = this.returnDeck();

	  for (let key in hc) {
	    if (hc[key].faction === faction) {
	      if (!this.game.state.cards_left[faction]) { this.game.state.cards_left[faction] = 0; }
	      this.game.state.cards_left[faction]++;
	      if (this.game.player === player) {
                let fhand_idx = this.returnFactionHandIdx(player, faction);
                if (!this.game.deck[0].fhand) { this.game.deck[0].fhand = []; }
                while (this.game.deck[0].fhand.length <= fhand_idx) { this.game.deck[0].fhand.push([]); }
	        this.game.deck[0].fhand[fhand_idx].push(key);
	      }
	    }
	  }

	  this.displayCardsLeft();
	  this.game.queue.splice(qe, 1);

	  return 1;

	}


        if (mv[0] === "play_diplomacy_card") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  if (this.game.player == player) {
	    this.playerPlayDiplomacyCard(faction);
	  } else {
	    if (faction == "papacy") {
  	      this.updateStatusAndListCards("Papacy playing their Diplomacy Card", this.game.deck[1].hand, () => {});
	    } else {
  	      this.updateStatusAndListCards("Protestants playing their Diplomacy Card", this.game.deck[1].hand, () => {});
	    }
	  }

	  return 0;

	}


	if (mv[0] === "faction_assigns_hits_first_field_battle") {

	  this.game.queue.splice(qe, 1);
	  let which_player = "";

	  if (mv[1] === "defender") {
	    this.game.state.field_battle.defender_hits_first = 1;
	    which_player = "defender";
	  }

	  if (mv[1] === "attacker") {

	    let reversed = false;
	    which_player = "defender";
	    this.game.state.field_battle.attacker_hits_first = 1;

	    for (let z = this.game.queue.length-1; reversed == false && z >= 1; z--) {

	      let mt = this.game.queue[z].split("\t");
	      let mb = this.game.queue[z-1].split("\t");

	      if (mt === "field_battle_assign_hits" && mb === "field_battle_assign_hits") {
		let x = this.game.queue[z];
		let y = this.game.queue[z-1];
		this.game.queue[z] = y;
		this.game.queue[z-1] = x;
	      }

	      reversed = true;
	    }
	  }

	  return 1;
	}
	if (mv[0] === "faction_assigns_hits_first_naval_battle") {

	  this.game.queue.splice(qe, 1);

	  let which_player = "";
	  if (mv[1] === "defender") {
	    this.game.state.naval_battle.defender_hits_first = 1;
	    which_player == "defender";
	  }

	  if (mv[1] === "attacker") {

	    let reversed = false;
	    this.game.state.naval_battle.attacker_hits_first = 1;
	    which_player == "defender";

	    for (let z = this.game.queue.length-1; reversed == false && z >= 1; z--) {

	      let mt = this.game.queue[z].split("\t");
	      let mb = this.game.queue[z-1].split("\t");

	      if (mt === "naval_battle_assign_hits" && mb === "naval_battle_assign_hits") {
		let x = this.game.queue[z];
		let y = this.game.queue[z-1];
		this.game.queue[z] = y;
		this.game.queue[z-1] = x;
	      }

	      reversed = true;
	    }
	  }

	  return 1;
	}


	// swiss mercenaries and landsnechts
	if (mv[0] === "add_units_before_field_battle") {

	  let his_self = this;
	  let faction = mv[1];
	  let unittype = mv[2];
	  let num = parseInt(mv[3]);

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            his_self.playerPlaceUnitsInSpaceWithFilter(unittype, num, faction,
              function(space) {
                if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
                if (!his_self.isSpaceFriendly(space.key, faction)) { return 0; }
                if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
                return 0;
              },
              function(spacekey) {
		if (his_self.game.state.field_battle.spacekey == spacekey) {
		  his_self.addMove("add_field_battle_bonus_rolls\t"+faction+"\t"+1+"\t"+unittype);
		}
	      } ,
              null ,
              true
            );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " placing units...");
	  }

	  this.game.queue.splice(qe, 1);

	  return 0;

	}

	if (mv[0] === "add_field_battle_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.game.state.field_battle.faction_map[faction] === his_self.game.state.field_battle.defender_faction) { is_attacker = false; }

          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.field_battle.attacker_hits++; }
              if (his_self.game.state.field_battle.tercios == 1) { if (x >= 4 && x < 5) { his_self.game.state.field_battle.attacker_hits++; } }
              his_self.game.state.field_battle.attacker_results.push(x);
              his_self.game.state.field_battle.attacker_modified_rolls.push(x);
              his_self.game.state.field_battle.attacker_units.push(comment);
              his_self.game.state.field_battle.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.field_battle.defender_hits++; }
              if (his_self.game.state.field_battle.tercios == 1) { if (x >= 4 && x < 5) { his_self.game.state.field_battle.defender_hits++; } }
              his_self.game.state.field_battle.defender_results.push(x);
              his_self.game.state.field_battle.defender_modified_rolls.push(x);
              his_self.game.state.field_battle.defender_units.push(comment);
              his_self.game.state.field_battle.defender_units_faction.push(faction);
            }
	  }

          his_self.field_battle_overlay.render(his_self.game.state.field_battle, 1);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



	if (mv[0] === "add_assault_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.game.state.assault.faction_map[faction] === his_self.game.state.assault.defender_faction) { is_attacker = false; }


          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.assault.attacker_hits++; }
              if (his_self.game.state.assault.siege_artillery == 1) { if (x >= 3 && x < 5) { his_self.game.state.assault.attacker_hits++; } }
              his_self.game.state.assault.attacker_modified_rolls.push(x);
              his_self.game.state.assault.attacker_units_units.push(comment);
              his_self.game.state.assault.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.assault.defender_hits++; }
              if (his_self.game.state.assault.siege_artillery == 1) { if (x >= 3 && x < 5) { his_self.game.state.assault.attacker_hits++; } }
              his_self.game.state.assault.defender_modified_rolls.push(x);
              his_self.game.state.assault.defender_units_units.push(comment);
              his_self.game.state.assault.defender_units_faction.push(faction);
            }
	  }

          his_self.assault_overlay.render(his_self.game.state.assault);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	if (mv[0] === "add_naval_battle_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.game.state.naval_battle.defender_faction === faction) { is_attacker = false; }


          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.naval_battle.attacker_hits++; }
              his_self.game.state.naval_battle.attacker_modified_rolls.push(x);
              his_self.game.state.naval_battle.attacker_units.push(comment);
              his_self.game.state.naval_battle.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.naval_battle.defender_hits++; }
              his_self.game.state.naval_battle.defender_modified_rolls.push(x);
              his_self.game.state.naval_battle.defender_units.push(comment);
              his_self.game.state.naval_battle.defender_units_faction.push(faction);
            }
	  }

          his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



	if (mv[0] === "hand_to_fhand") {

	  this.game.queue.splice(qe, 1);

	  let deckidx = parseInt(mv[1])-1;
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let show_overlay = false;
	  if (mv[4]) { show_overlay = true; }
	  let fhand_idx = this.returnFactionHandIdx(player, faction);
	  let cards = [];

	  if (this.game.player == player) {
	    if (!this.game.deck[deckidx].fhand) { this.game.deck[deckidx].fhand = []; }
	    while (this.game.deck[deckidx].fhand.length < (fhand_idx+1)) { this.game.deck[deckidx].fhand.push([]); }

	    for (let i = 0; i < this.game.deck[deckidx].hand.length; i++) {
	      this.game.deck[deckidx].fhand[fhand_idx].push(this.game.deck[deckidx].hand[i]);
	      cards.push(this.game.deck[deckidx].hand[i]);
	    }

	    // and clear the hand we have dealt
	    this.game.deck[deckidx].hand = [];

	    if (show_overlay) {
	      this.deck_overlay.render('hand', cards);
	    }

	  }

	  return 1;

	}

	if (mv[0] === "remove_translation_bonus") {
	  this.game.queue.splice(qe, 1);
	  this.game.state.tmp_protestant_translation_bonus = 0;
	  this.game.state.english_bible_translation_bonus = 0;
	  this.game.state.french_bible_translation_bonus = 0;
	  this.game.state.german_bible_translation_bonus = 0;
	  this.game.state.tmp_protestant_translation_bonus = 0;
	  return 1;
	}

	if (mv[0] === "reformation") {

	  //
	  // hide triangular help if game start
	  //
	  if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
	    this.game_help.hide();
	  }

	  this.game.queue.splice(qe, 1);


	  let space = mv[1];
	  let target_language_zone = mv[2] || "german";
	  this.game.state.tmp_reformations_this_turn.push(space);

	  let p_rolls = 0;
	  let c_rolls = 0;

	  let p_neighbours = 0;
	  let c_neighbours = 0;

	  let p_bonus = 0;
	  let c_bonus = 0;

	  let p_high = 0;
	  let c_high = 0;

	  let p_roll_desc = [];
	  let c_roll_desc = [];

	  let protestants_win = 0;

	  let ties_resolve = "protestant";

	  //
	  // neighbours
	  //
	  for (let i = 0; i < this.game.spaces[space].neighbours.length; i++) {

	    if (!this.game.spaces[space].pass.includes(this.game.spaces[space].neighbours[i]) && !this.game.spaces[this.game.spaces[space].neighbours[i]].unrest) {
	      if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "catholic") {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
	        c_neighbours++;
	      }
	      if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "protestant") {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
	        p_neighbours++;
	      }
	      if (this.hasProtestantLandUnits(this.game.spaces[space].neighbours[i])) {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
	        p_rolls++;
	      }
	      if (this.hasCatholicLandUnits(this.game.spaces[space].neighbours[i])) {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
	        c_rolls++;
	      }
	      if (this.hasProtestantReformer(this.game.spaces[space].neighbours[i])) {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "reformer"});
	        p_rolls++;
	      }
	      if (this.game.spaces[this.game.spaces[space].neighbours[i]].university) {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "jesuit university"});
	        c_rolls++;
	      }
	    }
	  }

	  //
	  // ourselves
	  //
	  if (this.hasProtestantLandUnits(space)) {
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    p_rolls++;
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    p_rolls++;
	  }
	  if (this.hasCatholicLandUnits(space)) {
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    c_rolls++;
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    c_rolls++;
	  }
	  if (this.hasProtestantReformer(space)) {
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
	    p_rolls++;
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
	    p_rolls++;
	  }
	  if (this.game.spaces[space].university) {
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
	    c_rolls++;
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
	    c_rolls++;
	  }

	  //
	  // language zone
	  //
	  if (this.game.spaces[space].language !== target_language_zone && target_language_zone != "all") {
	    ties_resolve = "catholic";
 	  }

	  //
	  // everyone gets a minimum of one roll
	  //
	  if (p_rolls == 0 && p_neighbours == 0) {
	    p_roll_desc.push({ name : "basic roll" , desc : "no adjacency or influence"});
	    p_rolls++;
	  }
	  if (c_rolls == 0 && c_neighbours == 0) {
	    c_roll_desc.push({ name : "basic roll" , desc : "no adjacency or influence"});
	    c_rolls++;
	  }

	  //
	  // temporary bonuses
	  //
	  if (this.game.state.printing_press_active) {
	    p_rolls++;
	    p_roll_desc.push({ name : "Bonus" , desc : "printing press"});
	  }
	  if (this.game.state.tmp_protestant_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_protestant_reformation_bonus_spaces.includes(space)) {
	      p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
	      this.game.state.tmp_protestant_reformation_bonus--;
	      if (this.game.state.tmp_protestant_reformation_bonus < 0) { this.game.state.tmp_protestant_reformation_bonus = 0; }
	    }
	  }
	  if (this.game.state.tmp_catholic_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_catholic_reformation_bonus_spaces.includes(space)) {
	      c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
	      this.game.state.tmp_catholic_reformation_bonus--;
	      if (this.game.state.tmp_catholic_reformation_bonus < 0) { this.game.state.tmp_catholic_reformation_bonus = 0; }
	    }
	  }

	  for (let i = 0; i < this.game.state.tmp_protestant_reformation_bonus; i++) {
	    p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
	  }
	  for (let i = 0; i < this.game.state.tmp_catholic_reformation_bonus; i++) {
	    c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
	  }
	  p_bonus += this.game.state.tmp_protestant_reformation_bonus;
	  c_bonus += this.game.state.tmp_catholic_reformation_bonus;


	  //
	  // calculate total rolls
	  //
	  p_rolls += p_neighbours;
	  p_rolls += p_bonus;
	  c_rolls += c_neighbours;
	  c_rolls += c_bonus;

          //
          // everyone rolls at least 1 dice
          //
          if (c_rolls == 0) {
	    c_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    c_rolls = 1;
	  }
          if (p_rolls == 0) {
	    p_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    p_rolls = 1;
	  }

	  let pdice = [];
	  let cdice = [];

	  for (let i = 0; i < p_rolls; i++) {
	    let x = this.rollDice(6);
	    if (this.game.state.events.calvins_institutes == 1 && this.game.spaces[space].language === "french") {
	      if (i == 0) { this.updateLog("Calvin's Institutes modifies Protestant rolls by +1"); }
	      x++;
	    }
	    if (this.game.state.english_bible_translation_bonus == 1 || this.game.state.french_bible_translation_bonus == 1 || this.game.state.german_bible_translation_bonus == 1) { x++; }
	    if (x > p_high) { p_high = x; }
	    pdice.push(x);
	  }

	  for (let i = 0; i < c_rolls; i++) {
	    let x = this.rollDice(6);
	    if (x > c_high) { c_high = x; }
	    cdice.push(x);
	  }

	  //
	  // do protestants win?
	  //
	  if (p_high > c_high) { protestants_win = 1; }
	  if (p_high == c_high && ties_resolve === "protestant") { protestants_win = 1; }

	  //
	  //
	  //
	  let obj = {};
	  obj.key = mv[1];
          obj.name = this.spaces[space].name;
	  obj.pdice = pdice;
	  obj.cdice = cdice;
	  obj.p_roll_desc = p_roll_desc;
	  obj.c_roll_desc = c_roll_desc;
	  obj.p_high = p_high;
	  obj.c_high = c_high;
	  obj.reformation = true;
	  obj.counter_reformation = false;
          obj.protestants_win = protestants_win;
	  this.reformation_overlay.render(obj);

	  //
	  // handle victory
	  //
	  if (protestants_win == 1) {
	    this.game.queue.push("convert\t"+space+"\tprotestant");
	  } else {
	    if (parseInt(this.game.state.events.carlstadt_debater) == 1) {
	      // unrest
	      this.game.queue.push("unrest\t"+space);
	    }
	    this.updateLog(this.returnSpaceName(space) + " remains Catholic");
	  }

	  return 1;

	}


	if (mv[0] === "counter_reformation") {

	  this.game.queue.splice(qe, 1);

	  let space = mv[1];
	  let target_language_zone = mv[2] || "german";
	  this.game.state.tmp_counter_reformations_this_turn.push(space);

	  let p_rolls = 0;
	  let c_rolls = 0;

	  let p_neighbours = 0;
	  let c_neighbours = 0;

	  let p_bonus = 0;
	  let c_bonus = 0;

	  let p_high = 0;
	  let c_high = 0;

	  let p_roll_desc = [];
	  let c_roll_desc = [];

	  let catholics_win = 0;

	  let ties_resolve = "protestant";

	  //
	  // language zone
	  //
	  //if (this.game.spaces[space].language === target_language_zone) {
	  //
	  // catholics win ties if Paul III or Julius III are Pope
	  //
	  if (this.game.state.leaders.paul_iii == 1 || this.game.state.leaders.julius_iii == 1) {
	    ties_resolve = "catholic";
	  }
 	  //}

          //
          // neighbours
          //
          for (let i = 0; i < this.game.spaces[space].neighbours.length; i++) {
	    if (!this.game.spaces[space].pass.includes(this.game.spaces[space].neighbours[i]) && !this.game.spaces[this.game.spaces[space].neighbours[i]].unrest) {
            if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "catholic") {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
              c_neighbours++;
            }
            if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "protestant") {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
              p_neighbours++;
            }
            if (this.hasProtestantLandUnits(this.game.spaces[space].neighbours[i])) {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
              p_rolls++;
            }
            if (this.hasCatholicLandUnits(this.game.spaces[space].neighbours[i])) {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
              c_rolls++;
            }
            if (this.hasProtestantReformer(this.game.spaces[space].neighbours[i])) {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "reformer"});
              p_rolls++;
            }
            if (this.game.spaces[this.game.spaces[space].neighbours[i]].university) {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "jesuit university"});
              c_rolls++;
            }
            }
          }

          //
          // ourselves
          //
          if (this.hasProtestantLandUnits(space)) {
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            p_rolls++;
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            p_rolls++;
          }
          if (this.hasCatholicLandUnits(space)) {
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            c_rolls++;
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            c_rolls++;
          }
          if (this.hasProtestantReformer(space)) {
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
            p_rolls++;
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
            p_rolls++;
          }
          if (this.game.spaces[space].university) {
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
            c_rolls++;
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
            c_rolls++;
          }

	  //
	  // temporary bonuses
	  //
	  if (this.game.state.tmp_protestant_counter_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_protestant_counter_reformation_bonus_spaces.includes(space)) {
	      this.game.state.tmp_protestant_counter_reformation_bonus--;
	      if (this.game.state.tmp_protestant_counter_reformation_bonus < 0) { this.game.state.tmp_protestant_counter_reformation_bonus = 0; }
	    }
	  }
	  if (this.game.state.tmp_catholic_counter_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_catholic_counter_reformation_bonus_spaces.includes(space)) {
	      this.game.state.tmp_catholic_counter_reformation_bonus--;
	      if (this.game.state.tmp_catholic_counter_reformation_bonus < 0) { this.game.state.tmp_catholic_counter_reformation_bonus = 0; }
	    }
	  }

          for (let i = 0; i < this.game.state.tmp_protestant_counter_reformation_bonus; i++) {
            p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
          }
          for (let i = 0; i < this.game.state.tmp_catholic_counter_reformation_bonus; i++) {
            c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
          }
          p_bonus += this.game.state.tmp_protestant_counter_reformation_bonus;
          c_bonus += this.game.state.tmp_catholic_counter_reformation_bonus;

	  //
	  // calculate total rolls
	  //
	  p_rolls += p_neighbours;
	  p_rolls += p_bonus;
	  c_rolls += c_neighbours;
	  c_rolls += c_bonus;

	  //
	  // everyone rolls at least 1 dice
	  //
          if (c_rolls == 0) {
	    c_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    c_rolls = 1;
	  }
          if (p_rolls == 0) {
	    p_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    p_rolls = 1;
	  }

	  let pdice = [];
	  let cdice = [];

	  for (let i = 0; i < p_rolls; i++) {
	    let x = this.rollDice(6);
	    pdice.push(x);
	    if (x > p_high) { p_high = x; }
	  }

	  for (let i = 0; i < c_rolls; i++) {
	    let x = this.rollDice(6);
	    if (his_self.game.state.events.augsburg_confession == 1) { x--; }
	    cdice.push(x);
	    if (x > c_high) { c_high = x; }
	  }

	  //
	  // do catholics win?
	  //
	  if (p_high < c_high) { catholics_win = 1; }
	  if (p_high == c_high && ties_resolve === "catholics") { catholics_win = 1; }

          //
          // render results
          //
          let obj = {};
          obj.key = mv[1];
          obj.name = this.spaces[space].name;
          obj.pdice = pdice;
          obj.cdice = cdice;
          obj.pdice = pdice;
          obj.cdice = cdice;
          obj.p_roll_desc = p_roll_desc;
          obj.c_roll_desc = c_roll_desc;
          obj.p_high = p_high;
          obj.c_high = c_high;
	  obj.reformation = false;
	  obj.counter_reformation = true;
          obj.catholics_win = catholics_win;
	  obj.protestants_win = 1;
	  if (catholics_win) { obj.protestants_win = 0; }
          this.reformation_overlay.render(obj);

	  //
	  // handle victory
	  //
	  if (catholics_win == 1) {
	    this.game.queue.push("convert\t"+space+"\tcatholic");
	  } else {
	    this.updateLog(this.returnSpaceName(space) + " remains Protestant");
	  }

	  return 1;

	}


	//
	// objects and cards can add commands
	//
        for (let i in z) {
	  //
	  // an action may have removed a card / event
	  //
	  if (z[i]) {
            if (!z[i].handleGameLoop(this, qe, mv)) { return 0; }
	  }
        }


        //
        // avoid infinite loops
        //
        if (shd_continue == 0) {
          console.log("NOT CONTINUING");
          return 0;
        }

    } // if cards in queue
    return 1;

  }



 

  returnArrayOfPlayersInFieldBattle() {
    if (this.game.state.field_battle.spacekey) {
      return this.returnArrayOfPlayersInSpacekey(this.game.state.field_battle.spacekey);
    }
    return this.game.players;
  }

  returnArrayOfPlayersInAssault() {
    if (this.game.state.assault.spacekey) {
      return this.returnArrayOfPlayersInSpacekey(this.game.state.assault.spacekey);
    }
    return this.game.players;
  }

  returnArrayOfPlayersInSpacekey(spacekey="") {
    let res = [];
    let s = this.game.spaces[spacekey];
    if (s) {
      for (let key in s.units) {
        if (s.units[key].length > 0) {
          let p = this.returnPlayerCommandingFaction(key);
          if (p > 0 && !res.includes(this.game.players[p-1])) {
            res.push(this.game.players[p-1]);
          }
        }
      }
    }
    if (res.length > 0) { return res; }
    return this.game.players;
  }

  returnPlayers(num = 0) {

    var players = [];
    let factions  = JSON.parse(JSON.stringify(this.factions));
    let factions2 = JSON.parse(JSON.stringify(this.factions));

    // < 6 player games
    if (num == 2) {
      for (let key in factions) {
        if (key !== "protestant" && key !== "papacy") {
          delete factions[key];
        }
      }
    }

    if (num == 3) {
      for (let key in factions) {
	if (key !== "protestant" && key !== "france" && key !== "papacy") {
	  delete factions[key];
	}
      }
    }

    if (num == 4) {
      for (let key in factions) {
	if (key !== "protestant" && key !== "france" && key !== "ottoman" && key !== "papacy") {
	  delete factions[key];
	}
      }
    }


    let f = [];
    if (factions["protestant"]) { f.push("protestant"); }
    if (factions["papacy"]) { f.push("papacy"); }
    if (factions["hapsburg"]) { f.push("hapsburg"); }
    if (factions["ottoman"]) { f.push("ottoman"); }
    if (factions["france"]) { f.push("france"); }
    if (factions["england"]) { f.push("england"); }

    for (let i = 0; i < num; i++) {

      if (i == 0) { col = "color1"; }
      if (i == 1) { col = "color2"; }
      if (i == 2) { col = "color3"; }
      if (i == 3) { col = "color4"; }
      if (i == 4) { col = "color5"; }
      if (i == 5) { col = "color6"; }


      let rf = "";
      

      if (i == 0) {
        if (this.game.options.player1 != undefined) {
          if (this.game.options.player1 != "random") {
            rf = this.game.options.player1;
          }
        }
      }
      if (i == 1) {
        if (this.game.options.player2 != undefined) {
          if (this.game.options.player2 != "random") {
            rf = this.game.options.player2;
          }
        }
      }
      if (i == 2) {
        if (this.game.options.player3 != undefined) {
          if (this.game.options.player3 != "random") {
            rf = this.game.options.player3;
          }
        }
      }
      if (i == 3) {
        if (this.game.options.player4 != undefined) {
          if (this.game.options.player4 != "random") {
            rf = this.game.options.player4;
          }
        }
      }
      if (i == 4) {
        if (this.game.options.player5 != undefined) {
          if (this.game.options.player5 != "random") {
            rf = this.game.options.player5;
          }
        }
      }
      if (i == 5) {
        if (this.game.options.player6 != undefined) {
          if (this.game.options.player6 != "random") {
            rf = this.game.options.player6;
          }
        }
      }

      if (rf === "" || rf === "undefined") {
        let dr = this.rollDice(f.length) - 1;
	rf = f[dr];
      }

      for (let z = 0; z < f.length; z++) {
	if (f[z] === rf) {
	  f.splice(z, 1);
	}
      }

      delete factions[rf];

      players[i] = {};
      players[i].tmp_debaters_committed_reformation = 0;
      players[i].tmp_debaters_committed_translation = 0;
      players[i].tmp_debaters_committed_counter_reformation = 0;
      players[i].tmp_roll_bonus = 0;
      players[i].tmp_roll_first = 0;
      players[i].tmp_roll_modifiers = [];
      players[i].factions = [];
      players[i].factions.push(rf);
      players[i].factions_passed = [];
      players[i].factions_passed.push(false); // faction not passed
      players[i].captured = [];
      players[i].num = i;

      //
      // Each power's VP total is derived from base, special, and bonus VP. 
      // The base VP total is shown in the lower-left of the power card.
      //
      players[i].vp_base = 0;
      players[i].vp_special = 0;
      players[i].vp_bonus = 0;

      players[i].active_faction = players[i].factions[0];
      players[i].active_faction_idx = 0;

    }


    if (num == 3) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "papacy") {
	  players[i].factions.push("hapsburg");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "france") {
	  players[i].factions.push("ottoman");
	  players[i].factions_passed.push(false);
	}
      }
    }

    if (num == 4) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "papacy") {
	  players[i].factions.push("hapsburg");
	  players[i].factions_passed.push(false);
	}
      }
    }

    if (num == 5) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
      }
    }

    return players;

  }

  //
  // runs each new round
  //
  resetPlayerRound(player_num) {

    this.game.state.tmp_bonus_protestant_translation_german_zone = 0;
    this.game.state.tmp_bonus_protestant_translation_french_zone = 0;
    this.game.state.tmp_bonus_protestant_translation_english_zone = 0;
    this.game.state.tmp_bonus_papacy_burn_books = 0;

    for (let i = 0; i < this.game.state.players_info[player_num-1].factions.length; i++) {
      this.game.state.players_info[player_num-1].factions_passed[i] = false;
    }

  }

  returnPlayerInfoFaction(faction) {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	if (this.game.state.players_info[i].factions[z].key == faction) {
	  return this.game.state.players_info[i].factions[z];
	}
      }
    }

    return null;
  }

  //
  // runs each new turn
  //
  resetPlayerTurn(player_num) {

    this.game.state.tmp_reformations_this_turn = [];
    this.game.state.tmp_counter_reformations_this_turn = [];
    this.game.state.tmp_protestant_reformation_bonus = 0;
    this.game.state.tmp_catholic_reformation_bonus = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus = 0;
    this.game.state.tmp_papacy_may_specify_debater = 0;
    this.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    this.deactivateDebaters();

    for (let s in this.game.spaces) {
      if (this.game.spaces[s].besieged == 2) {
	this.game.spaces[s].besieged = 1;
      }
      for (let f in this.game.spaces[s].units) {
	for (let z = 0; z < this.game.spaces[s].units[f].length; z++) {
	  this.game.spaces[s].units[f][z].already_moved = 0;
	}
      }
    }

    let p = this.game.state.players_info[(player_num-1)];
    p.tmp_debaters_committed_reformation = 0;
    p.tmp_debaters_committed_translation = 0;
    p.tmp_debaters_committed_counter_reformation = 0;
    p.tmp_roll_bonus = 0;
    p.tmp_roll_first = 0;
    p.tmp_roll_modifiers = [];

    this.game.state.field_battle = {};

    this.game.state.active_player = player_num;

  }

  isFactionInPlay(faction) {
    for (let i = 0; i < this.game.players.length; i++) {
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	if (this.game.state.players_info[i].factions[z] === faction) { return 1; }
      }
    }
    return 0;
  }

  returnPlayerOfFaction(faction) {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      if (this.game.state.players_info[i].factions.includes(faction)) {
	return i+1;
      }
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	let f = this.game.state.players_info[i].factions[z];
        if (this.game.state.activated_powers) {
	  if (this.game.state.activated_powers[f]) {
            if (this.game.state.activated_powers[f].includes(faction)) {
	      return (i+1);
            }
          }
        }
      }
    }
    let z = this.returnPlayerCommandingFaction(faction);
    if (z) { return this.game.state.players_info[z-1]; }
    return 0;
  }


  //
  // 1 hits to destroy everything, opt-in for naval units
  //
  playerAssignHits(faction, spacekey, hits_to_assign, naval_hits_acceptable=0) {

    let his_self = this;
    let space = spacekey;
    try { if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; } } catch (err) {}

    units_to_destroy = [];
    units_available = [];

    for (f in space.units) {
      if (f == faction || this.isAlliedMinorPower(f, faction)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular")   { units_available.push(space.units[f][i]); }
          if (space.units[f][i].type === "mercenary") { units_available.push(space.units[f][i]); }
          if (space.units[f][i].type === "cavalry")   { units_available.push(space.units[f][i]); }
        }
      }
    } 

    let selectUnitsInterface = function(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface) {

      let msg = "Hits Remaining: " + hits_to_assign;
      let html = "<ul>";
      let targets = 0;

      for (let i = 0; i < space.units[faction].length; i++) {
        if (!units_to_destroy.includes(parseInt(i))) {

	  let is_fodder = true;
          if (space.units[faction][i].land_or_sea === "sea" && naval_hits_acceptable == 0) { is_fodder = false; }
          if (space.units[faction][i].personage == true) { is_fodder = false; }

	  if (is_fodder == true) {
	    targets++;
            html += `<li class="option" id="${i}">${space.units[faction][i].name}</li>`;
          }
	}
      }
      html += "</ul>";

      if (targets <= 0 || hits_to_assign <= 0) {
	his_self.addMove("destroy_units\t"+faction+"\t"+spacekey+"\t"+JSON.stringify(units_to_destroy));
	his_self.endTurn();
	return;
      }

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        $('.option').off();
        let id = $(this).attr("id");

	his_self.updateStatus("assign hit...");

        if (!units_to_destroy.includes(id)) {
          units_to_destroy.push(parseInt(id));
        }

	if (units_available[id].type == "regular") { hits_to_assign -= 1; }
	if (units_available[id].type == "mercenary") { hits_to_assign -= 1; }
	if (units_available[id].type == "squadron") { hits_to_assign -= 1; }
	if (units_available[id].type == "corsair") { hits_to_assign -= 1; }
	if (units_available[id].type == "cavalry") { hits_to_assign -= 1; }

        selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

      });
    }

    selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

    return 0;

  }

  //
  // 2 hits to destroy a squadron, 1 for a corsair
  //
  playerAssignNavalHits(faction, hits_to_assign, spacekey) {

    let his_self = this;
    let space;

    if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
    if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

    let units_available = space.units[faction];
    let units_to_destroy = [];

    let selectUnitsInterface = function(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface) {

      let msg = "Hits Remaining: " + hits_to_assign;
      let html = "<ul>";
      let targets = 0;
      let one_hit_targets = false;
      for (let i = 0; i < space.units[faction].length; i++) {
        if (space.units[faction][i].land_or_sea === "sea" || space.units[faction][i].land_or_sea === "both") {
	  if (space.units[faction][i].personage == false) {
            if (!units_to_destroy.includes(parseInt(i))) {
  	      targets++;
	      if (space.units[faction][i].type === "squadron") {
                html += `<li class="option" id="${i}">${space.units[faction][i].name} (2 hits)</li>`;
              } else {
                html += `<li class="option" id="${i}">${space.units[faction][i].name} (1 hit)</li>`;
		one_hit_targets = true;
	      }
            }
            html += "</ul>";
          }
        }
      }

      if (targets <= 0 || hits_to_assign <= 0 || (hits_to_assign == 1 && one_hit_targets == false)) {
	his_self.addMove("destroy_naval_units\t"+faction+"\t"+spacekey+"\t"+JSON.stringify(units_to_destroy));
	his_self.endTurn();
	return;
      }

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

	his_self.updateStatus("assigning hits");

        let id = $(this).attr("id");

        if (!units_to_destroy.includes(id)) {
          units_to_destroy.push(parseInt(id));
        }

	if (units_available[id].type == "squadron") { hits_to_assign -= 2; }
	if (units_available[id].type == "corsair") { hits_to_assign -= 1; }

        selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

      });
    }

    his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
    selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

    return 0;

  }


  playerResolveNavalWinterRetreat(faction, spacekey) {

    let his_self = this;
    let space = null;
    if (his_self.game.spaces[spacekey]) { space = his_self.game.spaces[spacekey]; }
    if (his_self.game.navalspaces[spacekey]) { space = his_self.game.navalspaces[spacekey]; }

    let res = this.returnNearestFactionControlledPorts(faction, spacekey);

    let msg = this.returnFactionName(faction) + " - Select Winter Port for Naval Units in "+space.name;
    let opt = "<ul>";
    for (let i = 0; i < res.length; i++) {
      opt += `<li class="option" id="${res[i].key}">${res[i].key}</li>`;
    }
    opt += "</ul>";

    if (res.length == 0) {
      this.endTurn();
      return 0;
    }

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let id = $(this).attr('id');
      $(".option").off();
      his_self.updateStatus("wintering ships");

      his_self.addMove("retreat_to_winter_ports_resolve\t"+faction+"\t"+spacekey+"\t"+id);
      his_self.endTurn();

    });

  }

  //
  // 2P variant needs automatic determination of where to retreat
  //
  autoResolveWinterRetreat(faction, spacekey) {
    let his_self = this;
    let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(faction, spacekey);
    if (res.length > 0) {
      let space = this.game.spaces[spacekey];
      let roll = this.rollDice(res.length);
      if (res[roll-1].hops > 0) {
        let retreat_destination = res[roll-1].key;
        his_self.game.queue.push("retreat_to_winter_spaces_resolve\t"+faction+"\t"+spacekey+"\t"+retreat_destination);
      }
    }
  }

  playerResolveWinterRetreat(faction, spacekey) {

    let his_self = this;
    let res = this.returnNearestFriendlyFortifiedSpaces(faction, spacekey);
    let space = this.game.spaces[spacekey];

    let msg = this.returnFactionName(faction) + " - Select Winter Location for Units in "+space.name;
    let opt = "<ul>";
    for (let i = 0; i < res.length; i++) {
      opt += `<li class="option" id="${res[i].key}">${res[i].key}</li>`;
    }
    opt += "</ul>";

    if (res.length == 0) {
      this.endTurn();
      return 0;
    }

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let id = $(this).attr('id');
      $(".option").off();

      his_self.updateStatus("handling retreat...");
      his_self.addMove("retreat_to_winter_spaces_resolve\t"+faction+"\t"+spacekey+"\t"+id);
      his_self.endTurn();

    });

  }

  playerRetainUnitsWithFilter(faction, filter_func, num_to_retain) {

    let his_self = this;
    let units_available = [];
    let units_to_retain = [];

    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
	for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (filter_func(key, i)) {
	    units_available.push({spacekey : key, idx : i});
	  }
	}
      }
    }

    let selectUnitsInterface = function(his_self, units_to_retain, units_available, selectUnitsInterface) {

      let msg = "Select Units to Retain: ";
      let html = "<ul>";
      for (let i = 0; i < units_available.length; i++) {
	let spacekey = units_available[i].spacekey;
	let unit = his_self.game.spaces[spacekey].units[faction][units_available[i].idx];
        if (units_to_retain.includes(parseInt(i))) {
          html += `<li class="option" style="font-weight:bold" id="${i}">${units_available[i].name} - (${units_available[i].spacekey})</li>`;
        } else {
          html += `<li class="option" id="${i}">${units_available[i].name} - (${units_available[i].spacekey})</li>`;
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {

	  //
	  // moves prepended to last removed first
	  //
	  for (let i = units_available.length; i >= 0; i--) {
	    if (!units_to_retain.includes(i)) {
	      his_self.prependMove("destroy_unit_by_index\t"+faction+"\t"+spacekey+"\t"+units_available[i].idx);
	    }
	  }
	  his_self.endTurn();
	  return;

	}

	//
	// add unit to units available
	//
        if (units_to_retain.includes(id)) {
          let idx = units_to_retain.indexOf(id);
          if (idx > -1) {
            units_to_move.splice(idx, 1);
          }
        } else {
	  units_to_retain.push(id);
	}

	//
	// if this is max to retain, we end as well
	//
	if (units_to_retain.length === num_to_retain) {

	  //
	  // moves prepended to last removed first
	  //
	  for (let i = units_available.length; i >= 0; i--) {
	    if (!units_to_retain.includes(i)) {
	      his_self.prependMove("destroy_unit_by_index\t"+faction+"\t"+spacekey+"\t"+units_available[i].idx);
	    }
	  }
	  his_self.endTurn();
	  return;
	}
      });
    }

    selectUnitsInterface(his_self, units_to_retain, units_available, selectUnitsInterface);

    return 0;

  }

  returnPlayerFactions(player) {
    return this.game.state.players_info[player-1].factions;
  }

  returnActionMenuOptions(player=null, faction=null, limit="") {

    let menu = [];

if (limit === "build") {
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenary,
      fnct : this.playerBuyMercenary,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2,2,2],
      name : "Regular",
      check : this.canPlayerBuyRegular,
      fnct : this.playerBuyRegular,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Squadron",
      check : this.canPlayerBuyNavalSquadron,
      fnct : this.playerBuyNavalSquadron,
      category : "build" ,
      img : '/his/img/backgrounds/move/squadron.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Cavalry",
      check : this.canPlayerBuyCavalry,
      fnct : this.playerBuyCavalry,
      category : "build" ,
      img : '/his/img/backgrounds/move/cavalry.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Corsair",
      check : this.canPlayerBuyCorsair,
      fnct : this.playerBuyCorsair,
      category : "build" ,
      img : '/his/img/backgrounds/move/corsair.jpg',
    });

} else {

    //
    // only burning books and theological debates
    //
    if (limit === "mary_i") {
      menu.push({
        factions : ['papacy','protestant'],
        cost : [3,3],
        name : "Convene Debate",
        check : this.canPlayerCallTheologicalDebateMaryI,
        fnct : this.playerCallTheologicalDebateMaryI,
        category : "special" ,
        img : '/his/img/backgrounds/move/theological_debate.jpg',
      });
      menu.push({
        factions : ['papacy'],
        cost : [2],
        name : "Burn Books",
        check : this.canPlayerBurnBooksMaryI,
        fnct : this.playerBurnBooksMaryI,
        category : "special" ,
        img : '/his/img/backgrounds/move/burn_books.jpg',
      });
    } else {

    menu.push({
      factions : ['hapsburg','england','france','papacy','ottoman','protestant'],
      cost : [0,0,0,0,0,0],
      name : "First Game / Need Help?",
      check : this.canPlayerShowTutorial,
      fnct : this.playerShowTutorial,
      category : "move" ,
      img : '/his/img/backgrounds/move/help.jpeg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Move",
      check : this.canPlayerMoveFormationInClear,
      fnct : this.playerMoveFormationInClear,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_in_clear.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Move across Sea",
      check : this.canPlayerNavalTransport,
      fnct : this.playerNavalTransport,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_transport.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1],
      name : "Move Ships",
      check : this.canPlayerNavalMove,
      fnct : this.playerNavalMove,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_fleet.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2,2,2],
      name : "Regular",
      check : this.canPlayerBuyRegular,
      fnct : this.playerBuyRegular,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenary,
      fnct : this.playerBuyMercenary,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Cavalry",
      check : this.canPlayerBuyCavalry,
      fnct : this.playerBuyCavalry,
      category : "build" ,
      img : '/his/img/backgrounds/move/cavalry.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Squadron",
      check : this.canPlayerBuyNavalSquadron,
      fnct : this.playerBuyNavalSquadron,
      category : "build" ,
      img : '/his/img/backgrounds/move/squadron.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Corsair",
      check : this.canPlayerBuyCorsair,
      fnct : this.playerBuyCorsair,
      category : "build" ,
      img : '/his/img/backgrounds/move/corsair.jpg',
    });
    if (this.game.players.length == 2) {
      menu.push({
        factions : ['papacy','protestant'] ,
        cost : [1,1,1,1,1,1,1,1,1,1],
        name : "Remove Unrest",
        check : this.canPlayerRemoveUnrest,
        fnct : this.playerRemoveUnrest,
        category : "attack" ,
        img : '/his/img/backgrounds/move/control.jpg',
      });
    } else {
      menu.push({
        factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
        cost : [1,1,1,1,1,1,1,1,1,1],
        name : "Remove Unrest",
        check : this.canPlayerRemoveUnrest,
        fnct : this.playerRemoveUnrest,
        category : "attack" ,
        img : '/his/img/backgrounds/move/control.jpg',
      });
    }
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Control",
      check : this.canPlayerControlUnfortifiedSpace,
      fnct : this.playerControlUnfortifiedSpace,
      category : "attack" ,
      img : '/his/img/backgrounds/move/control.jpg',
    });
    menu.push({
      factions : ['ottoman','england'],
      cost : [1,1],
      name : "Foreign War",
      check : this.canPlayerFightForeignWar,
      fnct : this.playerFightForeignWar,
      category : "attack" ,
      img : '/his/img/backgrounds/move/foreign-war2.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [0,0,0,0,0,0,0,0,0,0],
      name : "Assault",
      check : this.canPlayerAssaultTutorial,
      fnct : this.playerAssaultTutorial,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Assault",
      check : this.canPlayerAssault,
      fnct : this.playerAssault,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [2,2,2],
      name : "Explore",
      check : this.canPlayerExplore,
      fnct : this.playerExplore,
      category : "special" ,
      img : '/his/img/backgrounds/move/explore.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [2,3,3],
      name : "Colonize",
      check : this.canPlayerColonize,
      fnct : this.playerColonize,
      category : "special" ,
      img : '/his/img/backgrounds/move/colonize.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [4,4,4],
      name : "Conquer",
      check : this.canPlayerConquer,
      fnct : this.playerConquer,
      category : "special" ,
      img : '/his/img/backgrounds/move/conquer.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [2],
      name : "Piracy",
      check : this.canPlayerInitiatePiracyInASea,
      fnct : this.playerInitiatePiracyInASea,
      category : "attack" ,
      img : '/his/img/backgrounds/move/piracy.jpg',
    });
    menu.push({
      factions : ['protestant'],
      cost : [1],
      name : "Translate Scripture",
      check : this.canPlayerTranslateScripture,
      fnct : this.playerTranslateScripture,
      category : "special" ,
      img : '/his/img/backgrounds/move/translate.jpg',
    });
if (this.game.state.events.cramner_active == 1) {
    menu.push({
      factions : ['england','protestant'],
      cost : [3,2],
      name : "Publish Treatise",
      check : this.canPlayerPublishTreatise,
      fnct : this.playerPublishTreatise,
      category : "special" ,
      img : '/his/img/backgrounds/move/printing_press.jpg',
    });
} else {
    menu.push({
      factions : ['england','protestant'],
      cost : [2,2],
      name : "Publish Treatise",
      check : this.canPlayerPublishTreatise,
      fnct : this.playerPublishTreatise,
      category : "special" ,
      img : '/his/img/backgrounds/move/printing_press.jpg',
    });
}
    menu.push({
      factions : ['papacy','protestant'],
      cost : [3,3],
      name : "Convene Debate",
      check : this.canPlayerCallTheologicalDebate,
      fnct : this.playerCallTheologicalDebate,
      category : "special" ,
      img : '/his/img/backgrounds/move/theological_debate.jpg',
    });
    menu.push({
      factions : ['papacy'],
      cost : [1],
      name : "Build Saint Peters",
      check : this.canPlayerBuildSaintPeters,
      fnct : this.playerBuildSaintPeters,
      category : "special" ,
      img : '/his/img/backgrounds/move/saint_peters.png',
    });
    menu.push({
      factions : ['papacy'],
      cost : [2],
      name : "Burn Books",
      check : this.canPlayerBurnBooks,
      fnct : this.playerBurnBooks,
      category : "special" ,
      img : '/his/img/backgrounds/move/burn_books.jpg',
    });
    // Loyola reduces Jesuit University Cost
    let university_founding_cost = 3;
    if (this.canPlayerCommitDebater("papacy", "loyola-debater")) {
      let university_founding_cost = 2;
    }
    menu.push({
      factions : ['papacy'],
      cost : [university_founding_cost],
      name : "Found University",
      check : this.canPlayerFoundJesuitUniversity,
      fnct : this.playerFoundJesuitUniversity,
      category : "special" ,
      img : '/his/img/backgrounds/move/university.png',
    });

    } // mary_i limit check
}

    //
    // major powers have limited options in 2P version
    //
    if (this.game.players.length == 2 && (faction === "hapsburg" || faction === "england" || faction === "france" || faction == "ottoman")) {
      for (let i = menu.length-1; i >= 0; i--) {
	if (menu[i].category == "build") { menu.splice(i, 1); } else {
	  if (menu[i].category == "special") { menu.splice(i, 1); } else {
  	    if (menu[i].name === "Move across Sea") { menu.splice(i, 1); }
          }
        }
      }
    } 

    if (player == null) { return menu; }

    let fmenu = [];

    for (let i = 0; i < menu.length; i++) {
      if (menu[i].factions.includes(faction)) {
        fmenu.push(menu[i]);
      }
    }

    return fmenu;

  }

  playerSelectFactionWithFilter(msg, filter_func, mycallback = null, cancel_func = null) {

    let his_self = this;
    let factions = this.returnImpulseOrder();
    let f = [];

    for (let i = 0; i < factions.length; i++) {
      if (filter_func(factions[i])) { f.push(factions[i]); }
    }

    let html = "<ul>";
    for (let i = 0; i < f.length; i++) {
      html += `<li class="option" id="${f[i]}">${f[i]}</li>`;
    }
    html += "</ul>";

    his_self.updateStatusWithOptions(msg, html);
     
    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");
      $('.option').off();
      mycallback(id);
    });

    return 0;
  }

  playerFactionSelectCardWithFilter(faction, msg, filter_func, mycallback = null, cancel_func = null) {

    let cards = [];
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      if (filter_func(this.game.deck[0].fhand[faction_hand_idx][i])) {
	cards.push(this.game.deck[0].fhand[faction_hand_idx][i]);
      }
    }

    this.updateStatusAndListCards(msg, cards);
    this.attachCardboxEvents(function(card) {
      mycallback(card, faction);
    });

  }

  countSpacesWithFilter(filter_func) {
    let count = 0;
    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) { count++; }
    }
    return count;
  }

  playerSelectSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let callback_run = false;
    let at_least_one_option = false;
    let html = '';
    html += '<ul class="hide-scrollbar">';

    $('.option').off();
    $('.hextile').off();
    $('.space').off();

    this.theses_overlay.space_onclick_callback = mycallback;

    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) {

        at_least_one_option = true;
        html += '<li class="option '+key+'" id="' + key + '">' + his_self.returnSpaceName(key) + '</li>';

	//
	// the spaces that are selectable are clickable on the main board (whatever board shows)
	//
	if (board_clickable) {
	  let t = "."+key;
	  document.querySelectorAll(t).forEach((el) => {
	    his_self.addSelectable(el);
	    el.onclick = (e) => {
	      e.stopPropagation();
	      e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	      el.onclick = () => {};
	      $('.option').off();
	      $('.space').off();
	      $('.hextile').off();
              his_self.theses_overlay.space_onclick_callback = null;
	      his_self.removeSelectable();
    	      if (callback_run == false) {
	        callback_run = true;
	        mycallback(key);
	      }
	    }
	  });
	}
      }
    }
    if (cancel_func != null) {
      html += '<li class="option" id="cancel">cancel</li>';
    }
    html += '</ul>';

    this.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      //
      // and remove on-board clickability
      //
      if (board_clickable) {
        for (let key in his_self.game.spaces) {
          if (filter_func(his_self.game.spaces[key]) == 1) {
	    let t = "."+key;
	    document.querySelectorAll(t).forEach((el) => {
	      el.onclick = (e) => {};
	    });
	  }
	}
      }

      his_self.removeSelectable();

      $('.option').off();
      $('.space').off();
      $('.hextile').off();

      let action = $(this).attr("id");
      if (action == "cancel") {
        cancel_func();
        return 0;
      }

      his_self.theses_overlay.space_onclick_callback = null;
      mycallback(action);

    });

    if (at_least_one_option) { return 1; }
    return 0;
  }

  playerSelectSpaceOrNavalSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {
    return this.playerSelectNavalSpaceWithFilter(msg, filter_func, mycallback, cancel_func, board_clickable);
  }

  playerSelectNavalSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let at_least_one_option = false;
    let callback_run = false;

    this.theses_overlay.space_onclick_callback = mycallback;

    // remove any previous events
    $('.option').off();
    $('.hextile').off();
    $('.space').off();

    let html = '';
    html += '<ul class="hide-scrollbar">';
    for (let key in this.game.navalspaces) {
      if (filter_func(this.game.navalspaces[key]) == 1) {
	at_least_one_option = true;
        html += '<li class="option" id="' + key + '">' + key + '</li>';
	if (board_clickable) {
	  document.querySelectorAll(`.${key}`).forEach((el) => { his_self.addSelectable(el); });
	  document.getElementById(key).onclick = (e) => {
	    $('.option').off();
     	    $('.hextile').off();
    	    $('.space').off();
	    if (callback_run == true) { return; }
	    callback_run = true;
	    e.stopPropagation();
	    e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	    his_self.removeSelectable();
            his_self.theses_overlay.space_onclick_callback = null;
    	    if (callback_run == false) {
	      callback_run = true;
    	      his_self.updateStatus("selected...");
	      mycallback(key);
	    }
	  }
	}
      }
    }
    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) {
        at_least_one_option = true;
        html += '<li class="option" id="' + key + '">' + key + '</li>';
	if (board_clickable) {
	  document.querySelectorAll(`.${key}`).forEach((el) => { his_self.addSelectable(el); });
	  document.getElementById(key).onclick = (e) => { 
	    document.getElementById(key).onclick = (e) => {};
	    $('.option').off();
     	    $('.hextile').off();
    	    $('.space').off();
	    if (callback_run == true) { return; }
	    callback_run = true;
	    e.stopPropagation();
	    e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	    his_self.removeSelectable();
            his_self.theses_overlay.space_onclick_callback = null;
    	    his_self.updateStatus("selected...");
	    mycallback(key);
	    return;
	  }
	}
      }
    }
    if (cancel_func != null) {
      html += '<li class="option" id="cancel">cancel</li>';
    }
    html += '</ul>';

    this.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action = $(this).attr("id");

      // remove events to prevent re-firing
      $('.option').off();
      $('.hextile').off();
      $('.space').off();

      his_self.removeSelectable();

      if (action == "cancel") {
        cancel_func();
        return 0;
      }

      his_self.theses_overlay.space_onclick_callback = null;
      mycallback(action);

    });

    if (at_least_one_option) { return 1; }
    return 0;
  }




  playerTurn(faction, selected_card=null) {

    this.startClock();

    let his_self = this;

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    let can_pass = true;

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length;i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (c === "001") { can_pass = false; }
      if (c === "002") { can_pass = false; }
      if (c === "003") { can_pass = false; }
      if (c === "004") { can_pass = false; }
      if (c === "005") { can_pass = false; }
      if (c === "006") { can_pass = false; }
      if (c === "007") { can_pass = false; }
      if (c === "008") { can_pass = false; }
      if (c === "009") { can_pass = false; }
      if (c === "010") { can_pass = false; }
      cards.push(this.game.deck[0].fhand[faction_hand_idx][i]);
      try {
        if (this.game.deck[0].cards[c].type == "mandatory") { can_pass = false; }
      } catch (err) {
	// cards removed by other cards -- force play to remove from deck
	can_pass = false;
      }

    } // no home card? can pass

    if (this.factions[faction].returnAdminRating(this) < this.game.deck[0].fhand[faction_hand_idx].length) {
      can_pass = false;
    }

    if (this.game.deck[0].fhand[faction_hand_idx].length == 0) {

      can_pass = true;
      if (!cards.includes("pass")) {
        cards.push("pass");
      }

      //
      // in faster_play mode, we will switch to HALTED if there are     
      // no other options. this halts OUR game but allows others to continue
      // to play more rapidly, which helps speed-up games where network connections
      // can be a little slow, at the cost of leaking a small amount of information
      // about player hands from the speed of the response (i.e. a fast response 
      // likely means an automatic response, which likely means no cards permitting
      // intervention are in-hand.
      //
      if (this.faster_play == 1) {
          
        //
        // we don't need to HALT the game because the game will not progress
        // until all players have hit RESOLVE anyway.
        //
        let my_specific_game_id = his_self.game.id;
        his_self.is_halted = 1;
        his_self.halted = 1;
        his_self.game.queue[his_self.game.queue.length-1] = "HALTED\tWaiting for Game to Continue\t"+his_self.publicKey;
        his_self.hud.back_button = false;
              
        his_self.updateStatusAndListCards(his_self.returnFactionName(faction) + " - You Must Pass", cards);
        his_self.attachCardboxEvents((card) => {
          try {
            $('.card').off();
            $('.card img').off();
          } catch (err) {}

          his_self.game = his_self.loadGame(my_specific_game_id);
            
          // tell game engine we can move
          his_self.is_halted = 0;
          his_self.halted = 0;
          his_self.gaming_active = 0;

          his_self.updateStatus('continuing...');

          //
          // our own move will have been ticked into the future queue, along with
          // anyone else's so we skip restartQueue() which will freeze if it sees
          // that we have moves still pending, but should clear if it now finds
          // UNHALT is the latest instruction and this resolve is coming from us!
          //
          his_self.processFutureMoves();

        });

        //
        // halt my game (copies from ACKNOWLEDGE)
        //
        his_self.addMove("pass\t"+faction+"\t0"); // 0 => no cards in hand
        his_self.endTurn();
        return 0;

      }
    }
    if (can_pass) {
      if (!cards.includes("pass")) {
        cards.push("pass");
      }
    }

    this.updateStatusAndListCards(this.returnFactionName(faction) + " - Select Your Card: ", cards);
    this.attachCardboxEvents((card) => {
      try {
        $('.card').off();
        $('.card img').off();
      } catch (err) {}
      this.game_help.hide();

      //
      //
      //
      if (card == "pass") {
        this.playerPlayCard(card, this.game.player, faction);
	return 1;
      }

      //
      // if faction is England and Mary I is ruler, we have 50% 
      //
      if (this.game.players.length > 2 && faction == "england" && this.game.state.leaders.mary_i == 1 && this.game.deck[0].cards[card].ops >= 2) {
	let x = this.rollDice(6);
	if (x >= 4) {
	  this.addMove("mary_i_subverts_protestantism\t"+card+"\t"+x);
	}
      }

      if (this.game.players.length == 2 && faction == "protestant" && this.game.state.leaders.mary_i) {
	this.addMove("decide_if_mary_i_subverts_protestantism_in_2P");
      }

      this.playerPlayCard(card, this.game.player, faction);
    });  

  }


  playerReliefForcesJoinBattle(faction, spacekey) {
    
    let space = this.game.spaces[spacekey];
    let player = this.returnPlayerCommandingFaction(faction);

    let his_self = this;
    let units_to_move = [];
    let available_units = [];

    for (f in space.units) {
      for (let i = 0; i < space.units[f].length; i++) {
	if (space.units[f][i].besieged != 0) {
          available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	}
      }
    }

    //
    // unfortify the units
    //
    let finishAndFortify = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let fa = {};
      for (let f in space.units) { fa[f] = []; };

      for (let i = 0; i < units_to_move.length; i++) {
        let tf = units_to_move[i].faction;
        let tu = units_to_move[i].idx;
        fa[tf].push(tu);
      }

      for (let f in fa) {
	for (let z = 0; z < fa[f].length; z++) {
          his_self.addMove("unfortify_unit_by_index\t"+spacekey+"\t"+f+"\t"+fa[f][z]);
	}
      }
      his_self.endTurn();
      return;
    }
 
    //
    // select the units to unfortify
    //
    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let unmoved_units = [];
      let moved_units = [];

      let msg = "Which Fortified Units Join the Field Battle: ";
      let html = "<ul>";

      for (let i = 0; i < available_units.length; i++) {
	let is_this_unit_moving = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (
	    units_to_move[z].faction == available_units[i].faction &&
	    units_to_move[z].idx == available_units[i].unit_idx
	  ) { 
	    is_this_unit_moving = true;
          }
        }
        let tf = available_units[i].faction;
        let tu = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (is_this_unit_moving) {
          html += `<li class="option" style="font-weight:bold" id="${i}">* ${tu.name} - ${his_self.returnFactionName(tf)} *</li>`;
	  moved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
	} else {
          html += `<li class="option" style="" id="${i}">${tu.name} - ${his_self.returnFactionName(tf)}</li>`;
	  unmoved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      let mobj = {
        spacekey : spacekey ,
        moved_units : moved_units ,
        unmoved_units : unmoved_units ,
      }

      his_self.fortification_overlay.render(mobj, [], selectUnitsInterface, finishAndFortify, 1); // 1 => "unfortifying"
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
          his_self.fortification_overlay.hide();
          finishAndFortify(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          areturn;
        }

	let x = id.split("-");
	let f = x[0];
	let idx = x[1];

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	}
	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	  }
	} else {

	  let unitno = 0;
	  for (let i = 0; i < units_to_move.length; i++) {
	    if (space.units[units_to_move[i].faction][units_to_move[i].idx].army_leader == false) { unitno++; }
	    if (unitno >= 4) {
	      alert("Max 4 Units Permitted in Fortification");
	      return;
	    }
	  }
	  units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	}

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);

      });
    }
 
    //
    // PLAYER STARTS HERE
    //
    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
    return 0;

  }



  playerFortifySpace(faction, attacker, spacekey, post_battle=false) {

    let space = this.game.spaces[spacekey];
    let faction_map = this.returnFactionMap(space, attacker, faction);
    let attacker_player = this.returnPlayerCommandingFaction(attacker);
    let player = this.returnPlayerCommandingFaction(faction);

    let his_self = this;
    let units_to_move = [];
    let available_units = [];
    let anyone_in_relief_force = false;

    for (f in faction_map) {
      if (this.returnPlayerCommandingFaction(f) != attacker_player) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].relief_force == 1) { anyone_in_relief_force = true; }
	}
      }
    }
    if (this.game.state.field_battle.relief_battle == 1) { anyone_in_relief_force = true; }

    for (f in faction_map) { 
      if (this.returnPlayerCommandingFaction(f) != attacker_player) {
        for (let i = 0; i < space.units[f].length; i++) {
	  if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary" || space.units[f][i].type == "cavalry" || space.units[f][i].army_leader == true) {
	    if (anyone_in_relief_force == false) {
              available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	    } else {
	      if (space.units[f][i].relief_force == 1) {
                available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	      } 
	    } 
          }
        }
      }
    }

    //
    // fortify the units_to_move
    //
    let finishAndFortify = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let fa = {};
      for (let f in faction_map) { fa[f] = []; };

      for (let i = 0; i < units_to_move.length; i++) {
        let tf = units_to_move[i].faction;
        let tu = units_to_move[i].idx;
        fa[tf].push(tu);
      }

      for (let f in fa) {
	for (let z = 0; z < fa[f].length; z++) {
          his_self.addMove("fortify_unit_by_index\t"+spacekey+"\t"+f+"\t"+fa[f][z]);
	}
      }
      his_self.endTurn();
      return;
    }

    //
    // select the units to fortify
    //
    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let unmoved_units = [];
      let moved_units = [];

      let msg = "Fortification Holds 4 Units: ";
      let html = "<ul>";

      for (let i = 0; i < available_units.length; i++) {
	let is_this_unit_moving = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (
	    units_to_move[z].faction == available_units[i].faction &&
	    units_to_move[z].idx == available_units[i].unit_idx
	  ) { 
	    is_this_unit_moving = true;
          }
        }
        let tf = available_units[i].faction;
        let tu = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (is_this_unit_moving) {
          html += `<li class="option" style="font-weight:bold" id="${i}">* ${tu.name} - ${his_self.returnFactionName(tf)} *</li>`;
	  moved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
	} else {
          html += `<li class="option" style="" id="${i}">${tu.name} - ${his_self.returnFactionName(tf)}</li>`;
	  unmoved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      let mobj = {
        spacekey : spacekey ,
        moved_units : moved_units ,
        unmoved_units : unmoved_units ,
      }

      his_self.fortification_overlay.render(mobj, [], selectUnitsInterface, finishAndFortify); // no destination interface
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
          his_self.fortification_overlay.hide();
          finishAndFortify(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          areturn;
        }

	let x = id.split("-");
	let f = x[0];
	let idx = x[1];

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	}
	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	  }
	} else {

	  let unitno = 0;
	  for (let i = 0; i < units_to_move.length; i++) {
	    if (space.units[units_to_move[i].faction][units_to_move[i].idx].army_leader == false) { unitno++; }
	    if (unitno >= 4) {
	      alert("Max 4 Units Permitted in Fortification");
	      return;
	    }
	  }
	  units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	}

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);

      });
    }


    //
    // PLAYER STARTS HERE
    //
    let can_we_quick_fortify = true;
    if (available_units.length > 4) {
      let overunits = 0;
      for (let i = 0; i < available_units.length; i++) {
	let u = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { overunits++; }
	if (u.relief_force == 1) { can_we_quick_fortify = false; }
      }
      if (overunits > 4) {
        can_we_quick_fortify = false; 
      }
    }

    if (can_we_quick_fortify == true) {

      //
      // prevents UI flickering to have AUTO copied here
      //
      if (post_battle == 0) {
        for (let i = 0; i < available_units.length; i++) {
          units_to_move.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
        finishAndFortify(his_self, units_to_move);
	return 0;
      }

      let msg = "Choose Fortification Option: ";
      let html = "<ul>";
      html += `<li class="option" id="auto">fortify everything (auto)</li>`;
      if (post_battle == 1) {
        html += `<li class="option" id="manual">select units (manual)</li>`;
      }
      html += "</ul>";
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "auto") {
          for (let i = 0; i < available_units.length; i++) {
            units_to_move.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
          }
          finishAndFortify(his_self, units_to_move);
          return 0;
        }

        if (id === "manual") {
          selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          return 0;
        }

      });

      return 0;

    } else {

      //
      // we have to move manually, this implies post_battle
      //
      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
      return;

    }

    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
    return 0;

  }

  playerPlayDiplomacyCard(faction) {

    let p = this.returnPlayerOfFaction(faction);
    let his_self = this;

    this.updateStatusAndListCards("Select Diplomacy Card to Play", this.game.deck[1].hand);
    this.attachCardboxEvents(function(card) {

      this.updateStatus(`Playing ${this.popup(card)}`, this.game.deck[1].hand);
      his_self.addMove("diplomacy_card_event\t"+faction+"\t"+card);
      his_self.addMove("discard_diplomacy_card\t"+faction+"\t"+card);

      let faction_hand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
      his_self.addMove("cards_left\t"+faction+"\t"+his_self.game.deck[0].fhand[faction_hand_idx].length); // no -1 because we r just updating other hand

      his_self.endTurn();
    });

  }

  playerPlayCard(card, player, faction) {
    
    //
    // cards left
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    let cards_in_hand = this.game.deck[0].fhand[faction_hand_idx].length;

    this.cardbox.hide();
    this.game.state.active_card = card;

    if (card === "pass") {
      this.updateStatus("Passing this Round...");
      this.addMove("pass\t"+faction+"\t"+cards_in_hand);
      this.endTurn();
      return;
    } else {
      this.addMove("cards_left\t"+faction+"\t"+(cards_in_hand-1)); // -1 because we playing this card
    }

    //
    // mandatory event cards effect first, then 2 OPS
    //
    let deck = this.returnDeck(true); // removed don't get evented
    let event_this = false;
    let can_event_this = false;

    try {
      if (deck[card].type === "mandatory" && deck[card].canEvent(this, faction)) {
        event_this = true;
      }
    } catch (err) {}

    if (event_this) {
      this.addMove("remove\t"+faction+"\t"+card);
      this.addMove("ops\t"+faction+"\t"+card+"\t"+2);
      this.playerPlayEvent(card, faction);
    } else {

      let html = `<ul>`;
      html    += `<li class="card" id="ops">play for ops</li>`;
      try {
        if (deck[card].canEvent(this, faction) && !this.game.state.cards_evented.includes(card)) {
  	  can_event_this = true;
        }
      } catch (err) {}
      if (can_event_this) {
        html    += `<li class="card" id="event">play for event</li>`;
      }
      html    += `</ul>`;

      let pick_card_function = () => {
        this.updateStatusWithOptions(`Playing ${this.popup(card)}`, html, true);
        this.bindBackButtonFunction(() => { this.playerTurn(faction); });
        this.attachCardboxEvents((user_choice) => {
          if (user_choice === "ops") {
            let ops = this.game.deck[0].cards[card].ops;
            this.playerPlayOps(card, faction, ops);
            return;
          }
          if (user_choice === "event") {
            if (this.game.deck[0].cards[card].warn.includes(faction)) {
              let c = confirm("Unorthodox! Are you sure you want to event this card?");
              if (!c) {
                pick_card_function();
               return;
              }
              this.playerPlayEvent(card, faction);
              return;
            } else {
              this.playerPlayEvent(card, faction);
              return;
	    }
            return;
          }
        });
      }

      pick_card_function();
    }

  }


  //
  // when Mary I is in play, 50% chance English cards can be
  // used to burn books and convene theological debates
  //
  async playerPlayMaryI(card="", faction) {

    let his_self = this;
    let menu = this.returnActionMenuOptions(this.game.player, faction, "mary_i");
    let ops = this.game.deck[0].cards[card].ops;

    let attachEventsToMenuOptions = () => {

      this.updateStatusWithOptions(`${this.returnFactionName(faction)}: ${ops} ops remaining`, html, false);
      this.attachCardboxEvents(async (user_choice) => {      

	his_self.menu_overlay.hide();

        if (user_choice === "end_turn") {
          this.endTurn();
          return;
        }

	let ops_to_spend = 0;

        for (let z = 0; z < menu[user_choice].factions.length; z++) {
          if (pfactions.includes(menu[user_choice].factions[z])) {
            ops -= menu[user_choice].cost[z];
	    ops_to_spend = menu[user_choice].cost[z];
  	    z = menu[user_choice].factions.length+1;
          }
        }

	//
	// we end if there is only 1 OP left
	//
        if (ops > 1) {
  	  this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
        }
        menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
        return;

      });

    } // attach events to menu options

    this.menu_overlay.render(menu, this.game.player, faction, ops, attachEventsToMenuOptions);
    attachEventsToMenuOptions();

  }

  async playerPlayOps(card="", faction, ops=null, limit="") {

    //
    // cards left
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    this.addMove("cards_left\t"+faction+"\t"+this.game.deck[0].fhand[faction_hand_idx].length-1); // -1 because we playing this card

    //
    // discard the card
    //
    if (card != "") {
      this.addMove("discard\t"+faction+"\t"+card);
      if (this.game.deck[0]) {
        if (this.game.deck[0].cards[card]) {
          if (this.game.deck[0].cards[card].ops == ops) {
            this.addEndMove("NOTIFY\t" + this.returnFactionName(faction) + " plays " + this.popup(card) + " for ops");
          }
        }
      }
    }

    let his_self = this;
    let menu = this.returnActionMenuOptions(this.game.player, faction, limit);
    let pfactions = this.returnPlayerFactions(this.game.player);

    if (ops == null) { ops = 2; }
    if (ops == 0) { 
      this.endTurn();
      return;
    }

    //
    // "ACTIVATED POWERS" are those for whom players have the choice of moving.
    // this can be triggered through alliance with a minor power, or through a 
    // diplomacy card in the 2P game.
    //
    if (this.game.state.activated_powers[faction].length > 0) {

      let html = `<ul>`;
      html    += `<li class="card" id="${faction}">${faction}</li>`;
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
         html    += `<li class="card" id="${this.game.state.activated_powers[faction][i]}">${this.game.state.activated_powers[faction][i]}</li>`;
         for (let z = 0; z < this.game.state.activated_powers[this.game.state.activated_powers[faction][i]].length; z++) {
	   html += `<li class="card" id="${this.game.state.activated_powers[this.game.state.activated_powers[faction][i]][z]}">${this.game.state.activated_powers[this.game.state.activated_powers[faction][i]][z]}</li>`;
	 }
      }
      html    += `</ul>`;

      let ops_text = `${ops} op`;
      if (ops > 0) { ops_text += 's'; }

      this.updateStatusWithOptions(`Which Faction: ${ops_text}`, html);
      this.attachCardboxEvents(function(selected_faction) {

        menu = this.returnActionMenuOptions(this.game.player, selected_faction, limit);

	//
	// duplicates code below
	//
        let html = `<ul>`;
        for (let i = 0; i < menu.length; i++) {
	  // added ops to check() for naval transport
          if (menu[i].check(this, this.game.player, selected_faction, ops)) {
            for (let z = 0; z < menu[i].factions.length; z++) {
              if (menu[i].factions[z] === selected_faction) {
  	        if (menu[i].cost[z] <= ops) {
		  if (menu[i].cost[z] > 0) {
                    html    += `<li class="card" id="${i}">${menu[i].name} [${menu[i].cost[z]} ops]</li>`;
                  }
                }
	        z = menu[i].factions.length+1;
              }
            }
          }
        }

        html    += `<li class="card" id="end_turn">end turn</li>`;
        html    += `</ul>`;

	let attachEventsToMenuOptions = () => {

        his_self.updateStatusWithOptions(`${his_self.returnFactionName(selected_faction)}: ${ops} ops remaining`, html, false);
        this.attachCardboxEvents(async (user_choice) => {      

	  his_self.updateStatus("acknowledge");
	  his_self.menu_overlay.hide();

          if (user_choice === "end_turn") {
            this.endTurn();
            return;
          }

	  //
	  // cost of founding depends on Loyola
	  //
	  if (menu[user_choice].name.indexOf("University") != -1) {

	    let default_cost = 3;
    	    if (this.canPlayerCommitDebater("papacy", "loyola-debater")) {

	      let msg = "Commit Loyola to reduce cost to 2 OPs?";
      	      let html = `<ul>`;
              html += `<li class="option" id="commit">commit Loyola (2 OPs)</li>`;
              html += `<li class="option" id="donot">do not commit (3 OPs)</li>`;
	      html += '</ul>';

	      his_self.updateStatusWithOptions(msg, html);
      	      his_self.attachCardboxEvents(async (moar_user_choice) => {      

	        if (moar_user_choice === "commit") {
                  ops -= 2;
                  if (ops > 0) {
 		    his_self.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
		  }
                  his_self.addMove("commit\tpapacy\tloyola-debater\t1");
                  his_self.playerFoundJesuitUniversity(his_self, player, "papacy");
                  return;
		}

		if (moar_user_choice === "donot") {
                  ops -= 3;
		  if (ops > 0) {
 		    his_self.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
                  }
                  his_self.playerFoundJesuitUniversity(his_self, player, "papacy");
                  return;
		}

	      });

	    } else {
              ops -= 3;
	      if (ops > 0) {
 	        his_self.addMove("continue\t"+this.game.player+"\t"+selected_faction+"\t"+card+"\t"+ops+"\t"+limit); 
              }
              menu[user_choice].fnct(this, this.game.player, selected_faction, 3, ops);
              return;
	    }

	  } else {

	    //
	    // sub-menu to simplify translations / st peters
	    //
	    if (menu[user_choice].name.indexOf("Peters") != -1 || menu[user_choice].name.indexOf("Translate") != -1) {

	      //
	      // skip if only 1 ops
	      //
	      if (ops == 1) {

                  menu[user_choice].fnct(this, this.game.player, selected_faction, 1, 0);
                  return;

	      } else {

	        let msg = "How many OPs to Spend: ";
                let html = `<ul>`;
	        let desc = ['one', 'two', 'three', 'four', 'five', 'six'];
                for (let i = 1; i <= ops; i++) {
                  html += `<li class="card" id="${i}">${desc[i-1]}</li>`;
                }
                html += '</ul>';

                this.updateStatusWithOptions(msg, html, false);
                this.attachCardboxEvents(async (uc) => {      

	          let ops_to_spend = parseInt(uc);
	          let ops_remaining = ops - ops_to_spend;
 
                  if (ops_remaining > 0) {
    	            this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops_remaining+"\t"+limit);
                  }
                  menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops_remaining);
                  return;
	        });

	      }

	    } else {

	      let ops_to_spend = 0;
	      let cost = 0;

              for (let z = 0; z < menu[user_choice].factions.length; z++) {
                if (menu[user_choice].factions[z] === selected_faction) {
		  cost = menu[user_choice].cost[z];
                  ops -= menu[user_choice].cost[z];
		  ops_to_spend = menu[user_choice].cost[z];
	          z = menu[user_choice].factions.length+1;
                }
              }
	      if (cost == 0) {
                menu[user_choice].fnct(this, this.game.player, selected_faction, ops_to_spend, ops);
		this.playerPlayOps(card, faction, ops, limit);
                return;
	      }
              if (ops > 0) {
	        this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
              }
              menu[user_choice].fnct(this, this.game.player, selected_faction, ops_to_spend, ops);
              return;

	    }
	  }
        });

	} // function

	his_self.menu_overlay.render(menu, this.game.player, selected_faction, ops, attachEventsToMenuOptions);

	attachEventsToMenuOptions();

      });
    } else {

      //
      // duplicates code above
      //
      let html = `<ul>`;
      for (let i = 0; i < menu.length; i++) {

        if (menu[i].check(this, this.game.player, faction)) {
          for (let z = 0; z < menu[i].factions.length; z++) {
            if (menu[i].factions[z] === faction) {
  	      if (menu[i].cost[z] <= ops) {
		if (menu[i].cost[z] > 0) {
                  html += `<li class="card" id="${i}">${menu[i].name} [${menu[i].cost[z]} ops]</li>`;
                }
              }
	      z = menu[i].factions.length+1;
            }
          }
        }
      }

      html    += `<li class="card" id="end_turn">end turn</li>`;
      html    += `</ul>`;

      let attachEventsToMenuOptions = () => {

      this.updateStatusWithOptions(`${this.returnFactionName(faction)}: ${ops} ops remaining`, html, false);
      this.attachCardboxEvents(async (user_choice) => {      

	his_self.updateStatus("acknowledge");
	his_self.menu_overlay.hide();

        if (user_choice === "end_turn") {
          this.endTurn();
          return;
        }

	//
	// sub-menu to simplify translations / st peters
	//
	if (menu[user_choice].name.indexOf("Peters") != -1 || menu[user_choice].name.indexOf("Translate") != -1) {

	  //
	  // skip if only 1 ops
	  //
	  if (ops == 1) {
            menu[user_choice].fnct(this, this.game.player, faction, 1, 0);
            return;
	  }

	  let msg = "How many OPs to Spend: ";
          let html = `<ul>`;
	  let desc = ['one', 'two', 'three', 'four', 'five', 'six'];
          for (let i = 1; i <= ops; i++) {
            html += `<li class="card" id="${i}">${desc[i-1]}</li>`;
          }
          html += '</ul>';

          this.updateStatusWithOptions(msg, html, false);
          this.attachCardboxEvents(async (uc) => {      

	    let ops_to_spend = parseInt(uc);
	    let ops_remaining = ops - ops_to_spend;

            if (ops_remaining > 0) {
  	      this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops_remaining+"\t"+limit);
            }
            menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops_remaining);
            return;
	  });

	} else {

	  let ops_to_spend = 0;
	  let cost = 0;

          for (let z = 0; z < menu[user_choice].factions.length; z++) {
            if (pfactions.includes(menu[user_choice].factions[z])) {
	      cost = menu[user_choice].cost[z];
              ops -= menu[user_choice].cost[z];
	      ops_to_spend = menu[user_choice].cost[z];
  	      z = menu[user_choice].factions.length+1;
            }
          }

	  if (cost == 0) {
            menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
	    this.playerPlayOps(card, faction, ops, limit);
            return;
	  }
          if (ops > 0) {
  	    this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
          }
          menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
          return;

	}
      });

      } // attach events to menu options

      this.menu_overlay.render(menu, this.game.player, faction, ops, attachEventsToMenuOptions);
      attachEventsToMenuOptions();

    }
  }
  playerPlayEvent(card, faction, ops=null) {

    //
    // cards left
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    this.addMove("cards_left\t"+faction+"\t"+this.game.deck[0].fhand[faction_hand_idx].length-1); // -1 because we playing this card
    
    let deck = this.returnDeck();
    if (deck[card].removeFromDeckAfterPlay(this, faction)) {
      this.addMove("remove\t"+faction+"\t"+card);
    }
    this.addMove("event\t"+faction+"\t"+card);
    this.addMove("discard\t"+faction+"\t"+card);

    // counter_or_acknowledge if the player is the Protestants and Wartburg is not in the discard pile as
    // the Protestants might have it. Otherwise ACKNOWLEDGE to ensure players know what is happening but
    // don't halt the game for the player moving.

    //
    // wartburg is 037 -- mandatory events cannot be cancelled so we use ACKNOWLEDGE
    // this prevents things like DEFENDER OF THE FAITH or CLEMENT VII from halting 
    // gameplay mid-turn and slowing everything down.
    //
    if (deck[card].type == "mandatory" || !deck[card].canEvent(this, faction)) {
      this.addMove("ACKNOWLEDGE\t" + this.returnFactionName(faction) + " triggers " + this.popup(card));
    } else {
      //
      // otherwise, we skip if the Protestants cannot interfere
      //
      if (faction == "protestant" || this.game.deck[0].discards["037"] || this.game.state.events.intervention_on_events_possible == false) {
        this.addMove("ACKNOWLEDGE\t" + this.returnFactionName(faction) + " triggers " + this.popup(card));
      } else {
        this.addMove("counter_or_acknowledge\t" + this.returnFactionName(faction) + " triggers " + this.popup(card) + "\tevent\t"+card);
        this.addMove("RESETCONFIRMSNEEDED\tall");
      }
    }

    this.endTurn();
  }


  playerActionMenu(player) {
    let menu_options = this.returnActionMenuOptions();
  }

  async playerReformationAttempt(player) {
    this.updateStatus("Attempting Reformation Attempt");
    return;
  }
  async playerCounterReformationAttempt(player) {
console.log("1");
return;
  }

  playerPlayPapacyDiplomacyPhaseSpecialTurn(enemies=[]) {

    let his_self = this;
    let player = this.returnPlayerOfFaction("papacy");
    if (this.game.player != player) { this.updateStatus("ERROR: you are not the papacy"); return; }

 
    let msg = `End a War? [`;
    for (let i = 0; i < enemies.length; i++) { if (i > 0) { msg += ", "; } msg += this.returnFactionName(enemies[i]); };
    msg += ']';
    let opt = "<ul>";
    opt += `<li class="option" id="yes">yes</li>`;
    opt += `<li class="option" id="no">no</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      his_self.updateStatus("acknowledge...");

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "no") {
	his_self.endTurn();
	return 0;
      }

      //
      // otherwise YES
      //
      let msg = `Which Faction?`;
      let opt = "<ul>";
      for (let i = 0; i < enemies.length; i++) {
        opt += `<li class="option" id="${enemies[i]}">${enemies[i]}</li>`;
      }
      opt += '</ul>';

      his_self.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {

	let enemy = $(this).attr('id');

        //
        // otherwise YES
        //
        let msg = `How would you like to End the War?`;
        let opt = "<ul>";
	let allow_bull = 0;

	if (enemy == "hapsburg" && his_self.game.state.excommunicated_factions["hapsburg"] != 1) { allow_bull = 1; }
	if (enemy == "france" && his_self.game.state.excommunicated_factions["france"] != 1) { allow_bull = 1; }

	if (allow_bull) {
          opt += `<li class="option" id="005">papal bull</li>`;
	}
        opt += `<li class="option" id="sue">sue for peace</li>`;
        opt += '</ul>';

        his_self.updateStatusWithOptions(msg, opt);

        $(".option").off();
        $(".option").on('click', function () {

	  let method = $(this).attr('id');

	  if (method === "005") {

	    //
	    // excommunicate faction 
	    //
	    his_self.addMove("excommunicate_faction\t"+enemy);

	    //
	    // factions no longer At War
	    //
	    his_self.addMove("unset_enemies\tpapacy\t"+enemy);

	    //
	    // regain control of home space, or draw card
	    //
    	    let msg = `Regain Home Space or Draw Card?`;
    	    let opt = "<ul>";
    	    opt += `<li class="option" id="regain">regain home space</li>`;
    	    opt += `<li class="option" id="draw">draw card</li>`;
    	    opt += '</ul>';

	    his_self.updateStatusWithOptions(msg, opt);

	    $(".option").off();
	    $(".option").on('click', function () {

	      let action2 = $(this).attr('id');

	      if (action2 === "draw") {
                his_self.addMove("hand_to_fhand\t1\t"+his_self.game.player+"\t"+"papacy");
                his_self.addMove(`DEAL\t1\t${his_self.game.player}\t1`);
		his_self.endTurn();
	      }

	      if (action2 === "regain") {

    	        his_self.playerSelectSpaceWithFilter(

                  "Select Home Space to Recapture" ,

        	  function(space) {
	            if (space.home === "papacy" && space.political !== "papacy") {
		      return 1;
		    }
		  },

      		  function(spacekey) {
                    his_self.addMove(`control\tpapacy\t${spacekey}`);
                    his_self.addMove(`withdraw_to_nearest_fortified_space\t${enemy}\t${spacekey}`);
	            his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
	            his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);
		    his_self.endTurn();
		  },

	    	  cancel_func,

	    	  true 

	  	);

	      }

	    });

	  }

	  if (method === "sue") {

	    //
	    // factions no longer At War
	    //
	    his_self.addMove("unset_enemies\tpapacy\t"+enemy);
	    // unset activated power for protestants in 2P
	    if (his_self.isActivatedPower("protestant", enemy) && (enemy === "hapsburg" || enemy === "france")) {
	      his_self.addMove("unset_activated_power\tprotestant\t"+enemy);
	    }

	    //
	    // protestants get War Winner 1 VP
	    //
	    his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
            his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);

	    //
	    // papacy removes 2 units
	    //
            his_self.playerSelectSpaceOrNavalSpaceWithFilter(
              `Select Space to Remove 1st Unit` ,
              function(space) {
	        if (space.units["papacy"].length > 0) { return 1; }
		return 0;
              },
              function(spacekey) {
	        let land_or_sea = "land";
	        let space = null;
	        if (his_self.game.navalspaces[spacekey]) {
	  	  land_or_sea = "sea";
		  space = his_self.game.navalspaces[spacekey];
	        } else {
		  space = his_self.game.spaces[spacekey];
	        }
	        if (space == null) {
		  alert("ERROR: not sure where you clicked - reload to continue");
		  return 1;
	        }
	        let faction_to_destroy = "papacy";
   	        let msg = "Destroy Which Unit: ";
                let unittypes = [];
                let html = '<ul>';
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].command_value == 0 && space.units[faction_to_destroy][i].personage != true) {
                    if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                      html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                      unittypes.push(space.units[faction_to_destroy][i].key);
                    }
                  }
                }
                html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);
                $('.option').off();
                $('.option').on('click', function () {
                  let unittype = $(this).attr("id");
		  his_self.updateStatus("removing unit...");
                  his_self.removeUnit(faction_to_destroy, spacekey, unittype);
                  his_self.displaySpace(spacekey);
                  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
	    	  //
	          // papacy removes 2 units
	          //
                  his_self.playerSelectSpaceOrNavalSpaceWithFilter(
                    `Select Space to Remove 2nd Unit` ,
                    function(space) {
	              if (space.units["papacy"].length > 0) { return 1; }
		      return 0;
                    },
                    function(spacekey) {

		      his_self.updateStatus("removing unit...");

	              let land_or_sea = "land";
	              let space = null;
	              if (his_self.game.navalspaces[spacekey]) {
	  	        land_or_sea = "sea";
		        space = his_self.game.navalspaces[spacekey];
	              } else {
		        space = his_self.game.spaces[spacekey];
	              }
	              if (space == null) {
		        alert("ERROR: not sure where you clicked - reload to continue");
		        return 1;
	              }
	              let faction_to_destroy = "papacy";
   	              let msg = "Destroy Which Unit: ";
                      let unittypes = [];
                      let html = '<ul>';
                      for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                        if (space.units[faction_to_destroy][i].personage != true && space.units[faction_to_destroy][i].battle_rating != 1) {
                         if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                            html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                            unittypes.push(space.units[faction_to_destroy][i].key);
                          }
                        }
                      }
                      html += '</ul>';
                      his_self.updateStatusWithOptions(msg, html);
                      $('.option').off();
                      $('.option').on('click', function () {
                        let unittype = $(this).attr("id");
		        his_self.updateStatus("removing unit...");
                        his_self.removeUnit(faction_to_destroy, spacekey, unittype);
                        his_self.displaySpace(spacekey);
                        his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
			let z = false;
                        his_self.addMove("player_play_papacy_regain_spaces_for_vp\t"+enemy);
		        his_self.endTurn();
		      });
	            },
	            0 ,
	            1
	          );
		});
	      },
	      0 ,
	      1
	    );
	  }	
	});
      });
    });

    return 0;

  }



  playerRegainLeadersForVPOrCards(loser, winner) {
 
    let his_self = this;
    let target_leaders = [];

    if (!f.includes(io[i])) {
      for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
        if (his_self.game.state.players_info[p2-1].captured[z].faction == loser) {
          target_leaders.push(his_self.game.state.players_info[p2-1].captured[z]);
        }
      }
    } 
   
    let msg = "Regain Leader for 1 VP or 1 CARD DRAW: ";
    let opt = "<ul>";
    for (let z = 0; z < target_leaders.length; z++) {
      opt += `<li class="option" id="${z}">${target_leaders[z].type}</li>`;
    }
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let leader = $(this).attr('id');
      
      if (prize == "skip") {
	his_self.endTurn();
	return;
      }

      his_self.addMove("display_vp_track");
      if (target_leaders.length > 1) {
        his_self.addMove(`war_loser_regain_leaders_for_vp_or_cards\t${loser}\t${winner}`);
      }
      his_self.addMove("ransom\t"+leader);
      his_self.endTurn();
    });

  }




  playerRegainSpacesForVPOrCards(loser, winner) {
 
    let his_self = this;
    let target_spaces = his_self.countSpacesWithFilter(function(space) { if (space.home == loser && space.political == winner) { return 1; } return 0; });
    let target_faction = winner;

    let msg = "Do you wish to Regain TWO Non-Key Home Spaces for 1 VP or 1 CARD DRAW: ";
    let opt = "<ul>";
    opt += `<li class="option" id="vp">regain and give VP</li>`;
    opt += `<li class="option" id="card">regain and give card</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let prize = $(this).attr('id');
      
      if (prize == "skip") {
	his_self.endTurn();
	return;
      }

      his_self.playerSelectSpaceWithFilter(
        "Select First Home Space to Recapture" ,
        function(space) {
          if (space.type != "key" && space.home === loser && space.political == winner) {
	    return 1;
	  }
	},
      	function(spacekey1) {

          his_self.playerSelectSpaceWithFilter(
            "Select First Home Space to Recapture" ,
            function(space) {
	      if (space.key != spacekey1 && space.type != "key" && space.home === loser && space.political == winner) {
	        return 1;
	      }
	    },
      	    function(spacekey2) {
	      if (target_spaces >= 4) {
                his_self.addMove(`war_loser_regain_spaces_for_vp_or_cards\t${loser}\t${winner}`);
	      }

              his_self.addMove("display_vp_track");
              his_self.addMove(`control\t${loser}\t${spacekey2}`);
              his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey2}`);
              his_self.addMove(`control\t${loser}\t${spacekey1}`);
              his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey1}`);

	      if (prize == "vp") {
	        let target_faction = winner;
                if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
                if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
                if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
                if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
                if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
                if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }
	      } else {
                his_self.addMove("pull_card\t"+winner+"\t"+loser);
	      }
	      his_self.endTurn();
	    },
	    null,
	    true,
	  );
	},
	null,
	true
      );
    });
  }




   playerRegainKeysForVP(loser, winner) {

    let his_self = this; 
    let captured_keys = 0;

    let spaces = his_self.returnSpacesWithFilter(
      function(spacekey) {
	if (his_self.game.spaces[spacekey].type == "key" && his_self.game.spaces[spacekey].home == loser && his_self.game.spaces[spacekey].political == winner) { return true; }
        return false;
      }
    ); 

    captured_keys = spaces.length;

    if (spaces.length == 0) {
      his_self.endTurn();
      return;
    }

    let msg = "Do you wish to Regain Home Keys for 1 VP: ";
    let opt = "<ul>";
    opt += `<li class="option" id="regain">regain and give VP</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "skip") {
	his_self.endTurn();
	return;
      }

      if (id === "regain") {
        his_self.playerSelectSpaceWithFilter(

          "Select Home Key to Recapture" ,

          function(space) {
	    if (space.type == "key" && space.home === loser && space.political == winner) {
	      return 1;
	    }
	  },

      	  function(spacekey) {

            his_self.addMove("display_vp_track");

	    if (captured_keys > 1) {
              his_self.addMove(`control\t${loser}\t${spacekey}`);
	    }

            his_self.addMove(`control\t${loser}\t${spacekey}`);
            his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey}`);

	    let target_faction = winner;
            if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
            if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
            if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
            if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
            if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
            if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }

	    his_self.endTurn();
	  },

	  null,

	  true 

        );

      }

    });


   }

   playerPlayPapacyRegainSpacesForVP(faction) {

    let his_self = this; 

    let spaces = his_self.returnSpacesWithFilter(
      function(spacekey) {
	if (his_self.game.spaces[spacekey].home == "papacy" && his_self.game.spaces[spacekey].political == faction) { return true; }
        return false;
      }
    ); 

    if (spaces.length == 0) {
      his_self.endTurn();
      return;
    }

    let msg = "Do you wish to Regain Home Space for 1 VP: ";
    let opt = "<ul>";
    opt += `<li class="option" id="regain">regain and give VP</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "skip") {
	his_self.endTurn();
	return;
      }

      if (id === "regain") {
        his_self.playerSelectSpaceWithFilter(

          "Select Home Space to Recapture" ,

          function(space) {
	    if (space.home === "papacy" && space.political !== "papacy") {
	      return 1;
	    }
	  },

      	  function(spacekey) {
            his_self.addMove("display_vp_track");
            his_self.addMove(`control\tpapacy\t${spacekey}`);
            his_self.addMove(`withdraw_to_nearest_fortified_space\t${faction}\t${spacekey}`);
	    his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
	    his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);
	    his_self.endTurn();
	  },

	  null,

	  true 

        );

      }

    });

  }


  playerReturnWinterUnits(faction) {

    this.addMove("RESOLVE\t"+this.publicKey);

    let his_self = this;
    let capitals = this.returnCapitals(faction);
    let viable_capitals = [];
    let units_to_move = [];
    let cancel_func = null;

    let processed_spacekeys = [];
    let selected_destination = "";
    let source_spacekey = "";

    for (let i = 0; i < capitals.length; i++) {
      let c = capitals[i];
      if (this.isSpaceControlled(c, faction)) {
        viable_capitals.push(capitals[i]);
      }
    }

    var finish_selecting_from_space_function = function() {};
    var select_units_function = function() {};
    var pick_capital_function = function() {};
    var select_spacekey_function = function() {};


    finish_selecting_from_space_function = function(his_self, units_to_move) {

      his_self.updateStatus("processing...");

      processed_spacekeys.push(source_spacekey);

      for (let i = 0; i < units_to_move.length; i++) {
        his_self.removeUnit(units_to_move[i].faction, units_to_move[i].spacekey, units_to_move[i].type);
        his_self.addMove("remove_unit\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+units_to_move[i].spacekey+"\t"+his_self.game.player);
        if (!capitals.includes(units_to_move[i].spacekey)) {
          his_self.addMove("build\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+selected_destination+"\t"+0);
	} else {
          his_self.addMove("build\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+units_to_move[i].spacekey+"\t"+0);
	}
      }

      //
      // reset !
      //
      units_to_move = [];

      his_self.displayBoard();

      let count = his_self.countSpacesWithFilter((space) => {
        if (
          his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0 &&
	  !capitals.includes(space.key) && 
	  !processed_spacekeys.includes(space.key)
	) { return 1; }
        return 0;
      });

      //
      // no viable spaces, so we exit
      //
      if (count == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " no more spaces with units to withdraw");
        his_self.endTurn(); 
        return;
      }

      let msg = his_self.returnFactionName(faction) + " - Return Units to Capital?";
      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
        opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
      }
      opt += `<li class="option" id="finish">finish</li>`;
      opt += '</ul>';

      his_self.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {

        let id = $(this).attr('id');

        if (id == "finish") {
          his_self.updateStatus("processing winter relocation...");
          his_self.endTurn();
          return;
        }

        selected_destination = id;
        select_spacekey_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);
      });

    }


    select_units_function = function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function) {

      let unmoved_units = [];
      let moved_units = [];

      let space = his_self.game.spaces[source_spacekey];
      let max_formation_size = 100;
      let msg = his_self.returnFactionName(faction) + " - Select from " + his_self.returnSpaceName(source_spacekey);

      let html = "<ul>";

      for (let i = 0; i < space.units[faction].length; i++) {
        let u = space.units[faction][i];
        if (u.type != "corsair" && u.reformer != true && u.type != "squadron") {
	  let does_units_to_move_have_unit = false;
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction == faction && units_to_move[z].idx == i && units_to_move[z].spacekey == source_spacekey) { does_units_to_move_have_unit = true; break; }
	  }
	  if (does_units_to_move_have_unit) {
	    html += `<li class="option" style="font-weight:bold" id="${faction}-${i}">*${u.name} (${faction})*</li>`;
	    moved_units.push({ spacekey : source_spacekey , faction : faction , idx : i , type : u.type });
	  } else {
	    html += `<li class="option" id="${faction}-${i}">${u.name} (${faction})</li>`;
	    unmoved_units.push({ spacekey : source_spacekey, faction : faction , idx : i , type : u.type });
	  }
	}
      }

      let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : source_spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : selected_destination ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	    selectUnitsInterface : select_units_function ,
	    selectDestinationInterface : finish_selecting_from_space_function ,
      }

      his_self.movement_overlay.renderForceOpen(mobj, units_to_move, select_units_function, finish_selecting_from_space_function); // no destination interface

      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";


      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "end") {
	    his_self.movement_overlay.hide();
	    finish_selecting_from_space_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);
	    return;
	}

	let x = id.split("-");
	let f = x[0];
	let idx = parseInt(x[1]);

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].spacekey == source_spacekey && units_to_move[z].faction == f  && units_to_move[z].idx == idx) {
	      does_units_to_move_have_unit = true; 
	      break; 
	    }
	}

	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].spacekey == source_spacekey && units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	      units_to_move.splice(z, 1);
	      his_self.available_units_overlay.fadeOut(true);
	      break;
	    }
	  }
	  if (units_to_move.length == 0) {
	    his_self.available_units_overlay.faded_out = false;
	  }
	} else {
          units_to_move.push( { spacekey : source_spacekey , faction : f , idx : idx , type : space.units[f][idx].type });
	}

	select_units_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);

      });
    }
  


    select_spacekey_function = function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function) {

      // reset u2m
      units_to_move = [];

      let count = his_self.countSpacesWithFilter((space) => {
        if (
          his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0 &&
	  !capitals.includes(space.key) && 
	  !processed_spacekeys.includes(space.key)
	) { return 1; }
        return 0;
      });

      //
      // no viable spaces, so we exit
      //
      if (count == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " no more spaces with units to withdraw");
        his_self.endTurn(); 
        return;
      }


      if (faction == "protestant") { his_self.theses_overlay.render("german"); }
      if (faction == "papacy") { his_self.theses_overlay.render("italian"); }
      if (faction == "england") { his_self.theses_overlay.render("english"); }
      if (faction == "france") { his_self.theses_overlay.render("french"); }
      if (faction == "hapsburg") { his_self.theses_overlay.render("spanish"); }
      if (faction == "ottoman") { his_self.theses_overlay.render("ottoman"); }

      his_self.playerSelectSpaceWithFilter(

        "Select Location to Move Units",

        //
        // any fortified non-capital space
        //
        function(space) {
          if (
            his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0 &&
	    !capitals.includes(space.key) && 
	    !processed_spacekeys.includes(space.key)
	  ) { return 1; }
          return 0;
        },

        //
        // launch unit selection overlay
        //
        function(spacekey) {
	  source_spacekey = spacekey;
	  select_units_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);
        },
        null ,
        1 
      );
    }

    pick_capital_function = function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function) {

      let msg = his_self.returnFactionName(faction) + " - Return Units to Capital?";
      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
        opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
      }
      opt += `<li class="option" id="finish">finish</li>`;
      opt += '</ul>';

      if (viable_capitals.length == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " skipping wintering in capital");
        his_self.endTurn(); 
	return;
      }

      his_self.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {
        let id = $(this).attr('id');
	if (id == "finish") {
	  his_self.updateStatus("processing winter relocation...");
	  his_self.endTurn();
	  return;
	}
        selected_destination = id;
        select_spacekey_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);
      });

    }

    //
    // start the magic
    //
    pick_capital_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);

  }

  playerPlaySpringDeployment(faction, player) {

    let his_self = this;
    let capitals = this.factions[faction].capitals;
    let viable_capitals = [];
    let can_deploy = 0;
    let units_to_move = [];
    let cancel_func = null;
    let source_spacekey;

    for (let i = 0; i < capitals.length; i++) {
      let c = capitals[i];
      if (this.game.spaces[c].units[faction].length > 0) {
        can_deploy = 1;
        viable_capitals.push(capitals[i]);
      }
    }

    if (can_deploy == 0) {
      this.updateStatus("Spring Deployment not possible");
      this.endTurn();
    } else {

      let msg = this.returnFactionName(faction) + " - Spring Deploy from:";     
      if (faction === "ottoman") { msg = "Ottomans - Spring Deploy from?"; }

      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
	opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
      }
      //opt += `<li class="option" id="cards">( see my cards )</li>`;
      opt += `<li class="option" id="pass">skip</li>`;
      opt += '</ul>';


      his_self.spring_deployment_overlay.render(faction);

      this.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {

        let id = $(this).attr('id');

	//if (id === "cards") {
        //  let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
        //  let c = his_self.game.deck[0].fhand[fhand_idx];
        //  his_self.deck_overlay.render("hand", c);
	//  return;
        //}

	source_spacekey = id;
        $(".option").off();
        his_self.spring_deployment_overlay.hide();

	if (id === "pass") {
	  his_self.updateStatus("passing...");
	  his_self.endTurn();
	  return;
        }

       his_self.playerSelectSpaceWithFilter(

          "Select Destination for Units from Capital: ",

          function(space) {
            if (his_self.isSpaceFriendly(space, faction)) {
              if (his_self.isSpaceConnectedToCapitalSpringDeployment(space, faction)) {
                if (!his_self.isSpaceFactionCapital(space, faction)) {
		  if (his_self.game.state.events.schmalkaldic_league == 0) {
		    if (his_self.isSpaceElectorate(space.key)) { return 0; }
		  }
                  return 1;
		}
              }
            }
            return 0;
          },


          function(destination_spacekey) {

            let space = his_self.spaces[source_spacekey];

	    //
	    // spring deployment doesn't have this, so we wrap the sending/end-move
	    // action in this dummy function so that the same UI can be used for 
	    // multiple movement options, with the normal one including intervention
	    // checks etc.
	    //
	    let selectDestinationInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	      // MOVE THE UNITS
	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

              for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+source_spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
              }
              his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" spring deploys to "+his_self.game.spaces[destination_spacekey].name);
              his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;
              return;

	    };

            let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) { 
              let unmoved_units = [];
              let moved_units = [];
	      let space = his_self.game.spaces[source_spacekey];

	      let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, source_spacekey);
	      if (faction != his_self.game.state.events.spring_preparations) { 
  		if (his_self.isSpaceConnectedToCapitalSpringDeployment(destination_spacekey, faction, 0) == 0) {
		  if (max_formation_size > 5) { max_formation_size = 5; } 
	        }
  	      }

	      let msg = "Max Formation Size: " + max_formation_size + " units";
	      let html = '<ul>';

	      for (let key in space.units) {
                if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
                  for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
                    if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
                    if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
                      let does_units_to_move_have_unit = false;
                      for (let z = 0; z < units_to_move.length; z++) {
                        if (units_to_move[z].faction == key && units_to_move[z].idx == i) { 
does_units_to_move_have_unit = true; }
		      }
                      if (does_units_to_move_have_unit) {
                        html += `<li class="option" style="font-weight:bold" id="${key}-${i}">*${space.units[key][i].name} (${key})*</li>`;
                        moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
                      } else {
                        html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
                        unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
                      }
                    }
                    }
                    }
                  }
                }
	      }

              let mobj = {
                space : space ,
                faction : faction ,
                source : source_spacekey ,
                unmoved_units : unmoved_units ,
                moved_units : moved_units ,
                destination : destination_spacekey ,
		units_to_move : units_to_move ,
		max_formation_size : max_formation_size ,
              }


	      //
	      // auto-move if only 1 unit
	      //
	      let can_we_quick_move = false;
	      if (mobj.moved_units.length == 0 && mobj.unmoved_units.length == 1) { can_we_quick_move = true; } 

	      if (can_we_quick_move == false) {
   	        his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
              }

	      html += `<li class="option" id="end">finish</li>`;
              html += "</ul>";

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let id = $(this).attr("id");

	        if (id === "end") {
	          his_self.movement_overlay.hide();
	          selectDestinationInterface(his_self, units_to_move);
	          return;
	        }

	        let x = id.split("-");
	        let f = x[0];
	        let idx = parseInt(x[1]);

	        let uob = his_self.returnOnBoardUnits(f);

	        let does_units_to_move_have_unit = false;
	        for (let z = 0; z < units_to_move.length; z++) {
	          if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		    does_units_to_move_have_unit = true;
		    break;
		  }
	        }

	        if (does_units_to_move_have_unit) {

	          if (uob.overcapacity == 1) {
	            alert("This faction is over-capacity (no more unused 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of manually re-assigning by numbers");
	            return;
	          }

	          for (let z = 0; z < units_to_move.length; z++) {
	            if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		      units_to_move.splice(z, 1);
	              his_self.available_units_overlay.fadeOut(true);
		      break;
		    }
	          }
	        } else {

	          if (uob.overcapacity == 1) {
	            alert("This faction is over-capacity (no more unused 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of manually re-assigning by numbers");
	            return;
	          }


	          //
	          // check for max formation size
	          //
	          let unitno = 0;
	          for (let i = 0; i < units_to_move.length; i++) {
	            if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	            if (unitno >= max_formation_size) { 
		      max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	              if (unitno >= max_formation_size) { 
	                alert("Maximum Formation Size: " + max_formation_size);
	                return;
		      }
	            }
	          }

	          units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	        }

                selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);

              });

	      if (can_we_quick_move) {
		units_to_move = JSON.parse(JSON.stringify(mobj.unmoved_units));
	        selectDestinationInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	        his_self.displaySpace(source_spacekey);
	        his_self.displaySpace(destination_spacekey);
		his_self.updateStatus("deploying...");
		return;
	      }
            }

            selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
          },

	  null ,

	  true

        );
      });
    }
  }

  returnMaxFormationSize(units_to_move, faction = "", spacekey = "") {

    let utm = [];
    if (units_to_move.length > 0) {
      if (typeof units_to_move[0] != "number") {
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].type && !units_to_move[z].owner) {
	    let added = 0;
	    for (let y = 0; added == 0 && y < this.game.spaces[spacekey].units[units_to_move[z].faction].length; y++) {
	      let u = this.game.spaces[spacekey].units[units_to_move[z].faction][y];
	      if (u.type !== "regular" && u.type !== "mercenary" && u.type !== "cavalry" && u.type !== "corsair" && u.type !== "squadron") {
		if (u.type === units_to_move[z].type) {
	    	  utm.push(this.game.spaces[spacekey].units[units_to_move[z].faction][y]);
		  added = 1;
		}
	      }
	    }
	    if (added == 0) {
	      utm.push(this.game.spaces[spacekey].units[units_to_move[z].faction][units_to_move[z].idx]);
	    }
	  } else {
	    utm.push(units_to_move[z]);
	  }
	}
      } else {
        for (let i = 0; i < units_to_move.length; i++) { utm.push(this.game.spaces[spacekey].units[faction][units_to_move[i]]); }
      }
    }

    let command_value_one = 0;
    let command_value_two = 0;
    let max_command_value = 0;

    for (let i = 0; i < utm.length; i++) {
      if (utm[i].command_value > 0) {
        // we can have up to two army leaders combine command values
	if (command_value_one == 0) {
	  command_value_one = utm[i].command_value; 
	} else {
	  if (command_value_two == 0) {
	    command_value_two = utm[i].command_value;
	  } else {
  	    if (command_value_one > command_value_two && utm[i].command_value > command_value_one) {
	      command_value_one = utm[i].command_value;
	    } else {
	      if (command_value_one < command_value_two && utm[i].command_value > command_value_two) {
	        command_value_two = utm[i].command_value;
	      }
	    }
	  }
	}
	max_command_value = command_value_one + command_value_two;
      }
    }

    if (max_command_value > 4) { return max_command_value; }
    return 4;

  }

//
// duplicates playerMoveFormationInClear
//
  async playerContinueToMoveFormationInClear(his_self, player, faction, spacekey, ops_to_spend, ops_remaining=0) {

    //
    // we add this before broadcasting, or the turn ends 
    //
    // blank is "card", which we don't care about anymore so don't include
    let continue_move = "continue\t"+this.game.player+"\t"+faction+"\t"+""+"\t"+(ops_remaining-ops_to_spend);

    let parent_faction = faction;
    let units_to_move = [];
    let cancel_func = null;
    let space = this.game.spaces[spacekey];
    let protestant_player = his_self.returnPlayerOfFaction("protestant");
    let parent_player = his_self.returnPlayerCommandingFaction(faction);

	//
	// first define the functions that will be used internally
	//
	let selectDestinationInterface = function(his_self, units_to_move) {  
    	  his_self.playerSelectSpaceWithFilter(

            "Select Destination for these Units",

      	    function(space) {
	      // no-one can move into electorates before schmalkaldic league forms
              if (his_self.game.player != protestant_player && his_self.game.state.events.schmalkaldic_league == 0) {
		if (space.type == "electorate") { return 0; }
	      }
	      // you cannot move into spaces that are not allied or enemies
              if (!his_self.canFactionMoveIntoSpace(faction, space.key)) { return 0; }
	      if (space.neighbours.includes(spacekey)) {
	        if (!space.pass) { 
		  return 1; 
		} else {
 		  if (!space.pass.includes(spacekey)) {
		    return 1;
		  } else {
		    if (ops_remaining >= 1) {
		      // we have to flag and say, "this costs an extra op"
		      return 1;
		    } else {
		      return 0;
		    }
		  }
		}
	  	return 1;
              }
	      return 0;
            },

      	    function(destination_spacekey) {

	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});
	
	      let does_movement_include_cavalry = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
		if (units_to_move[i].type === "cavalry") {
		  does_movement_include_cavalry = 1;
		}
	      }

	      //
	      // modify "continue" instruction if this is a move over a pass
	      //
	      let space = his_self.game.spaces[spacekey];
	      if (space.pass) {
		if (space.pass.includes(destination_spacekey)) {
		  let y = continue_move.split("\t");
		  let new_ops_remaining = parseInt(y[4])-1;
	  	  continue_move = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
	        }
	      }

	      his_self.addMove("interception_check\t"+faction+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

	      for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
	      }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination_spacekey].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination_spacekey].name + "\tmove");
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.prependMove(continue_move);
	      his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;

	    },

	    cancel_func,

	    true 

	  );
	}

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];

          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player) {
	      for (let i = 0; i < space.units[key].length; i++) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != true && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : "" ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = parseInt(x[1]);

	    let uob = his_self.returnOnBoardUnits(f);

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	        does_units_to_move_have_unit = true; 
		break; 
	      }
	    }

	    if (does_units_to_move_have_unit) {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more unused 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of manually re-assigning by numbers");
	        return;
	      }

	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		  units_to_move.splice(z, 1);
	          his_self.available_units_overlay.fadeOut(true);
		  break;
		}
	      }

	      if (units_to_move.length == 0) {
		his_self.available_units_overlay.faded_out = false;
	      }

	    } else {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of shifting forces in 1-UNIT increments");
	        return;
	      }

	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
	}





	//
	// is this a rapid move ?
	//
	let max_formation_size = his_self.returnMaxFormationSize(space.units[faction]);
	let units_in_space = his_self.returnFactionLandUnitsInSpace(faction, space, true); // true ==> include minor allies
	let can_we_quick_move = false;
	if (max_formation_size >= units_in_space) { can_we_quick_move = true; }
	for (let f in space.units) {
	  for (let z = 0; z < space.units[f].length; z++) {
	    if (space.units[f][z].locked == 1) { can_we_quick_move = false; }
	  }
	}

	if (can_we_quick_move == true) {

	  let msg = "Choose Movement Option: ";
	  let html = "<ul>";
	  html += `<li class="option" id="auto">move everything (auto)</li>`;
	  html += `<li class="option" id="manual">select units (manual)</li>`;
	  html += "</ul>";
	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    for (let key in space.units) {
	      if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	        for (let i = 0; i < space.units[key].length; i++) {
	          if (space.units[key][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1 && id === "auto") {
		    alert("Foul Weather: units in this space have already been moved, so movement from this space must happen manually using only unmoved forces");
		    return;
	          }
	        }
	      }
	    }

	    $('.option').off();

	    if (id === "auto") {
	      for (let key in space.units) {
	        if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	          for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].type !== "squadron" && space.units[key][i].type !== "corsair") {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	            if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
		      units_to_move.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	            }
	            }
	          }
	        }
	      }
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    if (id === "manual") {
	      //
	      // we have to move manually
	      //
	      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	      return;
	    }

	  });

	} else {

	  //
	  // we have to move manually
	  //
	  selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  return;

	}

  }

  async playerMoveFormationInClear(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    let parent_faction = faction;
    let units_to_move = [];
    let cancel_func = null;
    let spacekey = "";
    let space = null;
    let protestant_player = his_self.returnPlayerOfFaction("protestant");
    let parent_player = his_self.returnPlayerCommandingFaction(faction);

	//
	// first define the functions that will be used internally
	//
	let selectDestinationInterface = function(his_self, units_to_move) {  
    	  his_self.playerSelectSpaceWithFilter(

            "Select Destination for these Units",

      	    function(space) {
	      // no-one can move into electorates before schmalkaldic league forms
              if (his_self.game.player != protestant_player && his_self.game.state.events.schmalkaldic_league == 0) {
		if (space.type == "electorate") { return 0; }
	      }
	      // you cannot move into spaces that are not allied or enemies
              if (!his_self.canFactionMoveIntoSpace(faction, space.key)) { return 0; }
	      if (space.neighbours.includes(spacekey)) {
	        if (!space.pass) { 
		  return 1; 
		} else {
 		  if (!space.pass.includes(spacekey)) {
		    return 1;
		  } else {
		    if (ops_remaining >= 1) {
		      // we have to flag and say, "this costs an extra op"
		      return 1;
		    } else {
		      return 0;
		    }
		  }
		}
	  	return 1;
              }
	      return 0;
            },

      	    function(destination_spacekey) {

	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});
	
	      let does_movement_include_cavalry = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
		if (units_to_move[i].type === "cavalry") {
		  does_movement_include_cavalry = 1;
		}
	      }

	      //
	      // modify "continue" instruction if this is a move over a pass
	      //
	      let space = his_self.game.spaces[spacekey];
	      if (space.pass) {
		if (space.pass.includes(destination_spacekey)) {
	          for (let i = 0; i < his_self.moves.length; i++) {
		    let x = his_self.moves[i];
		    let y = x.split("\t");
		    let new_ops_remaining = parseInt(y[4])-1;
		    if (y[0] === "continue") {
		      if (new_ops_remaining) {
	  	        his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
  	  	      } else {
		        his_self.moves.splice(i, 1);
		      }
		    }
	          }
	        }
	      }

	      his_self.addMove("interception_check\t"+faction+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

	      for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
	      }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination_spacekey].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination_spacekey].name + "\tmove");
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;

	    },

	    cancel_func,

	    true 

	  );
	}

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];

          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player) {
	      for (let i = 0; i < space.units[key].length; i++) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != true && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : "" ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = parseInt(x[1]);

	    let uob = his_self.returnOnBoardUnits(f);

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	        does_units_to_move_have_unit = true; 
		break; 
	      }
	    }

	    if (does_units_to_move_have_unit) {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more unused 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of manually re-assigning by numbers");
	        return;
	      }

	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		  units_to_move.splice(z, 1);
	          his_self.available_units_overlay.fadeOut(true);
		  break;
		}
	      }

	      if (units_to_move.length == 0) {
		his_self.available_units_overlay.faded_out = false;
	      }

	    } else {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the tokens you wish to move instead of shifting forces in 1-UNIT increments");
	        return;
	      }

	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
	}
	//
	// end select units
	//


    his_self.playerSelectSpaceWithFilter(

      "Select Town from which to Move Units:",

      function(space) {
	let num_moveable = 0;
	if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }

	for (let z in space.units) {
	  if (space.units[z].length > 0 && his_self.returnPlayerCommandingFaction(z) == his_self.game.player && (z == faction || his_self.returnControllingPower(z) == faction)) {
	    //
	    // Foul Weather prevents spaces with already moved units
	    //
            if (his_self.returnPlayerCommandingFaction(z) == his_self.game.player) {
              for (let i = 0; i < space.units[z].length; i++) {
	        if (space.units[z][i].locked != 1) {
		  if (space.units[z][i].type === "cavalry") { num_moveable++; }
		  if (space.units[z][i].type === "regular") { num_moveable++; }
		  if (space.units[z][i].type === "mercenary") { num_moveable++; }
		  if (space.units[z][i].battle_rating > 0) { num_moveable++; }
                  if (space.units[z][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1) {
	            num_moveable--;
                  }
                }
              }
	      if (num_moveable <= 0) {
		return 0;
	      }
            }

	    return 1;
	  }
	}
	return 0;
      },

      function(skey) {

	spacekey = skey;

        let space = his_self.game.spaces[spacekey];

	//
	// is this a rapid move ?
	//
	let max_formation_size = his_self.returnMaxFormationSize(space.units[faction]);
	let units_in_space = his_self.returnFactionLandUnitsInSpace(faction, space, true); // true ==> include minor allies
	let can_we_quick_move = false;
	if (max_formation_size >= units_in_space) { can_we_quick_move = true; }
	for (let f in space.units) {
	  for (let z = 0; z < space.units[f].length; z++) {
	    if (space.units[f][z].locked == 1) { can_we_quick_move = false; }
	  }
	}

	if (can_we_quick_move == true) {

	  let msg = "Choose Movement Option: ";
	  let html = "<ul>";
	  html += `<li class="option" id="auto">move everything (auto)</li>`;
	  html += `<li class="option" id="manual">select units (manual)</li>`;
	  html += "</ul>";
	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    for (let key in space.units) {
	      if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	        for (let i = 0; i < space.units[key].length; i++) {
	          if (space.units[key][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1 && id === "auto") {
		    alert("Foul Weather: units in this space have already been moved, so movement from this space must happen manually using only unmoved forces");
		    return;
	          }
	        }
	      }
	    }

	    $('.option').off();

	    if (id === "auto") {
	      for (let key in space.units) {
	        if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	          for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].type !== "squadron" && space.units[key][i].type !== "corsair") {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	            if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
		      units_to_move.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	            }
	            }
	          }
	        }
	      }
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    if (id === "manual") {
	      //
	      // we have to move manually
	      //
	      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	      return;
	    }

	  });

	} else {

	  //
	  // we have to move manually
	  //
	  selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  return;

	}
      },

      cancel_func,

      true,

    );

  }

  //
  // players select a card with at least [cost] ops. this respects the "cannot pay with mandatory cards"
  // limitation.
  //
  canPlayerSelectOps(faction, cost) {

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (this.game.deck[0].cards[c].type != "mandatory" && this.game.deck[0].cards[c].ops >= cost) {
	return 1;
      }
    }

    return 0;
  }
  playerSelectOps(faction, cost, mycallback=null, optional_msg="", ignore_cards=[]) {

    let his_self = this;

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (this.game.deck[0].cards[c].type != "mandatory" && this.game.deck[0].cards[c].ops >= cost) {
	if (!ignore_cards.includes(c)) {
          cards.push(c);
	}
      }
    }

    if (optional_msg == "") { optional_msg = "Select a Card: "; }
    this.updateStatusAndListCards(optional_msg, cards);
    this.attachCardboxEvents((card) => {
      try {
        $('.card').off();
        $('.card img').off();
      } catch (err) {}
      mycallback(card);
    });  

  }


// faction is the attacker in pre-naval battles, but it should be the defender
//            this.playerEvaluateNavalRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
//
  playerEvaluateNavalRetreatOpportunity(faction, spacekey, player_comes_from_this_spacekey="", defender="", post_battle=false) {

    let his_self = this;
    let retreat_destination = "";

    let is_port_battle = false;
    let space;
    if (his_self.game.spaces[spacekey]) { is_port_battle = true; space = his_self.game.spaces[spacekey]; }
    if (his_self.game.navalspaces[spacekey]) { space = his_self.game.navalspaces[spacekey]; }

    let neighbours = this.returnNavalAndPortNeighbours(spacekey);
    let retreat_options = 0;
    for (let i = 0; i < neighbours.length; i++) {
      if (his_self.canFactionRetreatToNavalSpace(faction, neighbours[i])) {
	retreat_options++;
      }
    }

    let surviving_units = 0;
    for (let f in space.units) {
      if (f == faction || this.areAllies(f, faction)) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "squadron" || u.type == "corsair") {
	    surviving_units++;
	  }
	}
      }
    }

    if (surviving_units == 0) {
      his_self.updateLog("No units survive to retreat...");
      his_self.endTurn();
      return 0;
    }


    if (retreat_options == 0) {
      his_self.updateLog("Naval retreat not possible...");
      his_self.endTurn();
      return 0;
    }

    let onFinishSelect = function(his_self, destination_spacekey) {
      his_self.addMove("naval_retreat"+"\t"+faction+"\t"+spacekey+"\t"+destination_spacekey);
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {
      let available_destinations = false;
      let html = "<ul>";
      for (let i = 0; i < neighbours.length; i++) {
        if (his_self.canFactionRetreatToNavalSpace(defender, neighbours[i])) {
          available_destinations = true;
          html += `<li class="option" id="${neighbours[i]}">${neighbours[i]}</li>`;
	}
      }
      if (available_destinations == false) {
        html += `<li class="option" id="skip">skip (no options)</li>`;
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Naval Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");

	his_self.updateStatus("retreating...");

	if (id === "skip") {
	  his_self.endTurn();
	  return;
	}
        onFinishSelect(his_self, id);
      });
    };


    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">do not retreat</li>`;
    html    += `</ul>`;

    if (post_battle) {
      if (this.game.state.events.unexpected_war == 1) {
        this.updateStatusWithOptions(`${this.returnFactionName(faction)} must retreat. Retreat?`, html);
      } else {
	if (is_port_battle) {
          this.updateStatusWithOptions(`${this.returnFactionName(faction)} must retreat from Port Assault. Retreat?`, html);
	} else {
          this.updateStatusWithOptions(`${this.returnFactionName(faction)} loses the battle. Retreat?`, html);
	}
      }
    } else {
      this.updateStatusWithOptions(`${this.returnFactionName(faction)} approaches ${this.returnSpaceName(spacekey)}. ${this.returnFactionName(defender)} Retreat?`, html);
      //
      // pre-battle, this swap is NEEDED as faction is what retreats
      //
      faction = defender;
    }
    this.attachCardboxEvents(function(user_choice) {

      if (user_choice === "retreat") {
        his_self.updateStatus("retreating...");
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	if (post_battle) {
          his_self.updateStatus("fleet is sacrificed...");
          his_self.addMove("destroy_faction_units_in_spacekey\t"+faction+"\t"+spacekey);
	} else {
          his_self.updateStatus("processing...");
	}
	his_self.endTurn();
        return;
      }
    });

  }



  playerEvaluateBreakSiegeRetreatOpportunity(attacker, spacekey) {

    let his_self = this;
    let retreat_destination = "";

    let onFinishSelect = function(his_self, destination_spacekey) {
      his_self.addMove("retreat"+"\t"+attacker+"\t"+spacekey+"\t"+destination_spacekey);
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      let html = "<ul>";
      for (let i = 0; i < space.neighbours.length; i++) {
        if (his_self.canFactionRetreatToSpace(attacker, space.neighbours[i])) {
          html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
        }
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");
	his_self.updateStatus("retreating...");
        onFinishSelect(his_self, id);
      });
    };

    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">sacrifice forces</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(attacker)} - siege broken in ${this.returnSpaceName(spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
        his_self.addMove("destroy_faction_units_in_spacekey\t"+attacker+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluatePostBattleRetreatOpportunity(loser, winner, attacker, spacekey, attacker_comes_from_this_spacekey="") {

    let his_self = this;
    let retreat_destination = "";
    let space_name = this.game.spaces[spacekey].name;

    let onFinishSelect = function(his_self, destination_spacekey) {
      his_self.addMove("retreat"+"\t"+loser+"\t"+spacekey+"\t"+destination_spacekey);
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      his_self.field_battle_overlay.hide();

      his_self.playerSelectSpaceWithFilter(

                  "Choose Destination for Retreat:" ,

        	  function(space2) {
	            if (space.neighbours.includes(space2.key)) {
		      if (his_self.returnPlayerCommandingFaction(loser) === his_self.returnPlayerCommandingFaction(attacker)) {
	  		if (space2.key === attacker_comes_from_this_spacekey) {
          		  return 1;
	  		}
		      } else {
          		if (his_self.canFactionRetreatToSpace(loser, space2.key, "") && space2.key !== attacker_comes_from_this_spacekey) {
          		  return 1;
	  		}
		      }
		    }
	            return 0;
		  },

      		  function(spacekey) {
		    his_self.updateStatus("retreating...");

                    onFinishSelect(his_self, spacekey);
		  },

	    	  null, 

	    	  true 

      );
    };

    
    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">sacrifice forces</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(loser)} retreats, yes?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
        his_self.addMove("destroy_faction_units_in_spacekey\t"+loser+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluateRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey="", defender, is_attacker_loser=false) {

    let his_self = this;
    let retreat_destination = "";
    let space_name = this.game.spaces[spacekey].name;

    let onFinishSelect = function(his_self, destination_spacekey) {
      if (is_attacker_loser) {
        his_self.addMove("retreat"+"\t"+attacker+"\t"+spacekey+"\t"+destination_spacekey);
      } else {
        his_self.addMove("retreat"+"\t"+defender+"\t"+spacekey+"\t"+destination_spacekey);
      }
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      let html = "<ul>";
      for (let i = 0; i < space.neighbours.length; i++) {
	if (is_attacker_loser) {
          if (his_self.canFactionRetreatToSpace(attacker, space.neighbours[i], attacker_comes_from_this_spacekey)) {
            html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
	  }
	} else {
          if (his_self.canFactionRetreatToSpace(defender, space.neighbours[i], attacker_comes_from_this_spacekey)) {
            html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
	  }
	}
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");
	his_self.updateStatus("retreating...");
        onFinishSelect(his_self, id);
      });

    };

    
    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    if (is_attacker_loser) { 
      html    += `<li class="card" id="skip">sacrifice forces</li>`;
    } else {
      html    += `<li class="card" id="skip">do not retreat</li>`;
    }
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(attacker)} approaches ${this.returnSpaceName(spacekey)}. ${this.returnFactionName(defender)} Retreat?`, html);
    this.attachCardboxEvents(function(user_choice) {

      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	if (is_attacker_loser) {
          his_self.addMove("destroy_faction_units_in_spacekey\t"+attacker+"\t"+spacekey);
	}
	his_self.endTurn();
        return;
      }
    });
  }


  playerEvaluateFortification(attacker, faction, spacekey, post_battle=0) {

    let his_self = this;

    let html = `<ul>`;
    html    += `<li class="card" id="fortify">withdraw into fortification</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`Withdraw Units into Fortification?`, html);
    this.attachCardboxEvents(function(user_choice) {
      this.updateStatus("acknowledge...");
      if (user_choice === "fortify") {
	his_self.addMove("fortification\t"+attacker+"\t"+faction+"\t"+spacekey+"\t"+post_battle);
	his_self.endTurn();
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluateReliefForce(faction, spacekey) {

    let his_self = this;

    let html = `<ul>`;
    html    += `<li class="card" id="break">participate in battle</li>`;
    html    += `<li class="card" id="skip">remain besieged</li>`;
    html    += `</ul>`;

    this.game.state.field_battle.relief_battle = true;

    this.updateStatusWithOptions(`Do Your Besieged Forces participate in this Field Battle?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "break") {
	his_self.addMove("relief_forces_join_battle\t"+faction+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }





  playerEvaluateInterceptionOpportunity(attacker, spacekey, attacker_includes_cavalry, defender, defender_spacekey) {

    let his_self = this;

    let units_to_move = [];
    let parent_player = his_self.returnPlayerCommandingFaction(defender);

    let onFinishSelect = function(his_self, units_to_move) {
      his_self.addMove("intercept"+"\t"+attacker+"\t"+spacekey+"\t"+attacker_includes_cavalry+"\t"+defender+"\t"+defender_spacekey+"\t"+JSON.stringify(units_to_move));
      his_self.endTurn();
    };

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];
          let space = his_self.game.spaces[defender_spacekey];

	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, defender, defender_spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != true && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : defender ,
   	    source : defender_spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : spacekey ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size ,
 	  }

          // 
          // auto-move if only 1 unit
          //
          let can_we_quick_move = false;
          if (mobj.moved_units.length == 0 && mobj.unmoved_units.length == 1) { can_we_quick_move = true; }

	  if (!can_we_quick_move) {
   	    his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  }

	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = x[1];

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	    }

	    if (does_units_to_move_have_unit) {
	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	      }
	    } else {


	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });


          if (can_we_quick_move) {
            units_to_move = JSON.parse(JSON.stringify(mobj.unmoved_units));
            selectDestinationInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
            his_self.displaySpace(source_spacekey);
            his_self.displaySpace(destination_spacekey);
            his_self.updateStatus("intercepting...");
            return;
          }

	}
	//
	// end select units
	//



    let html = `<ul>`;
    html    += `<li class="card" id="intercept">intercept</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`Intercept from ${this.returnSpaceName(defender_spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      his_self.updateStatus("acknowledge");
      if (user_choice === "intercept") {
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }






  playerEvaluateNavalInterceptionOpportunity(attacker, spacekey, defender, defender_spacekey) {

    let his_self = this;

    let units_to_move = [];

    let onFinishSelect = function(his_self, units_to_move) {
      his_self.addMove("naval_intercept"+"\t"+attacker+"\t"+spacekey+"\t"+"\t"+defender+"\t"+defender_spacekey+"\t"+JSON.stringify(units_to_move));
      his_self.endTurn();
    };

    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, onFinishSelect) {

      let msg = "Select Units to Intercept: ";
      let space;
      if (his_self.game.spaces[defender_spacekey]) {
        space = his_self.game.spaces[defender_spacekey];
      }
      if (his_self.game.navalspaces[defender_spacekey]) {
        space = his_self.game.navalspaces[defender_spacekey];
      }

      let html = "<ul>";

      for (let i = 0; i < space.units[defender].length; i++) {
        if (space.units[defender][i].army_leader != true) {
        if (space.units[defender][i].land_or_sea === "sea" || space.units[defender][i].land_or_sea === "both") {
          if (units_to_move.includes(parseInt(i))) {
            html += `<li class="option" style="font-weight:bold" id="${i}">${space.units[defender][i].name}</li>`;
          } else {
            html += `<li class="option" id="${i}">${space.units[defender][i].name}</li>`;
          }
        }
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
          onFinishSelect(his_self, units_to_move);
          return;
        }

        if (units_to_move.includes(id)) {
          let idx = units_to_move.indexOf(id);
          if (idx > -1) {
            units_to_move.splice(idx, 1);
          }
        } else {
          units_to_move.push(parseInt(id));
        }

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
      });
    };


    let html = `<ul>`;
    html    += `<li class="card" id="intercept">intercept</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`Intercept from ${this.returnSpaceName(defender_spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "intercept") {
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }




  canPlayerNavalTransport(his_self, player, faction, ops_to_spend, ops_remaining) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    // no if no ships at sea
    let have_ships_at_sea = false;
    for (let key in his_self.game.navalspaces) {
      if (his_self.game.navalspaces[key].units[faction].length > 0) {
	have_ships_at_sea = true;
      }
    }
    if (!have_ships_at_sea) { return false; }

    if (ops_remaining < 2) { return 0; }
    let spaces_with_infantry = his_self.returnSpacesWithFactionInfantry(faction);
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      if (his_self.game.spaces[spaces_with_infantry[i]].ports.length == 0) {
	spaces_with_infantry.splice(i, 1);
	i--;
      } else {
	let s = his_self.game.spaces[spaces_with_infantry[i]];
        for (let z = 0; z < s.ports.length; z++) {
          if (his_self.doesFactionHaveNavalUnitsInSpace(faction, s.ports[z]) == 0) {
	    spaces_with_infantry.splice(i, 1);
	    i--;
	    z = s.ports.length + 2;
	  }
	}
      }
    }

    if (spaces_with_infantry.length == 0) { return 0; }

    for (let i = 0; i < spaces_with_infantry.length; i++) {
      let dest = his_self.returnNavalTransportDestinations(faction, spaces_with_infantry[i], ops_remaining);
      if (dest.length > 0) { return 1; }
    }

    return 0;

  }
  async playerNavalTransport(his_self, player, faction, ops_to_spend, ops_remaining) {

    let spacekey = "";
    let units_to_move = [];
    let cancel_func = null;
    let space = null;
    let destination = "";

    //
    // destination already set, so just fire the info out
    //
    let selectDestinationInterface = function(his_self, units_to_move) {

              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

              let does_movement_include_cavalry = 0;
              for (let i = 0; i < units_to_move.length; i++) {
                if (units_to_move[i].type === "cavalry") {
                  does_movement_include_cavalry = 1;
                }
              }

              his_self.addMove("interception_check\t"+faction+"\t"+destination+"\t"+does_movement_include_cavalry);
              for (let i = 0; i < units_to_move.length; i++) {
                his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination+"\t"+units_to_move[i].idx);
              }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination].name + "\tmove");
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
              his_self.endTurn();

    }

    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface) {

	  let unmoved_units = [];
	  let moved_units = [];
          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = 5; // cannot naval transport more than 5 units
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == player) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != true && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : destination ,
            units_to_move : units_to_move ,
            max_formation_size : max_formation_size ,  
 	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = x[1];

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	    }

	    if (does_units_to_move_have_unit) {
	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	      }
	    } else {


	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
    }
    //
    // end select units
    //


    let spaces_with_infantry = his_self.returnSpacesWithFactionInfantry(faction);
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      if (his_self.game.spaces[spaces_with_infantry[i]].ports.length == 0) {
	spaces_with_infantry.splice(i, 1);
	i--;
      } else {
	let s = his_self.game.spaces[spaces_with_infantry[i]];
	if (s.besieged > 0) {
	  spaces_with_infantry.splice(i, 1);
	  i--;
	  z = s.ports.length + 2;
        } else {
	  for (let z = 0; z < s.ports.length; z++) {
            if (his_self.doesFactionHaveNavalUnitsInSpace(faction, s.ports[z]) == 0) {
  	      spaces_with_infantry.splice(i, 1);
	      i--;
	      z = s.ports.length + 2;
	    }
	  }
	}
      }
    }

    let html = `<ul>`;
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      html    += `<li class="option" id="${i}">${spaces_with_infantry[i]}</li>`;
    }
    html    += `</ul>`;

    his_self.updateStatusWithOptions(`Transport from Which Port?`, html);
    his_self.attachCardboxEvents(function(user_choice) {

      spacekey = spaces_with_infantry[user_choice];

      let dest = his_self.returnNavalTransportDestinations(faction, spaces_with_infantry[user_choice], (ops_remaining+ops_to_spend));

      let html = `<ul>`;
      for (let i = 0; i < dest.length; i++) {
	let c = ops_remaining + ops_to_spend - dest[i].cost;
        html    += `<li class="option" id="${i}">${dest[i].key} (${c} CP)</li>`;
      }
      html    += `</ul>`;

      his_self.updateStatusWithOptions(`Select Destination:`, html);
      his_self.attachCardboxEvents(function(d) {
	destination = dest[d].key;
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
      });
    });

  }


  // 1 = yes, 0 = no / maybe
  canPlayerPlayCard(faction, card) {
    let player = this.returnPlayerOfFaction(faction);
    if (this.game.player == player) { 
      let faction_hand_idx = this.returnFactionHandIdx(player, faction);
      for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
        let c = this.game.deck[0].fhand[faction_hand_idx][i];
  	if (c === card) { return 1; }
      }
    }
    return 0;
  }

  canPlayerCommitDebater(faction, debater) {

    if (faction !== "protestant" && faction !== "papacy") { return false; }

    if (this.game.state.debater_committed_this_impulse[faction] == 1) { return false; }   
    if (this.isDisgraced(debater)) { return false; }
    if (this.isBurned(debater)) { return false; }

    let already_committed = false;
    let found_debater = false;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {

        found_debater = true;

        if (this.game.state.debaters[i].active == 1 && this.game.state.debaters[i].faction === "papacy" && faction === "papacy") {}
        if (this.game.state.debaters[i].active == 1 && this.game.state.debaters[i].faction === "protestant" && faction !== "papacy") { return false; }
        if (this.game.state.debaters[i].committed == 1) { return false; }

        let is_mine = false;

        if (this.game.state.debaters[i].faction === "papacy" && faction === "papacy") {
          is_mine = true;               
        }
        if (this.game.state.debaters[i].faction !== "papacy" && faction === "protestant") {
          is_mine = true;
        }
    
        if (is_mine == true) {
          if (this.game.state.debaters[i].active == 1) { already_comitted = true; }
        }
      }
    }

    if (found_debater != true) { return false; }

    return !already_committed;
  } 
    

  canPlayerNavalMove(his_self, player, faction) {

    if (his_self.game.state.events.foul_weather) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    // 2P game, papacy+protestant can move minor + allied naval units during their own turn
    if (his_self.game.players.length == 2) {
      if (his_self.doesFactionHaveNavalUnitsOnBoard(faction)) {
	if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	  return 1;
	}
      }
    }

    if (his_self.doesFactionHaveNavalUnitsOnBoard(faction)) { return 1; }
    return 0;

  }
  async playerNavalMove(his_self, player, faction) {

    let units_to_move = [];
    let units_available = his_self.returnFactionNavalUnitsToMove(faction);

    let selectUnitsInterface = function(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface) {

      let msg = "Select Unit to Move";
      let html = "<ul>";
      for (let i = 0; i < units_available.length; i++) {
	let spacekey = units_available[i].spacekey;
	let unit = units_available[i];
        if (units_to_move.includes(parseInt(i))) {
          html += `<li class="option" style="font-weight:bold" id="${i}">${units_available[i].name} (${units_available[i].spacekey} -> ${units_available[i].destination})</li>`;
        } else {
          html += `<li class="option" id="${i}">${units_available[i].name} (${his_self.returnSpaceName(units_available[i].spacekey)})</li>`;
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
	  let destinations = {};

	  for (let i = 0; i < units_to_move.length; i++) {
	    let unit = units_available[units_to_move[i]];
	    if (!destinations[unit.destination]) {
	      his_self.addMove("naval_interception_check\t"+faction+"\t"+unit.destination+"\t"+unit.spacekey);
	      destinations[unit.destination] = 1;
	    }
	  }

	  let revised_units_to_move = [];
	  let entries_to_loop = units_to_move.length;	
	  for (let z = 0; z < entries_to_loop; z++) {

	    let highest_idx = 0;
	    let highest_num = 0;

	    for (let y = 0; y < units_to_move.length; y++) {
   	      let unit = units_available[units_to_move[y]];
	      let max_num = unit.idx;
	      let max_idx = y;
	      if (max_num > highest_num) {
		highest_idx = max_idx;
		highest_num = max_num;
	      }
	    }

	    revised_units_to_move.unshift(JSON.parse(JSON.stringify(units_available[units_to_move[highest_idx]])));
	    units_to_move.splice(highest_idx, 1);
	  }

	  //
	  // revised units to move is
	  //
	  for (let i = 0; i < revised_units_to_move.length; i++) {
	    let unit = revised_units_to_move[i];
            his_self.addMove("move\t"+revised_units_to_move[i].faction+"\tsea\t"+unit.spacekey+"\t"+unit.destination+"\t"+revised_units_to_move[i].idx);
	  }
    	  if (his_self.game.state.events.intervention_on_movement_possible == 0) {
	    his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" shifting naval forces\tnavalmove");
          } else {
	    his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" shifting naval forces\tnavalmove");
	    his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  }
	  his_self.endTurn();
	  return;

	}

	//
	// add unit to units available
	//
        if (units_to_move.includes(id)) {
          let idx = units_to_move.indexOf(id);
          if (idx > -1) {
            units_to_move.splice(idx, 1);
          }
        } else {
          if (!units_to_move.includes(parseInt(id))) {
            units_to_move.push(parseInt(id));
            selectDestinationInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
          } else {
            for (let i = 0; i < units_to_move.length; i++) {
              if (units_to_move[i] === parseInt(id)) {
                units_to_move.splice(i, 1);
      	        selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
                break;
              }
            }
          }
        }
      });
    }

    let selectDestinationInterface = function(his_self, unit_to_move, units_available, selectUnitsInterface, selectDestinationInterface) {

      //
      // unit selected will always be last in array
      //
      let unit = units_available[unit_to_move[unit_to_move.length-1]];

      let destinations = his_self.returnNavalMoveOptions(unit.spacekey);

      let msg = "Select Destination";
      let html = "<ul>";
      let any_options = false;
      let num_options = 0;
      for (let i = 0; i < destinations.length; i++) {
	let spacekey = destinations[i];
	if (his_self.game.spaces[spacekey]) {
	  if (his_self.isSpaceHostileOrIndependent(spacekey, faction)) {
	    if (his_self.doesSpaceHaveNonFactionNavalUnits(spacekey, faction) || his_self.doesSpaceHaveNonFactionUnits(spacekey, faction)) {
              any_options = true;
  	      num_options++;
              html += `<li class="option" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
	    }
	  } else {
	    if (his_self.isSpaceFriendly(spacekey, faction)) {
              any_options = true;
  	      num_options++;
              html += `<li class="option" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
            }
          }
        } else {
          any_options = true;
	  num_options++;
          html += `<li class="option" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
	}
      }
      if (any_options == false) {
        html += `<li class="option" style="font-weight:bold" id="none">no valid options</li>`;
      }
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

	if (id === "none") {
          unit_to_move.splice(unit_to_move.length-1, 1);
          selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	  return;
	}

	unit.destination = id;
        selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);

      });

      if (num_options == 1) {
	document.querySelector(".option").click();
	return;
      }

    }

    selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);

  }

  canPlayerMoveFormationInClear(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let spaces_with_units = his_self.returnSpacesWithFactionInfantry(faction);
    if (spaces_with_units.length > 0) { 
      let any_unlocked_units = false;
      for (let i = 0; i < spaces_with_units.length; i++) {
       for (let z = 0; z < his_self.game.spaces[spaces_with_units[i]].units[faction].length; z++) {
	  if (his_self.game.spaces[spaces_with_units[i]].units[faction][z].locked != true) {
	    // if no neighbours, no move
	    if (his_self.game.spaces[spaces_with_units[i]].neighbours.length > 0) {
	      return 1;
	    }
	  }
	}
      }
    }
    return 0;
  }

  canPlayerBuyMercenary(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "mercenary") == 0) { return false; }

    return 1;
  }
  playerBuyMercenary(his_self, player, faction, ops_to_spend, ops_remaining) {

    //
    // ui for building multiple units
    //
    his_self.build_overlay.render(faction, "mercenary", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and place
      //
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Mercenaries`,

        function(space) {
	  if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	      if (space.key == "ireland") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "ireland") { return 1; }
	    }
	  }
          if (space.besieged != 0) { return 0; }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
  	  his_self.updateStatus("acknowledge...");
          for (let i = 0; i < num; i++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

    });

  
    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Mercenary",

      function(space) {
	if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	    if (space.key == "ireland") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "ireland") { return 1; }
	  }
	}
        if (faction == "hapsburg" && space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) {
          return 0;
        }
        if (space.besieged != 0) { return 0; }
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (his_self.isSpaceFriendly(space, faction) && space.home == faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }

  canPlayerBuyRegular(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "regular") == 0) { return false; }

    return 1;
  }
  async playerBuyRegular(his_self, player, faction, ops_to_spend, ops_remaining) {

    //
    // UI for multiple-unit builds
    //
    his_self.build_overlay.render(faction, "regular", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and select destination for these units
      //
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Regular(s)`,

        function(space) {
	  if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	    // can only build corsairs in a pirate haven
	    if (space.key == "algiers" || space.pirate_haven == 1) { return 0; }
	  }
  	  if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	      if (space.key == "persia") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "persia") { return 1; }
	    }
	  }
	  if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	      if (space.key == "egypt") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "egypt") { return 1; }
	    }
	  }
	  if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	      if (space.key == "ireland") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "ireland") { return 1; }
	    }
	  }
	  if (faction == "hapsburg" && space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) {
	    return 0;
	  }
          if (space.besieged != 0) { return 0; }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
	  his_self.updateStatus("acknowledge...");
	  for (let z = 0; z < num; z++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"regular"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

      return 0;

    });
            

    //
    // fall through is to build a single regular
    //
    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Regular",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	    if (space.key == "persia") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "persia") { return 1; }
	  }
	}
	if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	    if (space.key == "egypt") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "egypt") { return 1; }
	  }
	}
	if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	    if (space.key == "ireland") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "ireland") { return 1; }
	  }
	}
        if (space.besieged != 0) { return 0; }
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"regular"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }

  canPlayerBuyNavalSquadron(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "squadron") == 0) { return false; }

    return 1;
  }
  async playerBuyNavalSquadron(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Port for Naval Squadron",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	  // can only build corsairs in a pirate haven
	  if (space.key == "algiers" || space.pirate_haven == 1) { return 0; }
	}
        if (space.ports.length === 0) { return 0; }
        if (space.besieged != 0) { return 0; }
	if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
        if (space.owner === faction) { return 1; }
        if (space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"squadron"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,
      true,
    );
  }

  async playerBuildChateaux(his_self, player, faction) {
    his_self.game.chateaux_overlay.render();
  }

  canPlayerFightForeignWar(his_self, player, faction) {
    if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("persia")) { return 1; } }
    if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("egypt")) { return 1; } }
    if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("ireland")) { return 1; } }
    return 0;
  }
  playerFightForeignWar(his_self, player, faction) {

    let msg = "Attack in Foreign War: ";
    let html = '<ul>';
    if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("persia")) {
      html += '<li class="option" id="persia">War in Persia</li>';	
    }
    if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("egypt")) {
      html += '<li class="option" id="egypt">Revolt in Egypt</li>';	
    }
    if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("ireland")) {
      html += '<li class="option" id="ireland">Revolt in Ireland</li>';	
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
      his_self.updateStatus("acknowledge");
      let key = $(this).attr("id");
      if (key == "persia") {
        his_self.addMove("field_battle\tpersia\tottoman");
      }
      if (key == "egypt") {
        his_self.addMove("field_battle\tegypt\tottoman");
      }
      if (key == "ireland") {
        his_self.addMove("field_battle\tireland\tengland");
      }
      his_self.endTurn();
    });

    return 0;
  }
  canPlayerAssaultTutorial(his_self, player, faction) {
    if (his_self.game.state.assaulted_this_impulse == 1) { return 0; }
   if (!his_self.canPlayerAssault(his_self, player, faction)) {
      let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);
      for (let i = 0; i < conquerable_spaces.length; i++) {
        if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
          if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
            if (!his_self.isSpaceControlled(conquerable_spaces[i], faction)) {
              if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
                return 1;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  playerAssaultTutorial(his_self, player, faction) {

    his_self.endTurn();

    let player_warned = 0;
    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
        if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
          if (!his_self.isSpaceControlled(conquerable_spaces[i], faction) && !his_self.isSpaceInLineOfControl(conquerable_spaces[i], faction) && player_warned == 0) {
	    salert("You have a space under siege, but to assault it you need to have a Line of Control connecting it to another fortified key you control.");
	    player_warned = 1;
          }
	  if (player_warned == 0) {

	      //
	      // now check if there are squadrons in the port or sea protecting the town
	      //
	      let space = his_self.game.spaces[conquerable_spaces[i]];

	      let squadrons_protecting_space = his_self.returnNumberOfSquadronsProtectingSpace(conquerable_spaces[i]);
	      let attacker_squadrons_adjacent = 0;
	      for (let y = 0; y < his_self.game.spaces[conquerable_spaces[i]].ports.length; y++) {
	        let p = his_self.game.spaces[conquerable_spaces[i]].ports[y];
	        for (let z = 0; z < his_self.game.navalspaces[p].units[faction].length; z++) {
		  let u = his_self.game.navalspaces[p].units[faction][z];
		  if (u.type == "squadron") { attacker_squadrons_adjacent++; }
	        }
	      }

	      if (attacker_squadrons_adjacent < squadrons_protecting_space) {
		alert("You have a space under siege, but it is protected by a fleet. To assault such a space, you need more naval forces adjacent to this space than the defender has protecting it.");
		player_warned = 1;
	      }
	  }
	}
      }
    }
    return 1;
  }
  canPlayerAssault(his_self, player, faction) {

    if (his_self.game.state.events.foul_weather) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
        if (!his_self.isSpaceControlled(conquerable_spaces[i], faction) && his_self.isSpaceInLineOfControl(conquerable_spaces[i], faction)) {
          if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
	    if (!his_self.game.state.spaces_assaulted_this_turn.includes(conquerable_spaces[i])) {
	      //
	      // now check if there are squadrons in the port or sea protecting the town
	      //
	      let space = his_self.game.spaces[conquerable_spaces[i]];

	      let squadrons_protecting_space = his_self.returnNumberOfSquadronsProtectingSpace(conquerable_spaces[i]);
	      if (squadrons_protecting_space == 0) { return 1; }

	      let attacker_squadrons_adjacent = 0;
	      for (let y = 0; y < his_self.game.spaces[conquerable_spaces[i]].ports.length; y++) {
	        let p = his_self.game.spaces[conquerable_spaces[i]].ports[y];
	        for (let z = 0; z < his_self.game.navalspaces[p].units[faction].length; z++) {
		  let u = his_self.game.navalspaces[p].units[faction][z];
		  if (u.type == "squadron") { attacker_squadrons_adjacent++; }
	        }
	      }
	      if (attacker_squadrons_adjacent > squadrons_protecting_space) { return 1; }
	    }
	  }
        }
      }
    }

    return 0;
  }
  async playerAssault(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Space for Siege/Assault: ",

      function(space) {
	if (his_self.game.state.spaces_assaulted_this_turn.includes(space.key)) { return 0; }
	if (faction == "ottoman" && space.key == "persia" && his_self.game.state.events.war_in_persia == 1) { return 1; }
	if (faction == "ottoman" && space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1) { return 1; }
	if (faction == "england" && space.key == "ireland" && his_self.game.state.events.revolt_in_ireland == 1) { return 1; }
        if (his_self.isSpaceInLineOfControl(space, faction) && !his_self.isSpaceControlled(space, faction) && his_self.returnFactionLandUnitsInSpace(faction, space) > 0 && space.besieged == 1) {
          if (his_self.game.spaces[space.key].type === "fortress") {
  	    return 1;
	  }
          if (his_self.game.spaces[space.key].type === "electorate") {
  	    return 1;
	  }
          if (his_self.game.spaces[space.key].type === "key") {
  	    return 1;
	  }
        }
	return 0;
      },

      function(destination_spacekey) {
	if (faction == "ottoman" && destination_spacekey == "persia") { his_self.addMove("war\tottoman\tpersia"); his_self.endTurn(); return; }
	if (faction == "ottoman" && destination_spacekey == "egypt") { his_self.addMove("war\tottoman\tegypt"); his_self.endTurn(); return; }
	if (faction == "england" && destination_spacekey == "ireland") { his_self.addMove("war\tottoman\tireland"); his_self.endTurn(); return; }
	his_self.addMove("assault\t"+faction+"\t"+destination_spacekey);
	if (his_self.game.state.events.intervention_on_assault_possible == 0 || (his_self.game.deck[0].discards["031"] && his_self.game.deck[0].discards["032"])) {
	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(destination_spacekey);
          his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" announces siege of "+his_self.game.spaces[destination_spacekey].name + "\tassault\t" + destination_spacekey);
	} else {
          his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" announces siege of "+his_self.game.spaces[destination_spacekey].name + "\tassault\t" + destination_spacekey);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
	}
	his_self.endTurn();
      },

      null ,

      true ,
    );
  }

  canPlayerRemoveUnrest(his_self, player, faction) {

    let spaces_in_unrest = his_self.returnSpacesInUnrest();

    //
    // 2P requires only that it is in protestant or catholic religious influence
    //
    if (his_self.game.player.length == 2) {
      for (let i = 0; i < spaces_in_unrest.length; i++) {
        if (his_self.game.spaces[spaces_in_unrest[i]].religion == "protestant" && faction == "protestant") { return 1; }
        if (his_self.game.spaces[spaces_in_unrest[i]].religion == "catholic" && faction == "papacy") { return 1; }
      }
    //
    // 6P requires adjacent or direct military presence
    //
    } else {

      let adjacent_influence = his_self.returnSpacesWithAdjacentFactionInfantry(faction);
      let direct_influence = his_self.returnSpacesWithFactionInfantry(faction);

      for (let i = 0; i < spaces_in_unrest.length; i++) {

        //
        // i have regulars / infantry in this space
        //
	if (direct_influence.includes(spaces_in_unrest[i])) { return true; }

        //
        // i have adjacent regulars / infantry, and no enemies do
        //
	if (adjacent_influence.includes(spaces_in_unrest[i])) {

	  let neighbours = his_self.game.spaces[spaces_in_unrest[i]].neighbours;
	  let pass = his_self.game.spaces[spaces_in_unrest[i]].pass;
	  let impeding_units = true;

	  for (let z = 0; z < neighbours.length; z++) {
	    let number_of_hostiles = his_self.returnHostileLandUnitsInSpace(faction, neighbours[z]);
	    if (number_of_hostiles > 0) {
	    } else {
	      impeding_units = false;
	    }
	  }

	  if (impeding_units == false) { return 1; }

	}
      }

    }

    return 0;
  }
  canPlayerControlUnfortifiedSpace(his_self, player, faction) {
 
    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let conquerable_spaces = his_self.returnSpacesWithAdjacentFactionInfantry(faction);

    //
    // removed fortified spaces
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceFortified(n)) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.returnNonFactionLandUnitsInSpace(faction, n) > 0) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with adjacent other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let removed_space = false;
      let ns = his_self.game.spaces[conquerable_spaces[i]].neighbours;
      for (let z = 0; removed_space == false && z < ns.length; z++) {
        let n = his_self.game.spaces[ns[z]];
        if (his_self.returnHostileLandUnitsInSpace(faction, n) > 0) {
	  // unless we are there
          if (his_self.returnFactionLandUnitsInSpace(faction, conquerable_spaces[i]) > 0) {} else {
            conquerable_spaces.splice(i, 1); // remove
            removed_space = true;
          }
        }
      }
    }

    //
    // remove home spaces i control
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceControlled(s, faction)) { 
        conquerable_spaces.splice(i, 1); // remove
	i--;
      }
    }   
          

    //
    // remove non-independent, non-enemy spaces
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (!his_self.isSpaceHostileOrIndependent(s, faction)) {
        conquerable_spaces.splice(i, 1); // remove
        i--;
      }
    }

    for (let i = 0; i < spaces_in_unrest.length; i++) {
      if (!his_self.isSpaceControlled(spaces_in_unrest[i]), faction) { 
	let neighbours = his_self.game.spaces[spaces_in_unrest[i]];
	for (let z = 0; z < neighbours.length; z++) {
	  if (his_self.returnFactionLandUnitsInSpace(faction, neighbours[z]) > 0) {
	    return 1;
	  } 
	}
	if (his_self.returnFactionLandUnitsInSpace(faction, spaces_in_unrest[i]) > 0) {
	  return 1;
	} 
      }
    }

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (!his_self.isSpaceControlled(conquerable_spaces[i], faction)) { 
	if (his_self.game.spaces[conquerable_spaces[i]].besieged != 1 && his_self.game.spaces[conquerable_spaces[i]].besieged != 2) {
	  return 1;
	}
      } 
    }
    return 0;
  }
  async playerRemoveUnrest(his_self, player, faction) {

    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let spaces_to_fix = [];

    if (his_self.game.players.length == 2) {
      for (let i = 0; i < spaces_in_unrest.length; i++) {
        if (faction == "protestant" && his_self.game.spaces[spaces_in_unrest[i]].religion == "protestant"){spaces_to_fix.push(spaces_in_unrest[i]);}
        if (faction == "papacy" && his_self.game.spaces[spaces_in_unrest[i]].religion == "catholic"){spaces_to_fix.push(spaces_in_unrest[i]);}
      }
    } else {

      let adjacent_influence = his_self.returnSpacesWithAdjacentFactionInfantry(faction);
      let direct_influence = his_self.returnSpacesWithFactionInfantry(faction);

      for (let i = 0; i < spaces_in_unrest.length; i++) {

        if (faction == "protestant" && his_self.game.spaces[spaces_in_unrest[i]].religion == "protestant") {spaces_to_fix.push(spaces_in_unrest[i]);} else {

        //
        // i have regulars / infantry in this space
        //
	if (direct_influence.includes(spaces_in_unrest[i])) {
	  spaces_to_fix.push(spaces_in_unrest[i]);
	} else {
	  if (adjacent_influence.includes(spaces_in_unrest[i])) {
	    let neighbours = his_self.game.spaces[spaces_in_unrest[i]].neighbours;
	    let any_violent_neighbours = false;
	    for (let z = 0; z < neighbours.length; z++) {
	      let number_of_hostiles = his_self.returnHostileLandUnitsInSpace(faction, neighbours[z]);
	      if (number_of_hostiles > 0) {
		any_violent_neighbours = true;
	      } else {
		if (his_self.game.spaces[neighbours[z]].unrest == true) {
		  any_violent_neighbours = true;
		} else {
	          if (his_self.game.spaces[spaces_in_unrest[i]].pass.includes(neighbours[z])) {
		    any_violent_neighbours = true;
		  };
		}
	      }
	    }
	    if (any_violent_neighbours == false) {
	      spaces_to_fix.push(spaces_in_unrest[i]);
	    }
	  }
	}
      }
      }
    }

    his_self.playerSelectSpaceWithFilter(

      "Select Space to Remove Unrest:",

      function(space) {
        if (spaces_to_fix.includes(space.key)) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.addMove("remove_unrest\t"+faction+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
    return 0;
  }
  canPlayerExplore(his_self, player, faction) {
    if (his_self.game.state.may_explore[faction] == 0) { return 0; }
    if (faction === "protestant") {  return false; }
    for (let i = 0; i < his_self.game.state.explorations.length; i++) {
      if (his_self.game.state.explorations[i].faction == faction) { return 0; }
    }
    if (
      his_self.game.state.newworld['stlawrence'].claimed == 1 &&
      his_self.game.state.newworld['mississippi'].claimed == 1 &&
      his_self.game.state.newworld['greatlakes'].claimed == 1 &&
      his_self.game.state.newworld['amazon'].claimed == 1 &&
      his_self.game.state.newworld['pacificstrait'].claimed == 1 &&
      his_self.game.state.newworld['circumnavigation'].claimed == 1
    ) { return 0; }
    return 1;
  }
  async playerControlUnfortifiedSpace(his_self, player, faction) {
    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let pacifiable_spaces_in_unrest = [];
    for (let i = 0; i < spaces_in_unrest.length; i++) {
      if (!his_self.isSpaceControlled(spaces_in_unrest[i], faction)) { 
	let neighbours = his_self.game.spaces[spaces_in_unrest[i]];
	for (let z = 0; z < neighbours.length; z++) {
	  if (his_self.returnFactionLandUnitsInSpace(faction, neighbours[z]) > 0) { pacifiable_spaces_in_unrest.push(spaces_in_unrest[i]); } 
	}
	if (his_self.returnFactionLandUnitsInSpace(faction, spaces_in_unrest[i]) > 0) { pacifiable_spaces_in_unrest.push(spaces_in_unrest[i]); } 
      }
    }
    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction, true); // include adjacency

    //
    // removed fortified spaces
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceFortified(n)) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.returnNonFactionLandUnitsInSpace(faction, n) > 0) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with adjacent other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let removed_space = false;
      let ns = his_self.game.spaces[conquerable_spaces[i]].neighbours;
      for (let z = 0; removed_space == false && z < ns.length; z++) {
        let n = his_self.game.spaces[ns[z]];
        if (his_self.returnHostileLandUnitsInSpace(faction, n) > 0) {
	  // unless we are there
          if (his_self.returnFactionLandUnitsInSpace(faction, conquerable_spaces[i]) > 0) {} else {
            conquerable_spaces.splice(i, 1); // remove
            removed_space = true;
          }
        }
      }
    }

    //
    // remove home spaces i control
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceControlled(s, faction)) { 
        conquerable_spaces.splice(i, 1); // remove
	i--;
      }
    }   
          

    //
    // remove non-independent, non-enemy spaces
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (!his_self.isSpaceHostileOrIndependent(s, faction)) {
        conquerable_spaces.splice(i, 1); // remove
        i--;
      }
    }

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (his_self.isSpaceControlled(conquerable_spaces[i], faction) || his_self.game.spaces[conquerable_spaces[i]].besieged == 1 || his_self.game.spaces[conquerable_spaces[i]].besieged == 2) {
	conquerable_spaces.splice(i, 1);
	i--;
      }
    }

    his_self.playerSelectSpaceWithFilter(

      "Select Space to Pacify:",

      function(space) {
        if (pacifiable_spaces_in_unrest.includes(space.key)) { return 1; }
        if (conquerable_spaces.includes(space.key) && !his_self.isSpaceControlled(space.key, faction) && !his_self.isSpaceFriendly(space.key, faction)) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.addMove("pacify\t"+faction+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
    return 0;
  }
  canPlayerColonize(his_self, player, faction) {

    if (his_self.game.state.may_colonize[faction] == 0) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (faction === "ottoman") { return false; }
    if (faction === "papacy") { return false; }
    for (let i = 0; i < his_self.game.state.colonies.length; i++) {
      if (his_self.game.state.colonies[i].faction == faction) {
        if (his_self.game.state.colonies[i].round == his_self.game.state.round) { return 0; }
      }
    }
    if (faction === "england") {
      if (his_self.game.state.newworld['england_colony1'].claimed == 1 && his_self.game.state.newworld['england_colony2'].claimed == 1){ return 0; }
    }
    if (faction === "france") {
      if (his_self.game.state.newworld['france_colony1'].claimed == 1 && his_self.game.state.newworld['france_colony2'].claimed == 1){ return 0; }
    }
    if (faction === "hapsburg") {
      if (his_self.game.state.newworld['hapsburg_colony1'].claimed == 1 && his_self.game.state.newworld['hapsburg_colony2'].claimed == 1 && his_self.game.state.newworld['hapsburg_colony3'].claimed == 1){ return 0; }
    }
    return 1;
  }
  async playerExplore(his_self, player, faction) {
    his_self.addMove("explore\t"+faction);
    his_self.endTurn();
    return 0;
  }
  async playerColonize(his_self, player, faction) {
    his_self.addMove("colonize\t"+faction);
    his_self.endTurn();
    return 0;
  }
  canPlayerConquer(his_self, player, faction) {
    if (his_self.game.state.may_conquer[faction] == 0) { return 0; }
    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    for (let i = 0; i < his_self.game.state.conquests.length; i++) {
      if (his_self.game.state.conquests[i].round == his_self.game.state.round && his_self.game.state.conquests[i].faction == faction) { return 0; }
    }
    // nothing left to take
    if (his_self.game.state.newworld['inca'].claimed == 1 && his_self.game.state.newworld['aztec'].claimed == 1 && his_self.game.state.newworld['maya'].claimed == 1) { return 0; }
    return 1;
  }
  async playerConquer(his_self, player, faction) {
    his_self.addMove("conquer\t"+faction);
    his_self.endTurn();
    return 0;
  }
  canPlayerInitiatePiracyInASea(his_self, player, faction) {

    if (his_self.game.state.events.foul_weather) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    if (faction === "ottoman" && his_self.game.state.events.ottoman_piracy_attempts < 4 && his_self.game.state.events.ottoman_piracy_enabled == 1) { 

      for (let key in his_self.game.navalspaces) {
        let targetsea = false;
        for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
  	  if (his_self.game.navalspaces[key].units[faction][i].type == "corsair") {
	    if (!his_self.game.state.events.ottoman_piracy_seazones.includes(key)) {
	      targetsea = true;
	    }
	  }
        }
        if (targetsea == true) {
          return 1;
        }
      }

    }

    return 0;
  }

  async playerInitiatePiracyInASea(his_self, player, faction) {

    // relevant
    //state.events.ottoman_piracy_enabled = 0;
    //state.events.ottoman_corsairs_enabled = 0;
    //state.events.ottoman_piracy_attempts = 0;
    //state.events.ottoman_piracy_seazones = [];
    
    let msg = "Select Sea for Piracy: ";
    let html = '<ul>';
    for (let key in his_self.game.navalspaces) {
      let targetsea = false;
      for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
	if (his_self.game.navalspaces[key].units[faction][i].type == "corsair") { 
	  if (!his_self.game.state.events.ottoman_piracy_seazones.includes(key)) {
	    targetsea = true;
	  }
	}
      }
      if (targetsea == true) {
        html += '<li class="option" id="'+key+'">'+his_self.returnSpaceName(key)+'</li>';
      }
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
 
      his_self.updateStatus("acknowledge");
      let key = $(this).attr("id");
      let ports = [];
      let dragut = false;
      let barbarossa = false;

      let target_space = his_self.game.navalspaces[key];
      let adjacent_spaces = [];
      let io = his_self.returnImpulseOrder();
      let factions_at_war_with_ottoman = his_self.returnEnemies("ottoman", true); // true = include minor powers

      for (let i = 0; i < target_space.neighbours.length; i++) {
	adjacent_spaces.push(his_self.game.navalspaces[target_space.neighbours[i]]);
      }
      for (let i = 0; i < target_space.ports.length; i++) {
	adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
      }

      ports = his_self.game.navalspaces[key].ports;
      for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
	if (his_self.game.navalspaces[key].units[faction][i].type == "dragut") { dragut = true; }
	if (his_self.game.navalspaces[key].units[faction][i].type == "barbarossa") { barbarossa = true; }
      }

      let msg = "Select Target for Piracy: ";
      let html = '<ul>';

      for (let z = 0; z < ports.length; z++) {
	let controller = his_self.game.spaces[ports[z]].political;
	if (his_self.game.spaces[ports[z]].political == "") { controller = his_self.game.spaces[ports[z]].home; }
        if (io.includes(controller)) {
          html += '<li class="option" id="'+ports[z]+'">'+his_self.returnSpaceName(ports[z])+'</li>';
        }
      }
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {
 
        let target_port = $(this).attr("id");
        his_self.updateStatus("acknowledge");
	his_self.addMove("piracy\t"+faction+"\t"+key+"\t"+target_port);
	his_self.endTurn();

      });
    });

    return 0;
  }
  canPlayerBuyCavalry(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "cavalry") == 0) { return false; }

    return 1;
  }
  async playerBuyCavalry(his_self, player, faction, ops_to_spend, ops_remaining) {

    //
    // ui for building multiple units
    //
    his_self.build_overlay.render(faction, "cavalry", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and place
      //
      name : "" ,
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Cavalry`,

        function(space) {
	  if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	    // can only build corsairs in a pirate haven
	    if (space.key == "algiers" || space.pirate_haven == 1) { return 0; }
	  }
  	  if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	      if (space.key == "persia") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "persia") { return 1; }
	    }
	  }
	  if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	      if (space.key == "egypt") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "egypt") { return 1; }
	    }
	  }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (space.owner === faction) { return 1; }
          if (space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
	  his_self.updateStatus("acknowledge...");
	  for (let z = 0; z < num; z++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

    });

    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Cavalry",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	    if (space.key == "persia") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "persia") { return 1; }
	  }
	}
	if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	    if (space.key == "egypt") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "egypt") { return 1; }
	  }
	}
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (space.owner === faction) { return 1; }
        if (space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }
  canPlayerBuyCorsair(his_self, player, faction) {
    if (faction === "ottoman" && his_self.game.state.events.ottoman_corsairs_enabled == 1) { return 1; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "corsair") == 0) { return false; }
    return 0;
  }
  async playerBuyCorsair(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Port for Corsair",

      function(space) {
        if (space.pirate_haven == 1 && his_self.isSpaceControlled(space.key, "ottoman")) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"corsair"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }
  canPlayerTranslateScripture(his_self, player, faction) {
    if (faction === "protestant") { return 1; }
    return 0;
  }
  async playerTranslateScripture(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {

    let msg = "Select Work to Translate:";
    let html = '<ul>';

    if (his_self.game.state.translations['new']['german'] < 6) {
      html += '<li class="option german" style="" id="1">German (new testament)</li>';
    }
    if (his_self.game.state.translations['new']['french'] < 6) {
      html += '<li class="option french" style="" id="2">French (new testament)</li>';
    }
    if (his_self.game.state.translations['new']['english'] < 6) {
      html += '<li class="option english" style="" id="3">English (new testament)</li>';
    }
    if (his_self.game.state.translations['full']['german'] < 10 && his_self.game.state.translations['new']['german'] >= 6) {
      html += '<li class="option german" style="" id="4">German (full bible)</li>';
    }
    if (his_self.game.state.translations['full']['french'] < 10 && his_self.game.state.translations['new']['french'] >= 6) {
      html += '<li class="option french" style="" id="5">French (full bible)</li>';
    }
    if (his_self.game.state.translations['full']['english'] < 10 && his_self.game.state.translations['new']['english'] >= 6) {
      html += '<li class="option english" style="" id="6">English (full bible)</li>';
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = parseInt($(this).attr("id"));
      his_self.updateStatus("selecting...");
      his_self.language_zone_overlay.hide();

      if (id == 1 || id == 4) {
	his_self.addMove("translation\tgerman\t"+ops_to_spend);
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in German Language Zone\ttranslation_german_language_zone\tgerman\t"+faction);
      }
      if (id == 2 || id == 5) { 
	his_self.addMove("translation\tfrench\t"+ops_to_spend); 
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in French Language Zone\ttranslation_french_language_zone\tfrench\t"+faction);
      }
      if (id == 3 || id == 6) { 
	his_self.addMove("translation\tenglish\t"+ops_to_spend);
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in English Language Zone\ttranslation_english_language_zone\tenglish\t"+faction);
      }
      // we only ask for our own CONFIRMS
      his_self.addMove("RESETCONFIRMSNEEDED\t"+his_self.game.player);
      his_self.endTurn();

    });

  }
  canPlayerPublishTreatise(his_self, player, faction) {
    if (faction === "protestant") { return 1; }
    if (faction === "england") {
      if (his_self.isPersonageOnMap("england", "cranmer") != null) {
	return 1;
      }
    }
    return 0;
  }
  async playerPublishTreatise(his_self, player, faction) {

    if (faction === "protestant") {

      let msg = "Select Language Zone for Reformation Attempts:";
      let html = '<ul>';
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("german") || his_self.canProtestantsReformInLanguageZone("german")) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("english") || his_self.canProtestantsReformInLanguageZone("english")) {
        html += '<li class="option english" style="" id="english">English</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("french") || his_self.canProtestantsReformInLanguageZone("french")) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("spanish") || his_self.canProtestantsReformInLanguageZone("spanish")) {
        html += '<li class="option spanish" style="" id="spanish">Spanish</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("italian") || his_self.canProtestantsReformInLanguageZone("italian")) {
        html += '<li class="option italian" style="" id="italian">Italian</li>';
      }
      html += '</ul>';

      //
      // show visual language zone selector
      //
      his_self.language_zone_overlay.render();

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        $('.option').off();
        his_self.language_zone_overlay.hide();

        let id = $(this).attr("id");

	if (id === "french" && his_self.canPlayerCommitDebater("protestant", "calvin-debater") && his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {

          let msg = "Use Calvin Debater Bonus +1 Attempt:";
          let html = '<ul>';
          html += '<li class="option" style="" id="calvin-debater">Yes, Commit Calvin</li>';
          html += '<li class="option" style="" id="no">No</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('mouseover', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.show(action2);
            }
          });
          $('.option').on('mouseout', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.hide(action2);
            }
          });
          $('.option').on('click', function () {
            let id = $(this).attr("id");

	    his_self.updateStatus("submitting...");
	    his_self.addMove("hide_overlay\tpublish_treatise\tfrench");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    if (id === "calvin-debater") {
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	    } else {
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench\t1");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench\t1");
	    }
	    his_self.addMove("show_overlay\tpublish_treatise\tfrench");
	    if (id === "calvin-debater") {
	      his_self.addMove("commit\tprotestant\tcalvin-debater\t1");
	    }
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	    his_self.endTurn();

	    return 0;
	  });

	  return 0;
        }


	if (id === "german" && his_self.canPlayerCommitDebater("protestant", "carlstadt-debater") && his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {

          let msg = "Use Carlstadt Debater Bonus +1 Attempt:";
          let html = '<ul>';
          html += '<li class="option" style="" id="carlstadt-debater">Yes, Commit Carlstadt</li>';
          html += '<li class="option" style="" id="no">No</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('mouseover', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.show(action2);
            }
          });
          $('.option').on('mouseout', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.hide(action2);
            }
          });
          $('.option').on('click', function () {
            let id = $(this).attr("id");

	    his_self.updateStatus("submitting...");
	    his_self.cardbox.hide();

	    his_self.addMove("hide_overlay\tpublish_treatise\tgerman");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    if (id === "carlstadt-debater") {
	      his_self.addMove("SETVAR\tstate\tevents\tcarlstadt_debater\t0");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	    } else {
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman\t1");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman\t1");
	    }
	    his_self.addMove("show_overlay\tpublish_treatise\tgerman");
	    if (id === "carlstadt-debater") {
	      his_self.addMove("commit\tprotestant\tcarlstadt-debater\t1");
	      his_self.addMove("SETVAR\tstate\tevents\tcarlstadt_debater\t1");
	    }
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	    his_self.endTurn();

	    return 0;
	  });

	  return 0;
        }

	his_self.addMove("hide_overlay\tpublish_treatise\t"+id);
	his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.addMove("protestant_reformation\t"+player+"\t"+id+"\t1");
	his_self.addMove("protestant_reformation\t"+player+"\t"+id+"\t1");
	his_self.addMove("show_overlay\tpublish_treatise\t"+id);
	his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.endTurn();
      });

    }


    if (faction === "england") {
      let id = "english";
      his_self.addMove("protestant_reformation\t"+player+"\t"+id);
      his_self.addMove("protestant_reformation\t"+player+"\t"+id);
      his_self.endTurn();
    }

    return 0;
  }
  canPlayerCallTheologicalDebateMaryI(his_self, player, faction) {
    if (his_self.returnDebatersInLanguageZone("english", "protestant", 0) || his_self.returnDebatersInLanguageZone("english", "protestant", 1)) {
      return this.canPlayerCallTheologicalDebate(his_self, player, faction, 1);
    } else {
      return 0;
    }
  }
  canPlayerCallTheologicalDebate(his_self, player, faction, mary_i=0) {
    if (his_self.returnNumberOfUncommittedDebaters(faction) <= 0) { return 0; }
    if (his_self.game.state.events.wartburg == 1) { if (faction === "protestant") { return 0; } }
    if (faction === "protestant") { return 1; }
    if (faction === "papacy") { return 1; }
    return 0;
  }
  async playerCallTheologicalDebateMaryI(his_self, player, faction) {
    return this.playerCallTheologicalDebate(his_self, player, faction, 1);
  }
  async playerCallTheologicalDebate(his_self, player, faction, mary_i=0) {

    let msg = "Select Language Zone for Theological Debate:";
    let html = '<ul>';

    if (faction === "protestant" || faction === "england") {
      if (his_self.returnDebatersInLanguageZone("german", "protestant", 0)) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnDebatersInLanguageZone("french", "protestant", 0)) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnDebatersInLanguageZone("english", "protestant", 0)) {
	if (his_self.game.state.events.more_executed_limits_debates != 1) {
          html += '<li class="option english" style="" id="english">English</li>';
        }
      }
    }
    if (faction === "papacy") {
      if (mary_i == 1) {
        html += '<li class="option english" style="" id="english">English</li>';
      } else {
        html += '<li class="option german" style="" id="german">German</li>';
        if (his_self.returnDebatersInLanguageZone("french", "protestant", 0) || his_self.returnDebatersInLanguageZone("french", "protestant", 1)) {
          html += '<li class="option french" style="" id="french">French</li>';
        }
        if (his_self.returnDebatersInLanguageZone("english", "protestant", 0) || his_self.returnDebatersInLanguageZone("english", "protestant", 1)) {
          html += '<li class="option english" style="" id="english">English</li>';
        }
      }
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();
    his_self.language_zone_overlay.pushHudUnderOverlay();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', (e) => {

      $('.option').off();
      let language_zone = e.currentTarget.id;
      let opponent_faction = "protestant";
      if (faction != "papacy") { opponent_faction = "papacy"; }

      let msg = "Against Commited or Uncommited Debater?";
      let html = '<ul>';
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 1)) {
          html += '<li class="option" id="committed">Committed</li>';
      }
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 0)) {
          html += '<li class="option" id="uncommitted">Uncommitted</li>';
      }
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let committed = $(this).attr("id");

        his_self.language_zone_overlay.hide();

        if (committed === "committed") { committed = 1; } else { committed = 0; }

        if (faction === "papacy") {
	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+committed);
        } else {
    	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tProtestants call a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
    	  his_self.addMove("pick_first_round_debaters\tprotestant\tpapacy\t"+language_zone+"\t"+committed);
        }
        his_self.endTurn();

      });
    });

    return 0;

  }
  canPlayerBuildSaintPeters(his_self, player, faction) {
    if (faction === "papacy") {
      if (his_self.game.state.saint_peters_cathedral['vp'] < 5) { return 1; }
    }
    return 0;
  }
  async playerBuildSaintPeters(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {
    for (let z = 0; z < ops_to_spend; z++) {
      his_self.addMove("build_saint_peters\t"+player+"\t"+faction);
    }
    his_self.endTurn();
    return 0;
  }

  canPlayerShowTutorial(his_self, player, faction) {
    if (his_self.game.state.round == 1) { return 1; }
    return 0;
  }
  async playerShowTutorial(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {

    this.game.state.may_explore['england'] = 1;
    this.game.state.may_explore['france'] = 1;
    this.game.state.may_explore['hapsburg'] = 1;
    this.game.state.may_conquer['england'] = 1;
    this.game.state.may_conquer['france'] = 1;
    this.game.state.may_conquer['hapsburg'] = 1;
    this.game.state.may_colonize['england'] = 1;
    this.game.state.may_colonize['france'] = 1;
    this.game.state.may_colonize['hapsburg'] = 1;

    let title = "";
    let text = "";
    let img = "";
    let card = "";

    let options = [];

    //
    // Protestant
    //
    if (faction == "protestant") {

      title = "Publish a Treatise?";
      text = "You get +1 roll for each adjacent Protestant space. Committing debaters give you bonuses flipping spaces, but make them more vulnerable in theological debates...";
      img = "/his/img/backgrounds/move/printing_press.jpg";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      title = "Watch the Discard Pile";
      text = "The Protestants are the only power that can retrieve cards from the discard pile. Retrieve valuable cards and play or hold them for the next turn...";
      img = "/his/img/backgrounds/move/publish_treatise.jpg";
      card = his_self.returnCardImage("007");
      options.push({ title : title , text : text , img : img , card : card });

      if (ops_remaining == 1) {
        title = "Translate the Bible!";
        text = "Translating the New Testament into a language gives 6 reformation attempts. Translating the Full Bible gives 6 more and earns 1 VP per translation.";
        img = "/his/img/backgrounds/move/translate.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // Papacy
    //
    if (faction == "papacy") {

      title = "Convene a Debate?";
      text = "Leipzig Debate lets you pick your own debater - Eck is a great choice. If you get lucky, the Protestants will need to use their Home Card to send Luther, wasting 5 Protestant OPs";
      img = "/his/img/backgrounds/move/theological_debate.jpg";
      card = his_self.returnCardImage("007");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Conquer Florence";
      text = "Build troops in Rome. Move them to Siena. Control Siena. Then move them to Florence and besiege the city. The next turn you can assault it.";
      img = "/his/img/backgrounds/move/papacy-florence.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (ops_remaining == 1) {
        title = "Build St. Peters!";
        text = "The Papacy earns VP for building St. Peter's Cathedral. Use any excess OPs to build the basilica.";
        img = "/his/img/backgrounds/move/saint_peters.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }
    }

    //
    // Ottoman
    //
    if (faction == "ottoman") {

      title = "Crush the Hungarians";
      text = "Conquering Belgrade and Buda will earn 2 VP and force the Hapsburgs into declaring war...";
      img = "/his/img/backgrounds/tutorials/ottoman-hungary.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      title = "Control the Mediterranean";
      text = "Piracy is harder around fortresses. Build troops in Athens, move ships into the Aegean Sea, and transport those units to Rhodes to assault the fortress...";
      img = "/his/img/backgrounds/tutorials/ottoman-rhodes.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.events.barbary_pirates == 1) {
        title = "Piracy?!";
        text = "Build corsairs in Algiers. Move them in packs around the Mediterranean and target opponents with Piracy. Every hit earns VP or a card draw...";
        card = his_self.returnCardImage("009");
        img = "/his/img/backgrounds/move/piracy.jpg";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // Hapsburg
    //
    if (faction == "hapsburg") {

      if (his_self.game.spaces["metz"].besieged == 0) {
        title = "Control Metz";
        text = "Build troops in Becanson. Move them north into Metz. Your forces will automatically besiege the city. The next turn, spend 1 OP to assault and hopefully capture it.";
        img = "/his/img/backgrounds/tutorials/hapsburg-metz.png";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      title = "Invade France";
      text = "Build infantry in Navarre. Move them north to Bordeaux. If the French withdraw into fortifications spend 1 OP to assault Bordeaux the next turn.";
      img = "/his/img/backgrounds/tutorials/hapsburg-bordeaux.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_conquer['hapsburg'] == 1) {
        title = "New World Conquest";
        text = "Conquests roll dice in the New World Phase to see if they succeed. In addition to earning VP, successful conquests can also earn bonus cards subsequent turns.";
        img = "/his/img/backgrounds/move/conquer.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['hapsburg'] == 1) {
        title = "Found a Colony";
        text = "At the end of every turn your colonies roll dice for bonus cards. Consider sending an expedition now for more ops later in the game.";
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // France
    //
    if (faction == "france") {

      title = "Build a Chateaux";
      text = "Your Home Card allows you to get VP and bonus cards, and your chance of success increases if France is not under attack.";
      img = "/his/img/backgrounds/chateaux.png";
      card = his_self.returnCardImage("004");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Conquer the New World";
      text = "Conquests are harder than Explorations. In addition to earning VP if they succeed, they also roll dice for bonus cards at the end of every turn. Consider sending an expedition!";
      img = "/his/img/backgrounds/move/conquer.jpg";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_explore['france'] == 1) {
        title = "Explore the New World";
        text = "New World Explorations cost 2 OPs and earn VP if they succeed. Dice are rolled and discoveries are made at the end of each turn.";
        img = "/his/img/backgrounds/move/explore.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['france'] == 1) {
        title = "Found a Colony";
        text = "You are allowed up to three colonies. At the end of every turn your surviving colonies will roll dice for bonus cards. Having more cards can provide a crucial advantage later in the game."
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_conquer['france'] == 1) {
        title = "Fortify Italy";
        text = "It is hard for France to move forces quickly into Italy, and Milan is vulnerable to attack. Consider building forces and moving them over to protect your Italian territories.";
        img = "/his/img/backgrounds/tutorials/france-milan.png";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // England
    //
    if (faction == "england") {

      title = "Unify the British Isles?";
      text = "Your Home Card lets you declare war on Scotland, which is necessary for attacking Edinburgh. Remember you will need 2 squadrons in the North Sea to assault the city.";
      img = "/his/img/backgrounds/tutorials/england-edinburgh.png";
      card = his_self.returnCardImage("003");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Henry VIII and Marriage";
      text = "From round 2 on, event your Home Card to advance Henry VIII's marital status. England earns 6 VP once a male heir is born.";
      img = "/his/img/backgrounds/henry_viii.jpeg";
      card = his_self.returnCardImage("003");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Fortify Calais?";
      text = "Calais is vulnerable to attack from the French and offers your landing point for invasions of the continent. Consider reinforcing it sooner rather than later.";
      img = "/his/img/backgrounds/tutorials/england-calais.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_conquer['england'] == 1) {
        title = "Conquer the New World";
        text = "Conquests are harder than Explorations. In addition to earning VP if they succeed, they also roll dice for bonus cards at the end of every turn. Consider sending an expedition!";
        img = "/his/img/backgrounds/move/conquer.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_explore['england'] == 1) {
        title = "Explore the New World";
        text = "New World Explorations cost 2 OPs and earn VP if they succeed. Dice are rolled and discoveries are made at the end of each turn.";
        img = "/his/img/backgrounds/move/explore.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['england'] == 1) {
        title = "Found a Colony";
        text = "You are allowed up to three colonies. At the end of every turn your surviving colonies will roll dice for bonus cards. Having more cards can provide a crucial advantage later in the game."
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    let x = Math.floor(Math.random() * options.length);

    his_self.welcome_overlay.renderCustom({
      title : options[x].title ,
      text : options[x].text ,
      card : options[x].card ,
      img : options[x].img ,
    });

    return;

  }

  canPlayerBurnBooksMaryI(his_self, player, faction) {
    return this.canPlayerBurnBooks(his_self, player, faction, 1);
  }
  canPlayerBurnBooks(his_self, player, faction, mary_i=0) {
    if (faction === "papacy") { return 1; }
    return 0;
  }
  async playerBurnBooksMaryI(his_self, player, faction, ops_to_spend, ops_remaining, mary_i=1) {
    return this.playerBurnBooks(his_self, player, faction, ops_to_spend, ops_remaining, 1);
    return 0;
  }
  async playerBurnBooks(his_self, player, faction, ops_to_spend, ops_remaining, mary_i=0) {

    let msg = "Select Language Zone for Counter Reformations";
    let html = '<ul>';

    if (mary_i == 0) {
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("german")) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("english")) {
        html += '<li class="option english" style="" id="english">English</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("french")) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("spanish")) {
        html += '<li class="option spanish" style="" id="spanish">Spanish</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("italian")) {
        html += '<li class="option italian" style="" id="italian">Italian</li>';
      }
    } else {
      html += '<li class="option english" style="" id="english">English</li>';
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      $('.option').off();
      his_self.language_zone_overlay.hide();
      let id = $(this).attr("id");

      if ((his_self.canPlayerCommitDebater("papacy", "cajetan-debater") || his_self.canPlayerCommitDebater("papacy", "tetzel-debater") || his_self.canPlayerCommitDebater("papacy", "caraffa")) && his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {

        let msg = "Commit Debater for Burn Books Bonus:";
        let html = '<ul>';
        html += '<li class="option" style="" id="no">No</li>';
	if (his_self.canPlayerCommitDebater("papacy", "tetzel-debater")) {
          html += '<li class="option" style="" id="tetzel-debater">Tetzel +1 to St Peters</li>';
	}
	if (his_self.canPlayerCommitDebater("papacy", "cajetan-debater")) {
          html += '<li class="option" style="" id="cajetan-debater">Cajetan +1 Attempt</li>';
	}
	if (his_self.canPlayerCommitDebater("papacy", "caraffa-debater")) {
          html += '<li class="option" style="" id="caraffa-debater">Caraffa +1 Attempt</li>';
        }
	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

        $('.option').off();
        $('.option').on('mouseover', function () {
          let action2 = $(this).attr("id");
          if (his_self.debaters[action2]) {
            his_self.cardbox.show(action2);
          }
        });
        $('.option').on('mouseout', function () {
          let action2 = $(this).attr("id");
          if (his_self.debaters[action2]) {
            his_self.cardbox.hide(action2);
          }
        });
        $('.option').on('click', function () {
          let id2 = $(this).attr("id");

	  his_self.cardbox.hide();

	  if (id2 === "tetzel-debater") {
            his_self.addMove("build_saint_peters");
            his_self.addMove("commit\tpapacy\ttetzel-debater\t1");
	  }

	  his_self.addMove("hide_overlay\tburn_books\t"+id);
	  his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	  if (id2 === "cajetan-debater" || id2 === "caraffa-debater") {
	    if (id2 === "cajetan-debater") { his_self.addMove("commit\tpapacy\tcajetan-debater"); }
	    if (id2 === "caraffa-debater") { his_self.addMove("commit\tpapacy\tcaraffa-debater"); }
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
	  } else {
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
	  }
	  his_self.addMove("show_overlay\tburn_books\t"+id);
	  his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	  his_self.endTurn();

	  return 0;
	});

	return 0;
      }

      his_self.addMove("hide_overlay\tburn_books\t"+id);
      his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
      his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
      his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
      his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
      his_self.addMove("show_overlay\tburn_books\t"+id);
      his_self.endTurn();
    });

    return 0;
  }
  canPlayerFoundJesuitUniversity(his_self, player, faction) {
    if (faction === "papacy" && his_self.game.state.events.papacy_may_found_jesuit_universities == 1) { return 1; }
    return 0;
  }
  async playerFoundJesuitUniversity(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Catholic-Controlled Space for Jesuit University",

      function(space) {
        if (space.religion === "catholic" &&
            space.university != 1) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.addMove("found_jesuit_university\t"+destination_spacekey);
	his_self.endTurn();
      },

    );

    return 0;
  }

  playerPlaceUnitsInSpaceWithFilter(unittype, num, faction, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);

    if (count == 0) { his_self.endTurn(); return 0; }

    his_self.playerSelectSpaceWithFilter(

      `Place ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {
        
	his_self.updateStatus("acknowledge...");
	his_self.addUnit(faction, spacekey, unittype);
	his_self.displaySpace(spacekey);
        his_self.addMove("build\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
	if (mycallback != null) { mycallback(spacekey); }

	if (num == 1) {
          his_self.endTurn();
	} else {
  	  his_self.playerPlaceUnitsInSpaceWithFilter(unittype, num-1, faction, filter_func, mycallback, cancel_func, board_clickable);
	}
      },

      cancel_func ,

      board_clickable 
    );
  }


  playerRemoveUnitsInSpaceWithFilter(unittype, num, faction, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);
    if (count == 0) { 
      his_self.updateStatus("No Spaces Available for Unit Removal"); 
      his_self.endTurn();
      return 0;
    }

    his_self.playerSelectSpaceWithFilter(

      `Remove ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {

	his_self.updateStatus("removing unit...");

	his_self.removeUnit(faction, spacekey, unittype);

	his_self.displaySpace(spacekey);

        his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	

	if (num == 1) {
          his_self.endTurn();
	} else {
  	  his_self.playerRemoveUnitsInSpaceWithFilter(unittype, num-1, faction, filter_func, mycallback, cancel_func, board_clickable);
	}

      },

      cancel_func,

      true

    );
  }



  playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);
    if (count == 0) { 
      his_self.updateStatus("No Spaces Available for Unit Removal"); 
      his_self.endTurn();
      return 0;
    }

    his_self.playerSelectSpaceWithFilter(

      `Remove ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {

	his_self.updateStatus("removing unit...");

	let s = his_self.game.spaces[spacekey];
	let factions_with_units = [];
	for (let f in s.units) {
	  for (let z = 0; z < s.units[f].length; z++) {
	    if (s.units[f][z].type === unittype && !factions_with_units.includes(f)) { factions_with_units.push(f); z = 100; }
	  }
        }

	if (factions_with_units.length == 1) {
	  let faction = factions_with_units[0];
	  his_self.removeUnit(faction, spacekey, unittype);
	  his_self.displaySpace(spacekey);
          his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
  	  if (num == 1) {
            his_self.endTurn();
	  } else {
  	    his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num-1, filter_func, mycallback, cancel_func, board_clickable);
	  }
	} else {

          let msg = "Remove Mercenary from which Faction?";
          let html = '<ul>';
          for (let z = 0; z < factions_with_units.length; z++) {
	    html += `<li class="option" id="${factions_with_units[z]}">${his_self.returnFactionName(factions_with_units[z])}</li>`;
	  }
          html += '</ul>';
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let faction = $(this).attr("id");
	    his_self.removeUnit(faction, spacekey, unittype);
	    his_self.displaySpace(spacekey);
            his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
  	    if (num == 1) {
              his_self.endTurn();
	    } else {
  	      his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num-1, filter_func, mycallback, cancel_func, board_clickable);
	    }
          });
	}
      },

      cancel_func,

      true

    );
  }

  playerAddUnrest(his_self, faction="", zone="", religion="") {

    his_self.playerSelectSpaceWithFilter(
      "Select Space to add Unrest" ,
      function(space) {
        if (space.language === zone && space.religion === religion) { return 1; }
      },
      function(spacekey) {
        his_self.addMove(`unrest\t${spacekey}`);
        his_self.endTurn();
      },
      null,
      true 
    );

  }


  playerManuallyRemoveExcommunication(his_self, faction) {

    let msg = "Give Papacy Card to Remove Excommunication?";
    let html = '<ul>';
    html += `<li class="option" id="yes">give random card</li>`;
    html += `<li class="option" id="no">remain excommunicated</li>`;
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      if (id == "yes") {
        his_self.addMove("unexcommunicate_faction\t"+faction);
        his_self.addMove("pull_card\t"+"papacy"+"\t"+faction);
        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " gives card to remove excommunication");
      }
      his_self.endTurn();

    });
  }


  canFactionSueForPeace(faction) {

    let his_self = this;
    let f = [];
    let io = this.returnImpulseOrder();

    for (let i = 0; i < io.length; i++) {
      if (this.areEnemies(faction, io[i])) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == faction) {
	    if (this.returnFactionControllingSpace(key) == io[i]) {
	      if (!f.includes(io[i])) {
	        f.push(io[i]);
	      }
	    }
	  }
	}
	if (!f.includes(io[i])) {
	  let p2 = this.returnPlayerCommandingFaction(io[i]);
          for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
	    if (his_self.game.state.players_info[p2-1].captured[z].faction == faction) {
	      if (!f.includes(io[i])) {
	        f.push(io[i]);
	      }
	    }
	  }
        }
      }
    }

    if (faction == "protestant") {
      for (let z = 0; z < f.length; z++) {
	if (f[z] == "hapsburg" || f[z] == "papacy") { 
	  f.splice(z, 1);
	  z--;
	}
      }
    }
    if (faction == "papacy" || faction == "hapsburg") {
      for (let z = 0; z < f.length; z++) {
	if (f[z] == "protestant") {
	  f.splice(z, 1);
	  z--;
	}
      }
    }

    return f;

  }

  playerSueForPeace(his_self, faction) {

    let f = this.canFactionSueForPeace(faction);

    let msg = "Sue for Peace?";
    let html = '<ul>';
    for (let i = 0; i < f.length; i++) {
      html += `<li class="option" id="${f[i]}">${his_self.returnFactionName(f[i])}</li>`;
    }
    html += `<li class="option" id="skip">skip</li>`;
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");

      if (target_faction == "skip") {
	his_self.endTurn();
      }

      //
      // no longer enemies
      //
      his_self.addMove("unset_enemies\t"+faction+"\t"+target_faction);

      //
      // +1 War Winner VP
      //
      let bonus_vp = 1;
      if (target_faction == "ottoman" || faction == "ottoman") { bonus_vp = 2; }

      his_self.addMove("display_vp_track");
      for (let z = 0; z < bonus_vp; z++) {
        if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
        if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
        if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
        if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
        if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
        if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }
      }

      //
      // loser returns winner home spaces
      //
      for (let key in his_self.game.spaces) {
	if (his_self.game.spaces[key].home === target_faction) {
	  if (his_self.game.spaces[key].political === faction) {
            his_self.addMove(`control\t${target_faction}\t${key}`);
            his_self.addMove(`withdraw_to_nearest_fortified_space\t${faction}\t${key}`);
	  }
        }
      }

      //
      // loser removes 2 units
      //
      his_self.playerSelectSpaceOrNavalSpaceWithFilter(
        `Select Space to Remove 1st Unit` ,
        function(space) {
          if (space.units[faction].length > 0) {
	    for (let i = 0; i < space.units[faction].length; i++) {
	      let u = space.units[faction][i];
	      if (u.type == "regular" || u.type == "squadron" || u.type == "corsair" || u.type == "mercenary" || u.type == "cavalry") { return 1; }
	    }
	  }
          return 0;
        },
        function(spacekey) {
          let land_or_sea = "land";
          let space = null;
          if (his_self.game.navalspaces[spacekey]) {
            land_or_sea = "sea";
            space = his_self.game.navalspaces[spacekey];
          } else {
            space = his_self.game.spaces[spacekey];
          }
          if (space == null) {
            alert("ERROR: not sure where you clicked - reload to continue");
            return 1;
          }
          let faction_to_destroy = faction;
          let msg = "Destroy Which Unit: ";
          let unittypes = [];
          let html = '<ul>';
          for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
            if (space.units[faction_to_destroy][i].command_value == 0 && space.units[faction_to_destroy][i].personage != true) {
              if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                unittypes.push(space.units[faction_to_destroy][i].key);
              }
            }
          }
          html += '</ul>';
          his_self.updateStatusWithOptions(msg, html);
          $('.option').off();
          $('.option').on('click', function () {
            let unittype = $(this).attr("id");
            his_self.updateStatus("removing unit...");
            his_self.removeUnit(faction_to_destroy, spacekey, unittype);
            his_self.displaySpace(spacekey);
            his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
            //
            // loser removes 2 units
            //
            his_self.playerSelectSpaceOrNavalSpaceWithFilter(
              `Select Space to Remove 2nd Unit` ,
              function(space) {
                if (space.units[faction].length > 0) {
	          for (let i = 0; i < space.units[faction].length; i++) {
	          let u = space.units[faction][i];
	            if (u.type == "regular" || u.type == "squadron" || u.type == "corsair" || u.type == "mercenary" || u.type == "cavalry") { return 1; }
	          }
	        }
                return 0;
              },
              function(spacekey) {
                his_self.updateStatus("removing unit...");
                let land_or_sea = "land";
                let space = null;
                if (his_self.game.navalspaces[spacekey]) {
                  land_or_sea = "sea";
                  space = his_self.game.navalspaces[spacekey];
                } else {
                  space = his_self.game.spaces[spacekey];
                }
                if (space == null) {
                  alert("ERROR: not sure where you clicked - reload to continue");
                  return 1;
                }
                let faction_to_destroy = faction;
                let msg = "Destroy Which Unit: ";
                let unittypes = [];
                let html = '<ul>';
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].personage != true && space.units[faction_to_destroy][i].battle_rating != 1) {
                    if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                      html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                      unittypes.push(space.units[faction_to_destroy][i].key);
                    }
                  }
                }
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);
                $('.option').off();
                $('.option').on('click', function () {
                  let unittype = $(this).attr("id");
                  his_self.updateStatus("removing unit...");
                  his_self.removeUnit(faction_to_destroy, spacekey, unittype);
                  his_self.displaySpace(spacekey);
                  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
                  let z = false;
                  his_self.addMove("war_loser_regain_leaders_for_vp_or_cards\t"+faction+"\t"+target_faction);
                  his_self.addMove("war_loser_regain_spaces_for_vp_or_cards\t"+faction+"\t"+target_faction);
                  his_self.addMove("war_loser_regain_keys_for_vp\t"+faction+"\t"+target_faction);
                  his_self.endTurn();
                });
              },
              0 ,
              1
            );
          });
        },
        0 ,
        1
      );

    });
   

  }

  canPlayerDeclareWar(his_self, faction) {

    let t = his_self.returnDeclarationOfWarTargets(faction);
    for (let i = 0; i < t.length; i++) {
      if (t[i].cost > 0) { return 1; }
    }

    return 0;

  }

  //
  // similar to playerDeclareWar but permits choosing multiple
  // targets for war...
  //
  playerMakeDeclarationsOfWar(his_self, faction) {

    let t = his_self.returnDeclarationOfWarTargets(faction);
    let targets = [];

    let selectFactionsInterface = function(selectFactionsInterface, payCostsInterface) {

      let msg = `${his_self.returnFactionName(faction)} - Declarations of War?`;
      let existing_cost = 0;
      let html = '<ul>';
      let final_message = "do not declare war";

      for (let i = 0; i < targets.length; i++) {
	existing_cost += parseInt(targets[i].cost);
      }

      if (existing_cost > 0) { msg += " (cost: "+existing_cost+")"; }

      for (let i = 0; i < t.length; i++) {

	let include_faction = true;
	let already_declaring_war = false;
	for (let z = 0; z < targets.length; z++) {
	  if (targets[z].faction === t[i].faction) { 
	    already_declaring_war = true;
	  }
	}
	if (his_self.areEnemies(faction, t[i].faction)) {
	  include_faction = false;
	}

	if (include_faction) {
          if (already_declaring_war) {
  	    html += `<li class="option" id="${i}">* ${his_self.returnFactionName(t[i].faction)} (${t[i].cost} OPS) *</li>`;
            final_message = "declare war (and pay)";
	  } else {
            html += `<li class="option" id="${i}">${his_self.returnFactionName(t[i].faction)} (${t[i].cost} OPS)</li>`;
          }
        }
      }
      html += `<li class="option" id="end">${final_message}</li>`;
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

	let action = $(this).attr("id");

        let id = parseInt(action);
	$('.option').off();

	if (action == "end") {
	  if (targets.length == 0) {
	    his_self.endTurn();
	    return;
	  }
	  payCostsInterface(selectFactionsInterface, payCostsInterface);
	  return;
	}

        let enemy = t[id].faction;
        let cost = t[id].cost;

	let total_cost = 0;
	for (let i = 0; i < targets.length; i++) {
	  total_cost += targets[i].cost;
	}

	let already_in_targets = false;
	for (let i = 0; i < targets.length; i++) {
	  if (targets[i].faction == enemy) {
	    already_in_targets = true;
	    targets.splice(i, 1);
	  }
	}

	if (already_in_targets == false) {
	  targets.push({ faction : enemy , cost : cost });
	}

	selectFactionsInterface(selectFactionsInterface, payCostsInterface);

      });
    }


    let payCostsInterface = function(selectFactionsInterface, payCostsInterface) {

      let total_cost = 0;
      let total_cost_paid = 0;
      let cards_selected = [];

      for (let i = 0; i < targets.length; i++) {
        total_cost += targets[i].cost;
      }
  
      let selectCardsInterface = function(selectCardsInterface, selectFactionsInterface, payCostsInterface) {

        let msg = "Declare War: " + total_cost_paid + " of " + total_cost + " OPS"; 

        his_self.playerSelectOps(faction, 1, (card) => {

	  if (!cards_selected.includes(card)) { cards_selected.push(card); }
	  total_cost_paid += parseInt(his_self.game.deck[0].cards[card].ops);	 
          his_self.addMove(`discard\t${faction}\t${card}`);

	  if (total_cost_paid >= total_cost) {
	    for (let i = 0; i < targets.length; i++) {
              his_self.addMove(`declare_war\t${faction}\t${targets[i].faction}`);
	    }
	    his_self.endTurn();
	  } else {
	    selectCardsInterface(selectCardsInterface, selectFactionsInterface, payCostsInterface);
	  }

        }, msg, cards_selected);
	
      }

      selectCardsInterface(selectCardsInterface, selectFactionsInterface, payCostsInterface);

    }

    selectFactionsInterface(selectFactionsInterface, payCostsInterface);

    return 0;

  }

  playerDeclareWar(his_self, faction, cost=-1, targets=[]) {

    let t = his_self.returnDeclarationOfWarTargets(faction);

    let msg = "Declare War on which Power?";
    let html = '<ul>';
    for (let i = 0; i < t.length; i++) {
      if ((this.canPlayerSelectOps(faction, t[i].cost) || cost == -1) || (this.canPlayerSelectOps(faction, cost))) {
	if (targets.length > 0) {
          if (targets.includes(t[i].faction)) {
	    html += `<li class="option" id="${i}">${t[i].faction}</li>`;
	  }
	} else {
          html += `<li class="option" id="${i}">${t[i].faction}</li>`;
        }
      }
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");
      let enemy = t[id].faction;
      let cost = t[id].cost;

      his_self.playerSelectOps(faction, cost, (card) => {
        his_self.addMove(`discard\t${faction}\t${card}`);
        his_self.addMove(`declare_war\t${faction}\t${cost}`);
        his_self.endTurn();
      });

    });
     
    return 0;
  }


  
  returnDebaters(faction="papacy", type="uncommitted") {
    let debaters = [];
    let map = {};
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (faction == "papacy") {
        if (this.game.state.debaters[i].faction == faction) {
	  if (type == "uncommitted" && this.game.state.debaters[i].committed != 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	  if (type == "committed" && this.game.state.debaters[i].committed == 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	}
      } else {
        if (this.game.state.debaters[i].faction != "papacy") {
	  if (type == "uncommitted" && this.game.state.debaters[i].committed != 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	  if (type == "committed" && this.game.state.debaters[i].committed == 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	}
      }
    }
    return debaters;
  }




  returnDiplomacyMenuOptions(player=null, faction=null) {

    let menu = [];

    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "End War",
      check : this.canPlayerEndWar,
      fnct : this.playerEndWar,
      img : "dove.jpeg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Form Alliance",
      check : this.canPlayerFormAlliance,
      fnct : this.playerFormAlliance,
      img : "treaty.jpeg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Random Card",
      check : this.canPlayerIssueCards,
      fnct : this.playerIssueCards,
      img : "the-card-players.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Get Random Card",
      check : this.canPlayerPullCards,
      fnct : this.playerPullCards,
      img : "the-card-players.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Return Captured Leader",
      check : this.canPlayerReturnCapturedArmyLeader,
      fnct : this.playerReturnCapturedArmyLeader,
      img : "prison.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Yield Territory",
      check : this.canPlayerYieldTerritory,
      fnct : this.playerYieldTerritory,
      img : "diplomacy.png" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Gain Territory",
      check : this.canPlayerGainTerritory,
      fnct : this.playerGainTerritory,
      img : "diplomacy.png" ,
    });
    menu.push({
      factions : ['papacy'],
      name : "Approve Divorce",
      check : this.canPlayerApproveDivorce,
      fnct : this.playerApproveDivorce,
      img : "papal_decree.jpg" ,
    });
    menu.push({
      factions : ['papacy'],
      name : "Rescind Excommunication",
      check : this.canPlayerRescindExcommunication,
      fnct : this.playerRescindExcommunication,
      img : "excommunication.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Mercenaries",
      check : this.canPlayerGiveMercenaries,
      fnct : this.playerGiveMercenaries,
      img : "mercenary.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Loan Squadrons",
      check : this.canPlayerLoanSquadrons,
      fnct : this.playerLoanSquadrons,
      img : "squadron.jpg" ,
    });

    return menu;

  }


  convertTermsToText(terms=[]) {

    let text = [];

    for (let i = 0; i < terms.length; i++) {

      let x = terms[i].split("\t");

      if (x[0] === "declare_peace" || x[0] === "end_war") {
	text.push(`${this.returnFactionName(x[1])} and ${this.returnFactionName(x[2])} end their war`);
      }
      if (x[0] === "set_allies") {
	text.push(`${this.returnFactionName(x[1])} and ${this.returnFactionName(x[2])} agree to ally`);
      }
      if (x[0] === "yield_cards" || x[0] === "pull_card") {
	text.push(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} a card`);
      }
      if (x[0] === "returns_captured" || x[0] === "ransom") {
	text.push(`${this.returnFactionName(x[1])} returns ${x[1]}`);
      }
      if (x[0] === "control" || x[0] === "yield_key") {
	text.push(`${this.returnFactionName(x[3])} yields ${this.returnSpaceName(x[2])} to ${this.returnFactionName(x[1])}`);
      }
      if (x[0] === "approve_divorce" || x[0] === "advance_henry_viii_marital_status") {
	text.push(`${this.returnFactionName(x[1])} approves Henry VIII divorce`);
      }
      if (x[0] === "rescind_excommunication" || x[0] === "unexcommunicate_faction") {
	text.push(`Papacy rescinds ${this.returnFactionName(x[1])} excommunication`);
      }
      if (x[0] === "give_squadron" || x[0] === "loan_squadron") {
	if (!text.includes(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} squadron(s)`)) {
	  text.push(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} squadron(s)`);
	}
      }
      if (x[0] === "offer_mercenaries" || x[0] === "give_mercenaries") {
	text.push(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} mercenaries`);
      }
    }

    return text;
  }


  canPlayerEndWar(his_self, player, faction) {
    let io = his_self.returnDiplomacyImpulseOrder(faction);

console.log("can we end a war: " + faction);
    for (let i = 0; i < io.length; i++) {
console.log("checking with: " + io[i] + " -- " + his_self.areEnemies(faction, io[i]));
      if (his_self.areEnemies(faction, io[i])) { 
console.log("enemies: " + faction + " / " + io[i]);
	if (
	  !((faction == "papacy" && io[i] == "protestant") || (faction == "protestant" && io[i] == "papacy"))
	    && 
	  !((faction == "hapsburg" && io[i] == "protestant") || (faction == "protestant" && io[i] == "hapsburg"))
	) {

console.log("this player can end war...");
	  return 1;
	}
      }
    }
    return 0;
  }

  canPlayerFormAlliance(his_self, player, faction) {
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    for (let i = 0; i < io.length; i++) {
      let prohibited_alliance = false;
      if (faction == "papacy" && io[i] == "hapsburg" && his_self.game.state.henry_viii_pope_approves_divorce == 1) {
	prohibited_alliance = true;
      }
      if (faction == "papacy" && io[i] == "protestant") {
	prohibited_alliance = true;
      }
      if (faction == "protestant" && io[i] == "papacy") {
	prohibited_alliance = true;
      }
      if (faction == "hapsburg" && io[i] == "protestant") {
	prohibited_alliance = true;
      }
      if (faction == "protestant" && io[i] == "hapsburg") {
	prohibited_alliance = true;
      }
      if (faction == "papacy" && io[i] == "ottoman") {
	prohibited_alliance = true;
      }
      if (faction == "ottoman" && io[i] == "papacy") {
	prohibited_alliance = true;
      }
      if (faction == io[i]) {
	prohibited_alliance = true;
      }
      if (prohibited_alliance == false && !his_self.areAllies(faction, io[i]) && faction !== io[i]) { return 1; }
    }
    return 0;
  }

  canPlayerIssueCards(his_self, player, faction) {
    return 1;
  }
  canPlayerPullCards(his_self, player, faction) {
    return 1;
  }

  canPlayerReturnCapturedArmyLeader(his_self, player, faction) {
    let p = his_self.returnPlayerCommandingFaction(faction);
    for (let z = 0; z  < his_self.game.state.players_info[p-1].captured.length; z++) { 
      if (faction == his_self.game.state.players_info[p-1].capturing_faction) { return 1; }
    }
    return 0;
  }

  canPlayerYieldTerritory(his_self, player, faction) {
    let target_spaces = his_self.countSpacesWithFilter(
      function(space) { 
        if (space.political == faction || (space.political == "" && space.home == faction)) { return 1; }
      }
    );
    if (target_spaces) { return 1; }
    return 0;
  }

  canPlayerGainTerritory(his_self, player, faction) {
    return 1;
  }

  canPlayerApproveDivorce(his_self, player, faction) {
    if (his_self.game.state.henry_viii_marital_status == 1) { return 1; }
    return 0;
  }

  canPlayerRescindExcommunication(his_self, player, faction) {
    if (his_self.game.state.excommunicated_factions["france"] == 1) { return 1; }
    if (his_self.game.state.excommunicated_factions["england"] == 1) { return 1; }
    if (his_self.game.state.excommunicated_factions["hapsburg"] == 1) { return 1; }
    return 0;
  }

  canPlayerGiveMercenaries(his_self, player, faction) {
    for (let key in his_self.game.spaces) {
      if (his_self.game.spaces[key].units[faction].length > 0 && key != "persia" && key != "egypt" && key != "ireland") {
	for (let i = 0; i < his_self.game.spaces[key].units[faction].length; i++) {
	  if (his_self.game.spaces[key].units[faction][i].type === "mercenary") { return 1; }
        }
      }
    }
    return 0;
  }

  canPlayerLoanSquadrons(his_self, player, faction) {
    if (faction != "protestant") {
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let z = 0; z < s.units[faction].length; z++) {
	  if (s.units[faction][z].type == "squadron") { return 1; }
	}
      }
    }
    return 0;
  }




  async playerEndWar(his_self, faction, mycallback=null) {

    let terms = [];
    let msg = `${his_self.returnFactionName(faction)} - End War with Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (his_self.areEnemies(faction, io[i]) && faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (mycallback == null) { return; }

      his_self.updateStatus("submitted");
      mycallback([`declare_peace\t${faction}\t${action2}`]);

    });

    return 0;
  }

  async playerFormAlliance(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Form Alliance with Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      let prohibited_alliance = false;
      if (faction == "papacy" && io[i] == "hapsburg" && his_self.game.state.henry_viii_pope_approves_divorce == 1) {
	prohibited_alliance = true;
      }
      if (faction == "papacy" && io[i] == "ottoman") {
	prohibited_alliance = true;
      }
      if (faction == "ottoman" && io[i] == "papacy") {
	prohibited_alliance = true;
      }
      if (faction == io[i]) {
	prohibited_alliance = true;
      }
      if (prohibited_alliance == false && !his_self.areAllies(faction, io[i])) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (mycallback == null) { return; }
      his_self.updateStatus("submitted");

      mycallback([`set_allies\t${faction}\t${action2}`]);

    });

    return 0;
  }

  async playerIssueCards(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Issue Random Card Draw to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (mycallback == null) { return; }
      his_self.updateStatus("submitted");

      mycallback([`pull_card\t${action2}\t${faction}`,`NOTIFY\t${his_self.returnFactionName(action2)} pulls card from ${his_self.returnFactionName(faction)}`]);

    });

    return 0;
  }

  async playerPullCards(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Pull Random Card from Whom? `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (mycallback == null) { return; }
      his_self.updateStatus("submitted");

      mycallback([`pull_card\t${faction}\t${action2}`,`NOTIFY\t${his_self.returnFactionName(faction)} pulls card from ${his_self.returnFactionName(action2)}`]);

    });

    return 0;
  }

  async playerReturnCapturedArmyLeader(his_self, faction, mycallback=null) {

    let terms = [];

    let p = his_self.returnPlayerCommandingFaction(faction);
    let msg = `${his_self.returnFactionName(faction)} - Return which Leader? `;
    let html = '<ul>';
    for (let i = 0; i < his_self.game.state.players_info[p-1].captured.length; i++) {
      let u = his_self.game.state.players_info[p-1].captured[i];
      if (u.capturing_faction == faction) {
        html += `<li class="option" id="${u}">${u}</li>`;
      }
    }
    html += '</ul>';
      
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
      let give_which_leader = $(this).attr("id");
      if (mycallback == null) { return; }
      his_self.updateStatus("submitted");
      mycallback([`ransom\t${give_which_leader}\t${faction}`]);
    });

    return 0;

  }


  async playerGainTerritory(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Gain Territory from Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let giving_faction = $(this).attr("id");

      his_self.winter_overlay.hide();

      his_self.playerSelectSpaceWithFilter(

        "Gain which Space?",
              
          function(space) {
            if (space.political === giving_faction || (space.home == giving_faction && space.political == "")) {
	      return 1;
	    }
	    return 0;
          },

          function(spacekey) {
            if (mycallback == null) { return; }
            his_self.updateStatus("submitted");
            mycallback([`control\t${faction}\t${spacekey}\t${giving_faction}`,`NOTIFY\t${his_self.returnFactionName(giving_faction)} yields ${his_self.returnSpaceName(spacekey)} to ${his_self.returnFactionName(faction)}`]);
            his_self.winter_overlay.render();
          },
          
          null,

          true

        );
    });
    return 0;
  }

  async playerYieldTerritory(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Yield Territory to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let receiving_faction = $(this).attr("id");

      his_self.winter_overlay.hide();

      his_self.playerSelectSpaceWithFilter(

        "Yield which Space?",
              
          //
          // catholic spaces adjacent to protestant
          //
          function(space) {
            if (space.political === faction || (space.home == faction && space.political == "")) {
	      return 1;
	    }
	    return 0;
          },

          function(spacekey) {
            if (mycallback == null) { return; }
            his_self.updateStatus("submitted");
            mycallback([`control\t${receiving_faction}\t${spacekey}\t${faction}`,`NOTIFY\t${his_self.returnFactionName(faction)} yields ${his_self.returnSpaceName(spacekey)} to ${his_self.returnFactionName(receiving_faction)}`]);
            his_self.winter_overlay.render();
          },
          
          null,

          true

        );
    });
    return 0;
  }

  async playerApproveDivorce(his_self, faction, mycallback) {
    mycallback([`advance_henry_viii_marital_status`,`SETVAR\tstate\thenry_viii_pope_approves_divorce\t1`, `NOTIFY\tThe Papacy accedes to Henry VIII's request for a divorce.`]);
    return 0;
  }

  async playerRescindExcommunication(his_self, faction, mycallback) {

    let msg = `Rescind Excommunication of Whom: `;
    let html = '<ul>';
    if (his_self.game.state.excommunicated_factions["france"] == 1) {
      html += `<li class="option" id="france">France</li>`;
    }
    if (his_self.game.state.excommunicated_factions["england"] == 1) {
      html += `<li class="option" id="england">England</li>`;
    }
    if (his_self.game.state.excommunicated_factions["hapsburg"] == 1) {
      html += `<li class="option" id="hapsburg">Hapsburg</li>`;
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let beneficiary = $(this).attr("id");
      his_self.updateStatus("submitted");
      mycallback([`unexcommunicate_faction\t${beneficiary}`,`NOTIFY\tThe Papacy rescinds the excommunication of ${his_self.returnFactionName(beneficiary)}`]);

    });
    return 0;
  }




  async playerGiveMercenaries(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Give Mercenaries to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (!his_self.areAllies(faction, io[i]) && faction != io[i] && io[i] != "ottoman") {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      $('.option').off();
      his_self.updateStatus("submitted");
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[faction].length; i++) {
	  let u = s.units[faction][i];
	  if (u.type == "mercenary") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Mercenaries? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

        his_self.updateStatus("submitted");
        mycallback([`place_mercenaries\t${faction}\t${target_faction}\t${target_number}`,`give_mercenaries\t${faction}\t${target_faction}\t${target_number}`]);

      });
    });

    return 0;
  }

  async playerLoanSquadrons(his_self, faction, mycallback) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Give Squadrons to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (!his_self.areAllies(faction, io[i]) && faction != io[i] && io[i] != "protestant") {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      his_self.updateStatus("submitted");
      $('.option').off();
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[faction].length; i++) {
	  let u = s.units[faction][i];
	  if (u.type == "squadron") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Squadrons? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

	let instructions = [];
        his_self.updateStatus("submitted");

	for (let z = 0; z < target_number; z++) {
	  instructions.push(`give_squadron\t${faction}\t${target_faction}\t${target_number}`);
	}
        mycallback(instructions);
      });
    });

    return 0;
  }










  returnArrayOfFactionsInSpacekey(spacekey="") {
    let res = [];
    let s = this.game.spaces[spacekey];
    if (s) {
      for (let f in s.units) {
	if (s.units[key].length > 0) { res.push(f); }
      }
    };
    return res;
  }

  isPlayerControlledFaction(faction="") {
    if (faction === "") { return false; }
    if (this.isAlliedMinorPower(faction)) { return true; }
    if (this.isMajorPower(faction)) { return true; }
    return false;
  }

  returnFactionAdminRating(faction="") {
    if (this.factions[faction]) {
      return this.factions[faction].returnAdminRating(this);
    }
    return 0;
  }
 
  returnFactionName(f) {
    if (this.factions[f]) {
      return this.factions[f].name;
    }
    return "Unknown";
  }

  importFaction(name, obj) {

    if (obj.id == null)                 { obj.id = "faction"; }
    if (obj.name == null)               { obj.name = "Unknown Faction"; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.key == null)	        { obj.key = name; }
    if (obj.ruler == null)		{ obj.ruler = ""; }
    if (obj.cards == null)		{ obj.cards = 0; }
    if (obj.capitals == null)	        { obj.capitals = []; }
    if (obj.admin_rating == null)	{ obj.admin_rating = 0; } // cards "holdable"
    if (obj.cards_bonus == null)	{ obj.cards_bonus = 0; }
    if (obj.vp == null)			{ obj.vp = 0; }
    if (obj.vp_base == null)		{ obj.vp_base = 0; }
    if (obj.vp_special == null)		{ obj.vp_special = 0; }
    if (obj.vp_bonus == null)		{ obj.vp_bonus = 0; }
    if (obj.allies == null)		{ obj.allies = []; }
    if (obj.minor_allies == null)	{ obj.minor_allies = []; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.faction == null)		{ obj.faction = name; }
    if (obj.passed == null)		{ obj.passed = false; }
    if (obj.calculateBaseVictoryPoints == null) {
      obj.calculateBaseVictoryPoints = function() { return 0; }
    }
    if (obj.calculateBonusVictoryPoints == null) {
      obj.calculateBonusVictoryPoints = function() { return 0; }
    }
    if (obj.returnAdminRating == null) {
      obj.returnAdminRating = function(game_mod) { return this.admin_rating; }
    }
    if (obj.calculateSpecialVictoryPoints == null) {
      obj.calculateSpecialVictoryPoints = function() { return 0; }
    }
    if (obj.returnFactionSheet == null) {
      obj.returnFactionSheet = function(faction) {
        return `
	  <div class="faction_sheet" id="faction_sheet" style="background-image: url('/his/img/factions/${obj.img}')">
	    <div class="faction_sheet_ruler" id="faction_sheet_ruler"></div>
	    <div class="faction_sheet_vp" id="faction_sheet_vp"></div>
	  </div>
	`;
      }
    }
    if (obj.returnCardsDealt == null) {
      obj.returnCardsDealt = function(faction) {
	return 1;
      }
    }

    obj = this.addEvents(obj);
    this.factions[obj.key] = obj;

  }

  gainVictoryPoints(faction, points, type="special") {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let ii = 0; ii < this.game.state.players_info[i].factions.length; ii++) {
	if (faction === this.game.state.players_info[i].factions[ii]) {
	  if (type == "base") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_base += points;
	  }
	  if (type == "special") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_special += points;
	  }
	  if (type == "bonus") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_bonus += points;
	  }
	  break;
        }
      }
    }
    return -1;
  }


  returnControlledCapitals(faction) {
    let x = this.returnCapitals(faction);
    for (let i = 0; i < x.length; i++) {
      if (!this.isSpaceControlled(x[i], faction)) {
	x.splice(i, 1);
	i--;
      }
    }
    return x;
  }

  returnCapitals(faction) {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let ii = 0; ii < this.game.state.players_info[i].factions.length; ii++) {
	if (faction === this.game.state.players_info[i].factions[ii]) {
          return this.factions[this.game.state.players_info[i].factions[ii]].capitals;
        }
      }
    }
    return [];
  }

  returnFactionHandIdx(player, faction) {
    for (let i = 0; i < this.game.state.players_info[player-1].factions.length; i++) {
      if (this.game.state.players_info[player-1].factions[i] === faction) {
	return i;
      }
    }
    return -1;
  }




  /* override default */
  updateStatus(str, force = 0) {

    this.updateControls("");

    try {

      this.game.status = str;
      if (!this.browser_active) { return; }

      if (this.useHUD) {
        this.hud.updateStatus(str);
      }

      document.querySelectorAll(".status").forEach((el) => {
        el.innerHTML = str;
      });
      if (document.getElementById("status")) {
        document.getElementById("status").innerHTML = str;
      }

      if (this.useCardbox) {
	this.cardbox.attachCardboxEvents();
      }


    } catch (err) {
      console.warn("Error Updating Status: ignoring: " + err);
    }
  } 





  importUnit(name, obj) {

    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.active == null)		{ obj.active = 0; } // if bonus is active for debaters
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)             { obj.loaned = false; }
    if (obj.key == null)                { obj.key = name; }
    if (obj.gout == null)               { obj.gout = false; }
    if (obj.locked == null)		{ obj.locked = 0; }
    if (obj.already_moved == null)	{ obj.already_moved = 0; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (obj.returnCardImage == null) {
      obj.returnCardImage = () => { return ""; }
    }

    this.addEvents(obj);
    this.units[name] = obj;

  }

  newUnit(faction, type) {
    for (let key in this.units) {
      if (this.units[key].type === type) {
        let new_unit = JSON.parse(JSON.stringify(this.units[key]));
        new_unit.owner = faction;
        return new_unit;
      }
    }
    return null;
  }

  importArmyLeader(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = true; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.army[name]) {
      this.addEvents(obj);
      this.army[name] = obj;
    }
  }

  importNavyLeader(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "both"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = true; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.navy[name]) {
      this.addEvents(obj);
      this.navy[name] = obj;
    }
  }

  importWife(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.wives[name]) {
      this.addEvents(obj);
      this.wives[name] = obj;
    }
  }

  importReformer(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = true; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.reformers[name]) {
      this.addEvents(obj);
      this.reformers[name] = obj;
    }
  }

  importDebater(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = true; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.power == null)		{ obj.power = 0; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (obj.returnCardImage == null) {
      obj.returnCardImage = () => {
        let tile_f = "/his/img/tiles/debaters/" + obj.img;
        let tile_b = tile_f.replace('.svg', '_back.svg');
	return `
	  <div class="debater-card" id="${obj.key}" style="background-image: url('${tile_f}'); background-size: cover"></div>	
	`;
      }
    }

    if (!this.debaters[name]) {
      this.debaters[name] = obj;
      this.addEvents(obj);
    }
  }

  importConquistador(name, obj) {
    if (obj.faction == null)            { obj.faction = ""; }
    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.power == null)		{ obj.power = 0; }
    if (!this.conquistadors[name]) {
      this.addEvents(obj);
      this.conquistadors[name] = obj;
    }
  }

  importExplorer(name, obj) {
    if (obj.faction == null)            { obj.faction = ""; }
    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.power == null)		{ obj.power = 0; }
    if (!this.explorers[name]) {
      this.addEvents(obj);
      this.explorers[name] = obj;
    }
  }

  returnConquistadorName(key) {
    if (this.conquistadors[key]) { return this.conquistadors[key].name; }
    return "Conquerer";
  }
  returnExplorerName(key) {
    if (this.explorers[key]) { return this.explorers[key].name; }
    return "Explorer";
  }

  returnAvailableExplorers(faction="") {
    let unavailable = [];
    let available = [];
    for (let z = 0; z < this.game.state.explorations.length; z++) {
      let exp = this.game.state.explorations[z];
      if (exp.faction == faction) {
	if (exp.explorer_lost == 1) {
	  unavailable.push(exp.explorer);
        }
      }
    }
    for (let key in this.explorers) {
      if (this.explorers[key].faction == faction) {
        if (!unavailable.includes(key)) {
	  available.push(key);
        }
      }
    }
    return available;
  }

  returnAvailableConquistadors(faction="") {
    let unavailable = [];
    let available = [];
    for (let z = 0; z < this.game.state.conquests.length; z++) {
      let exp = this.game.state.conquests[z];
      if (exp.faction == faction) {
	if (exp.conquistador_lost == 1) {
	  unavailable.push(exp.conquistador);
        }
      }
    }
    for (let key in this.conquistadors) {
      if (this.conquistadors[key].faction == faction) {
        if (!unavailable.includes(key)) {
	  available.push(key);
        }
      }
    }
    return available;
  }

  removeArmyLeader(faction, space, leader) {

    if (!this.army[leader]) {
      console.log("ARMY LEADER: " + leader + " not found");
      return;
    }

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (space.units[faction][i].type === leader) {
	space.units[faction].splice(i, 1);
      }
    }

  }


  addArmyLeader(faction, space, leader) {
    if (!this.army[leader]) {
      console.log("ARMY LEADER: " + leader + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.army[leader]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
  }


  addNavyLeader(faction, space, leader) {
    if (!this.navy[leader]) {
      console.log("NAVY LEADER: " + leader + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    space.units[faction].push(this.navy[leader]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
  }


  removeReformer(faction, space, reformer) {
    if (!this.reformers[reformer]) {
      console.log("REFORMER: " + reformer + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (space.units[faction][i].type === reformer) {
	space.units[faction].splice(i, 1);
      }
    }
  }

  addReformer(faction, space, reformer) {
    if (!this.reformers[reformer]) {
      console.log("REFORMER: " + reformer + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.reformers[reformer]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
  }

  removeDebater(faction, debater) {
    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type == debater) { 
	this.game.state.debaters.splice(i, 1);
      }
    }
  }

  disgraceDebater(debater) { return this.burnDebater(debater, 1); }
  burnDebater(debater, disgraced = 0) {

    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }

    //
    // remove the debater
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type == debater) { 

	if (this.game.state.debaters[i].owner == "papacy") {
	  this.updateLog("Protestants gain " + this.game.state.debaters[i].power + " VP");
	  this.updateLog(this.popup(debater) + " disgraced");
	} else {
	  this.updateLog("Papacy gains " + this.game.state.debaters[i].power + " VP");
	  this.updateLog(this.popup(debater) + " burned");
	}

	this.game.state.debaters.splice(i, 1);
        this.game.state.burned.push(debater);

        let x = debater.split("-");

	//
	// also remove reformer (if exists)
	//
	try {
	  let reformer = x[0] + "-reformer";
          let s = this.returnSpaceOfPersonage(this.debaters[debater].faction, reformer);
	  if (s) { this.removeReformer(this.debaters[debater].faction, reformer); }
	  // re-display space
	  this.displaySpace(s);
	} catch (err) {
	  // reformer does not exist
	}
      }
    }

    //
    //
    //
    this.displayVictoryTrack();

  }

  addDebater(faction, debater) {

    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type === debater) {
	console.log("DEBATER: " + debater + " already added");
	return;
      }
    }

    this.game.state.debaters.push(this.debaters[debater]);
    this.game.state.debaters[this.game.state.debaters.length-1].owner = faction; 
    this.game.state.debaters[this.game.state.debaters.length-1].committed = 0; 

  }

  removeConquistador(faction, conquistador) {
    for (let i = 0; i < this.game.state.conquistadors.length; i++) {
      if (this.game.state.conquistadors[i].type === conquistador) {
	this.game.state.conquistadors.splice(i, 1);
	return;
      }
    }
  }

  removeExplorer(faction, explorer) {
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].type === explorer) {
	this.game.state.explorers.splice(i, 1);
	return;
      }
    }
  }

  addExplorer(faction, explorer) {

    if (!this.explorers[explorer]) {
      console.log("EXPLORER: " + explorer + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].type === explorer) {
	console.log("EXPLORER: " + explorer + " already added");
	return;
      }
    }

    this.game.state.explorers.push(this.explorers[explorer]);
  }

  addConquistador(faction, conquistador) {

    if (!this.conquistadors[conquistador]) {
      console.log("CONQUISTADOR: " + conquistador + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.conquistador.length; i++) {
      if (this.game.state.conquistador[i].type === conquistador) {
	return;
      }
    }

    this.game.state.conquistador.push(this.conquistadors[conquistador]);

  }

  isActive(debater) { return this.isDebaterActive(debater); }
  isDebaterActive(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].active == 1) { return 1; }
      }
    }
    return 0;
  }

  isDebaterDisgraced(debater) { return this.isBurned(debater); }
  isDisgraced(debater) { return this.isBurned(debater); }
  isDebaterBurned(debater) { return this.isBurned(debater); }
  isBurned(debater) { if (this.game.state.burned.includes(debater)) { return true; } return false; }
  isCommitted(debater) { return this.isDebaterCommitted(debater); }
  isDebaterCommitted(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].committed == 1) { return 1; }
      }
    }
    // sometimes debaters will be excommunicated without being committed
    for (let i = 0; i < this.game.state.excommunicated.length; i++) {
      if (this.game.state.excommunicated[i].debater) {
	if (this.game.state.excommunicated[i].debater.type == debater) {
	  if (this.game.state.debaters[i].committed == 1) { return 1; }
        }
      }
    }
    return 0;
  }

  isDebaterAvailable(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].committed == 0) { return 1; }
      }
    }
    return 0;
  }

  deactivateDebater(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {
        this.game.state.debaters[i].active = 0;
      }
    }
  }
  deactivateDebaters() {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      this.game.state.debaters[i].active = 0;
    }
  }

  commitDebater(faction, debater, activate=1) {

    let his_self = this;

    //
    // we can only commit 1 debater for the bonus each impulse, so note it if so
    //
    if (activate == 1) {
      this.game.state.debater_committed_this_impulse[faction] = 1;
    }

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	this.game.state.debaters[i].committed = 1;
	this.game.state.debaters[i].active = activate; // if the bonus is active
	this.debaters[debater].onCommitted(his_self, this.game.state.debaters[i].owner);
      }
    }
  }

  commitExplorer(faction, explorer) {
    let his_self = this;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].key == explorer) {
	this.game.state.explorer[i].committed = 1;
	this.explorers[explorer].onCommitted(his_self, this.game.state.explorers[i].owner);
      }
    }
  }

  commitConquistador(faction, explorer) {
    let his_self = this;
    for (let i = 0; i < this.game.state.conquistadors.length; i++) {
      if (this.game.state.conquistadors[i].key == explorer) {
	this.game.state.conquistadors[i].committed = 1;
	this.conquistadors[conquistador].onCommitted(his_self, this.game.state.conquistadors[i].owner);
      }
    }
  }

  //
  // each faction has a limited number of physical tokens to use to 
  // represent units that are available. the game will auto-reallocate
  // these tokens to teh extent possible.
  // 
  updateOnBoardUnits() { this.game.state.board_updated = 0; } // setting to 0 forces update next displaySpace
  returnOnBoardUnits(faction="") {

    let my_spaces = {};
    let available_units = {};
        available_units['regular'] = {};
        available_units['squadron'] = {};
        available_units['cavalry'] = {};
        available_units['corsair'] = {};
    let deployed_units = {};

    //
    // each faction has a separate token mix
    //
    if (faction == "protestant") {
      available_units['regular']['1'] = 8;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;    
    }
    if (faction == "england") {
      available_units['regular']['1'] = 9;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 5;    
    }
    if (faction == "ottoman") {
      available_units['regular']['1'] = 11;    
      available_units['regular']['2'] = 7;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 4;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 9;
    }
    if (faction == "france") {
      available_units['regular']['1'] = 10;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 3;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 5;    
    }
    if (faction == "papacy") {
      available_units['regular']['1'] = 7;    
      available_units['regular']['2'] = 4;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 2;
    }
    if (faction == "hapsburg") {
      available_units['regular']['1'] = 12;    
      available_units['regular']['2'] = 6;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 3;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 6;    
    }

    if (faction == "scotland") {
      available_units['regular']['1'] = 2;    
      available_units['regular']['2'] = 1;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 1;
    }
    if (faction == "genoa") {
      available_units['regular']['1'] = 2;    
      available_units['regular']['2'] = 2;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 1;    
    }
    if (faction == "venice") {
      available_units['regular']['1'] = 4;    
      available_units['regular']['2'] = 4;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;
      available_units['squadron']['1'] = 4;    
    }
    if (faction == "hungary") {
      available_units['regular']['1'] = 3;    
      available_units['regular']['2'] = 3;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 1;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;
    }
    if (faction == "independent") {
      available_units['regular']['1'] = 3;    
      available_units['regular']['2'] = 3;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;
    }

    //
    // find out what units I supposedly have deployed
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units) {
        if (this.game.spaces[key].units[faction].length > 0) {
          for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
      	    if (!my_spaces[key]) { my_spaces[key] = {}; }
	    let u = this.game.spaces[key].units[faction][i];
	    if (u.type == "squadron" || u.type == "corsair" || u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
              if (!my_spaces[key][u.type]) { my_spaces[key][u.type] = 0; }
              my_spaces[key][this.game.spaces[key].units[faction][i].type]++;
	    }
          }
        }
      }
    }
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units) {
        if (this.game.navalspaces[key].units[faction].length > 0) {
          for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
      	    if (!my_spaces[key]) { my_spaces[key] = {}; }
	    let u = this.game.navalspaces[key].units[faction][i];
	    if (u.type == "squadron" || u.type == "corsair") {
              if (!my_spaces[key][u.type]) { my_spaces[key][u.type] = 0; }
              my_spaces[key][u.type]++;
            }
          }
        }
      }
    }

    //
    //
    //
    for (let key in my_spaces) {
      deployed_units[key] = {};
      deployed_units[key]['regular'] = {};
      deployed_units[key]['regular']['1'] = 0;
      deployed_units[key]['regular']['2'] = 0;
      deployed_units[key]['regular']['3'] = 0;
      deployed_units[key]['regular']['4'] = 0;
      deployed_units[key]['regular']['5'] = 0;
      deployed_units[key]['regular']['6'] = 0;
      deployed_units[key]['mercenary'] = {};
      deployed_units[key]['mercenary']['1'] = 0;
      deployed_units[key]['mercenary']['2'] = 0;
      deployed_units[key]['mercenary']['3'] = 0;
      deployed_units[key]['mercenary']['4'] = 0;
      deployed_units[key]['mercenary']['5'] = 0;
      deployed_units[key]['mercenary']['6'] = 0;
      deployed_units[key]['cavalry'] = {};
      deployed_units[key]['cavalry']['1'] = 0;
      deployed_units[key]['cavalry']['2'] = 0;
      deployed_units[key]['cavalry']['3'] = 0;
      deployed_units[key]['cavalry']['4'] = 0;
      deployed_units[key]['cavalry']['5'] = 0;
      deployed_units[key]['cavalry']['6'] = 0;
      deployed_units[key]['squadron'] = {};
      deployed_units[key]['squadron']['1'] = 0;
      deployed_units[key]['corsair'] = {};
      deployed_units[key]['corsair']['1'] = 0;
    }


    //
    // order spaces 
    //
    let continue_to_apportion = true;
    while (continue_to_apportion == true) {

      continue_to_apportion = false;
      let changed_anything = false;

      for (let key in my_spaces) {

	if (my_spaces[key]['regular'] >= 6 && available_units['regular']['6'] > 0) { 
	  my_spaces[key]['regular'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['regular']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 6 && available_units['regular']['6'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['mercenary']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 6 && available_units['cavalry']['6'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['cavalry']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !5

	if (my_spaces[key]['regular'] >= 4 && available_units['regular']['4'] > 0) { 
	  my_spaces[key]['regular'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['regular']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 4 && available_units['regular']['4'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['mercenary']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 4 && available_units['regular']['4'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['cavalry']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !3

	if (my_spaces[key]['regular'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['regular'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['regular']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['mercenary']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['cavalry']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !1

	if (my_spaces[key]['regular'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['regular'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['regular']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['mercenary']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['cavalry']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	if (my_spaces[key]['squadron'] >= 1 && available_units['squadron']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['squadron'] -= 1;
	  available_units['squadron']['1']--;
	  deployed_units[key]['squadron']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['corsair'] >= 1 && available_units['squadron']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['corsair'] -= 1;
	  available_units['squadron']['1']--;
	  deployed_units[key]['corsair']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

      }

      if (changed_anything == true) {
        continue_to_apportion = true;
      }

    }

    let results = {};
    results.deployed = deployed_units;
    results.available = available_units;
    results.missing = {};
    for (let key in this.game.spaces) {
      results.missing[key] = {};
      results.missing[key]['regular'] = {}
      results.missing[key]['regular']['1'] = 0;
      results.missing[key]['regular']['2'] = 0;
      results.missing[key]['regular']['3'] = 0;
      results.missing[key]['regular']['4'] = 0;
      results.missing[key]['regular']['5'] = 0;
      results.missing[key]['regular']['6'] = 0;
      results.missing[key]['mercenary'] = {};
      results.missing[key]['mercenary']['1'] = 0;
      results.missing[key]['mercenary']['2'] = 0;
      results.missing[key]['mercenary']['3'] = 0;
      results.missing[key]['mercenary']['4'] = 0;
      results.missing[key]['mercenary']['5'] = 0;
      results.missing[key]['mercenary']['6'] = 0;
      results.missing[key]['cavalry'] = {};
      results.missing[key]['cavalry']['1'] = 0;
      results.missing[key]['cavalry']['2'] = 0;
      results.missing[key]['cavalry']['3'] = 0;
      results.missing[key]['cavalry']['4'] = 0;
      results.missing[key]['cavalry']['5'] = 0;
      results.missing[key]['cavalry']['6'] = 0;
      results.missing[key]['squadron'] = {};
      results.missing[key]['squadron']['1'] = 0;
    }

    //
    // pieces we are having difficulty assigning
    //
    for (let key in my_spaces) {
      if (my_spaces[key]['regular'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['regular'] = my_spaces[key]['regular'];
	results.overcapacity = 1;
      }	
      if (my_spaces[key]['mercenary'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['mercenary'] = my_spaces[key]['mercenary'];
	results.overcapacity = 1;
      }	
      if (my_spaces[key]['cavalry'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['cavalry'] = my_spaces[key]['cavalry'];
	results.overcapacity = 1;
      }	
    }

    this.game.state.board_updated = new Date().getTime();

    return results;

  }


  returnNumberOfUnitsAvailableForConstruction(faction, unittype) {

    //
    // TODO -- implement limits on squadron and corsair construction
    //
    if (unittype === "corsair") { unittype = "squadron"; }
    if (unittype === "cavalry" && faction == "ottoman") { unittype = "regular"; }
    if (unittype === "mercenary") { unittype = "regular"; }

    let res = this.returnOnBoardUnits(faction);

    let amount_over_capacity = 0;
    for (let key in res.missing) {
      if ((unittype == "regular" && res.missing[key]['regular'] > 0) || (unittype == "mercenary" && res.missing[key]['mercenary'] > 0) || (unittype == "regular" && res.missing[key]['cavalry'] > 0)) {
        return 0;
      }
    }

    let x = 0;

    if (res.available[unittype]['1'] > 0) { x += (1 * res.available[unittype]['1']); }
    if (res.available[unittype]['2'] > 0) { x += (2 * res.available[unittype]['2']); }
    if (res.available[unittype]['3'] > 0) { x += (3 * res.available[unittype]['3']); }
    if (res.available[unittype]['4'] > 0) { x += (4 * res.available[unittype]['4']); }
    if (res.available[unittype]['5'] > 0) { x += (5 * res.available[unittype]['5']); }
    if (res.available[unittype]['6'] > 0) { x += (6 * res.available[unittype]['6']); }

    return x;

  }





//
// NEW WORLD
//
// When factions explore or send a conquest or found a colony an extry is added into one
// of these three main arrays with the data structure that follows:
//
// 	this.game.state.colonies 
// 	this.game.state.explorations		
// 	this.game.state.conquests		
//
//    		{
//            		faction : faction,
//            		resolved :  0 ,
//            		round :   this.game.state.round,
//    		}
//
// at the end of the turn, we have three functions -- resolveColonies(), resolveConquests(), 
// and resolveExplorations() that loop through all of the "unresolved" items in these lists
// and roll the dice to figure out who has founded what. If user-intervention is required
// to pick a bonus, users will be invited to do so. data is added to these data structures
//
//
//
//

  returnNextColonyTile(faction="") {
    if (faction == "england") {
      if (this.game.state.newworld['england_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/Roanoke.svg";
      } else {
	return "/his/img/tiles/colonies/Jamestown.svg";
      }
    }

    if (faction == "france") {
      if (this.game.state.newworld['france_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/Charlesbourg.svg";
      } else {
	return "/his/img/tiles/colonies/Montreal.svg";
      }
    }

    if (faction == "hapsburg") {
      if (this.game.state.newworld['hapsburg_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/PuertoRico.svg";
      } else {
	if (this.game.state.newworld['hapsburg_colony1'].claimed != 1) {
          return "/his/img/tiles/colonies/Cuba.svg";
	} else {
          return "/his/img/tiles/colonies/Hispanola.svg";
	}
      }
    }

    return "/his/img/tiles/colonies/PuertoRico.svg";

  }

  resolveColonies() {

    for (let z = 0; z < this.game.state.colonies.length; z++) {
      if (this.game.state.colonies[z].resolved != 1) {

	this.game.state.colonies[z].resolved = 1;

        if (this.game.state.colonies[z].faction === "england") {
	  if (this.game.state.newworld['england_colony1'].claimed != 1) {
	    this.game.state.newworld['england_colony1'].claimed = 1;
	    this.game.state.colonies[z].colony = "england_colony1";
	    this.game.state.colonies[z].name = "Roanoke";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Roanoke.svg";
          } else {
	    this.game.state.newworld['england_colony2'].claimed = 1;
	    this.game.state.colonies[z].colony = "england_colony2";
	    this.game.state.colonies[z].name = "Jamestown";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Jamestown.svg";
	  }
        }

        if (this.game.state.colonies[z].faction === "france") {
	  if (this.game.state.newworld['france_colony1'].claimed != 1) {
	    this.game.state.newworld['france_colony1'].claimed = 1;
	    this.game.state.colonies[z].colony = "france_colony1";
	    this.game.state.colonies[z].name = "Charlesbourg";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Charlesbourg.svg";
          } else {
	    this.game.state.newworld['france_colony2'].claimed = 1;
	    this.game.state.colonies[z].colony = "france_colony2";
	    this.game.state.colonies[z].name = "Montreal";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Montreal.svg";
	  }
        }

        if (this.game.state.colonies[z].faction === "hapsburg") {
	  if (this.game.state.newworld['hapsburg_colony1'].claimed != 1) {
	      this.game.state.newworld['hapsburg_colony1'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony1";
	      this.game.state.colonies[z].name = "Puerto Rico";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/PuertoRico.svg";
          } else {
	    if (this.game.state.newworld['hapsburg_colony2'].claimed != 1) {
	      this.game.state.newworld['hapsburg_colony2'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony2";
	      this.game.state.colonies[z].name = "Cuba";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/Cuba.svg";
	    } else {
	      this.game.state.newworld['hapsburg_colony3'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony3";
	      this.game.state.colonies[z].name = "Hispanola";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/Hispanola.svg";
	    }
	  }
        }
      }
    }

    //
    // resolve potosi mines if outstanding
    //
    if (this.game.state.events.potosi_silver_mines != "") {

      let have_we_added_potosi_mines = false;
      let have_we_added_potosi_mines_idx = 0;

      for (let z = 0; z < this.game.state.colonies.length; z++) {
	if (this.game.state.colonies[z].img == "/his/img/tiles/colonies/Potosi.svg") {
	  have_we_added_potosi_mines = true;
	  have_we_added_potosi_mines_idx = z;
	}
      }

      if (!have_we_added_potosi_mines) {

	let pbox = "england_colony2";
	if (this.game.state.events.potosi_silver_mines == "france") { pbox = "france_colony2"; }
	if (this.game.state.events.potosi_silver_mines == "hapsburg") { pbox = "hapsburg_colony3"; }

	this.game.state.colonies.push({
	  faction : this.game.state.events.potosi_silver_mines ,
	  resolved : 1 ,
	  round : this.game.state.round ,
	  img : "/his/img/tiles/colonies/Potosi.svg" ,
	  name : "Potosi Silver Mines" ,
	  colony : pbox ,	  
	});

	this.game.state.newworld[pbox].claimed = 1;

      }

    }


    this.displayNewWorld();
    return 1;
  }

  resolveConquests() {

    let active_conquests = [];
    let sorted_conquests = [];
    
    for (let z = 0; z < this.game.state.conquests.length; z++) {
      let con = this.game.state.conquests[z];
      if (con.resolved == 0) {

        let available_conquistadors = this.returnAvailableConquistadors(con.faction);
	if (available_conquistadors.length > 0) {

	  //
	  // find explorer
	  //
	  let x = this.rollDice(available_conquistadors.length) - 1;
	  let conquistador = available_conquistadors[x];
	  con.conquistador = conquistador;

	  //
	  // calculate hits
	  //
	  let yy = this.rollDice(6);
	  let zz = this.rollDice(6);

	  let total_hits = yy + zz;

          let base_hits = total_hits;
	  let modifiers = 0;

	  //
	  // conquistador power
	  //
	  total_hits += this.conquistadors[conquistador].power;
	  modifiers += this.conquistadors[conquistador].power;

	  //
	  // smallpox
	  //
	  if (this.game.state.events.smallpox === con.faction) {
	    total_hits += 2;
	    modifiers += 2;
	    this.game.state.events.smallpox = 0;
	  }

	  con.base_roll = base_hits;
	  con.modifiers = modifiers;
	  con.modified_roll = total_hits;
	  con.hits = total_hits;
	  con.conquistador = conquistador;
	  con.img = this.conquistadors[conquistador].img;

	  active_conquests.push(z);

	}
      }
    }

    //
    // now determine sorted_explorations (order of resolution)
    //
    let hapsburg_done = 0;
    let england_done = 0;
    let france_done = 0;
    for (let i = 0; i < 3; i++) {
      target_faction = "hapsburg";
      if (i == 1) { target_faction = "england"; }
      if (i == 2) { target_faction = "france"; }
      for (let k = 0; k < active_conquests.length; k++) {
 	if (this.game.state.conquests[active_conquests[k]].faction === target_faction) { 
	  sorted_conquests.push(active_conquests[k]);
	}
      }
    }

    //
    // now resolve in order
    //
    for (let z = sorted_conquests.length-1; z >= 0; z--) {
      this.game.queue.push("resolve_conquest\t"+sorted_conquests[z]);
    }

    return 1;

  }

  resolveExplorations() {

    let active_explorations = [];
    let sorted_explorations = [];

    let cabot_england_found = 0;
    let cabot_france_found = 0;
    let cabot_hapsburg_found = 0;

    for (let z = 0; z < this.game.state.explorations.length; z++) {
      let exp = this.game.state.explorations[z];

      if (exp.cabot == 1) { 
	if (exp.faction == "england") { cabot_england_found = 1; }
	if (exp.faction == "france") { cabot_france_found = 1; }
	if (exp.faction == "hapsburg") { cabot_hapsburg_found = 1; }
      }

      if (exp.resolved == 0) {

        let available_explorers = this.returnAvailableExplorers(exp.faction);
	if (available_explorers.length > 0) {

	  //
	  // find explorer
	  //
	  let x = this.rollDice(available_explorers.length) - 1;
	  let explorer = available_explorers[x];

	  exp.explorer = explorer;

	  //
	  // calculate hits
	  //
	  let yy = this.rollDice(6);
	  let zz = this.rollDice(6);

	  let total_hits = yy + zz;
	  let base_hits = total_hits;
	  let modifiers = 0;

	  //
	  // modifications
	  //
	  if (this.game.state[`${exp.faction}_uncharted`]) {
	    total_hits--;
	    this.game.state[`${exp.faction}_uncharted`] = 0;
	  }

	  //
	  // explorer power
	  //
	  total_hits += this.explorers[explorer].power;
	  modifiers += this.explorers[explorer].power;

	  //
	  // mercators map
	  //
	  if (this.game.state.events.mercators_map === exp.faction) {
	    total_hits += 2;
	    modifiers += 2;
	    this.game.state.events.mercators_map = 0;
	  }
	  

	  if (!this.game.state[`${exp.faction}_uncharted`]) { total_hits++; }
	
	  exp.base_roll = base_hits;
	  exp.modified_roll = total_hits;
	  exp.explorer = explorer;
	  exp.prize = "-";
	  exp.hits = total_hits;
	  exp.modifiers = modifiers;
          exp.explorer = explorer;
          exp.explorer_img = this.explorers[explorer].img;
          exp.cabot = 0;

	  active_explorations.push(z);
 
	}
      }
    }

    //
    // sebastian cabot is a special case
    //
    if ((this.game.state.events.cabot_england == 1 && cabot_england_found == 0) || (this.game.state.events.cabot_france == 1 && cabot_france_found == 0) || (this.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0)) {

      //
      // which faction has
      //
      let f = "england";
      if (this.game.state.events.cabot_france == 1 && cabot_france_found == 0) { f = "france"; }
      if (this.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0) { f = "hapsburg"; }

      this.game.state.explorations.push({
	faction : f ,
	round : this.game.state.round ,
	resolved : 0 ,
      });
      let idx = this.game.state.explorations.length - 1;
      let exp = this.game.state.explorations[idx];

      let yy = this.rollDice(6);
      let zz = this.rollDice(6);

      let total_hits = yy + zz;
      let base_hits = total_hits;
      let modifiers = 1;
      total_hits += modifiers;

      exp.base_roll = base_hits;
      exp.modified_roll = total_hits;
      exp.prize = "-";
      exp.hits = total_hits;
      exp.modifiers = modifiers;
      exp.cabot = 1;
      exp.explorer = "Cabot";
      exp.explorer_img = "/his/img/tiles/explorers/Cabot_English.svg";
      if (f == "france") { exp.explorer_img = "/his/img/tiles/explorers/Cabot_French.svg"; }
      if (f == "hapsburg") { exp.explorer_img = "/his/img/tiles/explorers/Cabot_Hapsburg.svg"; }

      active_explorations.push(idx);

    }



    //
    // now determine sorted_explorations (order of resolution)
    //
    for (let z = 5; z >= -1; z--) {
      let idx = 0;
      let highest = -5;
      let highest_faction = "";

      //
      // sort resolution
      //
      while (active_explorations.length > sorted_explorations.length) {
        for (let k = 0; k < active_explorations.length; k++) {
  	  let exp = this.game.state.explorations[active_explorations[k]];
	  if (exp.sorted != 1) {
	    let explorer = exp.explorer;
	    let f = this.explorers[explorer].faction;
	    let p = this.explorers[explorer].power;
	    if (p == highest) {
	      if (f == "england") { highest = -5; } // force next IF to execute
    	      if (f == "france" && highest_faction == "hapsburg") { highest = -5; } //force next-IF to execute
	    }
	    if (p > highest) {
	      idx = k;
	      highest = p;
	      highest_faction = f;
	    }
          }
	  exp.sorted = 1;
	  sorted_explorations.push(active_explorations[k]);
        };
      }
    }

    //
    // now resolve in order
    //
    for (let z = sorted_explorations.length-1; z >= 0; z--) {
      this.game.queue.push("resolve_exploration\t"+sorted_explorations[z]);
    }

    return 1;

  }



  displayCustomOverlay(c="", msg="") {

    if (c === "protestants") {
      this.welcome_overlay.renderCustom({
        title : "New to the Protestants?" , 
        text : "Why not play cards for OPS and publish treatises in Germany? " ,
        card : this.returnCardImage("065") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "excommunication") {
      this.welcome_overlay.renderCustom({
        title : "Excommunicated!" , 
        text : this.returnFactionName(msg) + " has been excommunicated by Papal Decree" ,
        card : this.returnCardImage("005") ,
        img : '/his/img/backgrounds/events/excommunication.jpg',
      });
      return;
    }
    if (c === "protestant") {
      this.welcome_overlay.renderCustom({
        title : "New to the Protestants?" , 
        text : "Use OPS to publish treatises and convert more spaces to Protestantism" ,
        card : this.returnCardImage("007") ,
        img : '/his/img/backgrounds/move/printing_press.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "papacy") {
      this.welcome_overlay.renderCustom({
        title : "New to the Papacy?" , 
        text : "Why not use your OPS to control Siena and move an invasion force to Florence?" ,
        card : this.returnCardImage("067") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "ottoman") {
      this.welcome_overlay.renderCustom({
        title : "New to the Ottomans?" , 
        text : "Why not use your OPS to invade Hungary and expand your empire?" ,
        card : this.returnCardImage("042") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "england") {
      this.welcome_overlay.renderCustom({
        title : "New to England?" , 
        text : "Why not use your Home Card to declare war on Scotland or France?" ,
        card : this.returnCardImage("003") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "france") {
      this.welcome_overlay.renderCustom({
        title : "New to France?" , 
        text : "Establishing Colonies and building Chateaux is crucial early-game! " ,
        card : this.returnCardImage("004") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "hapsburg") {
      this.welcome_overlay.renderCustom({
        title : "New to the Hapsburgs?" , 
        text : "Are there any independent keys you can conquer this turn? ",
        card : this.returnCardImage("002") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "lost-at-sea") {
      this.welcome_overlay.renderCustom({
        title : "New World Losses" ,
        text : msg + " exploration is lost at sea..." ,
        img : '/his/img/backgrounds/newworld/lost_at_sea.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} mission is lost at sea`);
      return;
    }

    if (c === "killed") {
      this.welcome_overlay.renderCustom({
        title : "New World Losses" ,
        text : msg + " expedition killed by natives" ,
        img : '/his/img/backgrounds/newworld/killed.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} expedition killed by natives`);
      return;
    }

    if (c === "stlawrence") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg + " discovers the St. Lawrence River" ,
        img : '/his/img/backgrounds/newworld/st_lawrence.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} discovers St. Lawrence River`);
      return;
    }

    if (c === "mississippi") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg + " discovers the Mississippi River" ,
        img : '/his/img/backgrounds/newworld/mississippi.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} discovers the Mississippi River`);
      return;
    }

    if (c === "greatlakes") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg + " discovers the Great Lakes" ,
        img : '/his/img/backgrounds/newworld/greatlakes.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} discovers the Great Lakes`);
      return;
    }

    if (c === "amazon") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg + " discovers the Amazon River" ,
        img : '/his/img/backgrounds/newworld/amazon3.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} discovers the Amazon River`);
      return;
    }

    if (c === "pacificstrait") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg + " discovers the Pacific Strait" ,
        img : '/his/img/backgrounds/newworld/pacificstrait.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} discovers the Pacific Strait`);
      return;
    }

    if (c === "circumnavigation") {
      this.welcome_overlay.renderCustom({
        title : "New World Achievement" ,
        text : msg + " circumnavigates the globe" ,
        img : '/his/img/backgrounds/newworld/circumnavigation.jpg',
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} circumnavigates the globe`);
      return;
    }

    if (c === "aztec") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg + " conquers the Aztec" ,
        img : '/his/img/backgrounds/newworld/aztec.jpg',
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} conquers the Aztec`);
      return;
    }

    if (c === "maya") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg + " conquers the Maya" ,
        img : '/his/img/backgrounds/newworld/inca.jpg',
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} conquers the Maya`);
      return;
    }

    if (c === "inca") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg + " conquers the Inca" ,
        img : '/his/img/backgrounds/newworld/inca2.jpg',
      });
      this.game.queue.push(`ACKNOWLEDGE\t${msg} conquers the Inca`);
      return;
    }

    if (c === "battle-of-mohacs") {
      this.welcome_overlay.renderCustom({
        title : "War between the Hapsburg and Ottoman Empires" ,
        text : "The Ottoman subjugation of Hungary-Bohemia forces the Hapsburg Empire to intervene on the side of Christian Europe and in pre-emptive defense of Vienna" ,
        img : '/his/img/backgrounds/battle-of-mohacs.jpeg',
      });
      this.game.queue.push(`ACKNOWLEDGE\tThe Defeat of Hungary: the Hapsburg and Ottoman Empires are now At War`);
      return;
    }

    if (c === "colonize") {
      this.welcome_overlay.renderCustom({
        title : this.returnFactionName(msg) + " founds a Colony",
        text : "Colonies earn factions bonus cards in the New World Phase",
        img : '/his/img/backgrounds/move/colonize.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${this.returnFactionName(msg)} attempts to found a Colony`);
      return;
    }

    if (c === "conquest") {
      this.welcome_overlay.renderCustom({
        title : this.returnFactionName(msg) + " launches Conquest Expedition",
        text : "Conquests earn factions Victory Points and bonus cards in the New World Phase",
        img : '/his/img/backgrounds/newworld/inca2.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${this.returnFactionName(msg)} attempts Conquest Expedition`);
      return;
    }

    if (c === "explore") {
      this.welcome_overlay.renderCustom({
        title : this.returnFactionName(msg) + " launches Exploration",
        text : "Explorations earn Victory Points for strategic discoveries in the New World Phase",
        img : '/his/img/backgrounds/move/explore.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      this.game.queue.push(`ACKNOWLEDGE\t${this.returnFactionName(msg)} launches New World Exploration`);
      return;
    }

    let deck = this.returnDeck(true); // include removed
    if (deck[c]) {
      if (deck[c].returnCustomOverlay) {

        let obj = deck[c].returnCustomOverlay();    
        let title = obj.title;
        let text = obj.text;
        let img = obj.img;
        let card = this.returnCardImage(c);

        if (msg == "") {
    	  msg = this.popup(c) + " triggers";
        }
  
        this.welcome_overlay.renderCustom({
          text : text,
          title : title,
          img : img,
          card : card,
        });
        this.game.queue.push(`ACKNOWLEDGE\t${msg}`);

      }
    }

  }

  hideOverlays() {
    this.debate_overlay.hide();
    this.treatise_overlay.hide();
    this.religious_overlay.hide();
    this.faction_overlay.hide();
    this.diet_of_worms_overlay.hide();
    this.council_of_trent_overlay.hide();
    this.theses_overlay.hide();
    this.reformation_overlay.hide();
    this.language_zone_overlay.hide();
    this.debaters_overlay.hide();
    this.schmalkaldic_overlay.hide();
    this.assault_overlay.hide();
    this.field_battle_overlay.hide();
    this.movement_overlay.hide();
    this.welcome_overlay.hide();
    this.deck_overlay.hide();
    this.menu_overlay.hide();
    this.winter_overlay.hide();
    this.units_overlay.hide();
  }

  returnReligionImage(religion) {
    if (religion === "protestant") { return "/his/img/tiles/abstract/protestant.png"; }
    if (religion === "catholic") { return "/his/img/tiles/abstract/catholic.png"; }
    return "/his/img/tiles/abstract/independent.svg";
  }

  returnLanguageImage(language) {

    if (language == "english") { return "/his/img/tiles/abstract/english.png"; }
    if (language == "french") { return "/his/img/tiles/abstract/french.png"; }
    if (language == "spanish") { return "/his/img/tiles/abstract/spanish.png"; }
    if (language == "italian") { return "/his/img/tiles/abstract/italian.png"; }
    if (language == "german") { return "/his/img/tiles/abstract/german.png"; }

    return "/his/img/tiles/abstract/other.png";

  }

  returnControlImage(faction) {

    if (faction == "papacy") { return "/his/img/tiles/abstract/papacy.svg"; }
    if (faction == "protestant") { return "/his/img/tiles/abstract/protestant.svg"; }
    if (faction == "england") { return "/his/img/tiles/abstract/england.svg"; }
    if (faction == "france") { return "/his/img/tiles/abstract/france.svg"; }
    if (faction == "ottoman") { return "/his/img/tiles/abstract/ottoman.svg"; }
    if (faction == "hapsburg") { return "/his/img/tiles/abstract/hapsburg.svg"; }

    return "/his/img/tiles/abstract/independent.svg";   

  }

  displayCardsLeft() {
    try {
    for (let key in this.game.state.cards_left) {

      let qs = ".game-factions .game-menu-sub-options ";
      if (key === "hapsburg") { 
        qs += ".game-hapsburg .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Hapsburgs (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "france") { 
        qs += ".game-france .game-menu-option-label";
	document.querySelector(qs).innerHTML = `France (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "ottoman") { 
        qs += ".game-ottoman .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Ottoman (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "england") { 
        qs += ".game-england .game-menu-option-label";
	document.querySelector(qs).innerHTML = `England (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "protestants" || key == "protestant") { 
        qs += ".game-protestants .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Protestants (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "papacy") { 
        qs += ".game-papacy .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Papacy (${this.game.state.cards_left[key]} cards)`;
      }
    }
    } catch (err) {}
  }

  displayTurnTrack() {
    try {
      let obj = document.querySelector(".turntrack");
      obj.classList.remove(`turntrack1`);
      obj.classList.remove(`turntrack${this.game.state.round-1}`);
      obj.classList.add(`turntrack${this.game.state.round}`);
    } catch (err) {}
  }

  displayDiplomacyTable() { this.displayWarBox(); }
  displayWarBox() {
    try {
    let factions = ["ottoman","hapsburg","england","france","papacy","protestant","genoa","hungary","scotland","venice"];
    for (let i = 0; i < factions.length; i++) {
      for (let ii = 0; ii < factions.length; ii++) {
	if (ii > i) {
	  let obj = null;
	  let box = '#' + factions[i] + "_" + factions[ii];
	  obj = document.querySelector(box);
	  if (obj) {
	    if (this.areAllies(factions[i], factions[ii], 0)) {
	      obj.innerHTML = '<img src="/his/img/Allied.svg" />';
	      obj.style.display = "block";
	    } else {
	      if (this.areEnemies(factions[i], factions[ii], 0)) {
	        obj.innerHTML = '<img src="/his/img/AtWar.svg" />';
	        obj.style.display = "block";
	      } else {
	        obj.style.display = "none";
	      }
	    }
	  }
	}
      }
    }
    } catch (err) {}
  }

  displayDebaters() {
    this.debaters_overlay.render();
  }

  displayPersia() {
    let obj = document.querySelector("#persia");
    obj.style.display = "block";
  }
  hidePersia() {
    let obj = document.querySelector("#persia");
    obj.style.display = "none";
  }
  displayEgypt() {
    let obj = document.querySelector("#egypt");
    obj.style.display = "block";
  }
  hideEgypt() {
    let obj = document.querySelector("#egypt");
    obj.style.display = "none";
  }
  displayIreland() {
    let obj = document.querySelector("#ireland");
    obj.style.display = "block";
  }
  hideIreland() {
    let obj = document.querySelector("#ireland");
    obj.style.display = "none";
  }

  displayExplorers() {

    let html = `<div class="personage_overlay" id="personage_overlay">`;
    let f = ["hapsburg","france","england"];
    for (let i = 0; i < f.length; i++) {
      let x = this.returnAvailableExplorers(f[i]);
      for (let z = 0; z < x.length; z++) {
        html += `	<div class="personage_tile${z}" data-id="${this.explorers[x[z]].type}" style="background-image:url('${this.explorers[x[z]].img}')"></div>`;
      }
    }
    html += `</div>`;

    this.overlay.showOverlay(html);

  }

  displayConquistadors() {

    let html = `<div class="personage_overlay" id="personage_overlay">`;
    let f = ["hapsburg","france","england"];
    for (let i = 0; i < f.length; i++) {
      let x = this.returnAvailableConquistadors(f[i]);
      for (let z = 0; z < x.length; z++) {
        html += `	<div class="personage_tile${z}" data-id="${this.conquistadors[x[z]].type}" style="background-image:url('${this.conquistadors[x[z]].img}')"></div>`;
      }
    }
    html += `</div>`;

    this.overlay.showOverlay(html);

  }

  displayTheologicalDebater(debater, attacker=true) {

    let tile_f = "/his/img/tiles/debaters/" + this.debaters[debater].img;
    let tile_b = tile_f.replace('.svg', '_back.svg');

    if (attacker) {
      $('.attacker_debater').css('background-image', `url('${tile_f}')`);
      $('.attacker_debater').mouseover(function() { 
	$('.attacker_debater').css('background-image', `url('${tile_b}')`);
      }).mouseout(function() {
	$('.attacker_debater').css('background-image', `url('${tile_f}')`);
      });
    } else {
      $('.defender_debater').css('background-image', `url('${tile_f}')`);
      $('.defender_debater').mouseover(function() { 
	$('.defender_debater').css('background-image', `url('${tile_b}')`);
      }).mouseout(function() {
	$('.defender_debater').css('background-image', `url('${tile_f}')`);
      });
    }
  }

  displayTheologicalDebate(res) {
    this.debate_overlay.render(res);
  }


  displayReligiousConflictSheet() {

    let num_protestant_spaces = 0;
    let rcc = this.returnReligiousConflictChart();
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion === "protestant") {
        num_protestant_spaces++;
      }
    }
    if (num_protestant_spaces > 50) { num_protestant_spaces = 50; }
    let cid = "s" + num_protestant_spaces;

    let html = `
      <div class="religious_conflict_sheet" id="religious_conflict_sheet" style="background-image: url('/his/img/reference/religious.jpg')">
	<div class="religious_conflict_sheet_tile" id="religious_conflict_sheet_tile"></div>
	<div class="papal_debaters"></div>
	<div class="lutheran_debaters"></div>
	<div class="calvinist_debaters"></div>
	<div class="anglican_debaters"></div>
	<div class="protestant_debaters"></div>
      </div>
    `;

    this.overlay.showOverlay(html);

    //
    // list all debaters
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      let d = this.game.state.debaters[i];
      let dtile = `<img class="debater_tile" id="${i}" src="/his/img/tiles/debaters/${d.img}" />`;
      if (d.owner === "papacy") {
	this.app.browser.addElementToSelector(dtile, '.papal_debaters');
      }
      if (d.owner === "england") {
	this.app.browser.addElementToSelector(dtile, '.anglican_debaters');
      }
      if (d.owner === "hapsburg") {
	this.app.browser.addElementToSelector(dtile, '.calvinist_debaters');
      }
      if (d.owner === "protestant") {
	this.app.browser.addElementToSelector(dtile, '.protestant_debaters');
      }
    }

    let obj = document.getElementById("religious_conflict_sheet_tile");
    obj.style.top = rcc[cid].top;
    obj.style.left = rcc[cid].left;

  }

  returnProtestantSpacesTrackVictoryPoints() {

    let num_protestant_spaces = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion === "protestant") {
	if (!this.game.spaces[key].unrest) {
          num_protestant_spaces++;
	}
      }
    }
    if (num_protestant_spaces > 50) { num_protestant_spaces = 50; }

    let x = [];
    for (let i = 0; i < 51; i++) { 

      x[i] = {}; x[i].protestant = 0; x[i].papacy = 15;

      if (i >= 4)  { x[i].protestant++; x[i].papacy--; }
      if (i >= 7)  { x[i].protestant++; x[i].papacy--; }
      if (i >= 10) { x[i].protestant++; x[i].papacy--; }
      if (i >= 14) { x[i].protestant++; x[i].papacy--; }
      if (i >= 17) { x[i].protestant++; x[i].papacy--; }
      if (i >= 20) { x[i].protestant++; x[i].papacy--; }
      if (i >= 24) { x[i].protestant++; x[i].papacy--; }
      if (i >= 27) { x[i].protestant++; x[i].papacy--; }
      if (i >= 30) { x[i].protestant++; x[i].papacy--; }
      if (i >= 34) { x[i].protestant++; x[i].papacy--; }
      if (i >= 37) { x[i].protestant++; x[i].papacy--; }
      if (i >= 40) { x[i].protestant++; x[i].papacy--; }
      if (i >= 44) { x[i].protestant++; x[i].papacy--; }
      if (i >= 47) { x[i].protestant++; x[i].papacy--; }
      if (i >= 50) { x[i].protestant+=100; x[i].papacy--; }
    }

    return x[num_protestant_spaces];

  }


  displayFactionSheet(faction) {
    this.faction_overlay.render(faction);
  }

  returnFactionSheetKeys() {
  }

  displayBoard() {

    try {
      if (this.game.state.events.war_in_persia) { this.displayPersia(); }
      if (this.game.state.events.revolt_in_egypt) { this.displayEgypt(); }
      if (this.game.state.events.revolt_in_ireland) { this.displayIreland(); }
    } catch (err) {
      console.log("error displaying foreign wars... " + err);
    }

    try {
      this.displayTurnTrack();
    } catch (err) {
      console.log("error displaying turn track... " + err);
    }
    try {
      this.displayWarBox();
    } catch (err) {
      console.log("error displaying diplomacy box... " + err);
    }
    try {
      this.displayColony();
    } catch (err) {
      console.log("error displaying colonies... " + err);
    }
    try {
      this.displayConquest();
    } catch (err) {
      console.log("error displaying conquest... " + err);
    }
    try {
      this.displayElectorateDisplay();
    } catch (err) {
      console.log("error displaying electorates... " + err);
    }
    try {
      this.displayNewWorld();
    } catch (err) {
      console.log("error displaying new world... " + err);
    }
    try {
      this.displaySpaces();
    } catch (err) {
      console.log("error displaying spaces... " + err);
    }
    try {
      this.displayNavalSpaces();
    } catch (err) {
      console.log("error displaying naval spaces... " + err);
    }
    try {
      this.displayVictoryTrack();
    } catch (err) {
      console.log("error displaying victory track... " + err);
    }
  }

  displayNewWorldBonuses() {
    try {
      //
      // Galleons Colony #1
      //
      if (this.game.state.galleons['french'] == 1) {
	document.querySelector(".france_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      if (this.game.state.galleons['england'] == 1) {
	document.querySelector(".england_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      if (this.game.state.galleons['hapsburg'] == 1) {
	document.querySelector(".hapsburg_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      //
      // Plantations Colony #2
      //
      if (this.game.state.plantations['france'] == 1) {
	document.querySelector(".france_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".france_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "france") {
	document.querySelector(".france_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }

      if (this.game.state.plantations['england'] == 1) {
	document.querySelector(".england_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".england_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "england") {
	document.querySelector(".england_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }

      if (this.game.state.plantations['hapsburg'] == 1) {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "hapsburg") {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }
      //
      // Raiders Colony #3
      //
      if (this.game.state.raiders['protestant'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML = `<img class="army_tile" src="/his/img/Raider_Protestant.svg" />`;
      }
      if (this.game.state.raiders['england'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML += `<img class="army_tile" src="/his/img/Raider_French.svg" />`;
      }
      if (this.game.state.raiders['france'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML += `<img class="army_tile" src="/his/img/Raider_English.svg" />`;
      }
      //
      // Mercator's Map
      //
      if (this.game.state.events.mercators_map != "") {
	if (document.querySelector(".crossing_atlantic").innerHTML.indexOf("Mercator") == -1) {
	  document.querySelector(".crossing_atlantic").innerHTML += `<img class="army_tile" src="/his/img/Mercator.svg" />`;
        }
      }
    } catch (err) {
      console.log("error displaying New World bonuses: " + JSON.stringify(err));
    }
  }


  displayColony() {

    let obj = document.querySelector(".crossing_atlantic");


    for (let i = 0; i < this.game.state.colonies.length; i++) {
      let c = this.game.state.colonies[i];

      if (c.resolved != 1) {
        obj.innerHTML += `<img class="army_tile" src="${this.returnNextColonyTile(c.faction)}" />`;
      }

      if (c.resolved == 1 && c.destroyed != 1) {
        if (c.colony == "england_colony1")  { document.querySelector('.england_colony1').innerHTML  = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "england_colony2")  { document.querySelector('.england_colony2').innerHTML  = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "france_colony1")   { document.querySelector('.france_colony1').innerHTML   = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "france_colony2")   { document.querySelector('.france_colony2').innerHTML   = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "hapsburg_colony1") { document.querySelector('.hapsburg_colony1').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "hapsburg_colony2") { document.querySelector('.hapsburg_colony2').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony == "hapsburg_colony3") { document.querySelector('.hapsburg_colony3').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
      }
    }

  }


  displayConquest() {

    let obj = document.querySelector(".crossing_atlantic");
        obj.innerHTML = "";

    for (let z = 0; z < this.game.state.conquests.length; z++) {

      let con = this.game.state.conquests[z];
      let faction = con.faction;
      let round = con.round;

      //      
      // current round are unresolved      
      //      
      if (round == this.game.state.round) {
        if (faction == "hapsburg") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_Conquest.svg" />`;
        }
        if (faction == "france") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_Conquest.svg" />`;
        }
        if (faction == "england") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_Conquest.svg" />`;
        }
	if (this.game.state.events.smallpox != "") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/Smallpox.svg" />`;
	}
      }
    }

    let ec = [];
    let fc = [];
    let hc = [];

    if (this.game.state.newworld['aztec'].claimed == 1) {
      if (this.game.state.newworld['aztec'].faction == "england") { ec.push("aztec"); }
      if (this.game.state.newworld['aztec'].faction == "france") { fc.push("aztec"); }
      if (this.game.state.newworld['aztec'].faction == "hapsburg") { hc.push("aztec"); }
    }
    if (this.game.state.newworld['inca'].claimed == 1) {
      if (this.game.state.newworld['inca'].faction == "england") { ec.push("inca"); }
      if (this.game.state.newworld['inca'].faction == "france") { fc.push("inca"); }
      if (this.game.state.newworld['inca'].faction == "hapsburg") { hc.push("inca"); }
    }
    if (this.game.state.newworld['maya'].claimed == 1) {
      if (this.game.state.newworld['maya'].faction == "england") { ec.push("maya"); }
      if (this.game.state.newworld['maya'].faction == "france") { fc.push("maya"); }
      if (this.game.state.newworld['maya'].faction == "hapsburg") { hc.push("maya"); }
    }

    for (let z = 0, zz = 1; z < ec.length; z++) {
      let depl = ""; if (this.game.state.newworld[ec[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 2) {
	document.querySelector(`.england_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[ec[z]].img}" />`;
        zz++;
      }
    }
    for (let z = 0, zz = 1; z < fc.length; z++) {
      let depl = ""; if (this.game.state.newworld[fc[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 2) {
	document.querySelector(`.france_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[fc[z]].img}" />`;
        zz++;
      }
    }
    for (let z = 0, zz = 1; z < hc.length; z++) {
      let depl = ""; if (this.game.state.newworld[hc[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 3) {
	document.querySelector(`.hapsburg_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[hc[z]].img}" />`;
        zz++;
      }
    }

    if (this.game.state.newworld['maya'].claimed == 1) {
      let f = this.game.state.newworld['maya'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.maya').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['aztec'].claimed == 1) {
      let f = this.game.state.newworld['aztec'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.aztec').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['inca'].claimed == 1) {
      let f = this.game.state.newworld['inca'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.inca').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }

  }

  displayExploration() {

    let obj = document.querySelector(".crossing_atlantic");

    let cabot_england_found = 0;
    let cabot_france_found = 0;
    let cabot_hapsburg_found = 0;

    for (let z = 0; z < this.game.state.explorations.length; z++) {

      let exp = this.game.state.explorations[z];
      let faction = exp.faction;
      let round = exp.round;

      if (exp.cabot == 1) { if (faction == "england") { cabot_england_found = 1; } }
      if (exp.cabot == 1) { if (faction == "france") { cabot_france_found = 1; } }
      if (exp.cabot == 1) { if (faction == "hapsburg") { cabot_hapsburg_found = 1; } }

      //      
      // current round are unresolved      
      //      
      if (round == this.game.state.round) {
        if (faction == "hapsburg") {
          if (this.game.state.hapsburg_charted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_ExplorationCharted.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_Exploration.svg" />`;
          }
        }
        if (faction == "france") {
          if (this.game.state.france_charted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_ExplorationCharted.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_Exploration.svg" />`;
          }
        }
        if (faction == "england") {
          if (this.game.state.england_charted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_ExplorationCharted.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_Exploration.svg" />`;
          }
        }
      }
    }

    if (this.game.state.newworld['stlawrence'].claimed == 1) {
      let f = this.game.state.newworld['stlawrence'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.stlawrence').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['greatlakes'].claimed == 1) {
      let f = this.game.state.newworld['greatlakes'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.greatlakes').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['mississippi'].claimed == 1) {
      let f = this.game.state.newworld['mississippi'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.mississippi').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['amazon'].claimed == 1) {
      let f = this.game.state.newworld['amazon'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.amazon').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['pacificstrait'].claimed == 1) {
      let f = this.game.state.newworld['pacificstrait'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.pacificstrait').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['circumnavigation'].claimed == 1) {
      let f = this.game.state.newworld['circumnavigation'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.circumnavigation').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }

    if (cabot_england_found == 0 && this.game.state.events.cabot_england == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_English.svg" />`;
    }
    if (cabot_france_found == 0 && this.game.state.events.cabot_france == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_French.svg" />`;
    }
    if (cabot_hapsburg_found == 0 && this.game.state.events.cabot_hapsburg == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_Hapsburg.svg" />`;
    }

  }

  returnExplorationTile(f="") {
    if (f == "hapsburg") { return "Hapsburg_key.svg"; }
    if (f == "england") { return "England_key.svg"; }
    if (f == "france") { return "France_key.svg"; }
    return "";
  }

  displayNewWorld() {
try {
    this.displayConquest();
    this.displayExploration();
    this.displayColony();
    this.displayNewWorldBonuses();
} catch (err) {}
  }

  displaySpaceDetailedView(name) {
    // function is attached to this.spaces not this.game.spaces
    let html = this.spaces[name].returnView();    
    this.overlay.show(html);
  }

  displayElectorateDisplay() {
    let elecs = this.returnElectorateDisplay();
    for (let key in elecs) {
      let obj = document.getElementById(`ed_${key}`);
      let tile = this.returnSpaceTile(this.game.spaces[key]);
      obj.innerHTML = ` <img class="hextile" src="${tile}" />`;      
      if (this.returnElectoralBonus(key) != 0) {
        obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-${this.returnElectoralBonus(key)}.svg" />`;
      }
    }
  }


  // returns 1 if the bonus for controlling is still outstanding
  returnElectoralBonus(space) {

    if (space === "augsburg" && this.game.state.augsburg_electoral_bonus == 0) {
      return 2;
    }
    if (space === "mainz" && this.game.state.mainz_electoral_bonus == 0) {
      return 1;
    }
    if (space === "trier" && this.game.state.trier_electoral_bonus == 0) {
      return 1;
    }
    if (space === "cologne" && this.game.state.cologne_electoral_bonus == 0) {
      return 1;
    }
    if (space === "wittenberg" && this.game.state.wittenberg_electoral_bonus == 0) {
      return 2;
    }
    if (space === "brandenburg" && this.game.state.brandenburg_electoral_bonus == 0) {
      return 1;
    }

    return 0;

  }

  returnSpaceTile(space) {

    let owner = space.political;
    if (owner == "") { owner = space.home; }
    let tile = "";
    let stype = "hex";

    if (space.type == "town") { stype = "hex"; }
    if (space.type == "key") { stype = "key"; owner = this.returnControllingPower(owner); }
    if (owner == "protestant") { stype = "hex"; owner = this.returnControllingPower(owner); }

    if (owner != "") {
      if (owner === "hungary") {
        if (owner === "hungary") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "scotland") {
	if (owner === "scotland") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "venice") {
	if (owner === "venice") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "genoa") {
        if (owner === "genoa") {
	  tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }

      if (owner === "hapsburg") {
        tile = "/his/img/tiles/hapsburg/";	  
        if (space.religion === "protestant") {
          tile += `Hapsburg_${stype}_back.svg`;
        } else {
          tile += `Hapsburg_${stype}.svg`;
        }
      }
      if (owner === "england") {
        tile = "/his/img/tiles/england/";	  
        if (space.religion === "protestant") {
          tile += `England_${stype}_back.svg`;
        } else {
          tile += `England_${stype}.svg`;
        }
      }
      if (owner === "france") {
        tile = "/his/img/tiles/france/";	  
        if (space.religion === "protestant") {
          tile += `France_${stype}_back.svg`;
        } else {
          tile += `France_${stype}.svg`;
        }
      }
      if (owner === "papacy") {
        tile = "/his/img/tiles/papacy/";	  
        if (space.religion === "protestant") {
          tile += `Papacy_${stype}_back.svg`;
	} else {
	  tile += `Papacy_${stype}.svg`;
	}
      }
      if (owner === "protestant") {
        tile = "/his/img/tiles/protestant/";	  
        if (space.religion === "protestant") {
          tile += `Protestant_${stype}_back.svg`;
        } else {
          tile += `Protestant_${stype}.svg`;
        }
      }
      if (owner === "ottoman") {
        tile = "/his/img/tiles/ottoman/";	  
        if (space.religion === "protestant") {
          tile += `Ottoman_${stype}_back.svg`;
        } else {
          tile += `Ottoman_${stype}.svg`;
        }
      }
      if (owner === "independent") {
        tile = "/his/img/tiles/independent/";	  
        if (space.religion === "protestant") {
          tile += `Independent_${stype}_back.svg`;
        } else {
          tile += `Independent_${stype}.svg`;
        }
      }
    }

    return tile;

  }

  returnNavalTiles(faction, spacekey) {

      let html = "";
      let tile = "";
      let space = this.game.navalspaces[spacekey];
      if (!space) {
	// might be at a port
        space = this.game.spaces[spacekey];
      }
      let z = faction;
      let squadrons = 0;
      let corsairs = 0;

      for (let zz = 0; zz < space.units[z].length; zz++) {
	if (space.units[z][zz].type === "squadron") {
	  squadrons += 2;
	}
	if (space.units[z][zz].type === "corsair") {
	  corsairs += 1;
	}
      }

      while (squadrons >= 2) {
        if (z === "hapsburg") {
          tile = "/his/img/tiles/hapsburg/";	  
	  if (squadrons >= 2) {
            tile += `Hapsburg_squadron.svg`;
	    squadrons -= 2;
	  }
        }
        if (z === "england") {
          tile = "/his/img/tiles/england/";	  
	  if (squadrons >= 2) {
            tile += `English_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (z === "france") {
          tile = "/his/img/tiles/france/";	  
	  if (squadrons >= 2) {
            tile += `French_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (z === "papacy") {
          tile = "/his/img/tiles/papacy/";	  
	  if (squadrons >= 2) {
            tile += `Papacy_squadron.svg`;
	    squadrons -= 2;
	  }
        }
        if (z === "ottoman") {
          tile = "/his/img/tiles/ottoman/";	  
	  if (squadrons >= 2) {
            tile += `Ottoman_squadron.svg`;
	    squadrons -= 2;
          }
	  if (corsairs >= 1) {
            tile += `Ottoman_corsair.svg`;
	    corsairs -= 1;
          }
        }
        if (z === "venice") {
          tile = "/his/img/tiles/venice/";	  
	  if (squadrons >= 2) {
            tile += `Venice_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (z === "genoa") {
          tile = "/his/img/tiles/genoa/";	  
	  if (squadrons >= 2) {
            tile += `Genoa_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (z === "scotland") {
          tile = "/his/img/tiles/scotland/";	  
	  if (squadrons >= 2) {
            tile += `Scottish_squadron.svg`;
	    squadrons -= 2;
          }
        }

        html += `<img class="navy_tile" src="${tile}" />`;
      }

 
      while (corsairs >= 1) {
        if (z === "ottoman") {
          tile = "/his/img/tiles/ottoman/";	  
	  if (corsairs >= 1) {
            tile += `Ottoman_corsair.svg`;
	    corsairs -= 1;
          }
        }
        html += `<img class="navy_tile" src="${tile}" />`;
      }

    return html;
  }

  returnNavies(space) {

    let html = '<div class="space_navy" id="">';
    let tile = "";

    for (let z in space.units) {
      html += this.returnNavalTiles(z, space.key);
      tile = html;
    }
    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnArmyTiles(faction, spacekey) {
    let z = faction;
    let space = this.game.spaces[spacekey];
    let html = "";

    try {

    if (this.game.state.board[z]) {
      if (this.game.state.board[z].deployed[spacekey]) {
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-1.svg" />`;
	    }
	  }

      }
      //
      // surplus units that should not technically be available according to
      // tile limitations will be in the "missing" section. we do not want
      // pieces appearing and disappearing from the board, so we display them
      // as single-unit tiles.
      //
      if (this.game.state.board[z].missing[spacekey]) {
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-1.svg" />`;
	    }
	  }
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanMerc-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceMerc-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaMerc-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryMerc-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishMerc-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentMerc-1.svg" />`;
	    }
	  }
      }
    }
    //
    // if there is an error
    //
    } catch (err) {
	console.log("ERROR: need to run returnOnBoardUnits: " + JSON.stringify(err));
	this.returnOnBoardUnits();
    }

    return html;
  }

  returnArmies(space) {

    let html = '<div class="space_army" id="">';
    let tile = "";
    let spacekey = space.key;
    let controlling_faction = "";
    if (space.political != "") { controlling_faction = space.political; } else {
      if (space.home != "") { controlling_faction = space.home; }
    }

    for (let z in space.units) {

      //
      // ideally our space is "pre-calculated" and we can display the correct
      // mix of tiles. this should be saved in this.game.state.board["papacy"]
      // etc. see his-units for the returnOnBoardUnits() function that organizes
      // this data object.
      //
      if (this.game.state.board[z]) {
	// mercenary also handles cavalry
        html += this.returnMercenaryTiles(z, spacekey);
        html += this.returnArmyTiles(z, spacekey);
	tile = html;
      } else {

        new_units = false;

	//
	// AUTO - ARMIES
	//
        let army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
  	  if (space.units[z][zz].type === "regular") {
	    new_units = true;
	    army++;
	  }
        }

        while (army >= 1) {
          if (z === "hapsburg") {
            tile = "/his/img/tiles/hapsburg/";	  
	    if (army >= 4) {
              tile += `HapsburgReg-4.svg`;
	      army -= 4;
	    } else {
	      if (army >= 2) {
                tile += `HapsburgReg-2.svg`;
	        army -= 2;
	      } else {
	        if (army >= 1) {
                  tile += `HapsburgReg-1.svg`;
	          army -= 1;
	        }
	      }
            }
	  }
          if (z === "england") {
            tile = "/his/img/tiles/england/";	  
	    if (army >= 4) {
              tile += `EnglandReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `EnglandReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `EnglandReg-1.svg`;
	          army -= 1;
                }
              }
	    }
          }
          if (z === "france") {
            tile = "/his/img/tiles/france/";	  
	    if (army >= 4) {
              tile += `FrenchReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `FrenchReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `FrenchReg-1.svg`;
	          army -= 1;
                }
	      }
	    }
          }
          if (z === "papacy") {
            tile = "/his/img/tiles/papacy/";	  
            if (army >= 4) {
              tile += `PapacyReg-4.svg`;
              army -= 4;
            } else {
	      if (army >= 2) {
                tile += `PapacyReg-2.svg`;
	        army -= 2;
	      } else {
	        if (army >= 1) {
                  tile += `PapacyReg-1.svg`;
	          army -= 1;
	        }
	      }
	    }
          }
          if (z === "protestant") {
            tile = "/his/img/tiles/protestant/";	  
	    if (army >= 4) {
              tile += `ProtestantReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `ProtestantReg-2.svg`;
	        army -= 2;
               } else {
	         if (army >= 1) {
                   tile += `ProtestantReg-1.svg`;
	           army -= 1;
                 }
	       }
            }
          }
          if (z === "ottoman") {
            tile = "/his/img/tiles/ottoman/";	  
	    if (army >= 4) {
              tile += `OttomanReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `OttomanReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `OttomanReg-1.svg`;
	          army -= 1;
                }
              }
            }
          }
          if (z === "independent") {
            tile = "/his/img/tiles/independent/";	  
	    if (army >= 2) {
              tile += `IndependentReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `IndependentReg-1.svg`;
	        army -= 1;
              } 
	    }
          }
          if (z === "venice") {
            tile = "/his/img/tiles/venice/";	  
	    if (army >= 2) {
              tile += `VeniceReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `VeniceReg-1.svg`;
	        army -= 1;
              }
	    }
          }
          if (z === "hungary") {
            tile = "/his/img/tiles/hungary/";	  
	    if (army >= 4) {
              tile += `HungaryReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `HungaryReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `HungaryReg-1.svg`;
	          army -= 1;
                }
              }
            }
          }
          if (z === "genoa") {
            tile = "/his/img/tiles/genoa/";	  
	    if (army >= 2) {
              tile += `GenoaReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `GenoaReg-1.svg`;
	        army -= 1;
              }
            }
          }
          if (z === "scotland") {
            tile = "/his/img/tiles/scotland/";	  
	    if (army >= 2) {
              tile += `ScottishReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `ScottishReg-1.svg`;
	        army -= 1;
              }
            } 
          }
        }

        if (new_units == true) {
          if (controlling_faction != "" && controlling_faction !== z) {
            html += `<img class="army_tile army_tile" src="${tile}" />`;
  	  } else {
            html += `<img class="army_tile" src="${tile}" />`;
	  }
        }




        new_units = false;

        army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
          if (space.units[z][zz].type === "mercenary") {
  	    new_units = true;
            army++;
          }
        }

        while (army > 0) {
          if (z != "") {
            if (z === "hapsburg") {
              tile = "/his/img/tiles/hapsburg/";	  
	      if (army >= 4) {
                tile += `HapsburgMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2) {
                tile += `HapsburgMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1) {
                tile += `HapsburgMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "england") {
              tile = "/his/img/tiles/england/";	  
	      if (army >= 4) {
                tile += `EnglandMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `EnglandMerc-2.svg`;
	        army -= 4;
              } else {
	      if (army >= 1) {
                tile += `EnglandMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "france") {
              tile = "/his/img/tiles/france/";	  
	      if (army >= 4) {
                tile += `FrenchMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `FrenchMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `FrenchMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "papacy") {
              tile = "/his/img/tiles/papacy/";	  
	      if (army >= 4) {
                tile += `PapacyMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "protestant") {
              tile = "/his/img/tiles/protestant/";	  
	      if (army >= 4) {
                tile += `ProtestantMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `ProtestantMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `ProtestantMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "ottoman") {
              tile = "/his/img/tiles/ottoman/";	  
	      if (army >= 4) {
                tile += `OttomanMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `OttomanMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `OttomanMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
          }


          if (new_units == true) {
            if (controlling_faction != "" && controlling_faction !== z) {
              html += `<img class="army_tile army_tile" src="${tile}" />`;
  	    } else {
              html += `<img class="army_tile" src="${tile}" />`;
	    }
          }
        }
      }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnMercenaryTiles(faction, spacekey) {

    let z = faction;
    let space = this.game.spaces[spacekey];
    let html = "";

    if (this.game.state.board[z]) {
      if (this.game.state.board[z].deployed[spacekey]) {

	  let tile = "";
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-1.svg" />`;
	    }
	  }
      }
    }

    return html;

  }


  returnMercenaries(space) {

    let html = '<div class="space_mercenaries" id="">';
    let tile = "";
    let spacekey = space.key;

    for (let z in space.units) {

      //
      // ideally our space is "pre-calculated" and we can display the correct
      // mix of tiles. this should be saved in this.game.state.board["papacy"]
      // etc. see his-units for the returnOnBoardUnits() function that organizes
      // this data object.
      //
      if (this.game.state.board[z]) {
        html += this.returnMercenaryTiles(z, spacekey);
	tile = html;
      } else {

        new_units = false;

        let army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
          if (space.units[z][zz].type === "mercenary") {
  	    new_units = true;
            army++;
          }
        }

        while (army > 0) {
          if (z != "") {
            if (z === "hapsburg") {
              tile = "/his/img/tiles/hapsburg/";	  
	      if (army >= 4) {
                tile += `HapsburgMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2) {
                tile += `HapsburgMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1) {
                tile += `HapsburgMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "england") {
              tile = "/his/img/tiles/england/";	  
	      if (army >= 4) {
                tile += `EnglandMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `EnglandMerc-2.svg`;
	        army -= 4;
              } else {
	      if (army >= 1) {
                tile += `EnglandMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "france") {
              tile = "/his/img/tiles/france/";	  
	      if (army >= 4) {
                tile += `FrenchMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `FrenchMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `FrenchMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "papacy") {
              tile = "/his/img/tiles/papacy/";	  
	      if (army >= 4) {
                tile += `PapacyMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "protestant") {
              tile = "/his/img/tiles/protestant/";	  
	      if (army >= 4) {
                tile += `ProtestantMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `ProtestantMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `ProtestantMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "ottoman") {
              tile = "/his/img/tiles/ottoman/";	  
	      if (army >= 4) {
                tile += `OttomanMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `OttomanMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `OttomanMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
          }
          html += `<img class="mercenary_tile" src="${tile}" />`;
        }
      }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnPersonagesTiles(faction, spacekey) {

    let z = faction;
    let space = this.game.spaces[spacekey];
    if (!space || space == undefined) { space = this.game.navalspaces[spacekey]; }

    let html = "";

      for (let zz = 0; zz < space.units[z].length; zz++) {
	let added = 0;
	if (space.units[z][zz].debater === true) {
          html += `<img src="/his/img/tiles/debater/${space.units[z][zz].img}" />`;
	  tile = html;
	  added = 1;
	}
	if (space.units[z][zz].army_leader && added == 0) {
          html += `<img src="/his/img/tiles/army/${space.units[z][zz].img}" />`;
	  added = 1;
	}
        if (space.units[z][zz].navy_leader && added == 0) {
	  html += `<img src="/his/img/tiles/navy/${space.units[z][zz].img}" />`;
	  added = 1;
	} 
        if (space.units[z][zz].reformer && added == 0) {
	  html += `<img src="/his/img/tiles/reformers/${space.units[z][zz].img}" />`;
	  added = 1;
	}
      }
    return html;
  }

  returnPersonages(space) {

    let html = '<div class="figures_tile" id="">';
    let owner = space.political;
    if (owner == "") { owner = space.home; }
    let tile = "";

    for (let z in space.units) {
      html += this.returnPersonagesTiles(z, space.key);
      if (html != "") { tile = html; }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  refreshBoardUnits() {
    this.game.state.board["protestant"] = this.returnOnBoardUnits("protestant");
    this.game.state.board["papacy"] = this.returnOnBoardUnits("papacy");
    this.game.state.board["england"] = this.returnOnBoardUnits("england");
    this.game.state.board["france"] = this.returnOnBoardUnits("france");
    this.game.state.board["ottoman"] = this.returnOnBoardUnits("ottoman");
    this.game.state.board["hapsburg"] = this.returnOnBoardUnits("hapsburg");
    this.game.state.board["independent"] = this.returnOnBoardUnits("independent");
    this.game.state.board["venice"] = this.returnOnBoardUnits("venice");
    this.game.state.board["genoa"] = this.returnOnBoardUnits("genoa");
    this.game.state.board["scotland"] = this.returnOnBoardUnits("scotland");
    this.game.state.board["hungary"] = this.returnOnBoardUnits("hungary");
  }


  displaySpace(key) {

    if (this.game.navalspaces[key]) { this.displayNavalSpace(key); return; }

    let ts = new Date().getTime();
    let no_keytiles_in_keys = [];
    if (this.game.state.board_updated < ts + 20000) {
      this.refreshBoardUnits();
    }

    if (!this.game.spaces[key]) { return; }

    let space = this.game.spaces[key];
    let tile = this.returnSpaceTile(space);

    let stype = "hex";

    if (space.type == "town") { stype = "hex"; }
    if (space.type == "key") { stype = "key"; }

    //
    // should we show the tile?
    //
    let show_tile = 1;

    //
    // do not show under some conditions
    //
    if (space.political == space.home && space.religion != "protestant") { show_tile = 0; }
    if (space.political === "" && space.religion != "protestant") { show_tile = 0; }
    if (space.political == "protestant" && space.religion != "protestant") { show_tile = 1; }
    if (
      space.religion === "catholic" && 
      (
	(space.home == "venice" || space.home == "genoa" || space.home == "scotland" || space.home == "hungary") &&
	(space.home == space.political || space.political == "")
      )
    ) {
      let allied_to_major_power = false;
      if (space.type === "key" || space.type == "electorate") {
        if (this.areAllies(space.home, "protestant", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "papacy", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "france", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "england", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "ottoman", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "hapsburg", 0)) { allied_to_major_power = true; }
      }
      if (allied_to_major_power == false) {
        no_keytiles_in_keys.push(space.key);
        show_tile = 0;
      }
    }
    if (space.language == "german" && space.units["protestant"].length > 0) { show_tile = 1; }

    //
    // and force for keys
    //
    if (space.home === "" && space.political !== "") { show_tile = 1; }
    if (space.type === "key") { show_tile = 1; }
    if (space.type === "electorate") { show_tile = 1; }

    //
    // and force if has units
    //
    for (let key in space.units) {
      if (space.units[key].length > 0) {
	show_tile = 1; 
      }
    }

    //
    // sanity check
    //
    if (tile === "") { show_tile = 0; }

    let t = "."+key;
    document.querySelectorAll(t).forEach((obj) => {

      obj.innerHTML = "";

      if (show_tile === 1) {
	if (!no_keytiles_in_keys.includes(key)) {
          obj.innerHTML = `<img class="${stype}tile" src="${tile}" />`;
	}
        obj.innerHTML += this.returnArmies(space);
        obj.innerHTML += this.returnNavies(space);
        obj.innerHTML += this.returnPersonages(space);
      }

      if (space.fortified == 1) {
        obj.innerHTML += `<img class="fortified" src="/his/img/tiles/Fortress.svg" />`;
      }
      if (space.pirate_haven == 1) {
        obj.innerHTML += `<img class="pirate-haven" src="/his/img/tiles/ottoman/PirateHaven.svg" />`;
      }
      if (space.university == 1) {
        obj.innerHTML += `<img class="university" src="/his/img/tiles/papacy/Jesuit_Univ.svg" />`;
      }
      if (this.isSpaceInUnrest(space)) {
        obj.innerHTML += `<img class="unrest" src="/his/img/tiles/unrest.svg" />`;
      }
      if (this.isSpaceBesieged(space)) {
        obj.innerHTML += `<img class="siege" src="/his/img/tiles/siege.png" />`;
      }
    });

  }

  showPiracyMarker(key) {
    try {
      document.querySelector(`.piracy_marker.${key}`).style.display = "block";
    } catch (err) {}
  }

  hidePiracyMarker(key) {
    try {
      document.querySelector(`.piracy_marker.${key}`).style.display = "none";
    } catch (err) {}
  }

  displayNavalSpace(key) {

    if (this.game.spaces[key]) { this.displaySpace(key); return; }
    if (!this.game.navalspaces[key]) { return; }

    let obj = document.getElementById(key);
    let space = this.game.navalspaces[key];

    //
    // should we show the tile?
    //
    let show_tile = 1;

    //
    // show piracy marker if needed
    //
    if (this.game.state.events.ottoman_piracy_seazones.includes(key)) {
      this.showPiracyMarker(key);
    } else {
      this.hidePiracyMarker(key);
    }

    //
    // do not show under some conditions
    //
    if (show_tile === 1) {
      obj.innerHTML = "";
      obj.innerHTML += this.returnNavies(space);
      obj.innerHTML += this.returnPersonages(space);
    }

  }

  displayNavalSpaces() {

    //
    // add tiles
    //
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key]) {
	this.displayNavalSpace(key);
      }
    }

  }

  addSelectable(el) {
    if (!el.classList.contains("selectable")) {
      el.classList.add('selectable');
    }
  }

  removeSelectable() {
    document.querySelectorAll(".selectable").forEach((el) => {
      el.onclick = (e) => {};
      el.classList.remove('selectable');
    });
    $('.space').off();
  }

  displaySpaces() {

    let his_self = this;

    //
    // generate faction tile info
    //
    if (!this.game.state.board) {
      this.game.state.board["protestant"] = this.returnOnBoardUnits("protestant");
      this.game.state.board["papacy"] = this.returnOnBoardUnits("papacy");
      this.game.state.board["england"] = this.returnOnBoardUnits("england");
      this.game.state.board["france"] = this.returnOnBoardUnits("france");
      this.game.state.board["ottoman"] = this.returnOnBoardUnits("ottoman");
      this.game.state.board["hapsburg"] = this.returnOnBoardUnits("hapsburg");
    }


    //
    // add tiles
    //
    for (let key in this.spaces) {
      if (this.spaces.hasOwnProperty(key)) {
	this.displaySpace(key);
      }
    }

    let xpos = 0;
    let ypos = 0;


    if (!his_self.bound_gameboard_zoom) {

      $('.gameboard').on('mousedown', function (e) {
        if (e.currentTarget.classList.contains("space")) { return; }
        xpos = e.clientX;
        ypos = e.clientY;
      });
      $('.gameboard').on('mouseup', function (e) { 
        if (Math.abs(xpos-e.clientX) > 4) { return; }
        if (Math.abs(ypos-e.clientY) > 4) { return; }
	//
	// if this is a selectable space, let people select directly
	//
	// this is a total hack by the way, but it captures the embedding that happens when
	// we are clicking and the click actino is technically on the item that is INSIDE
	// the selectable DIV, like a click on a unit in a key, etc.
	//
	if (e.target.classList.contains("selectable")) {
	  // something else is handling this
	  return;
	} else {
	  let el = e.target;
	  if (el.parentNode) {
	    if (el.parentNode.classList.contains("selectable")) {
	      // something else is handling this
	      return;
	    } else {
	      if (el.parentNode.parentNode) {
	        if (el.parentNode.parentNode.classList.contains("selectable")) {
	          return;
	        }
	      }
	    }
	  }
	}
	// otherwise show zoom
        //if (e.target.classList.contains("space")) {
          his_self.theses_overlay.renderAtCoordinates(xpos, ypos);
	  //e.stopPropagation();
	  //e.preventDefault();	
	  //return;
	//}
      });

      his_self.bound_gameboard_zoom = 1;

    }


  }


  displayVictoryTrack() {

    let factions_and_scores = this.calculateVictoryPoints();

    let x = this.returnVictoryPointTrack();
    let tiles = [];
    let zindex = 1;
    for (let i = 0; i < 30; i++) { tiles.push(0); }

    for (f in factions_and_scores) {
try {
      let total_vp = factions_and_scores[f].vp;
      let ftile = f + "_vp_tile";
      obj = document.getElementById(ftile);
      obj.style.left = x[total_vp.toString()].left + "px";
      obj.style.top = x[total_vp.toString()].top + "px";
      obj.style.display = "block";
      if (tiles[total_vp] > 0) {
	let shift = 2 * tiles[total_vp];
        obj.style.transform = `translateY(-${shift}rem) translateX(${shift}rem)`;
	zindex = zindex-1;
        obj.style.zIndex = zindex;
        tiles[total_vp]++;
      } else {
	tiles[total_vp]++;
        obj.style.transform = ``;
        obj.style.zIndex = zindex;
      }
} catch (err) {
}

    }

  }



  returnCardImage(cardname, faction="") {

    let cardclass = "cardimg";
    let deckidx = -1;
    let card;
    let cdeck = this.returnDeck(true); // include removed cards
    let ddeck = this.returnDiplomaticDeck();

    if (cardname === "pass") {
      return `<img class="${cardclass}" src="/his/img/cards/PASS.png" /></div>`;
    }
    if (cardname === "autopass") {
      return `<img class="${cardclass}" src="/his/img/cards/AUTOPASS.png" /></div>`;
    }

    if (this.debaters[cardname]) { return this.debaters[cardname].returnCardImage(); }

    for (let i = 0; i < this.game.deck.length; i++) {
      var c = this.game.deck[i].cards[cardname];
      if (c == undefined) { c = this.game.deck[i].discards[cardname]; }
      if (c == undefined) { c = this.game.deck[i].removed[cardname]; }
      if (c !== undefined) { 
	deckidx = i;
        card = c;
      }
    }
    if (c == undefined) { c = cdeck[cardname]; card = cdeck[cardname]; }
    if (c == undefined) { c = ddeck[cardname]; card = ddeck[cardname]; }


    //
    // triggered before card deal
    //
    if (cardname === "008") { return `<img class="${cardclass}" src="/his/img/cards/HIS-008.svg" />`; }

    if (deckidx === -1 && !cdeck[cardname] && !ddeck[cardname]) {
      //
      // this is not a card, it is something like "skip turn" or cancel
      //
      return `<div class="noncard" id="${cardname.replaceAll(" ","")}">${cardname}</div>`;
    }

    var html = `<img class="${cardclass}" src="/his/img/${card.img}" />`;

    //
    // add cancel button to uneventable cards
    //
    let active_faction = faction;
    if (active_faction == "") { active_faction = this.game.state.active_faction; }

    if (deckidx == 0) { 
      if (this.deck[cardname]) {
        if (!this.deck[cardname].canEvent(this, active_faction)) {
          html += `<img class="${cardclass} cancel_x" src="/his/img/cancel_x.png" />`;
        }
      }
    }
    if (deckidx == 1) { 
      if (!this.diplomatic_deck[cardname].canEvent(this, active_faction)) {
        html += `<img class="${cardclass} cancel_x" src="/his/img/cancel_x.png" />`;
      }
    }

    return html

  }


  displayDebaterPopup(debater) {
    
  }



  async preloadImages() {
    var allImages = [
      "img/factions/protestant.png",
      "img/factions/papacy.png",
      "img/factions/england.png",
      "img/factions/france.png",
      "img/factions/ottoman.png",
      "img/factions/hapsburgs.png",
      "img/backgrounds/reformation.jpg",
      "img/backgrounds/theological-debate.jpg",
      "img/backgrounds/theological-debate2.jpg",
      "img/backgrounds/diet_of_worms.jpeg",
      "img/backgrounds/language-zone.jpg",
      "img/backgrounds/95_theses.jpeg",
      "img/cards/PASS.png",
    ];

    this.preloadImageArray(allImages);
  }

  preloadImageArray(imageArray=[], idx=0) {

    let pre_images = [imageArray.length];

    if (imageArray && imageArray.length > idx) {
      pre_images[idx] = new Image();
      pre_images[idx].onload = () => {
        this.preloadImageArray(imageArray, idx+1);
      }
      pre_images[idx].src = "/his/" + imageArray[idx];
    }

  }







  addCard(faction, card) {
    let p = this.returnPlayerOfFaction(faction);
    if (p) {
      for (let z = 0; z < this.game.state.players_info[p-1].factions.length; z++) {
	if (this.game.state.players_info[p-1].factions[z] == faction) {
	  if (this.game.player == p) {
  	    this.game.deck[0].fhand[z].push(card);
	  }
	}
      }
    }
  }



} // end and export

module.exports = HereIStand;


