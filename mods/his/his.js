const GameTemplate = require('../../lib/templates/gametemplate');
const DebateOverlay = require('./lib/ui/overlays/debate');
const ChateauxOverlay = require('./lib/ui/overlays/chateaux');
const MarriageOverlay = require('./lib/ui/overlays/marriage');
const PiracyOverlay = require('./lib/ui/overlays/piracy');
const VPOverlay = require('./lib/ui/overlays/vp');
const NewWorldOverlay = require('./lib/ui/overlays/newworld');
const TreatiseOverlay = require('./lib/ui/overlays/treatise');
const FactionOverlay = require('./lib/ui/overlays/faction');
const FactionBar = require('./lib/ui/factionbar');
const ReligiousOverlay = require('./lib/ui/overlays/religious');
const CouncilOfTrentOverlay = require('./lib/ui/overlays/council-of-trent');
const ReformationOverlay = require('./lib/ui/overlays/reformation');
// diplomacy overlay is new
const DiplomacyOverlay = require('./lib/ui/overlays/diplomacy');
const DiplomacyConfirmOverlay = require('./lib/ui/overlays/diplomacy-confirm');
const DiplomacyProposeOverlay = require('./lib/ui/overlays/diplomacy-propose');
const AvailableUnitsOverlay = require('./lib/ui/overlays/available-units');
const FortificationOverlay = require('./lib/ui/overlays/fortification');
const SpringDeploymentOverlay = require('./lib/ui/overlays/spring-deployment');
const BuildOverlay = require('./lib/ui/overlays/build');
const NavalMovementOverlay = require('./lib/ui/overlays/naval-movement');
const MovementOverlay = require('./lib/ui/overlays/movement');
const DietOfWormsOverlay = require('./lib/ui/overlays/diet-of-worms');
const FieldBattleOverlay = require('./lib/ui/overlays/field-battle');
const NavalBattleOverlay = require('./lib/ui/overlays/naval-battle');
const SchmalkaldicOverlay = require('./lib/ui/overlays/schmalkaldic');
const AssaultOverlay = require('./lib/ui/overlays/siege');
const ThesesOverlay = require('./lib/ui/overlays/theses');
const DebatersOverlay = require('./lib/ui/overlays/debaters');
const ExplorersOverlay = require('./lib/ui/overlays/explorers');
const ConquistadorsOverlay = require('./lib/ui/overlays/conquistadors');
const UnitsOverlay = require('./lib/ui/overlays/units');
const WarOverlay = require('./lib/ui/overlays/war');
const WelcomeOverlay = require('./lib/ui/overlays/welcome');
const HudPopup = require('./lib/ui/hud-popup');
const WinterOverlay = require('./lib/ui/overlays/winter');
const DeckOverlay = require('./lib/ui/overlays/deck');
const MenuOverlay = require('./lib/ui/overlays/menu');
const LanguageZoneOverlay = require('./lib/ui/overlays/language-zone');

// Tutorial Overlays
const GameHelp = require('./lib/ui/game-help/game-help');
const TutorialTemplate = require('./lib/ui/overlays/tutorials/tutorial.template');

const HISRules = require('./lib/core/rules.template');
const HISOptions = require('./lib/core/advanced-options.template');
const HISingularOption = require('./lib/core/options.template');
const htmlTemplate = require('./lib/core/game-html.template');

const JSON = require('json-bigint');

  //
  // used in counter_or_acknowledge
  //
  var counter_or_acknowledge_inactivity_timeout = null;
  var true_if_counter_or_acknowledge_cleared = false;



//////////////////
// CONSTRUCTOR  //
//////////////////
class HereIStand extends GameTemplate {

  constructor(app) {

    super(app);

    this.app             = app;

    this.name  		 = "HereIStand";
    this.gamename        = "Here I Stand";
    this.slug		 = "his";
    this.description     = `Here I Stand is a boardgame based on the military, political and religious conflicts within Europe at the outbreak of the Protestant Reformation (1517-1555). Each player controls one or more major powers that dominated Europe: the Ottoman Empire, the Hapsburgs, England, France, the Papacy and the Protestant states.`;
    this.publisher_message = `Here I Stand is published by GMT Games. This module is made available under an open source license provided by GMT Games that permits usage provided that at least one player per game has purchased a copy of the game. Support GMT Games: <a href="https://www.gmtgames.com/p-917-here-i-stand-500th-anniversary-reprint-edition-2nd-printing.aspx">purchase</a>`;
    this.categories      = "Games Boardgame Strategy";

    this.interface = 1; // graphical interface

    //
    // ui components
    //
    this.debate_overlay = new DebateOverlay(this.app, this);      // theological debates
    this.treatise_overlay = new TreatiseOverlay(this.app, this);  // publish treatise
    this.religious_overlay = new ReligiousOverlay(this.app, this);  // religious conflict sheet
    this.faction_overlay = new FactionOverlay(this.app, this);  // faction sheet
    this.factionbar = new FactionBar(this.app, this); // shows you which factions you are in multiplayer
    this.diet_of_worms_overlay = new DietOfWormsOverlay(this.app, this);  // diet of worms
    this.diplomacy_overlay = new DiplomacyOverlay(this.app, this);
    this.diplomacy_confirm_overlay = new DiplomacyConfirmOverlay(this.app, this);
    //this.diplomacy_propose_overlay = new DiplomacyProposeOverlay(this.app, this);
    this.council_of_trent_overlay = new CouncilOfTrentOverlay(this.app, this);  // council of trent
    this.chateaux_overlay = new ChateauxOverlay(this.app, this);  // build some fucking chateaux
    this.marriage_overlay = new MarriageOverlay(this.app, this);  // marry, divorce, repeat
    this.piracy_overlay = new PiracyOverlay(this.app, this);  // rape and pillage but mostly steal
    this.vp_overlay = new VPOverlay(this.app, this);  // end-of-turn points overlay
    this.newworld_overlay = new NewWorldOverlay(this.app, this);
    this.theses_overlay = new ThesesOverlay(this.app, this);  // 95 theses
    this.reformation_overlay = new ReformationOverlay(this.app, this);  // reformations and counter-reformations
    this.language_zone_overlay = new LanguageZoneOverlay(this.app, this);  // language zone selection
    this.debaters_overlay = new DebatersOverlay(this.app, this); 
    this.explorers_overlay = new ExplorersOverlay(this.app, this);
    this.conquistadors_overlay = new ConquistadorsOverlay(this.app, this);
    this.schmalkaldic_overlay = new SchmalkaldicOverlay(this.app, this);  // schmalkaldic league
    this.hud_popup = new HudPopup(this.app, this);  // hud popup
    this.assault_overlay = new AssaultOverlay(this.app, this);  // siege
    this.naval_battle_overlay = new NavalBattleOverlay(this.app, this);  // naval battles
    this.field_battle_overlay = new FieldBattleOverlay(this.app, this);  // field battles
    this.spring_deployment_overlay = new SpringDeploymentOverlay(this.app, this);  // spring deployment
    this.build_overlay = new BuildOverlay(this.app, this);  // unit building
    this.available_units_overlay = new AvailableUnitsOverlay(this.app, this);  // unit movement
    this.movement_overlay = new MovementOverlay(this.app, this);  // unit movement
    this.fortification_overlay = new FortificationOverlay(this.app, this);  // unit movement
    this.welcome_overlay = new WelcomeOverlay(this.app, this);  // hello world
    this.naval_movement_overlay = new NavalMovementOverlay(this.app, this);  // overlay to move ships
    this.deck_overlay = new DeckOverlay(this.app, this);  // overlay to show cards
    this.menu_overlay = new MenuOverlay(this.app, this);  // players doing stuff
    this.winter_overlay = new WinterOverlay(this.app, this);
    this.units_overlay = new UnitsOverlay(this.app, this);
    this.war_overlay = new WarOverlay(this.app, this);

    //
    // triangular help button
    //
    this.game_help = new GameHelp(this.app, this);

    //
    // this sets the ratio used for determining
    // the size of the original pieces
    //
    this.boardWidth  = 5100;

    //
    // newbie mode
    //
    this.confirm_moves = 1;
    this.faster_play = 1; // this speeds-up some responses at the cost of potentially
			  // leaking information on what response cards users have or
			  // do not have.

    //
    // "showcard" popups
    //
    this.useCardbox = 1;

    //
    //
    // players
    this.minPlayers 	 = 2;
    this.maxPlayers 	 = 6;

  }


  returnSingularGameOption(){
    return HISSingularOption();
  }

  returnAdvancedOptions() {
    return HISOptions();
  }

  returnGameRulesHTML(){
    return HISRules();
  }


  ////////////////
  // initialize //
  ////////////////
  initializeGame(game_id) {

    //
    // check user preferences to update interface, if text
    //
    if (this.app?.options?.gameprefs) {
      if (this.app.options.gameprefs.his_expert_mode) {
        if (this.app.options.gameprefs.his_expert_mode == 1) {
          this.confirm_moves = 0;
        } else {
          this.confirm_moves = 1;
        }
      }
      if (this.app.options.gameprefs.his_faster_play) {
	if (this.app.options.gameprefs.his_faster_play !== 1) {
          this.faster_play = 0;
        } else {
          this.faster_play = 1;
        }
      }
    }

    //
    // re-fill status and log
    //
    if (this.game.status != "") { this.updateStatus(this.game.status); }

    //
    // initialize game objects
    //
    this.factions = {};

    this.units = {};
    this.army = {};
    this.navy = {};
    this.reformers = {};
    this.debaters = {};
    this.explorers = {};
    this.conquistadors = {};
    this.wives = {};

    this.deck = this.returnDeck(true);
    this.diplomatic_deck = this.returnDiplomaticDeck();



    this.importFaction('faction2', {
      id		:	"faction2" ,
      key		:	"england" ,
      name		: 	"England",
      nickname		: 	"England",
      img		:	"england.png",
      admin_rating	:	1,
      capitals		:	["london"],
      cards_bonus	:	1,
      marital_status    :       0,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.henry_viii == 1) { base += 1; }
        if (game_mod.game.state.leaders.edward_vi == 1) { base += 1; }
        if (game_mod.game.state.leaders.mary_i == 1) { base += 1; }
        if (game_mod.game.state.leaders.elizabeth_i == 1) { base += 2; }

        return base;

      },
      returnCardsDealt  :	function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = 0;

	switch (kc) {
	  case 1: { base = 1; break; }
	  case 2: { base = 1; break; }
	  case 3: { base = 2; break; }
	  case 4: { base = 2; break; }
	  case 5: { base = 3; break; }
	  case 6: { base = 3; break; }
	  case 7: { base = 4; break; }
	  case 8: { base = 4; break; }
	  case 9: { base = 5; break; }
	  case 10: { base = 5; break; }
	  case 11: { base = 6; break; }
	  case 12: { base = 6; break; }
	  default: { base = 1; break; }
	}

	// bonuses based on leaders
	if (game_mod.game.state.leaders.henry_viii == 1) { base += 1; }
	if (game_mod.game.state.leaders.edward_vi == 1) { base += 0; }
	if (game_mod.game.state.leaders.mary_i == 1) { base += 0; }
	if (game_mod.game.state.leaders.elizabeth_i == 1) { base += 2; }

        base += game_mod.game.state.england_card_bonus;

	// TODO - bonus for home spaces under protestant control
	return base;

      },
      calculateBonusVictoryPoints  :	function(game_mod) {
	let base = 0;
        return base;
      },
      calculateSpecialVictoryPoints  :	function(game_mod) {

        let base = 0;

	//
	// 5 VP if Edward is born 
	//
	if (game_mod.game.state.henry_viii_sickly_edward == 1 || game_mod.game.state.henry_viii_edward_added == 1 || game_mod.game.state.henry_viii_healthy_edward == 1) {
 	  base += 5;
        } else {
	  if (game_mod.game.state.henry_viii_elizabeth_added == 1 || game_mod.game.state.henry_viii_add_elizabeth == 1) {
	    base += 2;
	  }
	}

	//
	// 1VP per every 2 protestant spaces
	//
	let eps = game_mod.returnNumberOfProtestantSpacesInLanguageZone("english", 1);
	while (eps > 1) { eps -= 2; base++; }

	return base;

      },
      calculateBaseVictoryPoints  :	function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("england");
        let base = this.vp;

	switch (kc) {
	  case 1: { base += 3; break; }
	  case 2: { base += 5; break; }
	  case 3: { base += 7; break; }
	  case 4: { base += 9; break; }
	  case 5: { base += 11; break; }
	  case 6: { base += 13; break; }
	  case 7: { base += 15; break; }
	  case 8: { base += 17; break; }
	  default: { base += 17; break; }
	}

	return base;

      },
    });
 


    this.importFaction('faction3', {
      id		:	"faction3" ,
      key		: 	"france",
      name		: 	"France",
      nickname		: 	"France",
      capitals          :       ["paris"],
      admin_rating	:	1,
      img		:	"france.png",
      cards_bonus	:	1,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.francis_i == 1) { base += 1; }
        if (game_mod.game.state.leaders.henry_ii == 1) { base += 1; }

        return base;

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("france");
        let base = this.vp; 
       
        switch (kc) {
          case 1: { base = 1; break; }
          case 2: { base = 1; break; }
          case 3: { base = 1; break; }
          case 4: { base = 2; break; }
          case 5: { base = 2; break; }
          case 6: { base = 3; break; }
          case 7: { base = 3; break; }
          case 8: { base = 4; break; }
          case 9: { base = 4; break; }
          case 10: { base = 5; break; }
          case 11: { base = 6; break; }
          case 12: { base = 6; break; }
          default: { base = 0; break; }
        }

        // bonuses based on leaders
        if (game_mod.game.state.leaders.francis_i == 1) { base += 1; }        
        if (game_mod.game.state.leaders.henry_ii == 1) { base += 0; }        

        base += game_mod.game.state.france_card_bonus;

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {

        let kc = game_mod.returnNumberOfKeysControlledByFaction("france");
        let base = 0;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
          case 7: { base += 14; break; }
          case 8: { base += 16; break; }
          case 9: { base += 18; break; }
          case 10: { base += 20; break; }
        } 
        
        return base;
        
      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
	let base = 0;
	if (game_mod.game.state.french_chateaux_vp) {
	  base += game_mod.game.state.french_chateaux_vp;
	}
	return base;
      },
    });
 



    this.importFaction('faction7', {
      id		:	"faction7" ,
      key		:	"genoa" ,
      name		: 	"Genoa",
      nickname		: 	"Genoa",
    });
 


    this.importFaction('faction1', {
      id		:	"faction1" ,
      key		: 	"hapsburg",
      name		: 	"Hapsburg",
      nickname		: 	"Hapsburg",
      capitals          :       ["valladolid","vienna"],
      img		:	"hapsburgs.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {
 
        let base = 0;

        if (game_mod.game.state.leaders.charles_v == 1) { base += 2; }

        return base;

        return base; 

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("hapsburg");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 1; break; }
          case 2: { base = 2; break; }
          case 3: { base = 2; break; }
          case 4: { base = 3; break; }
          case 5: { base = 3; break; }
          case 6: { base = 4; break; }
          case 7: { base = 4; break; }
          case 8: { base = 5; break; }
          case 9: { base = 5; break; }
          case 10: { base = 6; break; }
          case 11: { base = 6; break; }
          case 12: { base = 7; break; }
          case 13: { base = 7; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.charles_v == 1) { base += 0; }

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("hapsburg");
        let base = 0;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 3; break; }
          case 3: { base += 4; break; }
          case 4: { base += 5; break; }
          case 5: { base += 6; break; }
          case 6: { base += 7; break; }
          case 7: { base += 8; break; }
          case 8: { base += 9; break; }
          case 9: { base += 10; break; }
          case 10: { base += 11; break; }
          case 11: { base += 12; break; }
          case 12: { base += 13; break; }
          case 13: { base += 14; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
        let base = 0;
	if (game_mod.game.state.events.schmalkaldic_league == 1) {
	  if (game_mod.isSpaceControlled("mainz", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("wittenberg", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("augsburg", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("trier", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("cologne", "hapsburg")) { base += 1; }
	  if (game_mod.isSpaceControlled("brandenburg", "hapsburg")) { base += 1; }
	}
	return base;
      },
    });
 



    this.importFaction('faction8', {
      id                :       "faction8" ,
      key               :       "hungary" ,
      name              :       "Hungary",
      nickname          :       "Hungary",
    });



    this.importFaction('faction11', {
      id                :       "faction11" ,
      key               :       "independent" ,
      name              :       "Independent",
      nickname          :       "Independent",
    });



    this.importFaction('faction5', {
      id		:	"faction5" ,
      key		: 	"ottoman",
      name		: 	"Ottoman Empire",
      nickname		: 	"Ottoman",
      capitals          :       ["istanbul"],
      img		:	"ottoman.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {

        let base = 0;

        if (game_mod.game.state.leaders.suleiman == 1) { base += 2; }

        return base;

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("ottoman");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 2; break; }
          case 2: { base = 2; break; }
          case 3: { base = 3; break; }
          case 4: { base = 3; break; }
          case 5: { base = 4; break; }
          case 6: { base = 4; break; }
          case 7: { base = 5; break; }
          case 8: { base = 5; break; }
          case 9: { base = 6; break; }
          case 10: { base = 6; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.suleiman == 1) { base += 0; }        
 
        base += game_mod.game.state.ottoman_card_bonus;
      
        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("ottoman");
        let base = this.vp;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
          case 7: { base += 14; break; }
          case 8: { base += 16; break; }
          case 9: { base += 18; break; }
          case 10: { base += 20; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {
        let base = 0;
	base += parseInt(game_mod.game.state.events.ottoman_piracy_vp);
        base += parseInt(game_mod.game.state.events.ottoman_julia_gonzaga_vp);
	return base;
      },
    });
 



    this.importFaction('faction4', {

      id		:	"faction4" ,
      key		: 	"papacy",
      name		: 	"Papacy",
      nickname		: 	"Papacy",
      capitals          :       ["rome"],
      img		:	"papacy.png",
      admin_rating	:	0,
      cards_bonus	:	0,
      returnAdminRating  :       function(game_mod) {
 
        let base = 0;

        if (game_mod.game.state.leaders.leo_x == 1) { base += 0; }
        if (game_mod.game.state.leaders.clement_vii == 1) { base += 1; }
        if (game_mod.game.state.leaders.paul_iii == 1) { base += 1; }
        if (game_mod.game.state.leaders.julius_iii == 1) { base += 0; }

        return base; 

      },
      returnCardsDealt  :       function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("papacy");
        let base = 0;
        
        switch (kc) {
          case 1: { base = 2; break; }
          case 2: { base = 3; break; }
          case 3: { base = 3; break; }
          case 4: { base = 4; break; }
          case 5: { base = 4; break; }
          case 6: { base = 4; break; }
          default: { base = 0; break; }
        }

        if (game_mod.game.state.leaders.leo_x == 1) { base += 0; }
        if (game_mod.game.state.leaders.clement_vii == 1) { base += 0; }
        if (game_mod.game.state.leaders.paul_iii == 1) { base += 1; }
        if (game_mod.game.state.leaders.julius_iii == 1) { base += 1; }       

        base += game_mod.game.state.papacy_card_bonus;

        // TODO - bonus for home spaces under protestant control
        return base;

      },
      calculateBaseVictoryPoints  : function(game_mod) {
        
        let kc = game_mod.returnNumberOfKeysControlledByFaction("papacy");
        let base = this.vp;
        
        switch (kc) {
          case 1: { base += 2; break; }
          case 2: { base += 4; break; }
          case 3: { base += 6; break; }
          case 4: { base += 8; break; }
          case 5: { base += 10; break; }
          case 6: { base += 12; break; }
        } 
        
        return base;

      },
      calculateBonusVictoryPoints  :    function(game_mod) {
        return 0;
      },
      calculateSpecialVictoryPoints  :  function(game_mod) {

	// protestant spaces track
	let base = game_mod.returnProtestantSpacesTrackVictoryPoints().papacy;

        // burned protestant debaters
        for (let i = 0; i < game_mod.game.state.burned.length; i++) {
          let bd = game_mod.game.state.burned[i];
          if (game_mod.debaters[bd]) {
            if (game_mod.debaters[bd].faction == "protestant") {
              base += game_mod.debaters[bd].power;
            }
          }
        }

	// saint peters cathedral
 	base += game_mod.game.state.saint_peters_cathedral['vp'];

        return base;

      },
    });
 



    this.importFaction('faction6', {
      id		:	"faction6" ,
      key		: 	"protestant",
      name		: 	"Protestants",
      nickname		: 	"Protestants",
      capitals		:	[] ,
      img		:	"protestant.png",
      admin_rating	:	2,
      cards_bonus	:	0,
      returnCardsDealt  :       function(game_mod) {
	let base = 4; 
        let kc = game_mod.returnNumberOfElectoratesControlledByProtestants(1); // 1 = political control
        if (kc > 4) { base += 1; }
        if (game_mod.game.state.leaders.luther == 1) { base += 0; }
	base += game_mod.game.state.protestant_card_bonus;
	return base;
      },

      returnAdminRating  :       function(game_mod) {
	if (game_mod.game.state.leaders.luther == 1) { return 2; }
	if (game_mod.game.state.leaders.calvin == 1) { return 1; }
	return 0;
      },

      calculateBaseVictoryPoints  : function(game_mod) {
	// 2 VP for every electorate that is under Protesant religious + political control
        let base = 0;
        base += (2 * game_mod.returnNumberOfProtestantElectorates());        
        return base;
      },

      calculateBonusVictoryPoints  :    function(game_mod) {
	// + VP from disgraced papal debaters
	let bonus_vp_points = 0;
	bonus_vp_points += parseInt(game_mod.game.state.papal_debaters_disgraced_vp);
	bonus_vp_points += parseInt(game_mod.game.state.protestant_war_winner_vp);
        return bonus_vp_points;
      }
,
      calculateSpecialVictoryPoints  :  function(game_mod) {

	// protestant spaces track
        let base = game_mod.returnProtestantSpacesTrackVictoryPoints().protestant;

	// burned papal debaters
	for (let i = 0; i < game_mod.game.state.burned.length; i++) {
	  let bd = game_mod.game.state.burned[i];
	  if (game_mod.debaters[bd]) {
	    if (game_mod.debaters[bd].faction == "papacy") {
	      base += game_mod.debaters[bd].power;
	    }
	  }
	}
	
	// 1 VP for each full bible translation
        if (game_mod.game.state.translations['full']['german'] == 10) { base++; }
        if (game_mod.game.state.translations['full']['french'] == 10) { base++; }
        if (game_mod.game.state.translations['full']['english'] == 10) { base++; }

        return base;
      },
    });
 



    this.importFaction('faction10', {
      id                :       "faction10" ,
      key               :       "scotland" ,
      name              :       "Scotland",
      nickname          :       "Scotland",
    });



    this.importFaction('faction9', {
      id                :       "faction9" ,
      key               :       "venice" ,
      name              :       "Venice",
      nickname          :       "Venice",
    });



    this.importArmyLeader('suleiman', {
      type		:	"suleiman" ,
      name		: 	"Suleiman",
      personage		:	true,
      army_leader	:	true,
      img		:	"Suleiman.svg",
      battle_rating	:	2,
      command_value	:	12,
    });
 
    this.importArmyLeader('ibrahim-pasha', {
      type		:	"ibrahim-pasha" ,
      name		: 	"Ibrahim Pasha",
      personage		:	true,
      army_leader	:	true,
      img		:	"Ibrahim.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
  
    this.importArmyLeader('charles-v', {
      type		:	"charles-v" ,
      name		: 	"Charles V",
      personage		:	true,
      army_leader	:	true,
      img		:	"Charles_V.svg",
      battle_rating	:	2,
      command_value	:	10,
    });
 
    this.importArmyLeader('duke-of-alva', {
      type		:	"duke-of-alva" ,
      name		: 	"Duke of Alva",
      personage		:	true,
      army_leader	:	true,
      img		:	"Duke_of_Alva.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('ferdinand', {
      type		:	"ferdinand" ,
      name		: 	"Ferdinand",
      personage		:	true,
      army_leader	:	true,
      img		:	"Ferdinand.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('henry-viii', {
      type		:	"henry-viii" ,
      name		: 	"Henry VIII",
      personage		:	true,
      army_leader	:	true,
      img		:	"Henry_VIII.svg",
      battle_rating	:	1,
      command_value	:	8,
    });
 
    this.importArmyLeader('charles-brandon', {
      type		:	"charles-brandon" ,
      name		: 	"Charles Brandon",
      personage		:	true,
      army_leader	:	true,
      img		:	"Brandon.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('francis-i', {
      type		:	"francis-i" ,
      name		: 	"Francis I",
      personage		:	true,
      army_leader	:	true,
      img		:	"Francis_I.svg",
      battle_rating	:	1,
      command_value	:	8,
    });

    this.importArmyLeader('henry-ii', {
      type		:	"henry-ii" ,
      name		: 	"Henry II",
      personage		:	true,
      army_leader	:	true,
      img		:	"Henry_II.svg",
      battle_rating	:	0,
      command_value	:	8,
    });
 
    this.importArmyLeader('montmorency', {
      type		:	"montmorency" ,
      name		: 	"Montmorency",
      personage		:	true,
      army_leader	:	true,
      img		:	"Montmorency.svg",
      battle_rating	:	1,
      command_value	:	6,
    });
 
    this.importArmyLeader('andrea-doria', {
      type		:	"andrea-doria" ,
      name		: 	"Andrea Doria",
      personage		:	true,
      army_leader	:	true,
      img		:	"Andrea_Doria.svg",
      battle_rating	:	2,
      command_value	:	0,
    });

    this.importArmyLeader('maurice-of-saxony', {
      type		:	"maurice-of-saxony" ,
      name		: 	"Maurice of Saxony",
      personage		:	true,
      army_leader	:	true,
      img		:	"Maurice_Protestant.svg", // "Maurice_Hapsburg.svg"
      battle_rating	:	1,
      command_value	:	6,
    });

    this.importArmyLeader('dudley', {
      type              :       "dudley" ,
      name              :       "Dudley",
      personage         :       true,
      army_leader       :       true,
      img               :       "Dudley.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('john-frederick', {
      type              :       "john-frederick" ,
      name              :       "John Frederick",
      personage         :       true,
      army_leader       :       true,
      img               :       "John_Frederick.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('philip-hesse', {
      type              :       "philip-hesse" ,
      name              :       "Philip Hesse",
      personage         :       true,
      army_leader       :       true,
      img               :       "Philip_Hesse.svg",
      battle_rating     :       0,
      command_value     :       6,
    });

    this.importArmyLeader('renegade', {
      type              :       "renegade" ,
      name              :       "Renegade Leader",
      personage         :       true,
      army_leader       :       true,
      img               :       "Renegade.svg",
      battle_rating     :       1,
      command_value     :       6,
    });



/************************

Habsburg conquistadores:
1. Pizarro 3
2. Montejo 2
3. Cortez 4
4. Cordova 1
5. Coronado 1

************************/


      /***** English Conquistadors *****/
      this.importConquistador('english-conquistador1', {
	   faction	     :       "england",
           type              :       "english-conquistador1" ,
           name              :       "Conquistador",
           personage         :       true,
           img               :       "/his/img/tiles/england/English_Conquest.svg",
	   power	     :	     0,
      });
      this.importConquistador('english-conquistador2', {
	   faction	     :       "england",
           type              :       "english-conquistador2" ,
           name              :       "Conquistador",
           personage         :       true,
           img               :       "/his/img/tiles/england/English_Conquest.svg",
	   power	     :	     0,
      });


      /***** French Conquistadors *****/
      this.importConquistador('french-conquistador1', {
	   faction	     :       "france",
           type              :       "french-conquistador1" ,
           name              :       "Conquistador",
           personage         :       true,
           img               :       "/his/img/tiles/france/French_Conquest.svg",
	   power	     :	     0,
      });
      this.importConquistador('french-conquistador2', {
	   faction	     :       "france",
           type              :       "french-conquistador2" ,
           name              :       "Conquistador",
           personage         :       true,
           img               :       "/his/img/tiles/france/French_Conquest.svg",
	   power	     :	     0,
      });

      /***** Hapsburg Conquistadors *****/
      this.importConquistador('pizarro', {
	   faction	     :       "hapsburg",
           type              :       "pizarro" ,
           name              :       "Francisco Pizarro",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Pizarro.svg",
	   power	     :	     3,
      });
      this.importConquistador('montejo', {
	   faction	     :       "hapsburg",
           type              :       "montejo" ,
           name              :       "Francisco de Montejo",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Montejo.svg",
	   power	     :	     2,
      });
      this.importConquistador('cordova', {
	   faction	     :       "hapsburg",
           type              :       "cordova" ,
           name              :       "Neisa Cordova",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Cordova.svg",
	   power	     :	     4,
      });

      this.importConquistador('coronado', {
	   faction	     :       "hapsburg",
           type              :       "coronado" ,
           name              :       "Francisco VÃ¡zquez de Coronado",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Coronado.svg",
	   power	     :	     1,
      });

      this.importConquistador('cortez', {
	   faction	     :       "hapsburg",
           type              :       "cortez" ,
           name              :       "Hernan Cortes",
           personage         :       true,
           img               :       "/his/img/tiles/conquistadors/Cortez.svg",
	   power	     :	     1,
      });



    ////////////////
    // PROTESTANT //
    ////////////////
    this.importDebater('luther-debater', {
      type		:	"luther-debater" ,
      name		: 	"Martin Luther",
      img		:	"LutherDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	4,
      ability		:	"Bonus CP for translation in German zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_german_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'luther-debater', html : `<li class="option" id="luther-debater">Martin Luther +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone" && his_self.canPlayerCommitDebater("protestant", "luther-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tluther-debater\t1");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tgerman");
          his_self.endTurn();
        } 
        return 0; 
      },
    });
    this.importDebater('melanchthon-debater', {
      type		:	"melanchthon-debater" ,
      name		: 	"Philip Melanchthon",
      img		:	"MelanchthonDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"Bonus CP for translation in German zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_german_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'melanchthon-debater', html : `<li class="option" id="melanchthon-debater">Melanchthon +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone"  && his_self.canPlayerCommitDebater("protestant", "melanchthon-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_german_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tmelanchthon-debater\t1");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tgerman");
          his_self.endTurn();
        } 
        return 0; 
      },
    });






    this.importDebater('zwingli-debater', {
      type		:	"zwingli-debater" ,
      name		: 	"Ulrich Zwingli",
      img		:	"ZwingliDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Zurich" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'zwingli-debater', html : `<li class="option" id="zwingli-debater">Ulrich Zwingli +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "zwingli-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["zurich","basel","innsbruck","strasburg","besancon","geneva","trent","salzburg","augsburg"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("ulrich_zwingli");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "ulrich_zwingli") {
	  his_self.commitDebater("protestant", "zwingli-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["zurich","basel","innsbruck","strasburg","besancon","geneva","trent","salzburg","augsburg"];
	}
        return 1;
      }
    });

    this.importDebater('bucer-debater', {
      type		:	"bucer-debater" ,
      name		: 	"Martin Bucer",
      img		:	"BucerDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Strasburg" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'bucer-debater', html : `<li class="option" id="bucer-debater">Martin Bucer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "bucer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["strasburg","zurich","basel","geneva","dijon","besancon","stdizier","metz","liege","trier","mainz","nuremberg","worms","augsburg"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("martin_bucer");
	  his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "martin_bucer") {
	  his_self.commitDebater("protestant", "bucer-debater");
	  his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["strasburg","zurich","basel","geneva","dijon","besancon","stdizier","metz","liege","trier","mainz","nuremberg","worms","augsburg"];
	  his_self.game.queue.splice(qe, 1);
	  return 1;
	}
        return 1;
      }
    });
    this.importDebater('oekolampadius-debater', {
      type		:	"oekolampadius-debater" ,
      name		: 	"Johannes Oekolampadius",
      img		:	"OekolampadiusDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 for Reformation attempts within 2 spaces of Basel" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'oekolampadius-debater', html : `<li class="option" id="oekolampadius-debater">Johannes Oekolampadius +1 Bonus</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation"  && his_self.canPlayerCommitDebater("protestant", "oekolampadius-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["basel","zurich","innsbruck","strasburg","besancon","geneva","turin","grenoble","lyon","dijon","metz"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("oekolampadius");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "oekolampadius") {
	  his_self.commitDebater("protestant", "oekolampdius-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["basel","zurich","innsbruck","strasburg","besancon","geneva","turin","grenoble","lyon","dijon","metz"];
	}
        return 1;
      }
    });



    this.importDebater('bullinger-debater', {
      type		:	"bullinger-debater" ,
      name		: 	"Heinrich Bullinger",
      img		:	"BullingerDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Insert in 2nd round of debate in any Language Zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "debate") {
          return { faction : "protestant" , event : 'bullinger-debater', html : `<li class="option" id="bullinger-debater">substitute Bullinger</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu === "debate" && his_self.canPlayerCommitDebater("protestant", "bullinger-debater")) {
	  if (his_self.game.state.theological_debate.round === 2) {
            if (faction === "protestant") {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "debate") {
	  if (his_self.game.state.theological_debate.attacker === "papacy") {
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater\tbullinger-debater");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_power\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_bonus\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tround2_defender_debater\tbullinger-debater");
	  } else {
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tattacker_debater\tbullinger-debater");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tdefender_debater_power\t2");
            his_self.addMove("SETVAR\tstate\tevents\ttheological_debate\tround2_attacker_debater\tbullinger-debater");
	  }
          his_self.endTurn();
        }
        return 0;
      },

    });


    this.importDebater('carlstadt-debater', {
      type		:	"carlstadt-debater" ,
      name		: 	"Andreas Carlstadt",
      img		:	"CarlstadtDebater.svg",
      language_zone	:	"german" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"Target 3 German spaces with Treatise, unrest if fails" ,
      committed		: 	0,
      //
      // implemented in his-player, since provides +1 bonus target for publish treastise in German zone
      //
    });





    ////////////
    // PAPACY //
    ////////////
    this.importDebater('cajetan-debater', {
      type		:	"cajetan-debater" ,
      name		: 	"Thomas Cajetan",
      img		:	"CajetanDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	1 ,
      ability		:	"Target 3 spaces with burn books" ,
      committed		: 	0,
      //
      // ability implemented in his-player.js burnBooks
      //
    });
    this.importDebater('caraffa-debater', {
      type		:	"caraffa-debater" ,
      name		: 	"Carlo Caraffa",
      img		:	"CaraffaDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"Target 3 spaces in any zone with burn books" ,
      committed		: 	0,
      //
      // ability implemented in his-player.js burnBooks
      //
    });


    this.importDebater('eck-debater', {
      type		:	"eck-debater" ,
      name		: 	"Johann Eck",
      img		:       "EckDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die in Debate Attacks" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });
    this.importDebater('gardiner-debater', {
      type		:	"gardiner-debater" ,
      name		: 	"Stephen Gardiner",
      img		:	"GardinerDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die in debate in English zone if attacker" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });

    this.importDebater('aleander-debater', {
      type		:	"aleander-debater" ,
      name		: 	"Hieronymus Aleander",
      img		:       "AleanderDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"If concludes debate, winner flips an extra space" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic - note, can benefit protestants too
      //
    });

    this.importDebater('campeggio-debater', {
      type		:	"campeggio-debater" ,
      name		: 	"Lorenzo Campeggio",
      img		:	"CampeggioDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"Roll die after debate loss; if 5 or 6 result is ignored" ,
      committed		: 	0,
      //
      // implemented in his-gameloop in debate logic
      //
    });





    this.importDebater('loyola-debater', {
      type		:	"loyola-debater" ,
      name		: 	"Ignatius Loyola",
      img		:	"LoyolaDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	4 ,
      ability		:	"Found Jesuit University for only 2 CP" ,
      committed		: 	0,
      //
      // implemented in his-player -- foundJesuitUniversityWithLoyola
      //
    });

    this.importDebater('pole-debater', {
      type		:	"pole-debater" ,
      name		: 	"Reginald Pole",
      img		:	"PoleDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die for Papacy if at Council of Trent" ,
      committed		: 	0,
    });

    this.importDebater('tetzel-debater', {
      type		:	"tetzel-debater" ,
      name		: 	"Johann Tetzel ",
      img		:	"TetzelDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	1 ,
      ability		:	"1 CP to Saint Peters with Burn Books" ,
      committed		: 	0,
      //
      // implemented in his_player
      //
    });






    this.importDebater('canisius-debater', {
      type		:	"canisius-debater" ,
      name		: 	"Peter Canisius",
      img		:	"CanisiusDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+1 die for Counter-Reformation attempts within 2 spaces of Regensburg" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'canisius-debater', html : `<li class="option" id="canisius-debater">Peter Canisius +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "canisius-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player && ["regensburg","prague","vienna","linz","graz","salzburg","innsbruck","augsburg","worms","nuremberg","leipzig","mainz","kassal"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("peter_canisius");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "peter_canisius") {
	  his_self.commitDebater("papacy", "canisius-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;
	  his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = ["regensburg","prague","vienna","linz","graz","salzburg","innsbruck","augsburg","worms","nuremberg","leipzig","mainz","kassal"];
        }
        return 1;
      }
    });





    this.importDebater('contarini-debater', {
      type		:	"contarini-debater" ,
      name		: 	"Gasparo Contarini",
      img		:	"ContariniDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	2 ,
      ability		:	"+1 die for Counter-Reformations within 2 spaces of Charles V" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'contarini-debater', html : `<li class="option" id="contarini-debater">Gasparo Contarini +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "contarini-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
	    let cx = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	    if (cx) {
	      let targets = [];
	      if (his_self.spaces[cx]) {
	        targets.push(cx);

	        for (let i = 0; i < his_self.spaces[cx].neighbours.length; i++) {

		  let x = his_self.spaces[cx].neighbours[i];
		  if (!targets.includes(x)) { targets.push(x); }

	          for (let ii = 0; ii < his_self.spaces[x].neighbours.length; ii++) {
		    let y = his_self.spaces[x].neighbours[ii];
		    if (!targets.includes(y)) { targets.push(y); }
	  	  }
	        }
	      }
	      if (targets.includes(spacekey)) {
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("gasparo_contarini");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "gasparo_contarini") {
	  his_self.commitDebater("papacy", "contarini-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;

          let cx = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
          if (his_self.spaces[cx]) {
            let targets = [];
            targets.push(cx);

            for (let i = 0; i < his_self.spaces[cx].neighbours.length; i++) {

              let x = his_self.spaces[cx].neighbours[i];
              if (!targets.includes(x)) { targets.push(x); }

              for (let ii = 0; ii < his_self.spaces[x].neighbours.length; ii++) {
                let y = his_self.spaces[x].neighbours[ii];
                if (!targets.includes(y)) { targets.push(y); }
              }
            }
          }

          his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = targets;
        }
        return 1;
      }
    });

    this.importDebater('faber-debater', {
      type		:	"faber-debater" ,
      name		: 	"Peter Faber",
      img		:	"FaberDebater.svg",
      language_zone	:	"any" ,
      faction		:	"papacy" ,
      power		:	3 ,
      ability		:	"+2 die for Counter-Reformations against an Electorate" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "catholic_counter_reformation") {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'faber-debater', html : `<li class="option" id="faber-debater">Peter Faber +1 Roll</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "catholic_counter_reformation" && his_self.canPlayerCommitDebater("papacy", "faber-debater")) {
          let p = his_self.returnPlayerOfFaction("papacy");
          if (p === his_self.game.player) {
	    if (["augsburg","trier","cologne","wittenberg","mainz","brandenburg"].includes(spacekey)) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "catholic_counter_reformation") {
          his_self.addMove("peter_faber");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "peter_faber") {
	  his_self.commitDebater("papacy", "faber-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_catholic_counter_reformation_bonus++;
	  his_self.game.state.tmp_catholic_counter_reformation_bonus_spaces = ["augsburg","trier","cologne","wittenberg","mainz","brandenburg"];
        }
        return 1;
      }
    });






    ////////////
    // FRENCH //
    ////////////
    this.importDebater('calvin-debater', {
      type		:	"calvin-debater" ,
      name		: 	"John Calvin",
      img		:	"CalvinDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	4 ,
      ability		:	"Target 3 French-speaking spaces with a treatise" ,
      committed		: 	0,
      //
      // implemented in his-player
      //
    });

    this.importDebater('cop-debater', {
      type		:	"cop-debater" , 
     name		: 	"Nicolas Cop",
      img		:	"CopDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation attempts within 2 spaces of Paris" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'cop-debater', html : `<li class="option" id="cop-debater">Nicholas Cop +1 Roll</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "cop-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player && ["paris","stdizier","dijon","orleans","rouen","boulogne","stquentin","calais","brussels","metz","besancon","lyon","tours","nantes"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("nicholas_cop");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "nicholas_cop") {
          his_self.commitDebater("protestant", "cop-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["paris","stdizier","dijon","orleans","rouen","boulogne","stquentin","calais","brussels","metz","besancon","lyon","tours","nantes"];
        }
        return 1;
      }
    });

    this.importDebater('farel-debater', {
      type		:	"farel-debater" ,
      name		: 	"William Farel",
      img		:	"FarelDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation attempts within 2 spaces of Geneva" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'farel-debater', html : `<li class="option" id="farel-debater">William Farel +1 Roll</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "farel-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player && ["geneva","besancon","basel","strasburg","zurich","metz","dijon","lyon","orleans","limoges","avignon","grenoble","turin","milan","pavia","genoa"].includes(spacekey)) {
           return 1;
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("william_farel");
          his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "william_farel") {
          his_self.commitDebater("protestant", "farel-debater");
          his_self.game.queue.splice(qe, 1);
          his_self.game.state.tmp_protestant_reformation_bonus++;
          his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["geneva","besancon","basel","strasburg","zurich","metz","dijon","lyon","orleans","limoges","avignon","grenoble","turin","milan","pavia","genoa"];
        }
        return 1;
      }

    });

    this.importDebater('olivetan-debater', {
      type		:	"olivetan-debater" ,
      name		: 	"Pierre Robert Olivetan",
      img		:	"OlivetanDebater.svg",
      language_zone	:	"french" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"Bonus CP for translation in French Zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_french_language_zone") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'olivetan-debater', html : `<li class="option" id="olivetan-debater">Olivetan +1 Bonus CP</li>` };
          }
        } 
        return {};
      },  
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_french_language_zone"  && his_self.canPlayerCommitDebater("protestant", "olivetan-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 && 
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_french_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tolivetan-debater\t1");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tfrench");
          his_self.endTurn();
          his_self.updateStatus("acknowledge");
        } 
        return 0; 
      },
    });





    /////////////
    // ENGLISH //
    /////////////
    this.importDebater('cranmer-debater', {
      type		:	"cranmer-debater" ,
      name		: 	"Thomas Cranmer",
      img		:	"CranmerDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"+1 die for Reformation within 2 spaces of London" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'cranmer-debater', html : `<li class="option" id="cranmer-debater">Thomas Cranmer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "cranmer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["london","portsmouth","norwich","plymouth","bristol","wales","shrewsbury","carlisle","york","lincoln"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("thomas_cranmer");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "thomas_cranmer") {
	  his_self.commitDebater("protestant", "cranmer-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["london","portsmouth","norwich","plymouth","bristol","wales","shrewsbury","carlisle","york","lincoln"];
	}
        return 1;
      }
    });

    this.importDebater('wishart-debater', {
      type		:	"wishart-debater" ,
      name		: 	"George Wishart",
      img		:	"WishartDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"+1 die for Reformation attempts in Scotland" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'wishart-debater', html : `<li class="option" id="wishart-debater">George Wishart +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "wishart-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["stirling","glasgow","edinburgh"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("george_wishart");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "george_wishart") {
	  his_self.commitDebater("protestant", "wishart-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["stirling","glasgow","edinburgh"];
	}
        return 1;
      }
    });

    this.importDebater('latimer-debater', {
      type		:	"latimer-debater" ,
      name		: 	"Hugh Latimer",
      img		:	"LatimerDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	1 ,
      ability		:	"+1 die for Reformation attempts in England" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'latimer-debater', html : `<li class="option" id="latimer-debater">Hugh Latimer +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "latimer-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("hugh_latimer");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "hugh_latimer") {
	  his_self.commitDebater("protestant", "latimer-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich"];
	}
        return 1;
      }
    });

    this.importDebater('knox-debater', {
      type		:	"knox-debater" ,
      name		: 	"John Knox",
      img		:	"KnoxDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	3 ,
      ability		:	"+1 die for Reformation Attempts in England or Scotland" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "protestant_reformation") {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player) {
            return { faction : extra , event : 'knox-debater', html : `<li class="option" id="knox-debater">John Knox +1 Roll</li>` };
          }
        } 
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "protestant_reformation" && his_self.canPlayerCommitDebater("protestant", "knox-debater")) {
	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (p === his_self.game.player && ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich","glasgow","edinburgh","stirling"].includes(spacekey)) { 
           return 1;
          }
        }
        return 0;
      },  
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "protestant_reformation") {
          his_self.addMove("john_knox");
          his_self.endTurn();
        } 
        return 0; 
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] == "john_knox") {
	  his_self.commitDebater("protestant", "knox-debater");
	  his_self.game.queue.splice(qe, 1);
	  his_self.game.state.tmp_protestant_reformation_bonus++;
	  his_self.game.state.tmp_protestant_reformation_bonus_spaces = ["carlisle","berwick","york","lincoln","shrewsbury","wales","bristol","plymouth","portsmouth","london","norwich","glasgow","edinburgh","stirling"];
	}
        return 1;
      }
    });


    this.importDebater('tyndale-debater', {
      type		:	"tyndale-debater" ,
      name		: 	"William Tyndale",
      img		:	"TyndaleDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Bonus CP for translation in English zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_english_language_zone") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'tyndale-debater', html : `<li class="option" id="tyndale-debater">William Tyndale +1 Bonus CP</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone"  && his_self.canPlayerCommitDebater("protestant", "tyndale-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      }, 
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\ttyndale-debater\t1");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tenglish");
          his_self.endTurn();
        }
        return 0;
      },
    });

    this.importDebater('coverdale-debater', {
      type		:	"coverdale-debater" ,
      name		: 	"Myles Coverdale",
      img		:	"CoverdaleDebater.svg",
      language_zone	:	"english" ,
      faction		:	"protestant" ,
      power		:	2 ,
      ability		:	"Bonus CP for translation in English zone" ,
      committed		: 	0,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "translation_english_language_zone") {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            return { faction : extra , event : 'coverdale-debater', html : `<li class="option" id="coverdale-debater">Myles Coverdale +1 Bonus CP</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone"  && his_self.canPlayerCommitDebater("protestant", "coverdale-debater")) {
          let p = his_self.returnPlayerOfFaction("protestant");
          if (p === his_self.game.player) {
            if (his_self.game.state.players_info[player-1].tmp_debaters_committed_reformation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_translation == 0 &&
              his_self.game.state.players_info[player-1].tmp_debaters_committed_counter_reformation == 0) {
                return 1;
            }
          }
        }
        return 0;
      }, 
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "translation_english_language_zone") {
          his_self.addMove("insert_before_counter_or_acknowledge\tcommit\tprotestant\tcoverdale-debater\t1");
          his_self.addMove("insert_before_counter_or_acknowledge\ttranslation\tenglish");
          his_self.endTurn();
        }
        return 0;
      },
    });


      /***** English Explorers *****/

      this.importExplorer('chancellor', {
           faction           :       "england" ,
           type              :       "chancellor" ,
           name              :       "Chancellor",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Chancellor.svg",
           power	     :       1,
      });

      this.importExplorer('willoughby', {
           faction           :       "england" ,
           type              :       "willoughby" ,
           name              :       "Hugh Willoughby",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Willoughby.svg",
           power	     :       0,
      });

      this.importExplorer('rut', {
           faction           :       "england" ,
           type              :       "rut" ,
           name              :       "John Rut",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Rut.svg",
           power	     :       0,
      });



      /***** French Explorers *****/

      this.importExplorer('cartier', {
           faction           :       "france" ,
           type              :       "cartier" ,
           name              :       "Jacques Cartier",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Cartier.svg",
           power	     :       3,
      });

      this.importExplorer('roberval', {
           faction           :       "france" ,
           type              :       "roberval" ,
           name              :       "Jean-FranÃ§ois de La Rocque de Roberval",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Roberval.svg",
           power	     :       1,
      });

      this.importExplorer('verrazano', {
           faction           :       "france" ,
           type              :       "verrazano" ,
           name              :       "Giovanni da Verrazano" ,
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Verrazano.svg",
           power	     :       2,
      });



      /***** Hapsburg Explorers *****/

      this.importExplorer('orellana', {
           faction           :       "hapsburg" ,
           type              :       "orellana",
           name              :       "Hector Rodrigo Enriquez Orellana",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Orellana.svg",
           power	     :       3,
      });

      this.importExplorer('magellan', {
           faction           :       "hapsburg" ,
           type              :       "magellan" ,
           name              :       "Ferdinand Magellan",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Magellan.svg",
           power	     :       4,
      });

      this.importExplorer('leon', {
           faction           :       "hapsburg" ,
           type              :       "leon" ,
           name              :       "Leon",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Leon.svg",
           power	     :       1,
      });

      this.importExplorer('narvaez', {
           faction           :       "hapsburg" ,
           type              :       "narvaez" ,
           name              :       "Sofia Narvaez",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/Narvaez.svg",
           power	     :       -1,
      });

      this.importExplorer('de-vaca', {
           faction           :       "hapsburg" ,
           type              :       "de-vaca" ,
           name              :       "Cabeza De Vaca",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/De_Vaca.svg",
           power	     :       0,
      });

      this.importExplorer('de-soto', {
           faction           :       "hapsburg" ,
           type              :       "de-soto" ,
           name              :       "DeSoto",
           personage         :       true,
           img               :       "/his/img/tiles/explorers/DeSoto.svg",
           power	     :       2,
      });



    this.importNavyLeader('barbarossa', {
      type		:	"barbarossa" ,
      name		: 	"Barbarossa",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Barbarossa.svg",
      battle_rating	:	2,
      piracy_rating	:	1,
    });
 
    this.importNavyLeader('dragut', {
      type		:	"dragut" ,
      name		: 	"Dragut",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Dragut.svg",
      battle_rating	:	1,
      piracy_rating	:	2,
    });
 
    this.importNavyLeader('andrea-doria', {
      type		:	"andrea-doria" ,
      name		: 	"Andrea Doria",
      personage		:	true,
      navy_leader	:	true,
      img		:	"Andrea_Doria.svg",
      battle_rating	:	2,
      piracy_rating	:	0,
    });
 


      this.importReformer('calvin-reformer', {
           type              :       "calvin-reformer" ,
           name              :       "John Calvin",
           reformer          :       true,
           img               :       "CalvinReformer.svg",
	   spacekey	     :	     "geneva",
      });

      this.importReformer('cranmer-reformer', {
           type              :       "cranmer-reformer" ,
           name              :       "Thomas Cranmer ",
           reformer          :       true,
           img               :       "CranmerReformer.svg",
	   spacekey	     :	     "london",
      });

      this.importReformer('luther-reformer', {
           type              :       "luther-reformer" ,
           name              :       "Martin Luther",
           reformer          :       true,
           img               :       "LutherReformer.svg",
	   spacekey	     :	     "wittenberg",
      });

      this.importReformer('zwingli-reformer', {
           type              :       "zwingli-reformer" ,
           name              :       "Huldrych Zwingli",
           reformer          :       true,
           img               :       "ZwingliReformer.svg",
	   spacekey	     :	     "zurich",
      });


    this.importUnit('regular', {
      type		:	"regular" ,
      name		: 	"Regular",
    });
 
    this.importUnit('mercenary', {
      type		:	"mercenary" ,
      name		: 	"Mercenary",
    });
 
    this.importUnit('cavalry', {
      type		:	"cavalry" ,
      name		: 	"Cavalry",
    });
 
    this.importUnit('squadron', {
      type		:	"squadron" ,
      name		: 	"Squadron" ,
      land_or_sea	:	"sea" ,
    });

    this.importUnit('corsair', {
      type		:	"corsair" ,
      name		: 	"Corsair" ,
      land_or_sea	:	"sea" ,
    });

    this.importUnit('debater', {
      type		:	"debater" ,
      name		: 	"Debater",
      debater		:	true,
    });
 
    this.importUnit('reformer', {
      type		:	"reformer" ,
      name		: 	"Reformer",
      reformer		:	true,
    });
 





    this.importWife('anne-boleyn', {
      type		:	"anne-boleyn" ,
      name		: 	"Anne Boleyn",
      personage		:	true,
      img		:	"AnneBoleyn.svg",
    });

    this.importWife('anne-cleves', {
      type		:	"anne-cleves" ,
      name		: 	"Anne Cleves",
      personage		:	true,
      img		:	"AnneCleves.svg",
    });

    this.importWife('catherine-aragon', {
      type		:	"catherine-aragon" ,
      name		: 	"Catherine Aragon",
      personage		:	true,
      img		:	"CatherinAragon.svg",
    });

    this.importWife('jane-seymour', {
      type		:	"jane-seymour" ,
      name		: 	"Jane Seymour",
      personage		:	true,
      img		:	"JaneSeymour.svg",
    });

    this.importWife('katherine-parr', {
      type		:	"katherine-parr" ,
      name		: 	"Katherine Parr",
      personage		:	true,
      img		:	"KatherineParr.svg",
    });

    this.importWife('kathryn-howard', {
      type		:	"kathryn-howard" ,
      name		: 	"Kathryn Howard",
      personage		:	true,
      img		:	"KathrynHoward.svg",
    });


    let first_time_running = 0;

    //
    // initialize
    //
    if (!this.game.state) {

      first_time_running = 1;
      this.game.state = this.returnState();
      this.game.state.players_info = this.returnPlayers(this.game.players.length);
      this.game.spaces = this.returnSpaces();
      this.game.navalspaces = this.returnNavalSpaces();

console.log("PLAYERS INFO: " + JSON.stringify(this.game.state.players_info));

console.log("\n\n\n\n");
console.log("---------------------------");
console.log("---------------------------");
console.log("------ INITIALIZE GAME ----");
console.log("---------------------------");
console.log("---------------------------");
console.log("---------------------------");
console.log("DECK: " + this.game.options.deck);
console.log("\n\n\n\n");

      this.updateStatus("<div class='status-message' id='status-message'>Generating the Game</div>");

      //
      // Game Queue
      //
      this.game.queue.push("round");

//      let deck2 = JSON.parse(JSON.stringify(this.deck));
//      delete deck2['001'];
//      delete deck2['002'];
//      delete deck2['003'];
//      delete deck2['004'];
//      delete deck2['005'];
//      delete deck2['006'];
//      delete deck2['007'];
//      delete deck2['008'];
//
//      this.game.queue.push("DECK\t1\t"+JSON.stringify(deck2));
     this.game.queue.push("DECK\t1\t"+JSON.stringify({})); 
     this.game.queue.push("init");

    }

    //
    // attach events to spaces
    //
    this.spaces = {};
    for (let key in this.game.spaces) {
      this.spaces[key] = this.importSpace(this.game.spaces[key], key);
    }
    this.navalspaces = {};
    for (let key in this.game.navalspaces) {
      this.navalspaces[key] = this.importSpace(this.game.navalspaces[key], key);
    }

    //
    // add initial units
    //
    if (first_time_running == 1) {

      //
      // 1517 scenario
      //
      if (this.game.options.scenario === "1517") {

	//
	// 1517 wars and allies / diplomatic situation
	//
	this.setEnemies("hapsburg", "france");
	this.setEnemies("papacy", "france");
	this.setEnemies("ottoman", "hungary");

        //
        // 2P variant
        //
        if (this.game.players.length == 2) {

	  this.unsetEnemies("papacy", "france");
	  this.unsetEnemies("hapsburg", "france");
	  this.unsetEnemies("ottoman", "hungary");

	  // OTTOMAN
          this.addRegular("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
	  this.addRegular("ottoman", "buda", 1);
	  this.addRegular("ottoman", "belgrade", 1);

	  this.controlSpace("ottoman", "pressburg");
	  this.controlSpace("ottoman", "agram");
	  this.controlSpace("ottoman", "mohacs");
	  this.controlSpace("ottoman", "szegedin");

	  // HAPSBURG
          this.addRegular("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "tunis", 1);
          this.controlSpace("hapsburg", "tunis");
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 1);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  this.addRegular("hapsburg", "vienna", 4);
	  this.addRegular("hapsburg", "antwerp", 1);
	  this.addRegular("hapsburg", "valladolid", 1);


	  // ENGLAND
          this.addRegular("england", "london", 1);
          this.addRegular("england", "calais", 1);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  // FRANCE
          this.addRegular("france", "paris", 1);
          this.addRegular("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 1);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);
          this.addRegular("france", "milan", 2);

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
	
	  // PROTESTANT
	
	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // HUNGARY
	  this.addRegular("hungary", "prague", 1);

	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 1);
	
	  // INDEPENDENT
          this.addRegular("independent", "rhodes", 1);
          this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "florence", 1);	

	  // DEBATERS
	  this.addDebater("papacy", "eck-debater");
	  this.addDebater("papacy", "campeggio-debater");
	  this.addDebater("papacy", "aleander-debater");
	  this.addDebater("papacy", "tetzel-debater");
	  this.addDebater("papacy", "cajetan-debater");

	  this.addDebater("protestant", "luther-debater");
	  this.addDebater("protestant", "melanchthon-debater");
	  this.addDebater("protestant", "bucer-debater");
	  this.addDebater("protestant", "carlstadt-debater");

	  // CUSTOMIZED CONTROL
	  this.controlSpace("hapsburg", "prague");
	  this.controlSpace("hapsburg", "brunn");
	  this.controlSpace("hapsburg", "breslau");
	  this.controlSpace("ottoman", "buda");
	  this.controlSpace("ottoman", "belgrade");
	  this.controlSpace("ottoman", "ragusa");

	  this.setAllies("hungary", "hapsburg");

	} else {

	  // OTTOMAN
          this.addArmyLeader("ottoman", "istanbul", "suleiman");
          this.addArmyLeader("ottoman", "istanbul", "ibrahim-pasha");
          this.addRegular("ottoman", "istanbul", 7);
          this.addCavalry("ottoman", "istanbul", 1);
          this.addNavalSquadron("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addNavalSquadron("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
          this.addNavalSquadron("ottoman", "athens", 1);

	  // HAPSBURG
	  this.addArmyLeader("hapsburg", "valladolid", "charles-v");
	  this.addArmyLeader("hapsburg", "valladolid", "duke-of-alva");
          this.addRegular("hapsburg", "valladolid", 4);
          this.addRegular("hapsburg", "seville", 1);
          this.addNavalSquadron("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addNavalSquadron("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "tunis", 1);
          this.controlSpace("hapsburg", "tunis");
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 1);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  //this.addArmyLeader("hapsburg", "vienna", "ferdinand");
          this.addRegular("hapsburg", "vienna", 4);
          this.addRegular("hapsburg", "antwerp", 1);

	  this.game.state.players_info[0].captured.push(JSON.parse(JSON.stringify(this.army["ferdinand"])));


	  // ENGLAND
          this.addArmyLeader("england", "london", "henry-viii");
          this.addArmyLeader("england", "london", "charles-brandon");
          this.addRegular("england", "london", 3);
          this.addNavalSquadron("england", "london", 1);
          this.addNavalSquadron("england", "portsmouth", 1);
          this.addRegular("england", "calais", 2);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  // FRANCE
          this.addArmyLeader("france", "paris", "francis-i");
          this.addArmyLeader("france", "paris", "montmorency");
          this.addRegular("france", "paris", 4);
          this.addRegular("france", "rouen", 1);
          this.addNavalSquadron("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 2);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);
          this.addRegular("france", "milan", 2);

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
	
	  // PROTESTANT
	
	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // HUNGARY
          this.addRegular("hungary", "belgrade", 1);
          this.addRegular("hungary", "buda", 5);
          this.addRegular("hungary", "prague", 1);

	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 3);
          this.addNavalSquadron("scotland", "edinburgh", 1);
	
	  // INDEPENDENT
          this.addRegular("independent", "rhodes", 1);
          this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "florence", 1);

	  // DEBATERS
	  this.addDebater("papacy", "eck-debater");
	  this.addDebater("papacy", "campeggio-debater");
	  this.addDebater("papacy", "aleander-debater");
	  this.addDebater("papacy", "tetzel-debater");
	  this.addDebater("papacy", "cajetan-debater");

	  this.addDebater("protestant", "luther-debater");
	  this.addDebater("protestant", "melanchthon-debater");
	  this.addDebater("protestant", "bucer-debater");
	  this.addDebater("protestant", "carlstadt-debater");

	}

      }

      //
      // 1532 scenario
      //
      if (this.game.options.scenario === "1532" || this.game.options.scenario === "tournament") {

	  this.game.state.starting_round = 4;
	  this.game.state.round = 3; // the one before 4

	  //
	  // 1532 wars and allies / diplomatic situation
	  //
	  this.setEnemies("hapsburg", "ottoman");
	  this.setAllies("hapsburg", "hungary");
	  this.setActivatedPower("hapsburg", "hungary");

	  // OTTOMAN
          this.addArmyLeader("ottoman", "istanbul", "suleiman");
          this.addArmyLeader("ottoman", "istanbul", "ibrahim-pasha");
          this.addRegular("ottoman", "istanbul", 5);
          this.addCavalry("ottoman", "istanbul", 1);
          this.addNavalSquadron("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addNavalSquadron("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
          this.addNavalSquadron("ottoman", "athens", 1);
          this.addNavyLeader("ottoman", "algiers", "barbarossa");
          this.addRegular("ottoman", "algiers", 2);
          this.addCorsair("ottoman", "algiers", 2);
          this.controlSpace("ottoman", "algiers");
          this.addRegular("ottoman", "buda", 3);
          this.addCavalry("ottoman", "buda", 1);
          this.controlSpace("ottoman", "buda");
          this.addRegular("ottoman", "belgrade", 1);
          this.controlSpace("ottoman", "belgrade");
          this.controlSpace("ottoman", "mohacs");
          this.controlSpace("ottoman", "szegedin");
          this.controlSpace("ottoman", "agram");
          this.controlSpace("ottoman", "rhodes");

	  this.game.state.ottoman_war_winner_vp = 2;
	  this.game.spaces["algiers"].pirate_haven = 1;
	  this.game.spaces["algiers"].home = "ottoman";


	  // HAPSBURG
	  this.addArmyLeader("hapsburg", "valladolid", "charles-v");
	  this.addArmyLeader("hapsburg", "valladolid", "duke-of-alva");
          this.addRegular("hapsburg", "valladolid", 4);
          this.addRegular("hapsburg", "seville", 1);
          this.addNavalSquadron("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addNavalSquadron("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 1);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  this.addArmyLeader("hapsburg", "vienna", "ferdinand");
          this.addRegular("hapsburg", "vienna", 4);
          this.addMercenary("hapsburg", "vienna", 2);

          this.addRegular("hapsburg", "antwerp", 3);
          this.controlSpace("hapsburg", "prague");
          this.controlSpace("hapsburg", "breslau");
          this.controlSpace("hapsburg", "brunn");
          this.controlSpace("hapsburg", "pressburg");
          this.controlSpace("hapsburg", "regensburg");
          this.controlSpace("hapsburg", "salzburg");
          this.controlSpace("hapsburg", "munster");
          this.controlSpace("hapsburg", "cologne");
          this.controlSpace("hapsburg", "trier");
          this.controlSpace("hapsburg", "basel");
          this.controlSpace("hapsburg", "zurich");
          this.controlSpace("hapsburg", "vienna");

	  this.game.state.hapsburg_war_winner_vp = 1;

          this.game.state.newworld['circumnavigation'].faction = "hapsburg";
          this.game.state.newworld['circumnavigation'].claimed = 1;
          this.game.state.newworld['pacificstrait'].faction = "hapsburg";
          this.game.state.newworld['pacificstrait'].claimed = 1;
          this.game.state.newworld['aztec'].faction = "hapsburg";
          this.game.state.newworld['aztec'].claimed = 1;

          this.game.state.newworld['hapsburg_colony1'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony1'].claimed = 1;
          this.game.state.newworld['hapsburg_colony2'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony2'].claimed = 1;

          this.game.state.colonies.push({
            faction : "hapsburg" ,
            resolved : 1 ,
	    colony : "hapsburg_colony1" ,
            round : 1 ,
	    name : "Puerto Rico",
	    img : "/his/img/tiles/colonies/PuertoRico.svg",
          });
	  this.game.state.colonies.push({
            faction : "hapsburg" ,
            resolved : 1 ,
	    colony : "hapsburg_colony2" ,
            round : 2 ,
	    name : "Cuba",
	    img : "/his/img/tiles/colonies/Cuba.svg",
          });

	  this.removeExplorer("hapsburg", "magellan");
	  this.removeExplorer("hapsburg", "leon");
	  this.removeExplorer("hapsburg", "narvaez");
	  this.removeConquistador("hapsburg", "cordova");

	  this.game.state['hapsburg_uncharted'] = 0;

	  // ENGLAND
          this.addArmyLeader("england", "london", "henry-viii");
          this.addArmyLeader("england", "london", "charles-brandon");
          this.addRegular("england", "london", 3);
          this.addMercenary("england", "london", 2);
          this.addNavalSquadron("england", "london", 1);
          this.addNavalSquadron("england", "plymouth", 1);
          this.addNavalSquadron("england", "portsmouth", 1);
          this.addRegular("england", "calais", 2);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  this.game.state.england_card_bonus = 1;
	  this.game.state.henry_viii_marital_status = 1;
	  this.game.state['england_uncharted'] = 0;

	  // FRANCE
          this.addArmyLeader("france", "paris", "francis-i");
          this.addArmyLeader("france", "paris", "montmorency");
          this.addRegular("france", "paris", 4);
          this.addMercenary("france", "paris", 2);
          this.addRegular("france", "rouen", 1);
          this.addNavalSquadron("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 2);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);

	  this.removeExplorer("france", "verrazano");

	  this.game.state.france_card_bonus = 1;
	  this.game.state['france_uncharted'] = 0;
	  this.game.state.french_chateaux_vp = 2;

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addMercenary("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
          this.addMercenary("papacy", "ravenna", 1);
	  this.controlSpace("papacy", "florence");
          this.addRegular("papacy", "florence", 1);
	  this.controlSpace("papacy", "siena");
	
          this.game.state.saint_peters_cathedral['state'] = 0;
          this.game.state.saint_peters_cathedral['vp'] = 1;
	  this.game.state.leaders.leo_x = 0;
	  this.game.state.events.clement_vii = 1;
	  this.game.state.leaders.clement_vii = 1;
	  this.game.state.already_excommunicated.push("luther-debater");

	  // PROTESTANT
	  this.addRegular("protestant", "brandenburg");	
	  this.addRegular("protestant", "wittenberg", 2);
	  this.addRegular("protestant", "mainz");	
	  this.addMercenary("protestant", "mainz", 2);	
	  this.addRegular("protestant", "augsburg", 2);	

          this.addReformer("protestant", "wittenberg", "luther-reformer");
          this.addArmyLeader("protestant", "brandenburg", "philip-hesse");
          this.addArmyLeader("protestant", "wittenberg", "john-frederick");

    	  this.game.state.augsburg_electoral_bonus = 1;
    	  this.game.state.mainz_electoral_bonus = 1;
    	  this.game.state.trier_electoral_bonus = 0;
    	  this.game.state.cologne_electoral_bonus = 0;
    	  this.game.state.wittenberg_electoral_bonus = 1;
    	  this.game.state.brandenburg_electoral_bonus = 1;

          this.game.state.translations['full']['german'] = 0;
          this.game.state.translations['full']['english'] = 0;
          this.game.state.translations['full']['french'] = 0;
          this.game.state.translations['new']['german'] = 6;
          this.game.state.translations['new']['english'] = 2;
          this.game.state.translations['new']['french'] = 4;

	  this.removeDebater("protestant", "zwingli-debater");
	  this.removeReformer("protestant", "geneva", "zwingli-debater");

	  this.convertSpace("protestant", "wittenberg");
	  this.convertSpace("protestant", "brandenburg");
	  this.convertSpace("protestant", "stettin");
	  this.convertSpace("protestant", "lubeck");
	  this.convertSpace("protestant", "magdeburg");

	  this.convertSpace("protestant", "leipzig");
	  this.convertSpace("protestant", "erfurt");
	  this.convertSpace("protestant", "nuremberg");
	  this.convertSpace("protestant", "hamburg");
	  this.convertSpace("protestant", "bremen");

	  this.convertSpace("protestant", "kassel");
	  this.convertSpace("protestant", "brunswick");
	  this.convertSpace("protestant", "mainz");
	  this.convertSpace("protestant", "worms");
	  this.convertSpace("protestant", "strasburg");

	  this.convertSpace("protestant", "basel");
	  this.convertSpace("protestant", "zurich");
	  this.convertSpace("protestant", "augsburg");
	  this.convertSpace("protestant", "breslau");


          // DEBATERS
          this.addDebater("papacy", "eck-debater");
          this.addDebater("papacy", "campeggio-debater");
          this.addDebater("papacy", "aleander-debater");
          this.addDebater("papacy", "contarini-debater");
          this.addDebater("papacy", "tetzel-debater");
          this.addDebater("papacy", "cajetan-debater");

          this.addDebater("protestant", "luther-debater");
          this.addDebater("protestant", "melanchthon-debater");
          this.addDebater("protestant", "bucer-debater");
          this.addDebater("protestant", "carlstadt-debater");
          this.addDebater("protestant", "bullinger-debater");
          this.addDebater("protestant", "oekolampadius-debater");
          this.addDebater("protestant", "tyndale-debater");

	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // HUNGARY
	  this.addRegular("hungary", "prague", 1);

	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 3);
          this.addNavalSquadron("scotland", "edinburgh", 1);
          this.game.spaces['stirling'].fortify = 1;
	
	  // INDEPENDENT
          this.controlSpace("independent", "basel");
          this.controlSpace("independent", "zurich");
          this.controlSpace("independent", "milan");
          this.controlSpace("independent", "tunis");	
          this.controlSpace("independent", "malta", 1);
          this.addRegular("independent", "malta", 1);
          this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "milan", 1);
          this.addRegular("independent", "tunis", 1);

	  // ALLIANCES
	  this.setEnemies("ottoman", "hapsburg");
	  this.setEnemies("hapsburg", "protestant");
	  this.setEnemies("papacy", "protestant");
	  this.setAllies("hapsburg", "hungary");

	  // DEBATERS         
          this.addDebater("protestant", "farel-debater");
          this.addDebater("protestant", "cop-debater");
          this.addDebater("protestant", "olivetan-debater");
          this.addDebater("protestant", "calvin-debater");
          this.addReformer("protestant", "geneva", "calvin-reformer");
          this.convertSpace("protestant", "geneva");


          this.game.state.events.barbary_pirates = 1;
          this.game.state.events.ottoman_piracy_enabled = 1;
          this.game.state.events.ottoman_corsairs_enabled = 1;

	  this.removeCardFromGame("009");
	  this.removeCardFromGame("008");

      }

      if (this.game.options.scenario === "is_testing") {


	  this.game.state.starting_round = 4;
	  this.game.state.round = 3; // the one before 4

	  //
	  // 1532 wars and allies / diplomatic situation
	  //
	  this.setEnemies("hapsburg", "ottoman");
	  this.setAllies("france", "genoa");
	  this.setAllies("hapsburg", "hungary");
	  this.setActivatedPower("hapsburg", "hungary");

	  this.addNavalSquadron("hapsburg", "gibraltar", 1);
	  this.addNavalSquadron("hapsburg", "gibraltar", 1);

	  // OTTOMAN
          this.addArmyLeader("ottoman", "istanbul", "suleiman");
          this.addArmyLeader("ottoman", "istanbul", "ibrahim-pasha");
          this.addRegular("ottoman", "istanbul", 5);
          this.addCavalry("ottoman", "istanbul", 1);
          this.addNavalSquadron("ottoman", "istanbul", 1);
          this.addRegular("ottoman", "edirne");
          this.addRegular("ottoman", "salonika", 1);
          this.addNavalSquadron("ottoman", "salonika", 1);
          this.addRegular("ottoman", "athens", 1);
          this.addNavalSquadron("ottoman", "athens", 1);
          this.addNavyLeader("ottoman", "algiers", "barbarossa");
          this.addRegular("ottoman", "algiers", 2);
          this.addCorsair("ottoman", "algiers", 2);
          this.controlSpace("ottoman", "algiers");
          this.addRegular("ottoman", "buda", 3);
          this.addCavalry("ottoman", "buda", 1);
          this.controlSpace("ottoman", "buda");
          this.addRegular("ottoman", "belgrade", 1);
          this.controlSpace("ottoman", "belgrade");
          this.controlSpace("ottoman", "mohacs");
          this.controlSpace("ottoman", "szegedin");
          this.controlSpace("ottoman", "agram");
          this.controlSpace("ottoman", "rhodes");

	  this.game.state.ottoman_war_winner_vp = 2;
	  this.game.spaces["algiers"].pirate_haven = 1;
	  this.game.spaces["algiers"].home = "ottoman";


	  // HAPSBURG
//	  this.addArmyLeader("hapsburg", "valladolid", "charles-v");
	  this.addArmyLeader("hapsburg", "valladolid", "duke-of-alva");
          this.addRegular("hapsburg", "valladolid", 4);
          this.addRegular("hapsburg", "seville", 1);
          this.addNavalSquadron("hapsburg", "seville", 1);
          this.addRegular("hapsburg", "barcelona", 1);
          this.addNavalSquadron("hapsburg", "barcelona", 1);
          this.addRegular("hapsburg", "navarre", 1);
          this.addRegular("hapsburg", "naples", 2);
          this.addNavalSquadron("hapsburg", "naples", 1);
          this.addRegular("hapsburg", "besancon", 1);
          this.addRegular("hapsburg", "brussels", 1);
	  this.addArmyLeader("hapsburg", "vienna", "ferdinand");
          //this.addRegular("hapsburg", "vienna", 4);
          this.addMercenary("hapsburg", "vienna", 2);

// TESTING
	  this.addArmyLeader("hapsburg", "palma", "duke-of-alva");
	  this.addArmyLeader("hapsburg", "palma", "charles-v");
          this.addMercenary("hapsburg", "palma", 4);

          this.addRegular("hapsburg", "antwerp", 3);
          this.controlSpace("hapsburg", "prague");
          this.controlSpace("hapsburg", "breslau");
          this.controlSpace("hapsburg", "brunn");
          this.controlSpace("hapsburg", "pressburg");
          this.controlSpace("hapsburg", "regensburg");
          this.controlSpace("hapsburg", "salzburg");
          this.controlSpace("hapsburg", "munster");
          this.controlSpace("hapsburg", "cologne");
          this.controlSpace("hapsburg", "trier");
          this.controlSpace("hapsburg", "basel");
          this.controlSpace("hapsburg", "zurich");
          this.controlSpace("hapsburg", "vienna");

	  this.game.state.hapsburg_war_winner_vp = 1;

          this.game.state.newworld['circumnavigation'].faction = "hapsburg";
          this.game.state.newworld['circumnavigation'].claimed = 1;
          this.game.state.newworld['pacificstrait'].faction = "hapsburg";
          this.game.state.newworld['pacificstrait'].claimed = 1;
          this.game.state.newworld['aztec'].faction = "hapsburg";
          this.game.state.newworld['aztec'].claimed = 1;

          this.game.state.newworld['hapsburg_colony1'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony1'].claimed = 1;
          this.game.state.newworld['hapsburg_colony2'].faction = "hapsburg";
          this.game.state.newworld['hapsburg_colony2'].claimed = 1;

          this.game.state.colonies.push({
            faction : "hapsburg" ,
            resolved : 1 ,
	    colony : "hapsburg_colony1" ,
            round : 1 ,
	    name : "Puerto Rico",
	    img : "/his/img/tiles/colonies/PuertoRico.svg",
          });
	  this.game.state.colonies.push({
            faction : "hapsburg" ,
            resolved : 1 ,
	    colony : "hapsburg_colony2" ,
            round : 2 ,
	    name : "Cuba",
	    img : "/his/img/tiles/colonies/Cuba.svg",
          });

	  this.removeExplorer("hapsburg", "magellan");
	  this.removeExplorer("hapsburg", "leon");
	  this.removeExplorer("hapsburg", "narvaez");
	  this.removeConquistador("hapsburg", "cordova");

	  this.game.state['hapsburg_uncharted'] = 0;

	  // ENGLAND
          this.addArmyLeader("england", "london", "henry-viii");
          this.addArmyLeader("england", "london", "charles-brandon");
          this.addRegular("england", "london", 3);
          this.addMercenary("england", "london", 2);
          //this.addNavalSquadron("england", "london", 1);
          //this.addNavalSquadron("england", "plymouth", 1);
          //this.addNavalSquadron("england", "portsmouth", 1);
          this.addRegular("england", "calais", 2);
          this.addRegular("england", "york", 1);
          this.addRegular("england", "bristol", 1);

	  this.game.state.england_card_bonus = 1;
	  this.game.state.henry_viii_marital_status = 1;
	  this.game.state['england_uncharted'] = 0;

	  // FRANCE
          this.addArmyLeader("france", "paris", "francis-i");
          this.addArmyLeader("france", "paris", "montmorency");
          this.addRegular("france", "paris", 4);
          this.addMercenary("france", "paris", 2);
          this.addRegular("france", "rouen", 1);
          this.addNavalSquadron("france", "rouen", 1);
          this.addRegular("france", "bordeaux", 2);
          this.addRegular("france", "lyon", 1);
          this.addRegular("france", "marseille", 1);
          this.addNavalSquadron("france", "marseille", 1);

	  this.removeExplorer("france", "verrazano");

	  this.game.state.france_card_bonus = 1;
	  this.game.state['france_uncharted'] = 0;
	  this.game.state.french_chateaux_vp = 2;

	  // PAPACY
          this.addRegular("papacy", "rome", 1);
          this.addMercenary("papacy", "rome", 1);
          this.addNavalSquadron("papacy", "rome", 1);
          this.addRegular("papacy", "ravenna", 1);
          this.addMercenary("papacy", "ravenna", 1);
	  this.controlSpace("papacy", "florence");
          this.addRegular("papacy", "florence", 1);
	  this.controlSpace("papacy", "siena");
	
          this.game.state.saint_peters_cathedral['state'] = 0;
          this.game.state.saint_peters_cathedral['vp'] = 1;
	  this.game.state.leaders.leo_x = 0;
	  this.game.state.events.clement_vii = 1;
	  this.game.state.leaders.clement_vii = 1;
	  this.game.state.already_excommunicated.push("luther-debater");

	  // PROTESTANT
	  this.addRegular("protestant", "brandenburg");	
	  this.addRegular("protestant", "wittenberg", 2);
	  this.addRegular("protestant", "mainz");	
	  this.addMercenary("protestant", "mainz", 2);	
	  this.addRegular("protestant", "augsburg", 2);	

          this.addReformer("protestant", "wittenberg", "luther-reformer");
          this.addArmyLeader("protestant", "brandenburg", "philip-hesse");
          this.addArmyLeader("protestant", "wittenberg", "john-frederick");

    	  this.game.state.augsburg_electoral_bonus = 1;
    	  this.game.state.mainz_electoral_bonus = 1;
    	  this.game.state.trier_electoral_bonus = 0;
    	  this.game.state.cologne_electoral_bonus = 0;
    	  this.game.state.wittenberg_electoral_bonus = 1;
    	  this.game.state.brandenburg_electoral_bonus = 1;

          this.game.state.translations['full']['german'] = 0;
          this.game.state.translations['full']['english'] = 0;
          this.game.state.translations['full']['french'] = 0;
          this.game.state.translations['new']['german'] = 6;
          this.game.state.translations['new']['english'] = 2;
          this.game.state.translations['new']['french'] = 4;

	  this.removeDebater("protestant", "zwingli-debater");
	  this.removeReformer("protestant", "geneva", "zwingli-debater");

	  this.convertSpace("protestant", "wittenberg");
	  this.convertSpace("protestant", "brandenburg");
	  this.convertSpace("protestant", "stettin");
	  this.convertSpace("protestant", "lubeck");
	  this.convertSpace("protestant", "magdeburg");

	  this.convertSpace("protestant", "leipzig");
	  this.convertSpace("protestant", "erfurt");
	  this.convertSpace("protestant", "nuremberg");
	  this.convertSpace("protestant", "hamburg");
	  this.convertSpace("protestant", "bremen");

	  this.convertSpace("protestant", "kassel");
	  this.convertSpace("protestant", "brunswick");
	  this.convertSpace("protestant", "mainz");
	  this.convertSpace("protestant", "worms");
	  this.convertSpace("protestant", "strasburg");

	  this.convertSpace("protestant", "basel");
	  this.convertSpace("protestant", "zurich");
	  this.convertSpace("protestant", "augsburg");
	  this.convertSpace("protestant", "breslau");


          // DEBATERS
          this.addDebater("papacy", "eck-debater");
          this.addDebater("papacy", "campeggio-debater");
          this.addDebater("papacy", "aleander-debater");
          this.addDebater("papacy", "contarini-debater");
          this.addDebater("papacy", "tetzel-debater");
          this.addDebater("papacy", "cajetan-debater");

          this.addDebater("protestant", "luther-debater");
          this.addDebater("protestant", "melanchthon-debater");
          this.addDebater("protestant", "bucer-debater");
          this.addDebater("protestant", "carlstadt-debater");
          this.addDebater("protestant", "bullinger-debater");
          this.addDebater("protestant", "oekolampadius-debater");
          this.addDebater("protestant", "tyndale-debater");

	  // VENICE
          this.addRegular("venice", "venice", 2);
          this.addNavalSquadron("venice", "venice", 3);
          this.addRegular("venice", "corfu", 1);
          this.addRegular("venice", "candia", 1);
	
	  // GENOA
          this.addNavyLeader("genoa", "genoa", "andrea-doria");
          this.addNavalSquadron("genoa", "genoa", 1);
          this.addRegular("genoa", "genoa", 2);
	
	  // HUNGARY
	  this.addRegular("hungary", "prague", 1);

	  // SCOTLAND
          this.addRegular("scotland", "edinburgh", 3);
          this.addNavalSquadron("scotland", "edinburgh", 1);
          this.game.spaces['stirling'].fortify = 1;
	
	  // INDEPENDENT
          this.controlSpace("independent", "basel");
          this.controlSpace("independent", "zurich");
          this.controlSpace("independent", "milan");
          this.controlSpace("independent", "tunis");	
          this.controlSpace("independent", "malta", 1);
          this.addRegular("independent", "malta", 1);
          //this.addRegular("independent", "metz", 1);
          this.addRegular("independent", "milan", 1);
          this.addRegular("independent", "tunis", 1);

	  // ALLIANCES
	  this.setEnemies("ottoman", "hapsburg");
	  this.setEnemies("hapsburg", "protestant");
	  this.setEnemies("papacy", "protestant");
	  this.setAllies("hapsburg", "hungary");

	  // DEBATERS         
          this.addDebater("protestant", "farel-debater");
          this.addDebater("protestant", "cop-debater");
          this.addDebater("protestant", "olivetan-debater");
          this.addDebater("protestant", "calvin-debater");
          this.addReformer("protestant", "geneva", "calvin-reformer");
          this.convertSpace("protestant", "geneva");


          this.game.state.events.barbary_pirates = 1;
          this.game.state.events.ottoman_piracy_enabled = 1;
          this.game.state.events.ottoman_corsairs_enabled = 1;


	  this.controlSpace("ottoman", "pressburg");
          this.addArmyLeader("ottoman", "pressburg", "suleiman");
          this.addArmyLeader("ottoman", "pressburg", "ibrahim-pasha");
          this.addRegular("ottoman", "pressburg", 6);

	  //
	  // TESTING AND MODIFICTIONS
	  //
	  //
//	  this.addRegular("hapsburg", "graz", 4);

	  this.setAllies("england", "scotland");
	  this.setEnemies("hapsburg", "france");
	  this.setEnemies("england", "france");
	  this.controlSpace("hapsburg", "metz");

	  this.controlSpace("ottoman", "linz");
	  this.controlSpace("ottoman", "brunn");
	  this.controlSpace("ottoman", "salzburg");

	  this.game.spaces["london"].unrest = 1;
	  this.game.spaces["metz"].besieged = 1;
	  this.addRegular("france", "metz", 2);

	  this.removeCardFromGame("009");
	  this.removeCardFromGame("008");

	  this.setAllies("protestant", "england");
	  this.controlSpace("hapsburg", "trent");
	  this.setAllies("hapsburg", "venice");
	  this.setEnemies("ottoman", "venice");
	  this.controlSpace("ottoman", "agram");
	  this.controlSpace("ottoman", "zara");
	  this.controlSpace("ottoman", "ragusa");
          this.addNavalSquadron("hapsburg", "palma", 1);

	  this.addRegular("hapsburg", "prague", 2);
	  this.addRegular("england", "leipzig", 4);
          this.addArmyLeader("england", "leipzig", "charles-brandon");

      }

    }

    //
    // and show the board
    //
    this.displayBoard();

  }



  async render(app) {

    if (this.browser_active == 0) { return; }

    if (this.initialize_game_run) {
      return;
    }

    await this.injectGameHTML(htmlTemplate());

    await super.render(app);

    let game_mod = this;

    //
    //
    //
    if (!this.game.state) {
      this.game.state = this.returnState();
    }

    //
    // preload images
    //
    this.preloadImages();
    setTimeout(() => {
      try {
        this.preloadMoreImages();
      } catch (err) {}
    }, 20000);


    // required here so menu will be proper
    try {
      if (this.app.options.gameprefs.hereistand_expert_mode == 1) {
        this.confirm_moves = 0;
      } else {
        this.confirm_moves = 1;
      }
    } catch (err) {}


    this.menu.addMenuOption("game-game", "Game");

    this.menu.addSubMenuOption("game-game", {
      text : "About H.I.S.",
      id : "game-about",
      class : "game-about",
      callback : function(app, game_mod) {
	let help = "Here I Stand";
	let content = `
This edition of Here I Stand is made available under an open source license provided
by GMT Games. While it strives to be as faithful to the original game as possible,
minor changes have been made to hasten gameplay, including:

<p></p>
<ul style="margin-left:2rem">
<li>
browsers will "automatically" respond "no" when asked if they want to play
   event-response cards (like Wartburg) if they do not have those cards. This
   speeds up gameplay at the cost of "leaking" info that some players do not
   hold those cards. Players who have response cards also only have a limited 
   amount of time to select those cards. You can turn this feature off by 
   switching to "slow mode".
</li>
<li>
players have a limited amount of time to trigger response cards in response to
   opponent moves. this is designed to prevent slow players unnecessarily slowing
   gameplay and preventing opponents from moving.
</li>
<li>
impulse order is not enforced in Spring Deployment and Diplomacy and a few other
   minor retreat options. advanced players who wish to enforce Impulse Order in
   these cases can do so simply by having factions commit their moves in that 
   order.
</li>
<li>
winter retreat to fortified spaces is automated. all units are automatically 
   returned to the nearest fortified space with space. If no such space exists
   attrition costs are automatically assigned to the lowest-cost units being 
   moved. this removes some granularity in controlling which exact units winter
   in which exact spaces. players can take this into account when maneuvering 
   units out of fortified spaces.
</li>
<li>
the game engine automatically handles token denomination, merging smaller
   units into larger ones as possible. if factions hit their limits units are
   not destroyed - the faction is registered as being in "over-capacity" and 
   blocked from constructing new units until back under their token limit.
</li>
</ul>
`;
        game_mod.menu.hideSubMenus();
        game_mod.game_help.overlay.show(
	  `
      	    <div class="tutorial-overlay" id="tutorial-overlay">
              <div class="help">${help}</div>
              <div class="content">${content}</div>
            </div>
	  `
	);
      },
    });



    this.menu.addSubMenuOption("game-game", {
      text : "Difficulty",
      id : "game-confirm",
      class : "game-confirm",
      callback : null
    });
    this.confirm_moves = 0;
    if (this.app.options.gameprefs) {
      if (this.app.options.gameprefs.his_expert_mode) {
	this.confirm_moves = this.app.options.gameprefs.his_expert_mode;
	if (this.confirm_moves == 1) { this.game_help.enabled = false; }
      }
    }
    this.menu.addSubMenuOption("game-confirm",{
      text: `Newbie ${(this.confirm_moves==1)?"â":""}`,
      id:"game-confirm-newbie",
      class:"game-confirm-newbie",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 0){
	  document.querySelector("#game-confirm-newbie div").innerHTML = "Newbie â";
	  document.querySelector("#game-confirm-expert div").innerHTML = "Expert";
          game_mod.displayModal("Game Settings", "Tutorial Mode re-enabled");
          game_mod.saveGamePreference('his_expert_mode', 0);
	  game_mod.game_help.enabled = true;
	  game_mod.confirm_moves = 1;
        } else {
          game_mod.menu.hideSubMenus();
        }
      }
    });
    this.menu.addSubMenuOption("game-confirm",{ 
      text: `Expert ${(this.confirm_moves==1)?"":"â"}`,
      id:"game-confirm-expert",
      class:"game-confirm-expert",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 1){
	  document.querySelector("#game-confirm-newbie div").innerHTML = "Newbie";
	  document.querySelector("#game-confirm-expert div").innerHTML = "Expert â";
          game_mod.displayModal("Game Settings", "Tutorial Mode disabled");
          game_mod.saveGamePreference('his_expert_mode', 1);
	  game_mod.game_help.hide();
	  game_mod.game_help.enabled = false;
	  game_mod.confirm_moves = 0;
        }else{
          game_mod.menu.hideSubMenus();
        } 
      }
    });


    this.menu.addSubMenuOption("game-game", {
      text : "Gameplay",
      id : "game-gameplay",
      class : "game-gameplay",
      callback : null
    });

//    if (this.faster_play !== 0 && this.faster_player !== 1) {
//      this.faster_play = 1;
//    }
//    if (this.app.options.gameprefs) {
//      if (this.app.options.gameprefs.his_faster_play) {
//	this.faster_play = parseInt(this.app.options.gameprefs.his_faster_play);
//      }
//    }
    this.menu.addSubMenuOption("game-gameplay",{
      text: `Faster ${(this.faster_play==1)?"â":""}`,
      id:"game-gameplay-faster",
      class:"game-gameplay-faster",
      callback: function(app,game_mod){
        if (game_mod.faster_play == 0){
	  document.querySelector("#game-gameplay-slower div").innerHTML = "Slower â";
	  document.querySelector("#game-gameplay-faster div").innerHTML = "Faster";
          game_mod.displayModal("Game Settings", "Gameplay Speedup Disabled");
          game_mod.saveGamePreference('his_faster_play', 0);
	  game_mod.faster_play = 0;
        }else{
          game_mod.menu.hideSubMenus();
        }
      }
    });
      
    this.menu.addSubMenuOption("game-gameplay",{ 
      text: `Slower ${(this.faster_play==1)?"":"â"}`,
      id:"game-gameplay-slower",
      class:"game-gameplay-slower",
      callback: function(app,game_mod){
        if (game_mod.confirm_moves == 1){
	  document.querySelector("#game-gameplay-slower div").innerHTML = "Slower";
	  document.querySelector("#game-gameplay-faster div").innerHTML = "Faster â";
          game_mod.displayModal("Game Settings", "Gameplay Speedup Enabled");
          game_mod.saveGamePreference('his_faster_play', 1);
	  game_mod.faster_play = 1;
        }else{
          game_mod.menu.hideSubMenus();
        } 
      }
    });

    this.menu.addSubMenuOption("game-game", {
      text : "Log",
      id : "game-log",
      class : "game-log",
      callback : function(app, game_mod) {
        game_mod.menu.hideSubMenus();
        game_mod.log.toggleLog();
      }
    });
/****
    this.menu.addSubMenuOption("game-game", {
      text : "Stats",
      id : "game-stats",
      class : "game-stats",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.handleStatsMenu();
      }
    });
****/
    this.menu.addMenuOption("game-info", "Info");
    this.menu.addSubMenuOption("game-info", {
      text: "Units",
      id: "game-units",
      class: "game-units",
      callback: function(app, game_mod){
	game_mod.menu.hideSubMenus();
        game_mod.units_overlay.render();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text: "Marriage",
      id: "game-marriage",
      class: "game-marriage",
      callback: function(app, game_mod){
	game_mod.menu.hideSubMenus();
        game_mod.marriage_overlay.render();
      }
    });


/***
    this.menu.addSubMenuOption("game-info", {
      text: "Faction Cards",
      id: "game-faction-cards",
      class: "game-faction-cards",
      callback: function(app, game_mod){
        game_mod.menu.showSubSubMenu("game-faction-cards");
      }
    });
***/

    this.menu.addSubMenuOption("game-info", {
      text : "Cards",
      id : "game-cards",
      class : "game-cards",
      callback : null
    });
    this.menu.addSubMenuOption("game-cards", {
      text: "Discard Pile",
      id: "game-cards-discard",
      class: "game-cards-discard",
      callback: function(app, game_mod){
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("discards");
      }
    });
if (this.game.players.length > 2) {
    this.menu.addSubMenuOption("game-cards", {
      text : "Ottoman",
      id : "game-ottoman-cards",
      class : "game-ottoman-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("ottoman") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "ottoman");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("ottoman");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Hapsburg",
      id : "game-hapsburg-cards",
      class : "game-hapsburg-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("hapsburg") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "hapsburg");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("hapsburg");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "England",
      id : "game-england-cards",
      class : "game-england-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("england") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "england");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("england");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "France",
      id : "game-france-cards",
      class : "game-france-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("france") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "france");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("france");
      }
    });
}
    this.menu.addSubMenuOption("game-cards", {
      text : "Papacy",
      id : "game-papacy-cards",
      class : "game-papacy-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("papacy") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "papacy");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("papacy");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Protestant",
      id : "game-protestant-cards",
      class : "game-protestant-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
	if (game_mod.returnPlayerOfFaction("protestant") == game_mod.game.player) {
          let fhand_idx = game_mod.returnFactionHandIdx(game_mod.game.player, "protestant");
          let c = game_mod.game.deck[0].fhand[fhand_idx];
          game_mod.deck_overlay.render("hand", c);
	  return;
	}
        game_mod.deck_overlay.render("protestant");
      }
    });


/****
    this.menu.addSubMenuOption("game-cards", {
      text : "My Hand",
      id : "game-my-hand",
      class : "game-my-hand",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("hand");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Discards",
      id : "game-discards",
      class : "game-discards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("discards");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "All Cards",
      id : "game-all-cards",
      class : "game-all-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("all");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Unplayed",
      id : "game-unplayed-cards",
      class : "game-unplayed-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("unplayed");
      }
    });
    this.menu.addSubMenuOption("game-cards", {
      text : "Removed",
      id : "game-removed-cards",
      class : "game-removed-cards",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.deck_overlay.render("removed");
      }
    });
****/
    this.menu.addSubMenuOption("game-info", {
      text : "VP",
      id : "game-vp",
      class : "game-vp",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.vp_overlay.render();
      }
    });
/****
    this.menu.addSubMenuOption("game-info", {
      text : "New World",
      id : "game-new-world",
      class : "game-cnew-world",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.newworld_overlay.render();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Chateaux",
      id : "game-chateaux-building",
      class : "game-chateaux-building",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.chateaux_overlay.render("papacy");
      }
    });
****/
    this.menu.addSubMenuOption("game-info", {
      text : "Religion",
      id : "game-religious-conflict",
      class : "game-religious-conflict",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.religious_overlay.render();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Debaters",
      id : "game-debaters",
      class : "game-debaters",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayDebaters();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Explorers",
      id : "game-explorers",
      class : "game-explorers",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayExplorers();
      }
    });
    this.menu.addSubMenuOption("game-info", {
      text : "Conquistadors",
      id : "game-conquistadors",
      class : "game-conquistadors",
      callback : function(app, game_mod) {
	game_mod.menu.hideSubMenus();
        game_mod.displayConquistadors();
      }
    });

    this.menu.addMenuOption("game-factions", "Factions");
    this.menu.addSubMenuOption("game-factions", {
      text : "Ottomans",
      id : "game-ottoman",
      class : "game-ottoman",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("ottoman");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Hapsburgs",
      id : "game-hapsburg",
      class : "game-hapsburg",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("hapsburg");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "England",
      id : "game-england",
      class : "game-england",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("england");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "France",
      id : "game-france",
      class : "game-france",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("france");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Papacy",
      id : "game-papacy",
      class : "game-papacy",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("papacy");
      }
    });
    this.menu.addSubMenuOption("game-factions", {
      text : "Protestants",
      id : "game-protestants",
      class : "game-protestants",
      callback : function(app, game_mod) {
        game_mod.faction_overlay.render("protestant");
      }
    });

    this.menu.addChatMenu();
    this.menu.render();
    this.log.render();
    this.cardbox.render();

    //
    // add card events -- text shown and callback run if there
    //
    this.cardbox.addCardType("showcard", "", null);
    this.cardbox.addCardType("card", "select", this.cardbox_callback);
    if (app.browser.isMobileBrowser(navigator.userAgent)) {
      this.cardbox.skip_card_prompt = 0;
    }

    //
    // position cities / spaces / etc
    //
    let spaces = this.returnSpaces();
    for (let key in spaces) {
      if (spaces.hasOwnProperty(key)) {
	try {
	  let obj = document.getElementById(key);
	  obj.style.top = spaces[key].top + "px";
	  obj.style.left = spaces[key].left + "px";
        } catch (err) {
	}
      }
    }

    //
    // position pregnancy chart
    //
    let pregnancies = this.returnPregnancyChart();
    for (let key in pregnancies) {
      if (pregnancies.hasOwnProperty(key)) {
	try {
          let idname = "pregnancy"+key;
	  let obj = document.getElementById(idname);
	  obj.style.top = pregnancies[key].top + "px";
	  obj.style.left = pregnancies[key].left + "px";
        } catch (err) {
	}
      }
    }

    //
    // position diplomacy chart
    //
    let d = this.returnDiplomacyTable();
    for (let key in d) {
      if (d.hasOwnProperty(key)) {
	try {
          for (let key2 in d[key]) {
	    divname = key + "_" + key2;
	    let obj = document.getElementById(divname);
	    obj.style.top = d[key][key2].top + "px";
	    obj.style.left = d[key][key2].left + "px";
	  }
        } catch (err) {
	}
      }
    }
    this.game.diplomacy = d;



    //
    // position electorate display
    //
    let elec = this.returnElectorateDisplay();
    for (let key in elec) {
      if (elec.hasOwnProperty(key)) {
        try {
          let obj = document.getElementById(`ed_${key}`);
          obj.style.top = elec[key].top + "px";
          obj.style.left = elec[key].left + "px";
        } catch (err) {
        }
      }
    }



    try {

      if (app.browser.isMobileBrowser(navigator.userAgent)) {
        //this.hammer.render();
      } else {
	let his_self = this;
        this.sizer.render();
        this.sizer.attachEvents('#gameboard');
	//
	// sizer makes draggable 
	//
        //$('#gameboard').draggable({
	//  stop : function(event, ui) {
	//    his_self.saveGamePreference((his_self.returnSlug()+"-board-offset"), ui.offset);
	//  }
	//});
	//
      }

    } catch (err) {}

    this.factionbar.render();

    this.hud.render();

    this.displayBoard();

  }





  popup(card) {

    let c = null;
    if (!c && this.game.deck[0]) { c = this.game.deck[0].cards[card]; }
    if (!c && this.game.deck[1]) { c = this.game.deck[1].cards[card]; }
    if (!c && this.debaters) { 
      c = this.debaters[card];
      if (c) { return `<span class="showcard ${card}" id="${card}">${c.name}</span>`; }
    }
    if (!c) {
      // catches Here I Stand and other removed cards!
      let x = this.returnDeck(true);
      if (x[card]) { c = x[card]; }
    }
    if (c) { 
      if (c.name) {
        return `<span class="showcard ${card}" id="${card}">${c.name}</span>`;
      }
    }
    return `<span class="showcard ${card}" id="${card}">${card}</span>`;
  }

  returnNewCardsForThisTurn(turn = 1) {

    let deck = this.returnDeck();
    let new_deck = {};

    for (let key in deck) {
      if (key != "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
        if (deck[key].turn === turn) {

	  //
	  // exception for boleyn cards below
	  //
	  if (key != "064" && key != "063" && key != "062") {
	    new_deck[key] = deck[key];
	  }
        }

      }
    }

    //
    // Dissolution of the Monasteries, Pilgrimmage of Grace, Book of Common Prayer added as soon as Boleyn marries Henry
    //
    if (turn < 4 && this.game.state.henry_viii_marital_status >= 2 && this.game.state.henry_viii_boleyn_cards_added != 1) {

      this.game.state.henry_viii_boleyn_cards_added = 1;
      new_deck["064"] = deck["064"];
      new_deck["063"] = deck["063"];
      new_deck["062"] = deck["062"];

    } else {
 
      if (new_deck["064"]) { delete new_deck["064"]; }
      if (new_deck["063"]) { delete new_deck["063"]; }
      if (new_deck["062"]) { delete new_deck["062"]; }

      if (turn == 4 && (this.game.options.scenario === "1532" || this.game.options.scenario === "tournament")) {
	this.game.state.henry_viii_boleyn_cards_added = 1;
        new_deck["064"] = deck["064"];
        new_deck["063"] = deck["063"];
        new_deck["062"] = deck["062"];
      }

      if (turn == 5 && this.game.state.henry_viii_boleyn_cards_added != 1) {
	this.game.state.henry_viii_boleyn_cards_added = 1;
        new_deck["064"] = deck["064"];
        new_deck["063"] = deck["063"];
        new_deck["062"] = deck["062"];
      }

    }

    if (turn >= 6) {
      if (this.game.state.henry_viii_healthy_edward == 1 && this.game.state.henry_viii_edward_added != 1) {
	this.game.state.henry_viii_edward_added = 1;
	new_deck["019"] = deck["019"];
      }
      if (this.game.state.henry_viii_sickly_edward == 1 && this.game.state.henry_viii_edward_added != 1) {
	new_deck["019"] = deck["019"];
	this.game.state.henry_viii_edward_added = 1;
      }
      if (this.game.state.henry_viii_add_elizabeth == 1 && this.game.state.henry_viii_sickly_edward == 0 && this.game.state.henry_viii_healthy_edward == 0 && this.game.state.henry_viii_mary_added != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_i_added = 1;
      }
      if (this.game.state.henry_viii_add_elizabeth == 0 && this.game.state.henry_viii_sickly_edward == 0 && this.game.state.henry_viii_healthy_edward == 0 && this.game.state.henry_viii_mary_added != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_i_added = 1;
      }
      if (this.game.state.henry_viii_mary_added == 1 && this.game.state.henry_viii_add_elizabeth == 1 && this.game.state.henry_viii_elizabeth_added != 1) {
	new_deck["023"] = deck["023"];
	this.game.state.henry_viii_elizabeth_added = 1;
      }
      if (this.game.state.henry_viii_mary_i_added_with_sickly_edward_played == 1 && this.game.state.henry_viii_mary_added_twice != 1) {
	new_deck["021"] = deck["021"];
	this.game.state.henry_viii_mary_added_twice = 1;
      }

    }

    //
    // mary has entered play, but maybe we need to add Elizabeth or Edward
    //
    if (this.game.state.round == (this.game.state.henry_viii_mary_i_added_round+1)) {
      //
      // add elizabeth
      //
      if (this.game.state.henry_viii_elizabeth_added == 1) {
	let deck = this.returnDeck(true);
	new_deck["019"] = deck["019"];
      }

      //
      // re-add Mary (Edward VI won't make it very long)
      //
      if (this.game.state.henry_viii_re_add_mary_to_throne == 1) {
	for (let z = 0 ; z < this.game.state.removed.length; z++) {
	  if (this.game.state.removed[z] == "021") { this.game.state.removed.splice(z, 1); }
	}
	let deck = this.returnDeck(true);
	new_deck["021"] = deck["021"];
      }
    }

    return new_deck;

  }

  returnNewDiplomacyCardsForThisTurn(turn = 1) {

    let deck = this.returnDiplomaticDeck();
    let new_deck = {};

    for (let key in deck) {
      if (deck[key].turn === turn) {
        new_deck[key] = deck[key];
      }
    }

    if (turn == (this.game.state.events.schmalkaldic_league_round+1)) {
        new_deck['213'] = deck['213'];
        new_deck['214'] = deck['214'];
        new_deck['215'] = deck['215'];
        new_deck['216'] = deck['216'];
        new_deck['217'] = deck['217'];
        new_deck['218'] = deck['218'];
        new_deck['219'] = deck['219'];
    }

    return new_deck;

  }

  returnDiplomaticDeck() {

    let deck = {};

    deck['201'] = { 
      img : "cards/HIS-201.svg" , 
      name : "Andrea Doria" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {

          let f = his_self.returnAllyOfMinorPower("genoa");
	  if (f != "papacy") {
            his_self.deactivateMinorPower(f, "genoa");
            his_self.activateMinorPower("papacy", "genoa");
	    his_self.updateLog("Papacy allies with Genoa");
	  } else {
	    his_self.game.queue.push("andrea_dorea_placement\tpapacy");
	  }

	}

	if (faction === "protestant") {

          let f = his_self.returnAllyOfMinorPower("genoa");
	  if (f != "france") {
            his_self.deactivateMinorPower(f, "genoa");
            his_self.activateMinorPower("france", "genoa");
	    his_self.updateLog("France allies with Genoa");
	  } else {
	    his_self.game.queue.push("andrea_dorea_placement\tprotestant");
	  }

	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "andrea_dorea_placement") {

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (player == his_self.game.player) {
          his_self.playerSelectSpaceWithFilter(

            "Select Genoa Home Space for 4 Regulars",

            function(space) {
              if (space.home == "genoa") { return 1; }
	      return 0;
            },

            function(spacekey) {
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tgenoa\t"+"regular"+"\t"+spacekey);
              his_self.endTurn();
            }, 

	    null, 

	    true

          );
	  } else {
	    his_self.updateStatus("Genoa adding 4 Regulars");
	  }

          return 0;
        }
	return 1;
      }
    }
    deck['202'] = { 
      img : "cards/HIS-202.svg" , 
      name : "French Constable Invades" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.setEnemies("france", "papacy");

	let p = his_self.returnPlayerOfFaction("protestant");
	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select French-Controlled Space for Invasion Force",

            function(space) {
	      if (his_self.isSpaceControlled(space, "france")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("french_constable_invades\t"+spacekey);
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant"+"\t1"); // 1 = overlay
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\tmontmorency");
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null ,

	    true 
          );

          return 0;

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "french_constable_invades") {

	  let spacekey = mv[1];
          his_self.game.queue.splice(qe, 1);

	  //
	  // 2P game, so france get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tfrance");
	  his_self.addMove("declare_war\tpapacy\tfrance");

	  let p = his_self.returnPlayerOfFaction("protestant");

	  if (his_self.game.player == p) {

   	    let msg = "Additional Military Support:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">1 squadron in French home port</li>';
            html += '<li class="option" id="mercenaries">2 more mercenaries in '+his_self.returnSpaceName(spacekey)+'</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");
	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select French Home Port",

                  function(space) {
                    if (space.ports.length > 0 && space.home == "france") {
                      return 1;
                    }
                  },

                  function(spacekey) {
		    his_self.updateStatus("French build squadrons in " + his_self.returnSpaceName(spacekey));
                    his_self.addMove("build\tland\tfrance\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
                  },

		  null ,

		  true

                );
	      }
	      if (action === "mercenaries") {
	        his_self.updateStatus("French add mercenaries in " + his_self.returnSpaceName(spacekey));
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
	      }

	    });

	  } else {
	    his_self.updateStatus("Protestants playing French Constable Invades.");
	  }

	  return 0;
	}

        return 1;

      },
    }
    deck['203'] = { 
      img : "cards/HIS-203.svg" , 
      name : "Corsair Raid" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	let opponent_faction = "protestant";
	if (faction === "protestant") { opponent_faction = "papacy"; }

	let d1 = his_self.rollDice(6);
	let d2 = his_self.rollDice(6);
	let d3 = his_self.rollDice(6);
	let d4 = his_self.rollDice(6);

	let hits = 0;

	if (d1 >= 5) { hits++; }
	if (d2 >= 5) { hits++; }
	if (d3 >= 5) { hits++; }
	if (d4 >= 5) { hits++; }

	his_self.updateLog(`${his_self.popup('203')} rolls ` + hits + " hits ["+d1+","+d2+","+d3+","+d4+"]");

        if (his_self.game.player == p) {
	  for (let i = hits-1; i >= 0; i--) {
	    his_self.addMove("corsair_raid\t"+opponent_faction+"\t"+(i+1)+"\t"+hits);
	  }
	  his_self.addMove(`NOTIFY\t${his_self.popup('203')} rolls ${hits} hits`);
	  his_self.endTurn();
	}
	
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "corsair_raid") {

	  // faction is victim
	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let total = parseInt(mv[3]);
	  let hit = "hit";

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; hit = "hits"; }
	  if (num == 3) { num = "3rd"; hit = "hits"; }
	  if (num == 4) { num = "4th"; hit = "hits"; }


	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player == player) {

	    let is_squadron_available = false;
	    if (faction === "papacy") {
	      for (let s in his_self.game.spaces) {
	        let space = his_self.game.spaces[s];
	        for (let key in space.units) {
	          if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
	  	    for (let i = 0; i < space.units[key].length; i++) {
	  	      if (space.units[key][i].type === "squadron") { is_squadron_available = true; }
	            }
	          }
	        }
	      }
	    }
	    if (faction === "protestant") {
	      for (let s in his_self.game.spaces) {
	        let space = his_self.game.spaces[s];
	        for (let key in space.units) {
	          if (key === "france" || key === "ottoman") {
	  	    for (let i = 0; i < space.units[key].length; i++) {
		      if (space.units[key][i].type === "squadron") { is_squadron_available = true; }
	            }
	          }
	        }
	      }
	    }


 	    let msg = "Corsair Raid: "+num+" of "+total+" "+hit+":";
            let html = '<ul>';
            html += '<li class="option" id="discard">discard card</li>';
	    if (is_squadron_available) {
              html += '<li class="option" id="eliminate">eliminate squadron</li>';
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "eliminate") {

                his_self.playerSelectSpaceOrNavalSpaceWithFilter(

                  `Select Space to Remove Naval Squadron` ,

 	          function(space) {
		    if (faction === "papacy") {
		      for (let key in space.units) {
		        if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") { return 1; }
		          }
		        }
		      }
		    }
		    if (faction === "protestant") {
		      for (let key in space.units) {
		        if (key === "france" || key === "ottoman") {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") { return 1; }
		          }
		        }
		      }
		    }
	            return 0;
                  },

                  function(spacekey) {

		    let land_or_sea = "land";
		    let space = null;

	            if (his_self.game.navalspaces[spacekey]) {
		      land_or_sea = "sea";
		      space = his_self.game.navalspaces[spacekey];
	            } else {
		      space = his_self.game.spaces[spacekey];
	            }

		    if (faction === "papacy") {
		      for (let key in space.units) {
		        if (key === "papacy" || his_self.isAlliedMinorPower(key, "papacy")) {
		  	  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") {
  	    		      $('.option').off();
			      his_self.updateStatus("Papacy removes squadron");
          	  	      his_self.addMove("remove_unit\t"+land_or_sea+"\t"+key+"\t"+"squadron"+"\t"+spacekey+"\t"+0);
          	  	      his_self.addMove("NOTIFY\tPapacy removes squadron from "+his_self.returnSpaceName(spacekey));
          	  	      his_self.endTurn();
			      return 0;
			    }
		          }
		        }
		      }
		    }

		    if (faction === "protestant") {
		      for (let key in space.units) {
		        if (key === "france" || key === "ottoman") {
			  for (let i = 0; i < space.units[key].length; i++) {
			    if (space.units[key][i].type === "squadron") {
  	    		      $('.option').off();
			      his_self.updateStatus("Protestants remove squadron");
          	  	      his_self.addMove("remove_unit\t"+land_or_sea+"\t"+key+"\t"+"squadron"+"\t"+spacekey+"\t"+0);
          	  	      his_self.addMove("NOTIFY\tProtestant removes squadron from "+his_self.returnSpaceName(spacekey));
          	  	      his_self.endTurn();
			      return 0;
			    }
		          }
		        }
		      }
		    }

  	    	    $('.option').off();
		    his_self.updateStatus("No Squadrons Available to Remove");
	            his_self.addMove("NOTIFY\tNo Squadrons Available to Remove");
		    his_self.endTurn();
		    return 0;
		  },

		  null,

		  true

                );

	      }

	      if (action === "discard") {
		his_self.addMove("discard_random\t"+faction);
          	his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " discards card");
		his_self.endTurn();
	      }

	    });
	  }
	  return 0;
	}
        return 1;
      }
    }
    deck['204'] = { 
      img : "cards/HIS-204.svg" , 
      name : "Diplomatic Marriage" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player == p) {

	  let mp = his_self.returnMinorPowers();
	  let ca = [];
	  let cd = [];

	  for (let i = 0; i < mp.length; i++) {
	    if (his_self.canFactionActivateMinorPower(faction, mp[i])) {
	      if (his_self.returnAllyOfMinorPower(mp[i]) != faction) {
	        ca.push(mp[i]);
	      }
	    } else {
	      if (his_self.canFactionDeactivateMinorPower(faction, mp[i])) {
	        cd.push(mp[i]);
	      }
	    }
	  }

	  //
	  // 2P modifications
	  //
          if (faction === "protestant") {
	    if (!cd.includes("genoa") && his_self.returnAllyOfMinorPower("genoa") !== "genoa")  { cd.push("genoa"); }
	    if (!cd.includes("venice") && his_self.returnAllyOfMinorPower("venice") !== "venice")  { cd.push("venice"); }
	    if (!cd.includes("scotland") && his_self.returnAllyOfMinorPower("scotland") !== "scotland")  { cd.push("scotland"); }
	    if (!cd.includes("venice")) { cd.push("venice"); }
	    if (!cd.includes("genoa"))  { cd.push("scotland"); }
	    if (!ca.includes("genoa"))  { ca.push("genoa"); }
	    if (!ca.includes("venice")) { ca.push("venice"); }
	  }

	  let msg = 'Activate or De-activate a Minor Power?';
    	  let html = '<ul>';
	  for (let i = 0; i < ca.length; i++) {
            html += `<li class="option" id="activate_${ca[i]}">activate ${ca[i]}</li>`;
	  }
	  for (let i = 0; i < cd.length; i++) {
            html += `<li class="option" id="deactivate_${cd[i]}">deactivate ${cd[i]}</li>`;
	  }
          html += `<li class="option" id="skip">skip</li>`;
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

	    let action = $(this).attr("id");

	    if (action === "skip") { his_self.endTurn(); return 0; }
	    let zzt = action.split("_")[1];

	    if (ca.includes(zzt)) {

	      let finished = 0;

	      if (faction === "protestant" && action === "activate_genoa") {
		his_self.addMove("activate_minor_power\thapsburg\tgenoa");
		finished = 1;
	      }
	      if (faction === "protestant" && action === "activate_venice") {
		his_self.addMove("activate_minor_power\thapsburg\tvenice");
		finished = 1;
	      }
	      if (finished == 0) {
	        let x = action.split("_");
	        action = x[1];
		// some cases, same power can be deactivated
		if (x[0] === "deactivate") {
	          his_self.addMove("deactivate_minor_power\t"+his_self.returnAllyOfMinorPower(action)+"\t"+action);
		} else {
	          his_self.addMove("activate_minor_power\t"+faction+"\t"+action);
	        }
	      }

	    } else {
	      his_self.addMove("deactivate_minor_power\t"+his_self.returnAllyOfMinorPower(zzt[1])+"\t"+zzt[1]);
	    }
	    his_self.endTurn();
	  });
	}

	return 0;
      },
    }
    deck['205'] = { 
      img : "cards/HIS-205.svg" , 
      name : "Diplomatic Pressure" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {
	  his_self.game.queue.push("diplomatic_pressure_reveal\tpapacy\tprotestant");
	}

	if (faction === "protestant") {
	  his_self.game.queue.push("diplomatic_pressure_reveal\tprotestant\tpapacy");
	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "diplomatic_pressure_reveal") {

          let faction_taking = mv[1];
          let faction_giving = mv[2];

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player === p2) {
	    if (faction_taking === "protestant") {
              his_self.addMove("diplomatic_pressure_results_protestant\t"+JSON.stringify(his_self.game.deck[1].hand));
	    } else {
              his_self.addMove("diplomatic_pressure_results_papacy\t"+JSON.stringify(his_self.game.deck[1].hand));
	    }
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;
	}


        if (mv[0] === "diplomatic_pressure_results_papacy") {

          let cards = JSON.parse(mv[1]);

          his_self.game.queue.splice(qe, 1);
	  // also remove protestant card (which is next)
          his_self.game.queue.splice(qe-1, 1);
	
	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {

   	    let msg = "Choose Protestant Card:";
            let html = '<ul>';
	    for (let i = 0; i < cards.length; i++) {
              html += `<li class="option showcard" id="${cards[i]}">${his_self.game.deck[1].cards[cards[i]].name}</li>`;
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {
  	      $('.option').off();
              his_self.updateStatus("acknowledge...");
	      let action = $(this).attr("id");
              his_self.addMove("diplomacy_card_event\tprotestant\t"+action);
              his_self.addMove("discard_diplomacy_card\tprotestant\t"+action);
	      // protestant will be dealt another next turn - Jan 24
	      //his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("protestant"))+"\t1");
	      his_self.addMove("NOTIFY\tPapacy selects "+his_self.popup(action));
	      his_self.endTurn();
	    });

  	  } else {
	    salert("Papacy has played Diplomatic Pressure - selecting Protestant card to play");
	  }

          return 0;
        }

        if (mv[0] === "diplomatic_pressure_swap_cards") {

	  let papacy_card = mv[1];
	  let protestant_card = mv[2];

	  if (his_self.returnPlayerOfFaction("papacy") == his_self.game.player) {
	    for (let i = 0; i < his_self.game.deck[1].hand.length; i++) {
	      if (his_self.game.deck[1].hand[i] == papacy_card) {
		his_self.game.deck[1].hand.splice(i, 1);
	      }
	    }
	    his_self.game.deck[1].hand.push(protestant_card);
	  }
	  if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player) {
	    for (let i = 0; i < his_self.game.deck[1].hand.length; i++) {
	      if (his_self.game.deck[1].hand[i] == protestant_card) {
		his_self.game.deck[1].hand.splice(i, 1);
	      }
	    }
	    his_self.game.deck[1].hand.push(papacy_card);
	  }

          his_self.game.queue.splice(qe, 1);

	  return 1;

	}

        if (mv[0] === "diplomatic_pressure_results_protestant") {

          his_self.game.queue.splice(qe, 1);

          let cards = JSON.parse(mv[1]);

 	  let msg = "Papal Card is "+his_self.popup(cards[0]);
          let html = '<ul>';
          html += `<li class="option" id="discard">discard ${his_self.game.deck[1].cards[cards[0]].name}</li>`;
          html += `<li class="option" id="swap">swap ${his_self.game.deck[1].cards[cards[0]].name}</li>`;
    	  html += '</ul>';


	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {
	    his_self.updateStatus("Protestants playing Diplomatic Pressure");
	    return 0;
	  }

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

  	    $('.option').off();
	    let action = $(this).attr("id");
            his_self.updateStatus("acknowledge...");

	    if (action === "discard") {
	      his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("papacy"))+"\t1");
              his_self.addMove("discard_diplomacy_card\tpapacy\t"+cards[0]);
	      his_self.addMove("NOTIFY\tProtestants discard "+his_self.popup(cards[0]));
	      his_self.endTurn();
	    }

	    if (action === "swap") {
	      his_self.addMove("diplomatic_pressure_swap_cards\t"+cards[0]+"\t"+his_self.game.deck[1].hand[0]);
	      his_self.addMove("NOTIFY\tProtestants swap Diplomacy Cards");
	      his_self.endTurn();
	    }

	  });

          return 0;
	}

        return 1;

      },
    }
    deck['206'] = { 
      img : "cards/HIS-206.svg" , 
      name : "French Invasion" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.setEnemies("france", "papacy");

	let p = his_self.returnPlayerOfFaction("protestant");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select French-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "france")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("french_invasion\t"+spacekey);
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
	      if (his_self.game.state.leaders.francis_i) {
                his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\tfrancis-i");
              } else {
		his_self.addMove("add_army_leader\tfrance\t"+spacekey+"\thenry-ii");
              }
	      his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true 

          );

	}

        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "french_invasion") {

	  let spacekey = mv[1];
          his_self.game.queue.splice(qe, 1);

	  //
	  // 2P card, so french get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tfrance");
	  his_self.addMove("declare_war\tpapacy\tfrance");

	  let player = his_self.returnPlayerOfFaction("protestant");
	  if (his_self.game.player == player) {

 	    let msg = "Choose Option:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">1 squadron in French home port</li>';
            html += '<li class="option" id="mercenaries">2 more mercenaries in '+his_self.returnSpaceName(spacekey)+'</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");
	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select French Home Port",

                  function(space) {
                    if (space.ports.length > 0 && space.home == "france") {
                      return 1;
                    }
                  },

                  function(spacekey) {
		    his_self.updateStatus("French add Squadrons in " + his_self.returnSpaceName(spacekey));
                    his_self.addMove("build\tland\tfrance\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
                  },

		  null,

		  true

                );
	      }
	      if (action === "mercenaries") {
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\tfrance\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
	      }
	    });
	  } else {
	    his_self.updateLog("Protestants playing " + his_self.popup("206"));
	  }
	  return 0;
	}

        return 1;

      },
    }
    deck['207'] = { 
      img : "cards/HIS-207.svg" , 
      name : "Henry Petitions for Divorce" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");
	if (his_self.game.player == p) {

          let msg = his_self.popup("207") + " played for Diplomatic Event";
          let html = '<ul>';
          html += '<li class="option" id="grant">Grant Divorce</li>';
          html += '<li class="option" id="refuse">Refuse Divorce</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let action = $(this).attr("id");
            $('.option').off();

	    if (action === "grant") {

	      his_self.updateStatus("Papacy grants divorce...");
	      his_self.addMove(`NOTIFY\t${his_self.popup("207")} - Papacy grants divorce...`);
	      his_self.addMove("player_call_theological_debate\tpapacy");
	      his_self.addMove("henry_petitions_for_divorce_grant");
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
	      his_self.endTurn();
	    }

	    if (action === "refuse") {
	      his_self.updateStatus("Papacy refuses divorce...");
	      his_self.addMove(`NOTIFY\t${his_self.popup("207")} - Papacy refuses divorce...`);
	      his_self.addMove("henry_petitions_for_divorce_refuse\t3");
	      his_self.addMove("henry_petitions_for_divorce_refuse\t2");
	      his_self.addMove("henry_petitions_for_divorce_refuse\t1");
	      his_self.endTurn();
	    }

	  });
	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "henry_petitions_for_divorce_grant") {

          his_self.game.queue.splice(qe, 1);
	  his_self.game.state.events.henry_petitions_for_divorce_grant = 1;

	  let p = his_self.returnPlayerOfFaction("protestant");
	  if (his_self.game.player == p) {

            his_self.playerSelectSpaceWithFilter(

              "Select Hapsburg-Controlled Italian Space" ,

              (space) => {
                if (his_self.isSpaceControlled(space.key, "hapsburg") && space.language === "italian") { return 1; }
		return 0;
	      },

              (spacekey) => {
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
	        his_self.addMove(`NOTIFY\tHapsburg recruits 4 mercenaries in ${his_self.returnSpaceName(spacekey)}`);
	        his_self.endTurn();
	      },

    	      null ,

	      true
    
	    );

	  } else {
	    his_self.updateStatus("Protestants selecting Italian space for reinforcements");
	  }

	  return 0;
	}


        if (mv[0] === "henry_petitions_for_divorce_refuse") {

          his_self.game.queue.splice(qe, 1);

	  let num = parseInt(mv[1]);

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }

	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
            his_self.playerSelectSpaceWithFilter(

              `Select Hapsburg-Controlled Space to add ${num} Regular` ,

              function(space) {
	        if (space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) { return 0; }
                if (his_self.isSpaceControlled(space.key, "hapsburg")) { return 1; }
	        return 0;
              },

              function(spacekey) {
                his_self.addMove("build\tland\thapsburg\tregular\t"+spacekey);
	        his_self.addMove(`NOTIFY\tHapsburg add regular in ${his_self.returnSpaceName(spacekey)}`);
          	his_self.endTurn();
              },

              null, 

	      true

	    );
	  }

	  return 0;
	}
	return 1;
      }
    }
    deck['208'] = { 
      img : "cards/HIS-208.svg" , 
      name : "Knights of St. John" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	his_self.game.queue.push("knights-of-saint-john\t"+faction);
	his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
        his_self.game.queue.push(`DEAL\t1\t${p}\t1`);

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "knights-of-saint-john") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (player == his_self.game.player) {

            let fhand_idx = his_self.returnFactionHandIdx(player, faction);
            let c = his_self.game.deck[0].fhand[fhand_idx][his_self.game.deck[0].fhand[fhand_idx].length-1];
	    let card = his_self.game.deck[0].cards[c];
	    let ops = card.ops;

	    his_self.addMove("discard\t"+faction+"\t"+c);
	    his_self.addMove("build_saint_peters_with_cp\t"+ops);
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" pulls "+his_self.popup(c)+ " "+ops+" CP");
	    his_self.endTurn();

	  }

	  return 0;
        }

	return 1;	
      }
    }
    deck['209'] = { 
      img : "cards/HIS-209.svg" , 
      name : "Plague" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } , 
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("plague\t"+faction+"\t3");
	his_self.game.queue.push("plague\t"+faction+"\t2");
	his_self.game.queue.push("plague\t"+faction+"\t1");
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "plague") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);
	  let opponent_faction = "protestant";
	  if (faction === "protestant") { opponent_faction = "papacy"; }

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; his_self.game.state.plague_already_removed = []; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      let anything_here = false;
	      for (let key in space.units) {
		if (space.units[key].length > 1) {
		  if (!his_self.game.state.plague_already_removed.includes(space.key)) {
		    for (let z = 0; z < space.units[key].length; z++) {
		      let u = space.units[key][z];
		      if (u.type === "regular") { return 1; }
		      if (u.type === "mercenary") { return 1; }
		      if (u.type === "cavalry") { return 1; }
		      if (u.type === "corsair") { return 1; }
		      if (u.type === "squadron") { return 1; }
		    }
		  }
		}
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Choose Faction to Destroy Unit:";
              let html = '<ul>';
	      let u = 0;
              if (space.units["hapsburg"].length) { u++; html += '<li class="option" id="hapsburg">hapsburgs</li>'; }
              if (space.units["france"].length) { u++; html += '<li class="option" id="france">france</li>'; }
              if (space.units["england"].length) { u++; html += '<li class="option" id="england">england</li>'; }
              if (space.units["papacy"].length) { u++; html += '<li class="option" id="papacy">papacy</li>'; }
              if (space.units["protestant"].length) { u++; html += '<li class="option" id="protestant">protestant</li>'; }
              if (space.units["ottoman"].length) { u++; html += '<li class="option" id="ottoman">ottoman</li>'; }
              if (space.units["hungary"].length) { u++; html += '<li class="option" id="hungary">hungary</li>'; }
              if (space.units["venice"].length) { u++; html += '<li class="option" id="venice">venice</li>'; }
              if (space.units["scotland"].length) { u++; html += '<li class="option" id="scotland">scotland</li>'; }
              if (space.units["genoa"].length) { u++; html += '<li class="option" id="genoa">genoa</li>'; }
              if (space.units["independent"].length) { u++; html += '<li class="option" id="independent">independent</li>'; }
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();

	        let faction_to_destroy = $(this).attr("id");
   	        let msg = "Destroy Which Unit: ";
                let unittypes = [];
		let unit_destroyed = 0;
                let html = '<ul>';
		let du = -1;
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].command_value == 0) {
		    if (!unittypes.includes(space.units[faction_to_destroy][i].type) &&
		        (space.units[faction_to_destroy][i].type == "regular" ||
		        space.units[faction_to_destroy][i].type == "mercenary" ||
		        space.units[faction_to_destroy][i].type == "squadron" ||
		        space.units[faction_to_destroy][i].type == "corsair" ||
		        space.units[faction_to_destroy][i].type == "cavalry")
		    ) {
		      if (du == -1) { du = i; } else { du = -2; }
  		      html += `<li class="option nonskip" id="${space.units[faction_to_destroy][i].type}">${space.units[faction_to_destroy][i].type}</li>`;
		      unittypes.push(space.units[faction_to_destroy][i].type);
		    }
		  }
		}
  		html += `<li class="option" id="skip">skip</li>`;
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

   	        $('.option').off();
	        $('.option').on('click', function () {

   	          $('.option').off();
	          let unittype = $(this).attr("id");
		  if (unit_destroyed == 1) { return; }	
		  unit_destroyed = 1;

		  if (unittype === "skip") {
          	    his_self.endTurn();
		    return 0;
		  }

          	  his_self.removeUnit(faction_to_destroy, spacekey, unittype);

 	          his_self.game.state.plague_already_removed.push(spacekey);

		  his_self.displaySpace(spacekey);
		  if (num === "3rd") { 
		    his_self.updateStatus("submitted");
		    his_self.addMove("discard_random\t"+opponent_faction);
		  }

          	  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	  his_self.endTurn();
		});

		// auto-submit if only 1 choice
		if (du > -1) { $('.nonskip').click(); }

              });

	      // auto-submit if only 1 choice
	      if (u == 1) { $('.option').click(); }

	    },

            null, 

	    true

	  );

          return 0;

	}

	return 1;
      },
    }
    deck['210'] = { 
      img : "cards/HIS-210.svg" , 
      name : "Shipbuilding" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } , 
      onEvent(his_self, faction) {
        his_self.game.queue.push("shipbuilding_diplomacy_event\t"+faction);
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
    
        if (mv[0] == "shipbuilding_diplomacy_event") {
    
          his_self.game.queue.splice(qe, 1);
                        
          let faction = mv[1];
          let player = his_self.returnPlayerOfFaction(faction);
                    
          if (his_self.game.player === player) { 
    
            if (faction === "papacy") {

              //
              // pick port under Papal control
              //
              his_self.playerSelectSpaceWithFilter(

                "Select Space to add 1st Squadron" ,

                  (space) => {
                    if (his_self.isSpaceControlled(space.key, "papacy")) {
		      if (space.ports.length > 0) {
			return 1;
		      }
		    }
		    return 0;
		  },

                  (spacekey) => {

		    let firstspace = spacekey;

              	    //
              	    // pick port under Papal control
              	    //
              	    his_self.playerSelectSpaceWithFilter(

                      "Select Space to add 2nd Squadron" ,

   	              (space) => {
                        if (his_self.isSpaceControlled(space.key, "papacy")) {
		          if (space.ports.length > 0) {
			    return 1;
		          }
		        }
		        return 0;
		      },

                      (spacekey) => {

                        let secondspace = spacekey;
                        his_self.addMove("build\tland\tpapacy\t"+"squadron"+"\t"+firstspace);
                        his_self.addMove("build\tland\tpapacy\t"+"squadron"+"\t"+secondspace);
		        his_self.endTurn();
		      },

		      null ,

		      true
    
		    );

	          },

		  null ,

		  true
    
	      );

            }       
    
            if (faction === "protestant") {
               
	      let squadron_placement_function = (num=1, squadron_placement_function) => {

                let msg = "Add 1st Naval Squadron Where?";
		if (num == 2) { msg = "Add 2nd Naval Squadron Where?"; }

                let html = '<ul>';
                html += '<li class="option" id="french">French - Marseille</li>';
                html += '<li class="option" id="hapsburg">Hapsburg - Naples</li>';
                html += '<li class="option" id="ottoman">Ottoman - any home port</li>';
                html += '<li class="option" id="skip">skip</li>';
                html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {

                  let action = $(this).attr("id");

		  if (action === "skip") {
		    his_self.endTurn();
		  }

		  if (action === "hapsburg") {
                    his_self.addMove("build\tland\thapsburg\t"+"squadron"+"\tnaples");
		    if (num == 2) { his_self.endTurn(); return; }
		    squadron_placement_function(2);
		  }

		  if (action === "french") {
                    his_self.addMove("build\tland\tfrance\t"+"squadron"+"\tmarseille");
		    if (num == 2) { his_self.endTurn(); return; }
		    squadron_placement_function(2);
		  }

		  if (action === "ottoman") {
                    //
                    // pick any Ottoman home port
                    //
                    his_self.playerSelectSpaceWithFilter(

                      "Select Ottoman-Controlled Home Port" ,

                      (space) => {
                        if (his_self.isSpaceControlled(space.key, "ottoman")) {
		          if (space.ports.length > 0) {
			    return 1;
		          }
		        }
		        return 0;
		      },

                      (spacekey) => {
                        let space = his_self.game.spaces[spacekey];
                        his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
		        if (num == 2) { his_self.endTurn(); return; }
		        squadron_placement_function(2);
		      },

		      null ,

		      true
    
	            );

		  }

                });

              }

	      squadron_placement_function(1, squadron_placement_function);

            }

          }
	  return 0;

	}
	return 1;
      },
    }
    deck['211'] = { 
      img : "cards/HIS-211.svg" , 
      name : "Spanish Invasion" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let controlling_power = "papacy";
	let victim_power = "protestant";

	//
	// prior to League formation
	//
	if (his_self.game.state.events.schmalkaldic_league != 1) {
	  controlling_power = "protestant";
	  victim_power = "papacy";
	  his_self.setEnemies("papacy","hapsburg");
	}

	let controlling_player = his_self.returnPlayerOfFaction(controlling_power);

	//
	// remember who controls the invasion
	//
	his_self.game.state.events.spanish_invasion = controlling_power;

	//
	// controlling power gets 1 card
	//
	his_self.game.queue.push("hand_to_fhand\t1\t"+controlling_player+"\t"+controlling_power+"\t1");
        his_self.game.queue.push(`DEAL\t1\t${controlling_player}\t1`);
	his_self.game.queue.push("spanish_invasion_land\t"+controlling_player+"\t"+controlling_power+"\t"+victim_power);

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "spanish_invasion_land") {

          his_self.game.queue.splice(qe, 1);

	  let controlling_player = parseInt(mv[1]);
	  let controlling_power = mv[2];
	  let victim_power = mv[3];

	  if (his_self.game.player === controlling_player) {

  	    //
	    // 2P card, so spanish get activated under protestant control
	    //
	    his_self.addMove("set_activated_powers\t"+controlling_power+"\thapsburg");
	    his_self.addMove("declare_war\t"+victim_power+"\thapsburg");

            his_self.playerSelectSpaceWithFilter(

              "Select Hapsburg-Controlled Space for Invasion Force",

              function(space) {
	        if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	        return 0;
              },

              function(spacekey) {

		his_self.updateStatus("acknowledge...");

	        //
	        // move Duke of Alva, add regulars
	        //
                let ak = his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva");
                let ak_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "duke-of-alva", ak);
          
                his_self.addMove("spanish_invasion_naval\t"+controlling_player+"\t"+spacekey);
		if (ak_idx == -1) {
                  his_self.addMove("add_army_leader" + "\t" + "hapsburg" + "\t" + spacekey + "\t" + "duke-of-alva");
		} else {
                  his_self.addMove("move" + "\t" + "hapsburg" + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		}
	        his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
                his_self.endTurn();
              },

	      null,

	      true

            );
	  }

          return 0;

	}
        if (mv[0] == "spanish_invasion_naval") {

          his_self.game.queue.splice(qe, 1);

	  let controlling_player = parseInt(mv[1]);
	  let land_spacekey = mv[2];

	  if (his_self.game.player === controlling_player) {

            let msg = "Add Additional Units:";
            let html = '<ul>';
            html += '<li class="option" id="squadron">Naval Squadron</li>';
            html += '<li class="option" id="mercenaries">+2 Mercenaries</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
              $('.option').off();

	      if (action === "squadron") {

                his_self.playerSelectSpaceWithFilter(

                  "Select Hapsburg-Controlled Port for Squadron",

                  function(space) {
	            if (his_self.isSpaceControlled(space, "hapsburg") && space.home == "hapsburg" && space.ports.length > 0) { return 1; }
	            return 0;
                  },

                  function(spacekey) {
		    his_self.updateStatus("acknowledge...");
                    his_self.addMove("build\tland\thapsburg\t"+"squadron"+"\t"+spacekey);
                    his_self.endTurn();
		  },

		  null ,

		  true
                );
	      }

	      if (action === "mercenaries") {
		his_self.updateStatus("acknowledge...");
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+land_spacekey);
	        his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+land_spacekey);
		his_self.endTurn();
	      }

            });
	  }

	  return 0;

	}

	return 1;
      },
    }
    deck['212'] = { 
      img : "cards/HIS-212.svg" , 
      name : "Venetian Alliance" ,
      ops : 0 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	return 1;
      },
      onEvent : function(his_self, faction) {

	let ally = his_self.returnAllyOfMinorPower("venice");

	// papacy is only faction that can activate
	if (ally === "" || ally === "venice") {
	  his_self.activateMinorPower("papacy", "venice");
	}
	if (ally == "france") {
	  his_self.deactivateMinorPower("france", "venice");
	}
	if (ally == "hapsburg") {
	  his_self.deactivateMinorPower("hapsburg", "venice");
	}
        if (ally === "papacy" && faction == "papacy") {
	  his_self.game.queue.push("venetian_alliance_placement");
	}
        if (ally === "papacy" && faction == "ottoman") {
	  his_self.deactivateMinorPower("papacy", "venice");
	}
	his_self.displayWarBox();

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "venetian_alliance_placement") {

          his_self.game.queue.splice(qe, 1);
	  if (his_self.game.player == his_self.returnPlayerOfFaction("papacy")) {  
            his_self.playerSelectSpaceWithFilter(

              "Select Papal-Controlled Port not under Siege",

              function(space) {
	        if (his_self.isSpaceControlled(space, "papacy") && space.ports.length > 0 && !space.besieged) { return 1; }
	        return 0;
              },

              function(spacekey) {
	        his_self.addMove("build\tland\tvenice\t"+"regular"+"\t"+spacekey);
                his_self.addMove("build\tland\tvenice\t"+"squadron"+"\t"+spacekey);
                his_self.addMove("build\tland\tvenice\t"+"squadron"+"\t"+spacekey);
                his_self.endTurn();
              },

	      null,

	      true

            );
            return 0;
          } else {
	    his_self.updateStatus("Papacy executing " + his_self.popup("212"));
	  }

	  return 0;
	}

	return 1;

      },

    }
    deck['213'] = { 
      img : "cards/HIS-213.svg" , 
      name : "Austrian Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; }, 
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select Hapsburg-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy"+"\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\thapsburg\t"+spacekey+"\tferdinand");
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true
          );

	}

        return 0;
      },
    }
    deck['214'] = { 
      img : "cards/HIS-214.svg" , 
      name : "Imperial Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

	if (his_self.game.player == p) {

          his_self.playerSelectSpaceWithFilter(

            "Select Hapsburg-Controlled Space",

            function(space) {
	      if (his_self.isSpaceControlled(space, "hapsburg")) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"papacy\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\thapsburg\t"+spacekey+"\tcharles-v");
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.addMove("build\tland\thapsburg\t"+"mercenary"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true,
          );

	}

        return 0;
      },
    }
    deck['215'] = { 
      img : "cards/HIS-215.svg" , 
      name : "Machiavelli" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let vp = his_self.calculateVictoryPoints();
	let winner = "protestant";

	if (vp["protestant"].vp > vp["papacy"].vp) { winner = "papacy"; }
	if (vp["protestant"].vp == vp["papacy"].vp) { winner = faction; }

	//
	// TODO -- cannot pick an invasion card played earlier this turn
	//
	if (his_self.game.player == his_self.returnPlayerOfFaction(winner)) {

          let msg = "Select Invasion Card:";
          let html = '<ul>';
          html += '<li class="option showcard" id="216">Ottoman Invasion</li>';
          html += '<li class="option showcard" id="214">Imperial Invasion</li>';
          html += '<li class="option showcard" id="213">Austrian Invasion</li>';
          html += '<li class="option showcard" id="211">Spanish Invasion</li>';
          html += '<li class="option showcard" id="206">French Invasion</li>';
          html += '<li class="option showcard" id="202">French Constable Invades</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

	    his_self.updateStatus("acknowledge...");
            let card = $(this).attr("id");
	    his_self.addMove("reshuffle_diplomacy_deck");
	    his_self.addMove("diplomacy_card_event\t"+winner+"\t"+card);
	    his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus("Opponent playing " + his_self.popup("215"));
	}

        return 0;
      },
    }
    deck['216'] = { 
      img : "cards/HIS-216.svg" , 
      name : "Ottoman Invasion" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");
	his_self.setEnemies("ottoman", "papacy");

	if (his_self.game.player == p) {

  	  //
	  // 2P card, so ottoman get activated under protestant control
	  //
	  his_self.addMove("set_activated_powers\tprotestant\tottoman");
	  his_self.addMove("declare_war\tpapacy\tottoman");

          his_self.playerSelectSpaceWithFilter(

            `Select Ottoman-Controlled Port for ${his_self.popup("216")}`,

            function(space) {
	      if (his_self.isSpaceControlled(space, "ottoman") && space.ports.length > 0) { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+"protestant\t1");
              his_self.addMove(`DEAL\t1\t${p}\t1`);
              his_self.addMove("add_army_leader\tottoman\t"+spacekey+"\tsuleiman");
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.addMove("build\tland\tottoman\t"+"squadron"+"\t"+spacekey);
              his_self.endTurn();
            },

	    null,

	    true 

          );

	}

        return 0;
      },
    }
    deck['217'] = { 
      img : "cards/HIS-217.svg" , 
      name : "Secret Protestant Circle" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");
	let d = his_self.rollDice(6);

	his_self.rollDice("Secret Protestant Circle - rolls: " + d);

	if (d <= 3) {
	  his_self.updateLog("Protestants may flip an Italian and Spanish space");
	  his_self.game.queue.push("secret_protestant_circle\tspanish");
	  his_self.game.queue.push("secret_protestant_circle\titalian");
	} else {
	  his_self.updateLog("Protestants may convert an Italian space");
	  his_self.game.queue.push("secret_protestant_circle\titalian");
	}

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "secret_protestant_circle") {

	  let zone = mv[1];
	  let player = his_self.returnPlayerOfFaction("protestant");
	  if (player === his_self.game.player) {

            his_self.playerSelectSpaceWithFilter(

              "Select Space to Convert Protestant" ,

              function(space) {
                if (space.language === zone) { return 1; }
	        return 0;
              },

              function(spacekey) {
                his_self.addMove("convert\t"+spacekey+"\tprotestant");
                his_self.endTurn();
              },

	      null,

	      true
            );
	  }
	  
          his_self.game.queue.splice(qe, 1);
          return 0;
        }
	return 1;
      }
    }
    deck['218'] = { 
      img : "cards/HIS-218.svg" , 
      name : "Siege of Vienna" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let lockdown = ["regensburg","salzburg","linz","prague","breslau","brunn","vienna","graz","trieste","agram","pressburg","buda"];
	for (let i = 0; i < lockdown.length; i++) {
	  for (let z = 0; z < his_self.game.spaces[lockdown[i]].units["hapsburg"].length; z++) {
	    his_self.game.spaces[lockdown[i]].units["hapsburg"][z].locked = 1;
	  }
	  for (let z = 0; z < his_self.game.spaces[lockdown[i]].units["hungary"].length; z++) {
	    his_self.game.spaces[lockdown[i]].units["hungary"][z].locked = 1;
	  }
	}

	let spaces = his_self.returnSpacesWithFilter(
          function(spacekey) {
            if (his_self.returnFactionLandUnitsInSpace("hapsburg", spacekey)) { return true; }
            if (his_self.returnFactionLandUnitsInSpace("hungary", spacekey)) { return true; }
	    return false;
	  }
	);

	if (spaces.length >= 2) {
	  his_self.game.queue.push("siege_of_vienna\t"+faction+"\t2");
	}
	if (spaces.length >= 1) {
	  his_self.game.queue.push("siege_of_vienna\t"+faction+"\t1");
	}
	if (spaces.length == 0) {
console.log("Siege of Vienna - no valid spaces");
	}

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "siege_of_vienna") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerCommandingFaction(faction);

	  let lockdown = ["regensburg","salzburg","linz","prague","breslau","brunn","vienna","graz","trieste","agram","pressburg","buda"];
	  if (player == his_self.game.player) {

 	    let msg = `${his_self.popup("218")}: remove unit #${num}:`;
            let html = '<ul>';
            html += '<li class="option" id="hapsburg">remove hapsburg unit</li>';
            html += '<li class="option" id="hungary">remove hungarian unit</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

	      let action = $(this).attr("id");

	      if (action === "hapsburg") {

                let spaces = his_self.returnSpacesWithFilter(
                  function(spacekey) {
	            if (!lockdown.includes(spacekey)) { return false; }
                    if (his_self.returnFactionLandUnitsInSpace("hapsburg", spacekey)) { return true; }
                    return false;
                  } 
                );

	        if (spaces.length == 0) {
	 	  his_self.addMove("NOTIFY\tSiege of Vienna - no units to target.");
	 	  his_self.endTurn();
		  return 0;
	        }

                his_self.playerSelectSpaceWithFilter(

                  "Select Space to Remove Unit" ,

                  function(space) {
console.log("considering: " + space.key);
                    if (spaces.includes(space.key)) { return 1; }
	            return 0;
                  },

                  function(spacekey) {

console.log("selected: " + spacekey);

		    let has_mercenary = false;
		    let has_regular = false;
		    let has_cavalry = false;

		    for (let i = 0; i < his_self.game.spaces[spacekey].units["hapsburg"].length; i++) {
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "mercenary") { has_mercenary = true; }
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "regular") { has_regular = true; }
		      if (his_self.game.spaces[spacekey].units["hapsburg"][i].type === "cavalry") { has_cavalry = true; }
		    }

   	            let msg = "Choose Unit to Destroy:";
                    let html = '<ul>';
                    if (has_regular) { html += '<li class="option" id="regular">hapsburg regular</li>'; }
                    if (has_mercenary) { html += '<li class="option" id="mercenary">hapsburg mercenary</li>'; }
                    if (has_cavalry) { html += '<li class="option" id="cavalry">hapsburg cavalry</li>'; }
    	            html += '</ul>';

                    his_self.updateStatusWithOptions(msg, html);

   	            $('.option').off();
	            $('.option').on('click', function () {

		      let unittype = $(this).attr("id");
          	      his_self.removeUnit("hapsburg", spacekey, unittype);
		      his_self.displaySpace(spacekey);
          	      his_self.addMove("remove_unit\tland\thapsburg\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	      his_self.endTurn();
		    });
                  },

		  null, 

		  true
                );

              } // end hapsburg


	      if (action === "hungary") {

                let spaces = his_self.returnSpacesWithFilter(
                  function(spacekey) {
	            if (!lockdown.includes(spacekey)) { return false; }
                    if (his_self.returnFactionLandUnitsInSpace("hungary", spacekey)) { return true; }
                    return false;
                  } 
                );

                his_self.playerSelectSpaceWithFilter(

                  "Select Space to Remove Unit" ,

                  function(space) {
                    if (spaces.includes(space.key)) { return 1; }
	            return 0;
                  },

                  function(spacekey) {

		    let has_mercenary = false;
		    let has_regular = false;
		    let has_cavalry = false;

		    for (let i = 0; i < his_self.game.spaces[spacekey].units["hungary"].length; i++) {
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "mercenary") { has_mercenary = true; }
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "regular") { has_regular = true; }
		      if (his_self.game.spaces[spacekey].units["hungary"][i].type === "cavalry") { has_cavalry = true; }
		    }

   	            let msg = "Choose Unit to Destroy:";
                    let html = '<ul>';
                    if (has_regular) { html += '<li class="option" id="regular">hungarian regular</li>'; }
                    if (has_mercenary) { html += '<li class="option" id="mercenary">hungarian mercenary</li>'; }
                    if (has_cavalry) { html += '<li class="option" id="cavalry">hungarian cavalry</li>'; }
    	            html += '</ul>';

                    his_self.updateStatusWithOptions(msg, html);

   	            $('.option').off();
	            $('.option').on('click', function () {

		      let unittype = $(this).attr("id");
          	      his_self.removeUnit("hungary", spacekey, unittype);
		      his_self.displaySpace(spacekey);
          	      his_self.addMove("remove_unit\tland\thungary\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	      his_self.endTurn();
		    });
                  },

		  null, 

		  true
                );

              } // end hapsburg
            });

	  } // player

          his_self.game.queue.splice(qe, 1);
          return 0;

	} // siege_of_vienna

	return 1;
      }
    }
    deck['219'] = { 
      img : "cards/HIS-219.svg" , 
      name : "Spanish Inquisition" ,
      ops : 0 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (faction === "papacy") {
	  his_self.game.queue.push("spanish_inquisition_reveal");
	}

	if (faction === "protestant") {
	  his_self.game.queue.push("request_reveal_hand\tpapacy\tprotestant");
	  his_self.game.queue.push("NOTIFY\tProtestants play Spanish Inquisition");
   	}

        return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "spanish_inquisition_reveal") {

          if (his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {
            his_self.addMove("spanish_inquisition_results\t"+JSON.stringify(his_self.game.deck[1].hand));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;
	}


        if (mv[0] === "spanish_inquisition_results") {

          let cards = JSON.parse(mv[1]);

          his_self.game.queue.splice(qe, 1);
	  // remove protestant play 
          his_self.game.queue.splice(qe-1, 1);

	  if (his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {

   	    let msg = "Choose Protestant Card to Discard:";
            let html = '<ul>';
	    for (let i = 0; i < cards.length; i++) {
              html += `<li class="showcard option" id="${cards[i]}">${his_self.game.deck[1].cards[cards[i]].name}</li>`;
	    }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

  	    $('.option').off();
	    $('.option').on('click', function () {

  	      $('.option').off();
	      let action = $(this).attr("id");

	      let chosen_card = action;
	      let unchosen_card = "";
	      for (let i = 0; i < cards.length; i++) { if (cards[i] != action) { unchosen_card = cards[i]; } }

              his_self.addMove("diplomacy_card_event\tprotestant\t"+unchosen_card);
              his_self.addMove("discard_diplomacy_card\tprotestant\t"+chosen_card);
	      his_self.addMove("DEAL\t2\t"+(his_self.returnPlayerOfFaction("protestant"))+"\t1");
	      his_self.addMove("NOTIFY\tPapacy selects "+his_self.game.deck[1].cards[action].name+" to discard");
	      his_self.endTurn();

	    });

  	  }

          return 0;
        }

        return 1;

      },
    }
    for (let key in deck) {
      deck[key] = this.addEvents(deck[key]);
    }

    return deck;

  }


  removeCardFromGame(card) {
    if (!this.game.state.removed.includes(card)) { this.game.state.removed.push(card); }
    try { delete this.game.deck[0].cards[card]; } catch (err) {}
    try { delete this.game.deck[0].discards[card]; } catch (err) {}
  }


  returnDeck(include_removed=false) {

    var deck = {};

    /// HOME CARDS
    deck['001'] = { 
      img : "cards/HIS-001.svg" , 
      name : "Janissaries" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "ottoman" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "janissaries" || menu === "janissaries_naval") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
              let f = "ottoman";
              return { faction : f , event : '001', html : `<li class="option" id="001">janissaries (${f})</li>` };
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "janissaries") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
	      if (his_self.doesFactionHaveLandUnitsInSpace("ottoman", spacekey)) {
	        his_self.field_battle_overlay.render(his_self.game.state.field_battle);
                return 1;
              }
            }
          }
        }
        if (menu === "janissaries_naval") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('001')) {
	      if (his_self.doesFactionHaveNavalUnitsInSpace("ottoman", spacekey)) {
	        his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "janissaries") {
	  his_self.addMove("ACKNOWLEDGE\tOttomans play Janissaries");
          his_self.addMove("discard\tottoman\t001");
          his_self.addMove("janissaries");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        if (menu == "janissaries_naval") {
	  his_self.addMove("ACKNOWLEDGE\tOttomans play Janissaries");
          his_self.addMove("discard\tottoman\t001");
          his_self.addMove("janissaries\tnaval");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "janissaries") {

          his_self.game.queue.splice(qe, 1);
	  his_self.updateLog("Ottoman Empire plays "+his_self.popup('001'));

	  if (mv[1]) {
	    if (mv[1] === "naval") {
	      his_self.game.queue.push("add_naval_battle_bonus_rolls\tottoman\t4");
	      return 1;
	    }
	  }
	  his_self.game.queue.push("add_field_battle_bonus_rolls\tottoman\t5\tjanissaries");
	  return 1;
        }

	return 1;

      },
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

        if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

          //
          // add 4 regulars in Ottoman space
          //
          his_self.playerSelectSpaceWithFilter(
                
            "Add 4 regulars in Ottoman Home Space or Foreign War: #1", 
               
            function(space) {
              if (space.political != "" && space.political != "ottoman") { return 0; }
              if (space.key === "oran") { return 0; }
              if (space.key === "algiers") { return 0; }
              if (space.pirate_haven === 1) { return 0; }
              if (space.home == "ottoman") { return 1; }
              if ((space.key == "persia" && his_self.game.state.events.war_in_persia == 1) || (space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1)) { return 1; }
	      return 0;
            },

	    function(spacekey) {
	      his_self.addRegular("ottoman", spacekey, 1);
	      his_self.displayBoard(spacekey);
	      his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey+"\t"+his_self.game.player);

	      //
	      // #2
	      //
              his_self.playerSelectSpaceWithFilter(
                
                "Add 4 regulars in Ottoman Home Space or Foreign War: #2",                

                function(space) {
                  if (space.political != "" && space.political != "ottoman") { return 0; }
                  if (space.key === "oran") { return 0; }
                  if (space.key === "algiers") { return 0; }
                  if (space.pirate_haven === 1) { return 0; }
                  if (space.home == "ottoman") { return 1; }
                  if ((space.key == "persia" && his_self.game.state.events.war_in_persia == 1) || (space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1)) { return 1; }
	          return 0;
                },

	        function(spacekey) {

	          his_self.addRegular("ottoman", spacekey, 1);
		  his_self.displayBoard(spacekey);
	          his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey+"\t"+his_self.game.player);

	      	  //
	      	  // #3
	          //
                  his_self.playerSelectSpaceWithFilter(
                
                    "Add 4 regulars in Ottoman Home Space or Foreign War: #3",                

                    function(space) {
                      if (space.political != "" && space.political != "ottoman") { return 0; }
                      if (space.key === "oran") { return 0; }
                      if (space.key === "algiers") { return 0; }
                      if (space.pirate_haven === 1) { return 0; }
                      if (space.home == "ottoman") { return 1; }
                      if ((space.key == "persia" && his_self.game.state.events.war_in_persia == 1) || (space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1)) { return 1; }
	              return 0;
                    },

	            function(spacekey) {
	              his_self.addRegular("ottoman", spacekey, 1);
		      his_self.displayBoard(spacekey);
	              his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey+"\t"+his_self.game.player);

	              //
	      	      // #3
	              //
                      his_self.playerSelectSpaceWithFilter(
                
                        "Add 4 regulars in Ottoman Home Space or Foreign War: #4",                

                        function(space) {
                          if (space.political != "" && space.political != "ottoman") { return 0; }
                          if (space.key === "oran") { return 0; }
                          if (space.key === "algiers") { return 0; }
                          if (space.pirate_haven === 1) { return 0; }
                          if (space.home == "ottoman") { return 1; }
                          if ((space.key == "persia" && his_self.game.state.events.war_in_persia == 1) || (space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1)) { return 1; }
	                  return 0;
                        },
 
	                function(spacekey) {
	                  his_self.addRegular("ottoman", spacekey, 1);
		          his_self.displayBoard(spacekey);
	                  his_self.addMove("build\tland\tottoman\t"+"regular"+"\t"+spacekey+"\t"+his_self.game.player);
			  his_self.endTurn();
		        },

			null, 

		        true

		      );
		    },

		    null, 

		    true

	          );
	        },
	        
	        null,

	        true

	      );
	    },

	    null,

	    true

	  );
	}

	return 0;
      },

    }
    deck['002'] = { 
      img : "cards/HIS-002.svg" , 
      name : "Holy Roman Emperor" ,
      ops : 5 ,
      turn : 1 , 
      type : "normal" ,
      faction : "hapsburg" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let ck = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	let ck_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "charles-v", ck);
	if (ck_idx == -1) { return 0; }
        if (his_self.isBesieged("hapsburg", "charles-v")) { return 0; }
        if (his_self.isCaptured("hapsburg", "charles-v")) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let ck = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	let ak = his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva");
	let ck_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "charles-v", ck);
	let ak_idx = his_self.returnIndexOfPersonageInSpace("hapsburg", "duke-of-alva", ak);

	if (ck_idx === -1) {
	  his_self.updateLog("Skipping Holy Roman Emperor - Charles V not on board");
	  return 1;
	}

	if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {	

        his_self.playerSelectSpaceWithFilter(

	  "Select Destination for Charles V: ",

	  function(space) {
		if (
		  space.home === "hapsburg" &&
		  his_self.isSpaceControlled(space, "hapsburg") &&
		  !his_self.isSpaceBesieged(space)
	        ) {
		  return 1;
	        }
		return 0;
	  },

	  function(spacekey) {

		if (ak === ck && ak !== "") {

		  let msg = "Move Duke of Alva with Charles V?";
    		  let html = '<ul>';
        	  html += '<li class="option" id="yes">yes</li>';
        	  html += '<li class="option" id="no">no</li>';
    		  html += '</ul>';

    		  his_self.updateStatusWithOptions(msg, html);

	          $('.option').off();
	          $('.option').on('click', function () {

	            let action = $(this).attr("id");
		    his_self.updateStatus("moving...");
		    if (action === "yes") {
		      his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		      if (ck_idx > ak_idx) {
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		      } else {
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		        his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ak + "\t" + spacekey + "\t" + ak_idx + "\t1");
		      }
		      his_self.endTurn();
		    } else {
		      his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		      his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		      his_self.endTurn();
		    }
		  });

		} else {
		  his_self.addMove("ops\t"+faction+"\t"+"002"+"\t"+5);
		  his_self.addMove("move" + "\t" + faction + "\t" + "land" + "\t" + ck + "\t" + spacekey + "\t" + ck_idx + "\t1");
		  his_self.endTurn();
		}

	  },

	  null,

	  true 
	);
	} else {
	  his_self.updateStatus("Hapsburgs playing Home Card");
	}

        return 0;
      },
    }
    deck['003'] = { 
      img : "cards/HIS-003.svg" , 
      name : "Six Wives of Henry VIII" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "england" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("six-wives-of-henry-viii\t"+faction);
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "six-wives-of-henry-viii") {

	    let faction = mv[1];
            his_self.game.queue.splice(qe, 1);

	    let target_haps = false;
	    let target_france = false;
	    let target_scotland = false;

	    let options1 = false;
	    let options2 = false;

	    if (!his_self.areAllies("england", "hapsburg") && !his_self.areEnemies("england", "hapsburg")) { target_haps = true; }
	    if (!his_self.areAllies("england", "scotland") && !his_self.areEnemies("england", "scotland")) { target_scotland = true; }
	    if (!his_self.areAllies("england", "france") && !his_self.areEnemies("england", "france")) { target_france = true; }

	    if (target_haps || target_france || target_scotland) {
	      options1 = true;
	    }

	    if (his_self.game.state.round >= 2 && his_self.game.state.leaders.henry_viii == 1) {
	      if (!his_self.isCaptured("england", "henry-viii") && !his_self.isBesieged("hapsburg", "charles-v")) {
	        options2 = true;
	      }
	    }
	  
	    if (options1 && options2) {

	      if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {

                let msg = "Choose an Option: ";
                let html = '<ul>';
                html += `<li class="option" id="war">Declare War</li>`;
                html += `<li class="option" id="marital">Advance Marital Status</li>`;
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {
		
                  let action2 = $(this).attr("id");
	          his_self.updateStatus("submitting...");

	          if (action2 === "war") {
	    	    his_self.addMove("henry_viii_declaration_of_war");
		    his_self.endTurn();
	          }
	          if (action2 === "marital") {
	  	    his_self.addMove("display_vp_track");
	  	    his_self.addMove("advance_henry_viii_marital_status");
		    his_self.endTurn();
	          }
	        });

	        return 0;

              }
            } 

	    if (options1) {
	      his_self.game.queue.push("henry_viii_declaration_of_war");
	      return 1;
	    }

	    if (options2) {
	      his_self.game.queue.push("advance_henry_viii_marital_status");
	      return 1;
	    }

	  return 0;
        }

	if (mv[0] === "henry_viii_declaration_of_war") {

	  let target_haps = false;
	  let target_france = false;
	  let target_scotland = false;

	  let options1 = false;
	  let options2 = false;

	  if (!his_self.areAllies("england", "hapsburg") && !his_self.areEnemies("england", "hapsburg")) { target_haps = true; }
	  if (!his_self.areAllies("england", "scotland") && !his_self.areEnemies("england", "scotland")) { target_scotland = true; }
	  if (!his_self.areAllies("england", "france") && !his_self.areEnemies("england", "france")) { target_france = true; }

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {

            let msg = "Declare War on Whom?";
            let html = '<ul>';
            if (target_haps) { html += `<li class="option" id="hapsburg">Hapsburg</li>`; }
            if (target_france) { html += `<li class="option" id="france">France</li>`; }
            if (target_scotland) { html += `<li class="option" id="scotland">Scotland</li>`; }
	    html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {
		
              let action2 = $(this).attr("id");
	      his_self.updateStatus("acknowledge");

	      his_self.addMove("ops\tengland\t003\t5");
	      if (action2 === "scotland" && (!his_self.areAllies("england", "scotland") || !his_self.areEnemies("england","france"))) {
	        his_self.addMove("natural_ally_intervention\tfrance\tscotland\tengland\t0\tEngland declares war on Scotland");
	      }	
	      his_self.addMove("unexpected_war\tengland\t"+action2);
	      his_self.addMove("declare_war\tengland\t"+action2+"\t1"); // 1 = skip natural ally intervention
	      his_self.endTurn();

	    });

	  }

          his_self.game.queue.splice(qe, 1);

	  return 0;

	}

        if (mv[0] === "advance_henry_viii_marital_status") {

          his_self.game.queue.splice(qe, 1);
	  let msg = "Henry VIII is pleased with his marital progress...";

	  //
	  // prevents Hapsburg-Papal alliance... or de-activates it as may be
	  //
	  if (his_self.game.state.round == his_self.game.state.henry_viii_pope_approves_divorce_round) {
	    if (his_self.areAllies("papacy", "hapsburg")) {
	      his_self.unsetAllies("papacy", "hapsburg");
	    }
	  }

	  //
	  // Henry VIII already dead, cannot roll
	  //
	  if (his_self.game.state.leaders.mary_i == 1 || his_self.game.state.leaders.edward_vi == 1 || his_self.game.state.leaders.elizabeth_i == 1) {
	    return 1;
	  }

	  his_self.game.state.henry_viii_marital_status++;
	  if (!his_self.game.state.henry_viii_wives) { his_self.game.state.henry_viii_wives = []; }

	  if (his_self.game.state.henry_viii_marital_status == 1) {
	    his_self.updateLog("Henry VIII requests a divorce...");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 2) {
	    his_self.game.state.henry_viii_wives.push("boleyn");
	    his_self.updateLog("Henry VIII marries Anne Boleyn");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 3) {
	    his_self.game.state.henry_viii_wives.push("seymour");
	    his_self.updateLog("Henry VIII marries Jane Seymour");
	  }
	  if (his_self.game.state.henry_viii_marital_status == 4) {
	    his_self.game.state.henry_viii_wives.push("cleves");
	    his_self.updateLog("Henry VIII marries Anne of Cleves");

	    if (his_self.areAllies("england", "protestant")) {
	      let pp = his_self.returnPlayerOfFaction("protestant");
	      let pe = his_self.returnPlayerOfFaction("england");

              his_self.game.queue.push("cards_left\tprotestant\t"+(parseInt(his_self.game.state.cards_left["protestant"])+1));
              his_self.game.queue.push('hand_to_fhand\t1\t' + pp + '\t' + "protestant" + "\t1");
              his_self.game.queue.push("DEAL\t1\t"+pp+"\t1");

              his_self.game.queue.push("cards_left\tengland\t"+(parseInt(his_self.game.state.cards_left["england"])+1));
              his_self.game.queue.push('hand_to_fhand\t1\t' + pe + '\t' + "england" + "\t1");
              his_self.game.queue.push("DEAL\t1\t"+pe+"\t1");
	    }

	  }
	  if (his_self.game.state.henry_viii_marital_status == 5) {

	    his_self.game.state.henry_viii_wives.push("howard");
	    his_self.updateLog("Henry VIII marries Kathryn Howard");

	    let pe = his_self.returnPlayerOfFaction("england");

            his_self.game.queue.push("cards_left\tengland\t"+(parseInt(his_self.game.state.cards_left["england"])+1));
            his_self.game.queue.push('hand_to_fhand\t1\t' + pe + '\t' + "england" + "\t1");
            his_self.game.queue.push("DEAL\t1\t"+pe+"\t1");

	  }
	  if (his_self.game.state.henry_viii_marital_status == 6) {
	    his_self.game.state.henry_viii_wives.push("parr");
	    his_self.updateLog("Henry VIII marries Katherine Parr");
	  }

	  if (his_self.game.state.henry_viii_marital_status > 7) { his_self.game.state.henry_viii_marital_status = 7; return 1; }
	  if (his_self.game.state.henry_viii_marital_status >= 2) {

	    his_self.updateStatus("Henry VIII makes a roll on the pregnancy chart");
	    let dd = his_self.rollDice(6);

	    if (his_self.game.state.henry_viii_marital_status == 3) { 
	      his_self.updateLog("Henry VIII receives +1 bonus for Jane Seymour");
	      dd++;
	    }

	    if (his_self.game.state.henry_viii_rolls.includes(dd)) {
	      while (his_self.game.state.henry_viii_rolls.includes(dd) && dd < 6) {
	        dd++;
	      }
	    }

	    his_self.game.state.henry_viii_rolls.push(dd);

	    msg = "Henry VIII is pleased with his marital progress...";

	    // results of pregnancy chart rolls
	    if (dd == 1) {
	      msg = "Marriage Result: Marriage Fails...";
	      his_self.updateLog("Henry VIII rolls 1: marriage fails");
	    }
	    if (dd == 2) {
	      msg = "Marriage Result: Wife Barren...";
	      his_self.updateLog("Henry VIII rolls 2: marriage barren");
	    }
	    if (dd == 3) {
	      msg = "Marriage Result: Wife Beheaded for Unbecoming Conduct...";
	      his_self.updateLog("Henry VIII rolls 3: wife beheaded: will re-roll when England passes");
	      his_self.game.state.henry_viii_auto_reroll = 1;
	    }
	    if (dd == 4) {
	      msg = "Marriage Result: Elizabeth I born, +2VP for Female Succession...";
	      his_self.updateLog("Henry VIII rolls 4: Elizabeth I born");
	      his_self.updateLog("England gains 2 VP for Female Succession");
	      his_self.game.state.henry_viii_add_elizabeth = 1;
	    }
	    if (dd == 5) {
	      his_self.updateLog("Henry VIII rolls 5: sickly Edward VI");
	      if (his_self.game.state.henry_viii_add_elizabeth == 1) {
	        msg = "Marriage Result: Edward VI born sickly, +3VP for Male Succession...";
	        his_self.updateLog("England gains additional 3 VP for Male Succession");
	      } else {
	        msg = "Marriage Result: Edward VI born sickly, +5VP for Male Succession...";
	        his_self.updateLog("England gains 5 VP for Male Succession");
	      }
	      his_self.game.state.henry_viii_sickly_edward = 1;
	      his_self.game.state.henry_viii_add_elizabeth = 0;
	    }
	    if (dd >= 6) {
	      his_self.updateLog("Henry VIII rolls 6: healthy Edward VI");
	      if (his_self.game.state.henry_viii_sickly_edward == 0) {
		if (his_self.game.state.henry_viii_add_elizabeth == 1) {
	          msg = "Marriage Result: Edward VI born healthy, +3VP for Male Succession...";
	          his_self.updateLog("England gains additional 3 VP for Male Succession");
	        } else {
	          msg = "Marriage Result: Edward VI born healthy, +5VP for Male Succession...";
	        }
	      }
	      his_self.game.state.henry_viii_healthy_edward = 1;
	      his_self.game.state.henry_viii_sickly_edward = 0;
	      his_self.game.state.henry_viii_add_elizabeth = 0;
	    }

	    his_self.updateStatus(msg);
	  }

	  his_self.marriage_overlay.render(msg);
	  his_self.displayVictoryTrack();
	  his_self.displayPregnancyChart();

	  return 1;
	}

	return 1;
      },

    }
    deck['004'] = { 
      img : "cards/HIS-004.svg" , 
      name : "Patron of the Arts" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "france" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.leaders.francis_i == 1) {
	  if (his_self.isCaptured("france", "francis-i")) { return 0; }
	  if (his_self.isBesieged("france", "francis-i")) { return 0; }
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("patron-of-the-arts\t"+faction);
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "patron-of-the-arts") {
	  let faction = mv[1];
          his_self.game.queue.splice(qe, 1);
	  his_self.chateaux_overlay.render(faction);
          return 1;
        }

	return 1;
      },
    }
    if (this.game.players.length > 2) {
      deck['005'] = { 
        img : "cards/HIS-005.svg" , 
        name : "Papal Bull" ,
        ops : 4 ,
        turn : 1 ,
        type : "normal" ,
        faction : "papacy" ,
        removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
        canEvent : function(his_self, faction) {
	  return 1;
        },
        handleGameLoop : function(his_self, qe, mv) {

          if (mv[0] === "papal_bull_add_unrest") {
        
            let region = mv[1]; // france, england, hapsburg
  	    his_self.game.queue.splice(qe, 1);

	    if (his_self.game.player == his_self.returnPlayerOfFaction("papacy")) {

              let space1 = "";
              let space2 = "";
	      let regiontxt = "France";
	      if (region == "england") { regiontxt = "English"; }
	      if (region == "hapsburg") { regiontxt = "Spanish"; }

              his_self.playerSelectSpaceWithFilter(
                `Select 1st Unoccupied ${regiontxt} Home Space: `,
                function(space) {
                  if (
                    space.home === region &&
                    (!his_self.isOccupied(space) && !space.unrest)
                  ) {
                    return 1;
                  }
                  return 0;
                },
                function(spacekey) {

                  space1 = spacekey;

                  his_self.addUnrest(space1);
                  his_self.displaySpace(space1);

                  his_self.playerSelectSpaceWithFilter(
                    `Select 2nd Unoccupied ${regiontxt} Home Space: `,
                    function(space) {
                      if (
                        space.home === region &&
                        space.key != space1 &&
                        (!his_self.isOccupied(space) && !space.unrest)
                      ) {
                        return 1;
                      }
                      return 0;
                    },
                    function(spacekey2) {
                      his_self.updateStatus("adding unrest...");
                      space2 = spacekey2;

                      his_self.addUnrest(space2);
                      his_self.displaySpace(space2);

                      his_self.addMove("unrest\t"+space1);
                      his_self.addMove("unrest\t"+space2);
                      his_self.endTurn();
                    },
                    null,
                    true
                  );
                },
                null,
                true
	      );

	    } else {
	      his_self.updateStatus("Papacy adding unrest after Excommunication");
	    }

	    return 0;

	  }

	  return 1;

        },
	onEvent : function(his_self, faction) {

	  let do_grounds_for_excommunication_exist = [];
	  let papacy = his_self.returnPlayerOfFaction("papacy");
	  if (his_self.canPapacyExcommunicateFaction("france")) { do_grounds_for_excommunication_exist.push("france"); }
	  if (his_self.canPapacyExcommunicateFaction("england")) { do_grounds_for_excommunication_exist.push("england"); }
	  if (his_self.canPapacyExcommunicateFaction("hapsburg")) { do_grounds_for_excommunication_exist.push("hapsburg"); }

	  //
	  // both options call this function
	  //
	  let excommunicate_leader_subfunction = () => {

	    if (papacy == his_self.game.player) {

              let msg = "Excommunicate Which Leader?";
              let html = '<ul>';
	      for (let z = 0; z < do_grounds_for_excommunication_exist.length; z++) {
                html += `<li class="option" id="${do_grounds_for_excommunication_exist[z]}">${his_self.returnFactionName(do_grounds_for_excommunication_exist[z])}</li>`;
	      }
	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let action2 = $(this).attr("id");
		his_self.updateStatus("clerics processing excommunication...");
	        his_self.addMove("papal_bull_add_unrest\t"+action2);
	        his_self.addMove("excommunicate_faction\t"+action2);
	        his_self.endTurn();

	      });
	    } else {
	      his_self.updateStatus("Papacy Excommunicating Heretic");
	    }
	  };

	  let excommunicate_reformer_subfunction = () => {

	    if (papacy == his_self.game.player) {

              let msg = "Excommunicate Protestant Reformer:";
	      let reformer_exists = 0;
              let html = '<ul>';
	      for (let key in his_self.reformers) {
	        let s = his_self.returnSpaceOfPersonage("protestant", key);
	        if (s) {
	  	  if (!his_self.game.state.already_excommunicated.includes(key)) {
	            reformer_exists = 1;
                    html += `<li class="option" id="${key}">${his_self.reformers[key].name}</li>`;
	          }
	        }
	      }
	
	      if (reformer_exists == 0) {

                let msg = "Convene Theological Debate?";
                let html = '<ul>';
                html += `<li class="option" id="yes">yes</li>`;
                html += `<li class="option" id="no">no</li>`;
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {

                  let action2 = $(this).attr("id");
	          his_self.updateStatus("convening debate...");

		  if (action2 === "yes") {
		    his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
		    return;
		  }

		  // no
	          his_self.updateLog("No excommunicable Protestant reformers exist");
	          his_self.endTurn();
		  return 0;

	        });

	        return 0;
	      }

	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);
  
              $('.option').off();
              $('.option').on('click', function () {

                let selected_reformer = $(this).attr("id");

	        if (selected_reformer === "cranmer-reformer") {
	  	  his_self.addEndMove("counter_or_acknowledge\tPapal Bull announces excommunication of Cranmer\tpapal_bull_cranmer_excommunication");
		  his_self.addEndMove("RESETCONFIRMSNEEDED\tall");
	        }
	        his_self.addEndMove("excommunicate_reformer\t"+selected_reformer);

                let msg = "Convene Theological Debate after Excommunication?";
                let html = '<ul>';
                html += `<li class="option" id="yes">yes</li>`;
                html += `<li class="option" id="no">no</li>`;
	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

                $('.option').off();
                $('.option').on('click', function () {
		
	          his_self.updateStatus("convening...");
                  let action2 = $(this).attr("id");

		  let language_zone = "german";
		  //if (selected_reformer == "luther-reformer") { language_zone = "english"; }
		  //if (selected_reformer == "zwingli-reformer") { language_zone = "english"; }
		  if (selected_reformer == "cranmer-reformer") { language_zone = "english"; }
		  if (selected_reformer == "calvin-reformer") { language_zone = "french"; }

		  if (action2 === "yes") {
	            his_self.addMove("excommunicate_reformer\t"+selected_reformer);
	            his_self.addMove("player_call_theological_debate_in_region\tpapacy\t"+language_zone);
		    his_self.endTurn();
		    return;
		  }

		  // no
	          his_self.updateLog("No excommunicable Protestant reformers exist");
	          his_self.endTurn();
		  return;

	        });

	      });
            } else {
	      his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	    }
	  };


	  if (papacy == his_self.game.player) {

            let msg = "Excommunicate Heretic?";
            let html = '<ul>';
                html += `<li class="option" id="reformer">Protestant Reformer</li>`;
	        if (do_grounds_for_excommunication_exist.length > 0) {
                  html += `<li class="option" id="leader">Unfaithful Monarch</li>`;
	        }
		html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action2 = $(this).attr("id");
	      if (action2 == "reformer") {
	        excommunicate_reformer_subfunction();
	      } else {
	        excommunicate_leader_subfunction();
    	      }
	    });
	  } else {
	    his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	  }

	  return 0;
	},
      }
    } else {
      deck['005'] = { 
        img : "cards/HIS-005-2P.svg" , 
        name : "Papal Bull" ,
        ops : 4 ,
        turn : 1 ,
        type : "normal" , 
        faction : "papacy" ,
        removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
        canEvent : function(his_self, faction) {
	  return 1;
        },
        onEvent : function(his_self, faction) {

	  let papacy = his_self.returnPlayerOfFaction("papacy");
	  if (papacy == his_self.game.player) {

            let msg = "Excommunicate Protestant Reformer:";
	    let reformer_exists = 0;
            let html = '<ul>';
	    for (let key in his_self.reformers) {
	      let s = his_self.returnSpaceOfPersonage("protestant", key);
	      if (s) {
		if (!his_self.game.state.already_excommunicated.includes(key)) {
	          reformer_exists = 1;
                  html += `<li class="option" id="${key}">${his_self.reformers[key].name}</li>`;
	        }
	      }
	    }
	
	    if (reformer_exists == 0) {

              let msg = "Convene Theological Debate?";
              let html = '<ul>';
              html += `<li class="option" id="yes">yes</li>`;
              html += `<li class="option" id="no">no</li>`;
	      html += '</ul>';
              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let action2 = $(this).attr("id");
	        his_self.updateStatus("submitting...");

		if (action2 === "yes") {
		  his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
		  return;
		}

		// no
	        his_self.updateLog("No excommunicable Protestant reformers exist");
	        his_self.endTurn();
		return 0;

	      });

	      return 0;
	    }

	    html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);
  
            $('.option').off();
            $('.option').on('click', function () {

              let selected_reformer = $(this).attr("id");

	      if (selected_reformer === "cranmer-reformer") {
		his_self.addEndMove("counter_or_acknowledge\tPapal Bull announces excommunication of Cranmer\tpapal_bull_cranmer_excommunication");
		his_self.addEndMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.addEndMove("excommunicate_reformer\t"+selected_reformer);

              let msg = "Convene Theological Debate after Excommunication?";
              let html = '<ul>';
              html += `<li class="option" id="yes">yes</li>`;
              html += `<li class="option" id="no">no</li>`;
	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {
		
	        his_self.updateStatus("convening...");
                let action2 = $(this).attr("id");

		if (action2 === "yes") {
	          his_self.addMove("excommunicate_reformer\t"+selected_reformer);
	          his_self.addMove("player_call_theological_debate\tpapacy");
		  his_self.endTurn();
		  return;
		}

		// no
	        his_self.updateLog("No excommunicable Protestant reformers exist");
	        his_self.endTurn();
		return;

	      });

	    });

	    return 0;

          } else {
	    his_self.updateStatus("Papacy playing "+his_self.popup("005"));
	  }

	  return 0;
	},
      }
    }
    deck['006'] = { 
      img : "cards/HIS-006.svg" , 
      name : "Leipzig Debate" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" , 
      faction : "papacy" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("papacy");

        his_self.game.state.tmp_papacy_may_specify_debater = 1;
        his_self.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 1;

	if (his_self.game.player === p) {

          let msg = "Select Language Zone for Theological Debate:";
          let html = '<ul>';

          if (his_self.returnDebatersInLanguageZone("german", "protestant")) { 
            html += '<li class="option" style="" id="german">German</li>';
          }
          if (his_self.returnDebatersInLanguageZone("french", "france")) { 
            html += '<li class="option" style="" id="french">French</li>';
          }
          if (his_self.returnDebatersInLanguageZone("english", "france")) { 
            html += '<li class="option" style="" id="english">English</li>';
          }
          html += '</ul>';

	  //
  	  // show visual language zone selector
  	  //
  	  his_self.language_zone_overlay.render("catholic_counter_reformation");

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let language_zone = $(this).attr("id");

            let msg = "Target Committed or Uncommitted Protestant?";
            let html = '<ul>';
            if (1 <= his_self.returnDebatersInLanguageZone(language_zone, "protestant", 0)) {
              html += '<li class="option uncommitted" id="uncommitted">Uncommitted</li>';
            }
            if (1 <= his_self.returnDebatersInLanguageZone(language_zone, "protestant", 1)) {
              html += '<li class="option committed" id="committed">Committed</li>';
            }
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);
            $('.option').off();
            $('.committed').on('mouseover', function () {
	      his_self.language_zone_overlay.hideDebaters();
	      his_self.language_zone_overlay.showDebaters(language_zone, "committed", "protestant");
            });
            $('.committed').on('mouseout', function () {
	      his_self.language_zone_overlay.hideDebaters();
            });
            $('.uncommitted').on('mouseover', function () {
	      his_self.language_zone_overlay.hideDebaters();
	      his_self.language_zone_overlay.showDebaters(language_zone, "uncommitted", "protestant");
            });
            $('.uncommitted').on('mouseout', function () {
	      his_self.language_zone_overlay.hideDebaters();
            });

            $('.option').on('click', function () {

              let is_committed = $(this).attr("id");
	      if (is_committed == "uncommitted") { is_committed = 0; } else { is_committed = 1; }

              let msg = "Leipzig Debate Format?";
              let html = '<ul>';
              html += '<li class="option" id="select">Pick My Debater</li>';
	      // or prohibit uncommitted debaters
              if (is_committed == 0 && 1 < his_self.returnDebatersInLanguageZone(language_zone, "protestant", is_committed)) {
                html += '<li class="option" id="prohibit">Prohibit Protestant Debater</li>';
              }
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
  
              $('.option').off();
              $('.option').on('click', function () {

                let opt = $(this).attr("id");

	        if (opt === "select") {

                  let msg = "Select Uncommitted Papal Debater:";
                  let html = '<ul>';
		  for (let i = 0; i < his_self.game.state.debaters.length; i++) {
		    let d = his_self.game.state.debaters[i];
		    if (d.faction === "papacy" && d.committed === 0) {
            	      html += `<li class="option" id="${d.type}">${d.name}</li>`;
		    }
		  }
		  html += '</ul>';
                  his_self.updateStatusWithOptions(msg, html);
  
                  $('.option').off();
                  $('.option').on('mouseover', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.show(action2);
                    }
                  });
                  $('.option').on('mouseout', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.hide(action2);
                    }
                  });
                  $('.option').on('click', function () {
                    his_self.language_zone_overlay.hide();
                    let selected_papal_debater = $(this).attr("id");
	            his_self.addMove("theological_debate");
        	    his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t" + language_zone);
                    let c = [his_self.game.players[his_self.returnPlayerOfFaction("papacy")-1],his_self.game.players[his_self.returnPlayerOfFaction("protestant")-1]];
        	    his_self.addMove("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));
	            if (is_committed == 0) {
		      his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"uncommitted\t" + selected_papal_debater);
	            } else { 
		      his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"committed\t" + selected_papal_debater);
		    }
		    his_self.endTurn();
		  });
	
	        } else {

                  let msg = "Prohibit Protestant Debater:";
                  let html = '<ul>';
		  for (let i = 0; i < his_self.game.state.debaters.length; i++) {
		    let d = his_self.game.state.debaters[i];
		    if (d.faction !== "papacy" && d.language_zone === language_zone && d.committed == is_committed) {
            	      html += `<li class="option" id="${i}">${d.name}</li>`;
		    }
		  }
		  html += '</ul>';
                  his_self.updateStatusWithOptions(msg, html);
  
                  $('.option').off();
                  $('.option').on('mouseover', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.show(action2);
                    }
                  });
                  $('.option').on('mouseout', function() {
                    let action2 = $(this).attr("id");
                    if (his_self.debaters[action2]) {
                      his_self.cardbox.hide(action2);
                    }
                  });
                  $('.option').on('click', function () {
                    his_self.language_zone_overlay.hide();
                    let selected_idx = parseInt($(this).attr("id"));
		    let prohibited_protestant_debater = his_self.game.state.debaters[selected_idx].type;
	            his_self.addMove("theological_debate");
        	    his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t" + language_zone);
                    let c = [his_self.game.players[his_self.returnPlayerOfFaction("papacy")-1],his_self.game.players[his_self.returnPlayerOfFaction("protestant")-1]];
        	    his_self.addMove("RESETCONFIRMSNEEDED\t"+JSON.stringify(c));
	 	    if (is_committed == 0) {
	              his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"uncommitted\t\t"+prohibited_protestant_debater);
		    } else {
	              his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+"committed\t\t"+prohibited_protestant_debater);
		    }
		    his_self.endTurn();
		  });
	
	        }

	      });
	    });
	  });

	} else {
	  his_self.updateStatus("Papacy calling Theological Debate");
	}

	return 0;
      },

    }

    deck['007'] = { 
      img : "cards/HIS-007.svg" , 
      name : "Here I Stand" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      faction : "protestant" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {       
	if (his_self.game.state.leaders.luther != 1) { return 0; }
	let cards_available = 0;
        for (let key in his_self.game.deck[0].discards) { if (parseInt(key) > 23) { cards_available++; } }
        if (cards_available == 0) { return 0; }
	if (Object.keys(his_self.game.deck[0].discards).length > 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player === p) {

	  let msg = "Retrieve Card from Discard Pile: ";
          let html = '<ul>';
	  for (let key in his_self.game.deck[0].discards) {
	    if (parseInt(key) > 9 && !his_self.game.state.protestant_cards_evented.includes(key)) {
              html += `<li class="option" id="${key}">${his_self.game.deck[0].cards[key].name}</li>`;
	    }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
          $('.option').on('mouseover', function() {
            let action2 = $(this).attr("id");
            his_self.cardbox.show(action2);
          });
          $('.option').on('mouseout', function() {
            let action2 = $(this).attr("id");
            his_self.cardbox.hide(action2);
          });
	  $('.option').on('click', function () {

	    $('.option').off();
	    let card = $(this).attr("id");

	    let msg = "Play or Hold Card? ";
            let html = '<ul>';
            html += '<li class="option" id="play">play card</li>';
            html += '<li class="option" id="hold">hold card</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action == "play") {

		his_self.addMove("card\tprotestant\t"+card);
		his_self.addMove("discard\tprotestant\t007");
		his_self.addMove("NOTIFY\tProtestants retrieve "+his_self.popup(card));
		his_self.endTurn();

	      } else {

		//
		// remove any cards_left update that runs after this coming cards_left update and undoes us
		//
		for (let i = 0; i < his_self.moves.length; i++) {
		  let lmv = his_self.moves[i].splice("\t");
		  if (lmv[0] == "cards_left") {
		    his_self.moves.splice(i, 1);
		  }
		}

    		his_self.addMove("remove_cards_left");
    		his_self.addMove("cards_left\tprotestant\t"+(parseInt(his_self.game.state.cards_left["protestant"])+1));
		his_self.addMove("discard\tprotestant\t007");
		his_self.addMove("NOTIFY\tProtestants retrieve "+his_self.popup(card));
		his_self.addMove("here_i_stand_event\t"+card);
		his_self.endTurn();

	      }

	    });
	  });
	} else {
	  his_self.updateStatus("Protestants retrieving card: " + his_self.popup("007"));
	}

	return 0;
      },
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu === "debate") {
	  if (extra === "german") {
            return { faction : "protestant" , event : '007', html : `<li class="option" id="007">Here I Stand (assign Luther)</li>` };
	  }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "debate") {
	  if (extra === "german") {
	    //
	    // Wartburg stops Luther
	    //
	    if (his_self.game.state.events.wartburg == 1) { 
	      return 0;
	    }
	    if (his_self.game.state.leaders.luther == 1) {
	      if (his_self.game.state.theological_debate) {
		if (his_self.game.state.theological_debate.round1_attacker_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round1_defender_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round2_attacker_debater == "luther-debater") { return 0; }
	        if (his_self.game.state.theological_debate.round2_defender_debater == "luther-debater") { return 0; }
	        if (player === his_self.returnPlayerOfFaction("protestant")) {
	          if (his_self.canPlayerPlayCard("protestant", "007")) {
		    return 1;
		  } else {
		  }
	        }
	      }
	    }
	  }
	}
	return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "debate") {
	  let p = his_self.returnPlayerOfFaction("protestant");
    	  his_self.addMove("cards_left\tprotestant\t"+(parseInt(his_self.game.state.cards_left["protestant"])+1));
          his_self.addMove('hand_to_fhand\t1\t' + p + '\t' + "protestant" + "\t1");
	  his_self.addMove("DEAL\t1\t"+p+"\t1");
	  his_self.addMove("discard\tprotestant\t007");
	  his_self.addMove("NOTIFY\t"+his_self.popup("007") + ": Luther enters Theological Debate");
	  his_self.addMove("here_i_stand_response");
	  his_self.endTurn();
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "here_i_stand_event") {

          his_self.game.queue.splice(qe, 1);

	  //
	  // first option not implemented
	  //
          let card = mv[1];

	  if (his_self.game.deck[0].discards[card]) {

	    let p = his_self.returnPlayerOfFaction("protestant");

	    //
	    // player returns to hand
	    //
	    if (his_self.game.player === p) {
              let fhand_idx = his_self.returnFactionHandIdx(p, "protestant");
	      his_self.game.deck[0].fhand[fhand_idx].push(card);
	    }

	    //
	    // everyone removes from discards
	    //
	    delete his_self.game.deck[0].discards[card];

	  }

	  return 1;
	}

        if (mv[0] === "here_i_stand_response") {

          his_self.game.queue.splice(qe, 1);

	  his_self.updateLog("Protestants trigger " + his_self.popup("007"));
	  // protestants get extra card
	  his_self.game.queue.push("ACKNOWLEDGE\tProtestants swap Martin Luther into debate");

	  //
	  // second option -- only possible if Wartburg not in-play
	  //
	  if (his_self.game.state.events.wartburg == 0) {

	    //
	    // existing protestant debater is committed, but de-activated (bonus does not apply)
	    //
	    for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	      let d = his_self.game.state.debaters[i];
	      if (his_self.game.state.theological_debate.attacker === "papacy") {
	        if (his_self.game.state.theological_debate.round == 1) {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round1_defender_debater) {
	  	    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        } else {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round2_defender_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        }
	      } else {
	        if (his_self.game.state.theological_debate.round == 1) {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round1_attacker_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        } else {
	          if (his_self.game.state.debaters[i].key === his_self.game.state.theological_debate.round2_attacker_debater) {
		    his_self.commitDebater("protestant", d.key);
	  	    his_self.deactivateDebater(d.key);
	          }
	        }
	      }
	    }

	    let is_luther_committed = 0;
console.log("is luther committed?");
console.log(JSON.stringify(his_self.game.state.excommunicated));
	    for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	      if (his_self.game.state.debaters[i].key === "luther-debater") {
		if (his_self.game.state.debaters[i].committed == 1) { 
		  // remove +1 bonus if luther is committed
		  if (his_self.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
		    his_self.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
                    his_self.game.state.theological_debate.defender_debater_bonus--;
		  }
		  is_luther_committed = 1;
		}
	      }
	    }
	    for (let i = 0; i < his_self.game.state.excommunicated.length; i++) {
	      if (his_self.game.state.excommunicated[i].debater) {
	        if (his_self.game.state.excommunicated[i].debater.type === "luther-debater") {
console.log("FOUND LUTHER");
		  if (his_self.game.state.excommunicated[i].debater.committed == 1) {
console.log("LUTHER IS COMMITTED!");
		    // remove +1 bonus if luther is committed
		    if (his_self.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
		      his_self.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
                      his_self.game.state.theological_debate.defender_debater_bonus--;
		    }
		    is_luther_committed = 1;
		  }
	        }
	      }
	    }


	    if (his_self.game.state.theological_debate.attacker === "papacy") {
	      if (his_self.game.state.theological_debate.round == 1) {
                his_self.game.state.theological_debate.round1_defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater_power = 4;
                his_self.game.state.theological_debate.defender_debater_bonus = 1;
		if (is_luther_committed == 0) {
                  his_self.game.state.theological_debate.defender_debater_bonus++;
		}
	      } else {
                his_self.game.state.theological_debate.round2_defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater = "luther-debater";
                his_self.game.state.theological_debate.defender_debater_power = 4;
                his_self.game.state.theological_debate.defender_debater_bonus = 1;
		if (is_luther_committed == 0) {
                  his_self.game.state.theological_debate.defender_debater_bonus++;
		}
	      }
	    } else {
	      if (his_self.game.state.theological_debate.round == 1) {
                his_self.game.state.theological_debate.round1_attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater_power = 4;
                his_self.game.state.theological_debate.attacker_debater_bonus = 3;
	      } else {
                his_self.game.state.theological_debate.round2_attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater = "luther-debater";
                his_self.game.state.theological_debate.attacker_debater_power = 4;
                his_self.game.state.theological_debate.attacker_debater_bonus = 3;
	      }
	    }


	  }

	  // re-render debate overlay with luther there
console.log("rendering with luther here: ");
console.log(JSON.stringify(his_self.game.state.theological_debate));
          his_self.debate_overlay.render(his_self.game.state.theological_debate);
          his_self.displayTheologicalDebater(his_self.game.state.theological_debate.attacker_debater, true);
          his_self.displayTheologicalDebater(his_self.game.state.theological_debate.defender_debater, false);

	  return 1;

        }

	return 1;
      },
    }
    // 95 Theses
    deck['008'] = { 
      img : "cards/HIS-008.svg" , 
      name : "Luther's 95 Theses" ,
      ops : 0 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.factionbar.setActive("protestant");

	// set player to protestant
	let player = his_self.returnPlayerOfFaction("protestant");

	let players_to_go = [];
	for (let i = 1; i < his_self.game.players.length; i++) {
	  if (i != his_self.returnPlayerOfFaction("protestant")) {
	    players_to_go.push(i);
	  }
	}

	// protestant gets 2 roll bonus at start
	his_self.game.state.tmp_protestant_reformation_bonus = 1;
	his_self.game.state.tmp_protestant_reformation_bonus_spaces = [];
	his_self.game.state.tmp_catholic_reformation_bonus = 0;
	his_self.game.state.tmp_catholic_reformation_bonus_spaces = [];
	his_self.game.state.tmp_reformations_this_turn = [];
	his_self.game.state.wittenberg_electoral_bonus = 1;

	his_self.game.queue.push("hide_overlay\ttheses");
        his_self.game.queue.push("ACKNOWLEDGE\tThe Reformation has begun!");
	his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("STATUS\tProtestants selecting reformation targets...\t"+JSON.stringify(players_to_go));
	his_self.game.queue.push("show_overlay\ttheses");
        his_self.convertSpace("protestant", "wittenberg");
        his_self.convertSpace("protestant", "wittenberg");
        his_self.addUnit("protestant", "wittenberg", "regular");
        his_self.addUnit("protestant", "wittenberg", "regular");
        his_self.addReformer("protestant", "wittenberg", "luther-reformer");
        his_self.displaySpace("wittenberg");

	return 1;
      },
    }
    deck['009'] = { 
      img : "cards/HIS-009.svg" , 
      name : "Barbary Pirates" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Algiers is in play, the Ottomans may now build corsairs and engage in piracy!",
          title : "Barbary Pirates!",
          img : "/his/img/backgrounds/events/An_Action_between_an_English_Ship_and_Vessels_of_the_Barbary_Corsairs.jpg",
	  msg : "Barbary Pirates in Play...",
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	// algiers space is now in play
	his_self.game.spaces['algiers'].home = "ottoman";
	his_self.game.spaces['algiers'].political = "ottoman";
	his_self.game.spaces['algiers'].pirate_haven = 1;
	his_self.addRegular("ottoman", "algiers", 2);
	his_self.addCorsair("ottoman", "algiers", 2);
	his_self.addNavyLeader("ottoman", "algiers", "barbarossa");
	his_self.game.state.events.barbary_pirates = 1;
	his_self.game.state.events.ottoman_piracy_enabled = 1;
	his_self.game.state.events.ottoman_corsairs_enabled = 1;

	// re-display algiers
	his_self.displaySpace("algiers");

	return 1;
      },

    }
    deck['010'] = { 
      img : "cards/HIS-010.svg" , 
      name : "Clement VII" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Leo X is replaced by Clement VII. Papacy may now hold a card between turns.",
          title : "Accession of Clement VII",
          img : "/his/img/backgrounds/events/clement-vii.png",
	  msg : "Clement VII becomes Pope...",
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.clement_vii = 1;
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 1;
	return 1;
      },
    }
    deck['011'] = { 
      img : "cards/HIS-011.svg" , 
      name : "Defender of the Faith" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let papacy = his_self.returnPlayerOfFaction("papacy");

	if (faction === "england") {
	  if (his_self.game.player.length < 6) { let faction_hand_idx = 1;  }  
	  let england_player = his_self.returnPlayerCommandingFaction("england");
 	  his_self.game.queue.push("hand_to_fhand\t1\t"+england_player+"\t"+"england"+"\t1");
	  his_self.game.queue.push(`DEAL\t1\t${england_player}\t1`);
        }
	// three counter-reformation attempts
	his_self.game.queue.push(`hide_overlay\tburn_books`);
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
	his_self.game.queue.push(`catholic_counter_reformation\tpapacy\tall`);
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['012'] = { 
      img : "cards/HIS-012.svg" , 
      name : "Master of Italy" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 

	let keys = ["genoa","milan", "venice", "florence", "naples"];
	let f = {};

	for (let key in keys) {
	  let fac = his_self.returnFactionControllingSpace(keys[key]);
	  let owner = his_self.returnAllyOfMinorPower(fac);
	  if (!f[owner]) { f[owner] = 1; }
	  else { f[owner]++; }
	}

	for (let key in f) {
	  if (f[key] >= 4) {
	    return 1;
	  }
	  if (f[key] == 3) {
	    return 1;
	  }
	  if (f[key] == 2) {
	    return 1;
	  }
	}

	return 0;
      } ,
      onEvent : function(his_self, faction) {

        let keys = ["genoa","milan", "venice", "florence", "naples"];
        let f = {};
        for (let key in keys) {
          let fac = his_self.returnFactionControllingSpace(keys[key]);
          let owner = his_self.returnAllyOfMinorPower(fac);
          if (!f[owner]) { f[owner] = 1; }
          else { f[owner]++; }
        } 

	his_self.game.queue.push("display_vp_track");
        
        for (let key in f) {
          if (f[key] >= 4) {
	    his_self.game.queue.push("SETVAR\tstate\tmaster_of_italy\t"+key+"\t"+parseInt(his_self.game.state.master_of_italy[faction])+2);
	    his_self.game.queue.push(`NOTIFY\t${his_self.returnFactionName(key)} gains 2 VP as Master of Italy`);
          }
          if (f[key] == 3) {
	    his_self.game.queue.push("SETVAR\tstate\tmaster_of_italy\t"+key+"\t"+parseInt(his_self.game.state.master_of_italy[faction])+1);
	    his_self.game.queue.push(`NOTIFY\t${his_self.returnFactionName(key)} gains 1 VP from Master of Italy`);
          }
          if (f[key] == 2) {
	    if (his_self.game.players.length > 2) {
	      let player = his_self.returnPlayerOfFaction(key);
 	      his_self.game.queue.push("hand_to_fhand\t1\t"+(player)+"\t"+key+"\t1");
	      his_self.game.queue.push(`DEAL\t1\t${player}\t1`);
	      his_self.game.queue.push(`NOTIFY\t${his_self.returnFactionName(key)} draws 1 card from Master of Italy`);
            }
          }
        }

	his_self.displayVictoryTrack();

	return 1;

      }
    }
    let sl_img = "cards/HIS-013.svg";
    if (this.game.players.length == 2) {
      sl_img = "cards/HIS-013-2P.svg";
    }
    deck['013'] = { 
      img : sl_img,
      name : "Schmalkaldic League" ,
      ops : 2 ,
      turn : 1 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	  if (his_self.game.state.round >= 2 && his_self.returnNumberOfProtestantSpacesInLanguageZone("all") >= 12) {
	    return 1; 
	  }
	  return 0;
      },
      onEvent : function(his_self, faction) {

        his_self.game.state.events.schmalkaldic_league_round = his_self.game.state.round;
        his_self.game.state.events.schmalkaldic_league = 1;
	his_self.schmalkaldic_overlay.render();
        his_self.setEnemies("protestant","papacy");
        his_self.setEnemies("protestant","hapsburg");
        if (his_self.game.players.length == 2) { his_self.setAllies("papacy","hapsburg"); }

	//
	// protestant home + political spaces
	//
	// skip keys are home for other factions
	//
	let skip_keys = ["innsbruck","linz","vienna","graz","zurich","basel"];
	for (let key in his_self.game.spaces) {
	  s = his_self.game.spaces[key];
	  if (s.language == "german") { 
	    if (s.religion == "protestant") {
	      if (!skip_keys.includes(key)) {
	 	s.home = "protestant";
	        if (!s.fortified && !s.unrest) {
	          s.political = "protestant";
	        }
	      }
	    } else {
	      if (!skip_keys.includes(key)) {
	 	s.home = "protestant";
		if (s.political == "") { 
		  s.political = "haspburg";
	        }
	      }
	    }
	  }
	}
	for (let i = 0; i < his_self.game.state.activated_powers["protestant"].length; i++) {
	  if (his_self.game.state.activated_powers["protestant"][i] === "hapsburg") {
	    his_self.game.state.activated_powers["protestant"].splice(i, 1);
	    his_self.game.state.events.spanish_invasion = "";
	  }
	}

	//
	// John Frederick and Philip of Hesse
	//
	let jf_added = 0;
        if (his_self.returnSpaceOfPersonage("protestant", "john-frederick")) { jf_added = 1; }
	if (his_self.isSpaceControlled("wittenberg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "wittenberg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "wittenberg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("brandenburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "brandenburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "brandenburg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("augsburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "augsburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "augsburg", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("mainz", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "mainz") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "mainz", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("trier", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "trier") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "trier", "john-frederick");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("cologne", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "cologne") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "cologne", "john-frederick");
	  jf_added = 1;
	}
	jf_added = 0;
        if (his_self.returnSpaceOfPersonage("protestant", "philip-hesse")) { jf_added = 1; }
	if (his_self.isSpaceControlled("mainz", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "mainz") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "mainz", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("cologne", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "cologne") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "cologne", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("trier", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "trier") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "trier", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("augsburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "augsburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "augsburg", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("brandenburg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "brandenburg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "brandenburg", "philip-hesse");
	  jf_added = 1;
	}
	if (his_self.isSpaceControlled("wittenberg", "protestant") && his_self.returnFactionLandUnitsInSpace("protestant", "wittenberg") > 0 && jf_added == 0) {
	  his_self.addArmyLeader("protestant", "wittenberg", "philip-hesse");
	  jf_added = 1;
	}

	//
	// move protestant regulars in catholic spaces to nearest protestant-controlled electorates
	//
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].political != "protestant") {
	    if (his_self.game.spaces[key].units["protestant"].length > 0) {
	      let already_routed_through = {};
    	      let res = his_self.returnNearestSpaceWithFilter(
				key ,
				function(spacekey) {
				  if (his_self.game.spaces[spacekey].type === "electorate" && his_self.game.spaces[spacekey].political === "protestant") { return 1; }
				  return 0;
				},
				function(spacekey) {
        			  if (already_routed_through[spacekey] == 1) { return 0; }
				  already_routed_through[spacekey] = 1;
				  return 1;
				},
				0, // transit passes (no need)
				0, // transit seas (no need)
				"protestant" ,
				0 // already crossed sea zone
	      );

	      for (let z = 0; z < his_self.game.spaces[key].units["protestant"].length; z++) {
    		let u = his_self.game.spaces[key].units["protestant"][z];
		if (u.type == "regular" || u.type == "mercenary" || u.army_leader == true) {
		  if (res.length > 0) {
		    his_self.game.spaces[res[0].key].units["protestant"].push(u);
		  }
    		  his_self.game.spaces[key].units["protestant"].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }
	}

	//
	// in 2P papacy now controls hapsburg
	//
	if (his_self.game.players.length == 2) {
          his_self.game.state.activated_powers["papacy"].push("hapsburg");
	}

	his_self.removeCardFromGame("013");

	his_self.displayBoard();
	return 1;

      }
    }
    deck['014'] = { 
      img : "cards/HIS-014.svg" , 
      name : "Paul III" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Clement VII is replaced by Paul III. Papacy now wins ties Counter-Reformation rolls.",
          title : "Accession of Paul III",
          img : "/his/img/backgrounds/events/paul-iii.jpg",
	  msg : "Paul III becomes Pope...",
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.events.paul_iii = 1;
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 0;
	his_self.removeCardFromGame('010'); // remove clement vii
	his_self.game.state.leaders.paul_iii = 1;
	return 1;
      },
    }
    deck['015'] = { 
      img : "cards/HIS-015.svg" , 
      name : "Society of Jesus" ,
      ops : 2 ,
      turn : 5 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "The Society of Jesus receives a Papal charter to found Jesuit Universities",
          title : "Society of Jesus",
          img : "/his/img/backgrounds/events/loyola-jesuits.jpg",
	  msg : "Society of Jesus in Play...",
	  styles : [{ key : "backgroundPosition" , val : "center" }],
        }
      } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.events.society_of_jesus = 1;
	let papacy = his_self.returnPlayerOfFaction("papacy");
	if (his_self.game.player === papacy) {
    	  his_self.playerSelectSpaceWithFilter(
      	    "Select Catholic-Controlled Space for First Jesuit University",
      	    function(space) {
              if (space.religion === "catholic" && space.university != 1) { return 1; }
              return 0; 
            },          
            function(destination_spacekey) {
	      his_self.game.spaces[destination_spacekey].university = 1;
	      his_self.displaySpace(destination_spacekey);
    	      his_self.playerSelectSpaceWithFilter(
      	        "Select Catholic-Controlled Space for Second Jesuit University",
       	        function(space) {
                  if (space.key != destination_spacekey && space.religion === "catholic" && space.university != 1) { return 1; }
                  return 0; 
                },
                function(second_spacekey) {
	          his_self.game.spaces[second_spacekey].university = 1;
	          his_self.displaySpace(second_spacekey);
                  his_self.addMove("found_jesuit_university\t"+second_spacekey);
                  his_self.addMove("found_jesuit_university\t"+destination_spacekey);
	          his_self.addMove("SETVAR\tstate\tevents\tpapacy_may_found_jesuit_universities\t1");
                  his_self.endTurn();
	        },
		null,
		true
	      );
	    },
	    null,
	    true
	  );
        }
	return 0;
      },    
    }
    deck['016'] = { 
      img : "cards/HIS-016.svg" , 
      name : "Calvin" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.leaders['luther'] = 0;
	his_self.game.state.leaders['calvin'] = 1;

	let x = his_self.returnSpaceOfPersonage("protestant", "luther-reformer");
	let y = his_self.returnIndexOfPersonageInSpace("protestant", "luther-reformer", x);

	if (y > -1) {
	  his_self.game.spaces[x].units["protestant"].splice(y, 1);
	}

	for (let i = 0; i < his_self.game.state.debaters.length; i++) {
	  if (his_self.game.state.debaters[i].type === "luther-debater") {
	    his_self.game.state.debaters.splice(i, 1);
	  }
	}

	his_self.displaySpace(x);
	his_self.updateLog("Luther dies and is replaced by Calvin");

	return 1;
      }
    }
    deck['017'] = { 
      img : "cards/HIS-017.svg" , 
      name : "Council of Trent" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.council_of_trent = {};
	his_self.game.state.council_of_trent.papacy = {};
	his_self.game.state.council_of_trent.protestants = {};

	his_self.game.queue.push("hide_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_results");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_protestants");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");
	his_self.game.queue.push("council_of_trent_papacy");
	his_self.game.queue.push("show_overlay\tcouncil_of_trent");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "council_of_trent_add_debaters") {

          his_self.game.queue.splice(qe, 1);
	  
	  let faction = mv[1];
	  let debaters = mv[2];

	  if (faction === "papacy") {
	    his_self.game.state.council_of_trent.papacy.debaters = JSON.parse(debaters);
	  } else {
	    his_self.game.state.council_of_trent.protestants.debaters = JSON.parse(debaters);
	  }

	  return 1;

	}

        if (mv[0] === "council_of_trent_papacy") {

          his_self.game.queue.splice(qe, 1);
	  his_self.council_of_trent_overlay.render("papacy");

	  return 0;

	}

        if (mv[0] === "council_of_trent_results") {

          his_self.game.queue.splice(qe, 1);
	  //
	  // this adds stuff to the queue -- so we pass through
	  //
	  his_self.council_of_trent_overlay.render("results");

	  return 1;

	}

        if (mv[0] === "council_of_trent_protestants") {

          his_self.game.queue.splice(qe, 1);
	  his_self.council_of_trent_overlay.render("protestant");

	  return 0;

        }

	return 1;
      },
    }
    deck['018'] = { 
      img : "cards/HIS-018.svg" , 
      name : "Dragut" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	// barbarossa dies, replaced by Dragut
	let s = his_self.returnSpaceOfPersonage("ottoman", "barbarossa");

	if (s != "") {
	  let idx = his_self.returnIndexOfPersonageInSpace("ottoman", "barbarossa", s);
	  if (idx > -1) {
	    if (his_self.game.spaces[s]) {
	      his_self.game.spaces[s].units["ottoman"].splice(idx, 1);
	      his_self.addNavyLeader("ottoman", s, "dragut");
	    }  
	    if (his_self.game.navalspaces[s]) {
	      his_self.game.navalspaces[s].units["ottoman"].splice(idx, 1);
	      his_self.addNavyLeader("ottoman", s, "dragut");
	    }  
	  } 

	  his_self.displaySpace(s);

	} else {
	  his_self.addNavyLeader("ottoman", "istanbul", "dragut");
	  his_self.displaySpace("istanbul");
	}

	return 1;
      },
    }
    deck['019'] = { 
      img : "cards/HIS-019.svg" , 
      name : "Edward VI" ,
      ops : 2 ,
      turn : 0 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

        //
        // removes captured leaders
        //
        for (let i = 0; i < his_self.game.state.players_info.length; i++) {
          for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
            if (his_self.game.state.players_info[i].captured[ii].type == "henry-viii") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; } else {
              if (his_self.game.state.players_info[i].captured[ii].type == "charles-brandon") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; }
	    }
	  }
	}

	his_self.game.state.leaders.edward_vi = 1;
	his_self.game.state.leaders.henry_viii = 0;
	his_self.game.state.leaders.mary_i = 0;
	his_self.game.state.leaders.elizabeth_i = 0;

	let placed = 0;

        // henry_viii dies, replaced by dudley
        let s = his_self.returnSpaceOfPersonage("england", "henry-viii");
        if (s != "") {
          let idx = his_self.returnIndexOfPersonageInSpace("england", "henry-viii", s);
          if (idx > -1) {
            his_self.game.spaces[s].units["england"].splice(idx, 1);
            his_self.addArmyLeader("england", s, "dudley");
	    placed = 1;
          } 
        }
        
	if (placed == 0) {
          his_self.addArmyLeader("england", "london", "dudley");
	}

	his_self.displaySpace("london");

	return 1;
      },
    }

    deck['020'] = { 
      img : "cards/HIS-020.svg" , 
      name :"Henry II" ,
      ops : 2 ,
      turn : 6 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.leaders.francis_i = 0;
	his_self.game.state.leaders.henry_ii = 1;
	let placed = 0;

        // francis_i dies replaced by henry_ii
        let s = his_self.returnSpaceOfPersonage("france", "francis-i");
        if (s != "") {
          let idx = his_self.returnIndexOfPersonageInSpace("france", "francis-i", s);
          if (idx > -1) {
            his_self.game.spaces[s].units["france"].splice(idx, 1);
            his_self.addArmyLeader("france", s, "henry-ii");
	    placed = 1;
          } 
        }
        
	if (placed == 0) {
          his_self.addArmyLeader("france", "paris", "henry-ii");
	}

	return 1;
      },
    }
    deck['021'] = { 
      img : "cards/HIS-021.svg" , 
      name : "Mary I" ,
      ops : 2 ,
      turn : 0 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

	//
	// this means Mary I was triggered before, but Sickly Edward acceeded the 
	// throne and we now have Mary I being evented again after being added to
	// the deck.
	//
	if (his_self.game.state.henry_viii_re_add_mary_to_throne == 1) {
	  his_self.game.state.henry_iii_sickly_edward = 0;
	}


        //
        // removed captured leaders
        //
        for (let i = 0; i < his_self.game.state.players_info.length; i++) {
          for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
            if (his_self.game.state.players_info[i].captured[ii].type == "henry-viii") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; } else {
              if (his_self.game.state.players_info[i].captured[ii].type == "charles-brandon") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; }
	    }
	  }
	}

	his_self.game.state.leaders.edward_vi = 0;
	his_self.game.state.leaders.mary_i = 1;
	his_self.game.state.henry_viii_mary_i_added_round = his_self.game.state.round;

	//
	// it is possible that a healthy Edward has already been born before this
	// card has been played, in which case Mary I is actually Edward VI since
	// the succession passes to him.
	//
        if (his_self.game.state.henry_viii_healthy_edward == 1) {
	  let deck = his_self.returnDeck();
	  let card = deck["019"];
	  card.onEvent(his_self,faction);
	  his_self.game.state.leaders.edward_vi = 1;
	  his_self.game.state.leaders.mary_i = 0;
	  return 1;
        } else {

	  //
	  // otherwise remove Edward from the Deck
	  //
	  if (his_self.game.state.henry_viii_sickly_edward == 1) {

	    //
	    // Sickly Edward was born before Mary I was evented, so we put Edward on the 
	    // throne, but Mary re-enters the deck next turn like a looming bird of 
	    // death.
	    //
	    his_self.game.state.henry_viii_re_add_mary_to_throne = 1;
            let deck = his_self.returnDeck();
            let card = deck["019"];
            card.onEvent(his_self,faction);
            return 1;

	    his_self.removeCardFromGame('019'); // remove edward_vi if still in deck

	  }

	  if (his_self.game.state.henry_viii_add_elizabeth == 1) {

	    //
	    // Elizabeth should be added next round anyway
	    //

	  }

	}

	//
	// if sickly edward has been born but this card has been played, we want
	// to push it back into the deck next turn. the card will be removed because
	// it is a mandatory card, so we make a note to re-add it next turn.
	//
        if (his_self.game.state.henry_viii_sickly_edward == 1) {
	  his_self.game.state.henry_viii_mary_i_added_with_sickly_edward_played = 1;
	  return 1;
        }

	//
	// if Elizabeth has been born, we will tag to add her next round
	//
	// this code is in returnNewCards...
	//
	let placed = 0;
	if (his_self.game.state.leaders.henry_viii == 1) {

	  his_self.game.state.leaders.henry_viii = 0; 

	  //
          // mary_i replaces edward_vi or henry_viii
	  //
          let s = his_self.returnSpaceOfPersonage("england", "henry-viii");
          if (s != "") {
            let idx = his_self.returnIndexOfPersonageInSpace("england", "henry-viii", s);
            if (idx > -1) {
              his_self.game.spaces[s].units["england"].splice(idx, 1);
              his_self.addArmyLeader("england", s, "dudley");
	      placed = 1;
            } 
          }
	}

	if (placed == 0) {
          let s = his_self.returnSpaceOfPersonage("england", "dudley");
	  if (s == "") { his_self.addArmyLeader("england", "london", "dudley"); }
	}

	return 1;
      },
    }
    deck['022'] = { 
      img : "cards/HIS-022.svg" , 
      name : "Julius III" ,
      ops : 2 ,
      turn : 7 ,
      type : "mandatory" ,
      returnCustomOverlay : function() {
	return {
          text : "Paul III is replaced by Julius III. Papacy wins Counter-Reformation ties.",
          title : "Accession of Julius III",
          img : "/his/img/backgrounds/events/julius-iii.jpg",
	  msg : "Julius III becomes Pope...",
        }
      } ,
      canEvent : function(his_self, faction) {
        return 1;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.state.leaders.leo_x = 0;
	his_self.game.state.leaders.clement_vii = 0;
	his_self.game.state.leaders.paul_iii = 0;
	his_self.game.state.leaders.julius_iii = 1;
	his_self.removeCardFromGame('010');
	his_self.removeCardFromGame('014');
	return 1;
      },
    }
    deck['023'] = { 
      img : "cards/HIS-023.svg" , 
      name : "Elizabeth I" ,
      ops : 2 ,
      turn : 0 ,
      type : "mandatory" ,
      canEvent : function(his_self, faction) { return 1; },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.game.state.events.england_changed_rulers_this_turn = 1;

        //
        // removes captured leaders
        //
        for (let i = 0; i < his_self.game.state.players_info.length; i++) {
          for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
            if (his_self.game.state.players_info[i].captured[ii].type == "henry-viii") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; } else {
              if (his_self.game.state.players_info[i].captured[ii].type == "charles-brandon") { his_self.game.state.players_info[i].captured.splice(ii, 1); ii--; }
  	    }
	  }
	}

	his_self.game.state.leaders.henry_viii = 0;
	his_self.game.state.leaders.edward_vi = 0;
	his_self.game.state.leaders.mary_i = 0;
	his_self.game.state.leaders.elizabeth_i = 1;
	his_self.removeCardFromGame('019');
	his_self.removeCardFromGame('021');
	return 1;
      },
    }
    deck['024'] = { 
      img : "cards/HIS-024.svg" , 
      name : "Arquebusiers" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu === "pre_field_battle_rolls" || menu === "pre_naval_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('024')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (menu === "pre_field_battle_rolls") {
	    if (his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
              return { faction : f , event : '024', html : `<li class="option" id="024">arquebusiers (${f})</li>` };
            }
	  }
	  if (menu === "pre_naval_battle_rolls") {
	    if (his_self.doesFactionHaveNavalUnitsInSpace(f, his_self.game.state.naval_battle.spacekey)) {
              return { faction : f , event : '024', html : `<li class="option" id="024">arquebusiers (${f})</li>` };
            }
	  }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
try {
        if (menu === "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnControllingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('024')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        if (menu === "pre_naval_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('024')) {
	      if (his_self.doesPlayerHaveNavalUnitsInSpace(his_self.game.player, spacekey)) {
                return 1;
              }
            }
          }
        }
} catch (err) { 
console.log("ERR: " + JSON.stringify(err));
}
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_naval_battle_rolls") {
	  his_self.addMove("insert_before_counter_or_acknowledge\tadd_naval_battle_bonus_rolls\t"+faction+"\t2");
	  his_self.addMove("discard\t"+faction+"\t024");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("024"));
	  his_self.endTurn();
        }
        if (menu === "pre_field_battle_rolls") {
	  his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t2");
	  his_self.addMove("discard\t"+faction+"\t024");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("024"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['025'] = { 
      img : "cards/HIS-025.svg" , 
      name : "Field Artillery" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('025')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '025', html : `<li class="option" id="025">field artillery (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnControllingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('025')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  if (faction === "france" || faction === "ottoman") {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t3");
	  } else {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t2");
	  }
	  his_self.addMove("discard\t"+faction+"\t025");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("025"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['026'] = { 
      img : "cards/HIS-026.svg" , 
      name : "Mercenaries Bribed" ,
      ops : 3 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('026')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (f === "ottoman") { return {}; }
	  if (f != "") { 
	    if (his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
              return { faction : f , event : '026', html : `<li class="option" id="026">mercenaries bribed (${f})</li>` };
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnControllingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('026')) {
	        if (his_self.doesPlayerHaveLandUnitsInSpace(his_self.game.player, spacekey)) {
                  return 1;
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  his_self.addMove("mercenaries_bribed\t"+faction);
	  his_self.addMove("discard\t"+faction+"\t026");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("026"));
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "mercenaries_bribed") {

          his_self.game.queue.splice(qe, 1);

	  let cmd = "field_battle\t" + his_self.game.state.field_battle.spacekey+"\t"+his_self.game.state.field_battle.attacker_faction;

	  console.log("QUEUE: " + JSON.stringify(his_self.game.queue));

          let faction = mv[1];
	  let card_player_is_attacker = true;
	  if (his_self.game.state.field_battle.faction_map[faction] == his_self.game.state.field_battle.defender_faction) { card_player_is_attacker = false; }

          let spacekey = his_self.game.state.field_battle.spacekey;
          let fmap = his_self.game.state.field_battle.faction_map;
          let remove_next_mercenary = 1;
          let total_mercenaries_removed = 0;

	  if (card_player_is_attacker) {
	    for (let f in fmap) {
	      if (fmap[f] == his_self.game.state.field_battle.defender_faction) {
		for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		  let u = his_self.game.spaces[spacekey].units[f][z];
		  if (u.type === "mercenary") {
		    if (remove_next_mercenary) {
		      his_self.game.spaces[spacekey].units[f].splice(z, 1);
		      z--;
		      total_mercenaries_removed++;
		      remove_next_mercenary = 0;
		    } else {
		      remove_next_mercenary = 1;
		    }
		  }
		}  
	      }
	    }
	  } else {
	    for (let f in fmap) {
	      if (fmap[f] == his_self.game.state.field_battle.attacker_faction) {
		for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		  let u = his_self.game.spaces[spacekey].units[f][z];
		  if (u.type === "mercenary") {
		    if (remove_next_mercenary) {
		      his_self.game.spaces[spacekey].units[f].splice(z, 1);
		      z--;
		      total_mercenaries_removed++;
		      remove_next_mercenary = 0;
		    } else {
		      remove_next_mercenary = 1;
		    }
		  }
		}  
	      }
	    }
	  }

	  his_self.addMercenary(faction, spacekey, total_mercenaries_removed);

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lmv = his_self.game.queue[i].split("\t");
	    if (lmv[0].indexOf("field_b") == 0) {
	      his_self.game.queue.splice(i, 1); 
	    } else {
	      if (lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("HALTED") == 0 || lmv[0].indexOf("counter_or_ac") == 0) {
	      } else {
	        his_self.game.queue.splice(i+1, 0, cmd);
	        if (lmv[0].indexOf("ACKNOWLEDGE") == 0) {} else {
	          i = 0;
	        }
	      }
	    }
	  }
        }
        return 1;
      },
    }
    deck['027'] = { 
      img : "cards/HIS-027.svg" , 
      name : "Mercenaries Grow Restless" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_assault_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('027')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              return { faction : f , event : '027', html : `<li class="option" id="027">mercenaries grow restless (${f})</li>` };
              break;
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_assault_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnControllingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('027')) {
	        let assault_spacekey = "";
	        if (his_self.game.state.assault) {
	          if (his_self.game.state.assault.spacekey) {
		    let fac = his_self.returnFactionControllingSpace(his_self.game.state.assault.spacekey);
		    if (his_self.game.player == his_self.returnPlayerCommandingFaction(fac)) {
                      return 1;
	 	    }
	 	  }
	 	}
	      }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_assault_rolls") {
	  his_self.addMove(`mercenaries_grow_restless\t${faction}`);
  	  his_self.addMove(`discard\t${faction}\t027`);
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("027"));
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
        if (mv[0] === "mercenaries_grow_restless") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  his_self.updateLog(his_self.returnFactionName(faction) + " triggers " + his_self.popup("027"));
	  salert(his_self.returnFactionName(faction) + " events Mercenaries Grow Restless!"); 

          let player = his_self.returnPlayerOfFaction(faction);
	  let space = his_self.game.spaces[his_self.game.state.assault.spacekey];
	  let attacker_land_units_remaining = 0;
	  let defender_land_units_remaining = 0;
	  for (let f in his_self.game.state.assault.faction_map) {
            if (his_self.game.state.assault.faction_map[f] === his_self.game.state.assault.attacker_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		if (space.units[f][z].type === "mercenary") {
		  space.units[f].splice(z, 1);
		  z--;
		} else {
		  if (space.units[f][z].type === "cavalry" || space.units[f][z].type === "regular") {
		    attacker_land_units_remaining++;
		  }
		}
	      }
            }       
            if (his_self.game.state.assault.faction_map[f] === his_self.game.state.assault.defender_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		let u = space.units[f][z];
	        if (u.type === "mercenary" || u.type === "regular" || u.type === "cavalry") {
		  defender_land_units_remaining++;
		}
	      }
	    }
          }

	  if (defender_land_units_remaining > attacker_land_units_remaining) {

	    //
	    // remove rest of assault
	    //
	    for (let i = his_self.game.queue.length-1; i > 0 ; i--) {
	      let lmv = his_self.game.queue[i].split("\t");
	      if (!(lmv[0].indexOf("assault") == 0 || lmv[0].indexOf("counter") == 0 || lmv[0].indexOf("RESETC") == 0 || lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("discard") == 0)) {
		break;
	      } else {
	        if (lmv[0].indexOf("RESOLVE") == 0 || lmv[0].indexOf("discard") == 0) {

	        } else {
		  his_self.game.queue.splice(i, 1);
	        }
	      }
	    }

	    his_self.game.queue.push("break_siege");
	    his_self.game.queue.push("hide_overlay\tassault");
    	    his_self.game.queue.push(`discard\t${faction}\t027`);

	  //
	  // assault may continue -- this will take us back to the acknowledge menu
	  //
	  } else {

	    //
	    // remove rest of assault
	    //
	    for (let i = his_self.game.queue.length-1; i > 0 ; i--) {
	      let lmv = his_self.game.queue[i].split("\t");
	      if (!(lmv[0].indexOf("discard") == 0 || lmv[0].indexOf("continue") == 0 || lmv[0].indexOf("play") == 0)) {
		his_self.game.queue.splice(i, 1);
	      } else {
		break;
	      }
	    }

	    his_self.game.queue.push(`assault\t${his_self.game.state.assault.attacker_faction}\t${his_self.game.state.assault.spacekey}`);
	    his_self.game.queue.push("hide_overlay\tassault");
    	    his_self.game.queue.push(`discard\t${faction}\t027`);

	  }

	}


        return 1;
      }
    }
    deck['028'] = { 
      img : "cards/HIS-028.svg" , 
      name : "Siege Mining" ,
      ops : 1 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player, spacekey) {
        if (menu == "pre_assault_rolls") {
 	  if (his_self.game.player != his_self.game.state.active_player) {
	    return {};
	  }
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnCommandingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('028')) {
console.log("and we have Siege Mining...");
                f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
                return { faction : f , event : '028', html : `<li class="option" id="028">siege mining (${f})</li>` };
              }
            }
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) { // extra= assault spacekey
        if (menu == "pre_assault_rolls") {
          if (his_self.game.player != his_self.game.state.active_player) { return 0; }
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('028')) {
	      return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_assault_rolls") {
	  his_self.addMove("add_assault_bonus_rolls\t"+faction+"\t3");
	  his_self.addMove("discard\t"+faction+"\t028");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("028"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['029'] = { 
      img : "cards/HIS-029.svg" , 
      name : "Surprise Attack" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('029')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  if (his_self.doesFactionHaveLandUnitsInSpace(f, his_self.game.state.field_battle.spacekey)) {
            return { faction : f , event : '029', html : `<li class="option" id="029">surprise attack (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) { // extra = spacekey of assault
        if (menu == "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('029')) {
	        for (let f in his_self.game.spaces[spacekey].units) {
		  if (his_self.returnFactionLandUnitsInSpace(f, his_self.game.spaces[spacekey]) > 0) {
		    if (his_self.game.player == his_self.returnPlayerCommandingFaction(f)) {
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_field_battle_rolls") {
	  let is_attacker = false;
	  for (let f in his_self.game.state.field_battle.faction_map) {
	    if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	      is_attacker = true;
	    }
	  }
	  if (is_attacker) {
	    his_self.addMove("insert_before_counter_or_acknowledge\tfaction_assigns_hits_first_field_battle\tattacker");
	  } else {
	    his_self.addMove("insert_before_counter_or_acknowledge\tfaction_assigns_hits_first_field_battle\tdefender");
	  }

	  his_self.addMove("discard\t"+faction+"\t029");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("029"));
	  his_self.endTurn();
        }
        return 1;
      },
    }
    deck['030'] = { 
      img : "cards/HIS-030.svg" , 
      name : "Tercios" ,
      ops : 2 ,
      turn : 1 ,
      type : "combat" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player, extra="") {
        if (menu === "pre_field_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('030')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
	  let are_haps_in_space = false;
	  if (extra != "") {
	    if (his_self.game.spaces[extra]) {
	      for (let f in his_self.game.spaces[extra].units) {
		if (his_self.game.spaces[extra].units[f].length > 0) {
		  if (his_self.returnControllingPower(f) == "hapsburg") {
		    are_haps_in_space = true;
		  }
		}
	      }
	    }
	  }
	  if (!are_haps_in_space) { return {}; }
          return { faction : f , event : '030', html : `<li class="option" id="030">tercios (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_field_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    for (let z = 0; z < fis.length; z++) { fis[z] = his_self.returnControllingPower(fis[z]); }
	    if (fis.includes(f)) {
              if (his_self.game.deck[0].fhand[i].includes('030')) {
	        for (let f in his_self.game.spaces[spacekey].units) {
		  if (his_self.game.spaces[spacekey].units[f].length > 0) {
		    if (his_self.returnControllingPower(f) == "hapsburg") {
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "pre_field_battle_rolls") {
	  if (faction === "hapsburg") {
	    his_self.addMove("insert_before_counter_or_acknowledge\tadd_field_battle_bonus_rolls\t"+faction+"\t3");
            his_self.addMove("insert_before_counter_or_acknowledge\tSETVAR\tstate\tfield_battle\ttercios\t1");
	    his_self.addMove("discard\t"+faction+"\t030");
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("030"));
	    his_self.endTurn();
          } else {
	    let nhr = 0;
	    for (let f in his_self.game.spaces[his_self.game.state.field_battle.spacekey].units) {
	      if (his_self.returnControllingPower(f) == "hapsburg") {
	        for (let i = 0; i < his_self.game.spaces[his_self.game.state.field_battle.spacekey].units[f].length; i++) {
		  if (his_self.game.spaces[his_self.game.state.field_battle.spacekey].units[f][i].type == "regular") {
		    nhr++;
	          }
	        }
	      }
	    }
	    if (nhr >= 3) {
	      his_self.addMove("discard\t"+faction+"\t030");
	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " triggers " + his_self.popup("030"));
	      his_self.addMove("tercios_remove_haps_rolls\t"+his_self.game.state.field_battle.spacekey+"\t"+faction+"\t"+3);
	      his_self.endTurn();
	    } else {
	      // submit the resolve at least
	      his_self.endTurn();
	    }
	  }
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "tercios_remove_haps_rolls") {

	  let spacekey = mv[1];
	  let faction = mv[2];

	  if (his_self.returnControllingPower(his_self.game.state.field_battle.attacker_faction) == "hapsburg") {
	    for (let i = 0; i < 3; i++) {
	      if (his_self.game.state.field_battle.attacker_modified_rolls[i]) {
		if (his_self.game.state.field_battle.attacker_modified_rolls[i] >= 5) {
	          his_self.game.state.field_battle.attacker_hits--;
		}
	        his_self.game.state.field_battle.attacker_modified_rolls[i] = 0;
	      }
	    }
	  } else {
	    for (let i = 0; i < 3; i++) {
	      if (his_self.game.state.field_battle.defender_modified_rolls[i]) {
		if (his_self.game.state.field_battle.defender_modified_rolls[i] >= 5) {
	          his_self.game.state.field_battle.defender_hits--;
		}
	        his_self.game.state.field_battle.defender_modified_rolls[i] = 0;
	      }
	    }
	  }

          his_self.game.queue.splice(qe, 1);
	  his_self.displayModal(his_self.returnFactionName(faction) + " triggers Tercios");

	  return 1;

        }

        return 1;
      }
    }
    deck['031'] = { 
      img : "cards/HIS-031.svg" , 
      name : "Foul Weather" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu == "navalmove" || menu == "move" || menu == "assault" || menu == "piracy") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('031')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '031', html : `<li class="option blink" id="031">foul weather (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "navalmove" || menu == "move" || menu == "assault" || menu == "piracy") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('031')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "navalmove" || menu == "move" || menu == "assault" || menu == "piracy") {
	  his_self.addMove(`foul_weather\t${player}\t${faction}`);
  	  his_self.addMove("discard\t"+faction+"\t"+"031");
	  if (his_self.game.deck[0].discards["032"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "foul_weather") {

          let player = mv[1];
          let faction = mv[2];
	  let is_move_over_pass = false;

          his_self.game.queue.splice(qe, 1);

	  his_self.displayModal(his_self.returnFactionName(faction) + " triggers Foul Weather");

	  his_self.updateLog(his_self.returnFactionName(faction) + " triggers " + his_self.popup("031"));
	  his_self.game.state.events.foul_weather = 1;


	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    let lmv = lqe.split("\t");
	    if (lmv[0] == "move") {
	      let source = lmv[3];
	      let destination = lmv[4];
	      if (his_self.game.spaces[source]) {
	        if (his_self.game.spaces[source].pass) {
	          for (let z = 0; z < his_self.game.spaces[source].pass.length; z++) {
		    if (his_self.game.spaces[source].pass[z] == destination) {
		      is_move_over_pass = true;
		    }
	          }
	        }
	      }
	    }
	  }


	  //
	  // "lose 1 CP"
	  //
	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("cards_left") != 0 && lqe.indexOf("continue") != 0 && lqe.indexOf("play") != 0 && lqe.indexOf("counter_or_acknowledge") != 0 && lqe.indexOf("RESOLVE") != 0 && lqe.indexOf("HALTED") != 0) {
	      his_self.game.queue.splice(i, 1);
	    } else {
	      // only stop if at "continue" or "play"
	      if (lqe.indexOf("cards_left") == 0 || lqe.indexOf("counter_or_acknowledge") == 0 || lqe.indexOf("RESOLVE") == 0 || lqe.indexOf("HALTED") == 0)  {
	      } else {
		if (is_move_over_pass) {
	          if (lqe.indexOf("continue") == 0) {
		    let lmv = lqe.split("\t");
		    let replacement_command = lmv[0] + "\t" + lmv[1] + "\t" + lmv[2] + "\t" + lmv[3] + "\t" + (parseInt(lmv[4])+1) + "\t" + lmv[5];
		    his_self.game.queue[i] = replacement_command;
		  }
		}
	        i = -1;
	      }
	    }
	  }

	  return 1;

        }

	return 1;
      }
    }
    deck['032'] = { 
      img : "cards/HIS-032.svg" , 
      name : "Gout" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player, extra) {
        if (menu == "event") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
              return { faction : f , event : '032', html : '<li class="option blink" id="032">play gout</li>' };
	    }
	  }
	  return {};
	}
        if (menu == "move" || menu == "assault") {
	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    }
	  }

	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }
	  if (f == "") { return {}; }

	  let includes_army_leader = false;

	  if (menu == "assault") {
	    for (let i = his_self.game.queue.length-1; i > 0; i--) {
	      let lqe = his_self.game.queue[i];
	      if (lqe.indexOf("assault") == 0) {
		let lmv = lqe.split("\t");
		if (lmv[0] === "assault") {
		  let faction = lmv[1];
		  let source = lmv[2];
		  let unit_idx = -1;
		  let space = his_self.game.spaces[source];
		  for (let i = 0; i < space.units[faction].length; i++) {
		    if (space.units[faction][i].army_leader == true) {
		      includes_army_leader = true;
		    }
		  }
		}
	      }
	    }
	  }

	  if (menu == "move") {
	    for (let i = his_self.game.queue.length-1; i > 0; i--) {
	      let lqe = his_self.game.queue[i];
	      if (lqe.indexOf("move") == 0) {
		let lmv = lqe.split("\t");
		if (lmv[0] === "move") {
		  let faction = lmv[1];
		  let source = lmv[3];
		  let unit_idx = -1;
		  for (let i = 0; i < his_self.game.spaces[source].units[faction].length; i++) {
		    let unit = his_self.game.spaces[source].units[faction][i];
		    if (unit.army_leader == true) {
		      let unit_idx = -1;
		      includes_army_leader = true;
		    }
		  }
		}
	      }
	    }
	  }

	  if (includes_army_leader) {
            return { faction : f , event : '032', html : '<li class="option blink" id="032">play gout</li>' };
	  } 
       }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra="") {
        if (menu == "event" && extra == "002") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      return 1;
	    }
	  }
	}
        if (menu == "move" || menu == "assault") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      return 1;
	    }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
	// only triggered by Holy Roman Emperor
	if (menu === "event") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              his_self.addMove("gout_stops_charles_v\t"+f);
  	      his_self.addMove(`discard\t${f}\t032`);
              his_self.endTurn();
	      return 1;
	    }
	  }
	}

	if (menu === "assault") {

	  let faction = null;
	  let source = null;
	  let unit_idx = null;

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("assault") == 0) {
	      let lmv = lqe.split("\t");
	      faction = lmv[1];
	      source = lmv[2];
	      if (lmv[0] === "assault") {
	        let space = his_self.game.spaces[source];
	        for (let i = 0; i < space.units[faction].length; i++) {
	          if (space.units[faction][i].army_leader) {
	            unit_idx = i;
	          }
	        }
	      }
	      break;
	    }
	  }

	  //
	  // out of desperation, give random unit gout
	  //
	  if (unit_idx == null) { unit_idx = 0; }

	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }

	  if (faction == null || source == null || unit_idx == null) { his_self.endTurn(); return 0; }
	  his_self.addMove(`gout\t${faction}\t${source}\t${unit_idx}\t${f}`);
  	  his_self.addMove(`discard\t${f}\t032`);
	  if (his_self.game.deck[0].discards["031"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
          his_self.endTurn();

	}


        if (menu === "move") {

	  let faction = null;
	  let source = null;
	  let unit_idx = null;

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("move") == 0) {
	      let lmv = lqe.split("\t");
	      if (lmv[0] === "move") {
		faction = lmv[1];
		source = lmv[3];
	        let space = his_self.game.spaces[source];
	        for (let i = 0; i < space.units[faction].length; i++) {
	          if (space.units[faction][i].army_leader) {
	            unit_idx = i;
	          }
	        }
	      }
	    }
	  }

	  //
	  // out of desperation, give random unit gout
	  //
	  if (unit_idx == null) { unit_idx = 0; }

	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('032')) {
	      f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	      break;
	    }
	  }

	  if (faction == null || source == null || unit_idx == null) { his_self.endTurn(); return 0; }
	  his_self.addMove(`gout\t${faction}\t${source}\t${unit_idx}\t${f}`);
  	  his_self.addMove(`discard\t${f}\t032`);
	  if (his_self.game.deck[0].discards["031"]) {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t0");
	  }
          his_self.endTurn();

        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

	if (mv[0] === "gout_stops_charles_v") {

	  let triggering_faction = mv[1];

          his_self.game.queue.splice(qe, 1);

	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    if (his_self.game.queue[i] == "event\thapsburg\t002") {
	      his_self.game.queue[i] = "ops\thapsburg\t002\t5";
	    }
	  }
	  his_self.updateLog(his_self.returnFactionName(triggering_faction) + " triggers Gout");
	  his_self.displayModal(his_self.returnFactionName(triggering_faction) + " triggers Gout");

	  return 1;

	}


        if (mv[0] === "gout") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let triggering_faction = mv[4];

	  his_self.displayModal(his_self.returnFactionName(triggering_faction) + " triggers Gout");

	  his_self.game.spaces[source].units[faction][unit_idx].gout = true;
	  his_self.game.spaces[source].units[faction][unit_idx].locked = 1;
	  his_self.updateLog(his_self.game.spaces[source].units[faction][unit_idx].name + " has come down with " + his_self.popup("032"));

	  //
	  // "lose 1 CP"
	  //
	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lqe = his_self.game.queue[i];
	    if (lqe.indexOf("cards_left") != 0 && lqe.indexOf("continue") != 0 && lqe.indexOf("play") != 0 && lqe.indexOf("counter_or_acknowledge") != 0 && lqe.indexOf("RESOLVE") != 0 && lqe.indexOf("HALTED") != 0) {
	      his_self.game.queue.splice(i, 1);
	    } else {
	      // only stop if at "continue" or "play"
	      if (lqe.indexOf("cards_left") == 0 || lqe.indexOf("counter_or_acknowledge") == 0 || lqe.indexOf("RESOLVE") == 0 || lqe.indexOf("HALTED") == 0)  {
	      } else {
	        i = -1;
	      }
	    }
	  }

console.log("POST_GOUT_QUEUE: " + JSON.stringify(his_self.game.queue));

	  return 1;

	}

        return 1;
      }
    }
    deck['033'] = { 
      img : "cards/HIS-033.svg" , 
      name : "Landsknechts" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {
        his_self.game.queue.push("landsknechts\t"+faction);
	return 1;
      },
      menuOption  :       function(his_self, menu, player, spacekey="") {
        if (menu == "pre_field_battle_rolls" || menu === "move" || menu === "assault") {
	  let f = "";
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    if (his_self.game.deck[0].fhand[i].includes('033')) {
	      if (spacekey != "") {
                if (his_self.returnFriendlyLandUnitsInSpace(his_self.game.state.players_info[his_self.game.player-1].factions[i], spacekey)) {
                  f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	          break;
	        }
	      } else {
	        f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	        break;
	      }
	    }
	  }
	  // removal is very messy if done when units are moving pre-field battle due to RESOLVES flying around
	  if (f === "ottoman" && menu === "pre_field_battle_rolls") { return {}; }
          return { faction : f , event : '033', html : `<li class="option blink" id="033">landsknechts (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "pre_field_battle_rolls" || menu === "move" || menu === "assault") {
	  for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
	    let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	    let fis = his_self.returnArrayOfFactionsInSpace(spacekey);
	    let one_of_ours = false;
	    for (let z = 0; z < fis.length; z++) {
	      let cf = fis[z];
	      cf = his_self.returnControllingPower(cf);
	      if (f == cf) { one_of_ours = true; }
	    }
	    if (one_of_ours) {
	      if (his_self.game.deck[0].fhand[i].includes('033')) {
	        if (menu === "assault") { 
		  let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
		  if (his_self.returnFriendlyUnbesiegedLandUnitsInSpace(faction, spacekey) > 0) {
		    return 1;
		  }
	        }

	        if (menu === "move") { 
		  let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
		  if (his_self.returnFactionLandUnitsInSpace(f, spacekey, 1) > 0) {
		    return 1;
	          }
		}

		if (menu === "pre_field_battle_rolls") {
	          return 1;
		}

	      }
	    }
	  }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction, spacekey="") {
        if (menu === "pre_field_battle_rolls" || menu === "assault" || menu === "move") {

	  if (menu == "pre_field_battle_rolls") {
	    let spacekey = his_self.game.state.player_last_spacekey;
	    let num = 2;
	    if (faction === "hapsburg") { num = 4; }
	    his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("033"));
            his_self.addMove("add_units_before_field_battle\t"+faction+"\t"+"mercenary"+"\t"+num+"\t"+spacekey);
            his_self.addMove("discard\t"+faction+"\t033");
            his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("033"));
            his_self.endTurn();

	  } else {

            his_self.addMove("discard\t"+faction+"\t033");
  	    his_self.addMove("landsknechts\t"+faction);
	    his_self.endTurn();            

	  }
	}
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "landsknechts") {

          let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == player) {

	    if (faction === "hapsburg") {
              his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", 4, "hapsburg",
	        function(space) {
	  	  if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
		  if (his_self.returnFactionLandUnitsInSpace("hapsburg", space.key)) { return 1; }
		  if (his_self.returnFriendlyLandUnitsInSpace("hapsburg", space.key)) { return 1; }
	        } ,
	        null ,
	        null ,
	        true
	      );
	    } else {
	      if (faction === "ottoman") {
                his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter("mercenary", 2,
	          function(space) {
		    for (let key in space.units) {
		      for (let i = 0; i < space.units[key].length; i++) {
		        if (space.units[key][i].type === "mercenary") { return 1; }
		      }
		    }
	          } ,
	          null ,
	          null ,
	          true
	        );
	      } else {
                his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", 2, faction,
	          function(space) {
		    if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
		    if (his_self.returnFactionLandUnitsInSpace(faction, space.key)) { return 1; }
		    if (his_self.game.players.length == 2) {
		      if (faction == "protestant") {
			// protestants cannot put protestant mercs into spaces since
			// they aren't technically allied with those powers so much 
			// as just controlling them to screw with the Papacy.
			return 0;
		      }
		    }
		    if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
		    return 0;
	          } ,
	          null ,
	          null ,
	          true
	        );
	      }
	    }
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing Landsknechts");
	  }

          his_self.game.queue.splice(qe, 1);
	  return 0;

        }

	return 1;
      },
    }
    deck['034'] = { 
      img : "cards/HIS-034.svg" , 
      name : "Professional Rowers" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player) {
	if (menu === "naval_intercept" || menu === "naval_avoid_battle") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('034')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              i = 100;
            }
          }
          return { faction : f , event : '034', html : `<li class="option" id="034">professional rowers (${f})</li>` };
	}
        if (menu === "naval_intercept" || menu === "pre_naval_battle_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('034')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              i = 100;
            }
          }
	  if (his_self.game.state.naval_battle.attacker_faction != f && his_self.game.state.naval_battle.defender_faction != f) { return {}; }
          return { faction : f , event : '034', html : `<li class="option" id="034">professional rowers (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "naval_intercept" || menu === "naval_avoid_battle") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('034')) {
              return 1;
            }
          }
        }
        if (menu === "pre_naval_battle_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('034')) {
              let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              if (his_self.doesFactionHaveNavalUnitsInSpace(f, spacekey)) {
                his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);
                return 1;
              }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {

        his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t0");
        his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t0");

	if (menu === "naval_intercept") {
	  his_self.game.state.naval_intercept_bonus = 2;
          his_self.addMove("SETVAR\tstate\tnaval_intercept_bonus\t2");
          his_self.addMove("discard\t"+faction+"\t034");
	  his_self.endTurn();
	  return 0;
	}

	if (menu === "naval_avoid_battle") {
	  his_self.game.state.naval_avoid_battle_bonus = 2;
          his_self.addMove("SETVAR\tstate\tnaval_avoid_battle_bonus\t2");
          his_self.addMove("discard\t"+faction+"\t034");
	  his_self.endTurn();
	  return 0;
	}

        if (menu === "pre_naval_battle_rolls") {

	  let attacker_faction = his_self.game.state.naval_battle.attacker_faction;
	  let defender_faction = his_self.game.state.naval_battle.defender_faction;

	  if (faction == attacker_faction || faction == defender_faction) {

	    his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" play " + his_self.popup("034"));
            his_self.addMove("discard\t"+faction+"\t034");
            his_self.addMove("add_naval_battle_bonus_rolls\t"+faction+"\t3");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
	    his_self.endTurn();
	    his_self.updateStatus("acknowledge");

          } else {

            let html = '<ul>';
  	    html += `<li class="option" id="${attacker_faction}">${attacker_faction}</li>`;
  	    html += `<li class="option" id="${defender_faction}">${defender_faction}</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions("Bonus Hits for Whom?", html);

   	    $('.option').off();
	    $('.option').on('click', function () {

	      let winner = $(this).attr("id");
   	      $('.option').off();
	      his_self.updateStatus("acknowledge");
	      his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("034"));
              his_self.addMove("discard\t"+faction+"\t034");
              his_self.addMove("add_naval_battle_bonus_rolls\t"+winner+"\t3");
              his_self.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
	      his_self.endTurn();

	    });

	  }

        }
        return 0;
      },
    }
    deck['035'] = { 
      img : "cards/HIS-035.svg" , 
      name : "Siege Artillery" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      menuOption  :       function(his_self, menu, player, extra="") {
        if (menu === "post_assault_rolls") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('035')) {
	      let assault_spacekey = his_self.game.state.assault.spacekey;
	      let attacker_faction = his_self.game.state.assault.attacker_faction;
	      for (let z = 0; z < his_self.game.state.players_info[his_self.game.player-1].factions.length; z++) {
                if (attacker_faction == his_self.game.state.players_info[his_self.game.player-1].factions[z]) {
                  if (4 >= his_self.returnHopsToFortifiedHomeSpace(assault_spacekey, attacker_faction)) {
              	    f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              	    i = 100;
              	    return { faction : f , event : '035', html : `<li class="option blink" id="035">siege artillery (${f})</li>` };
		  }
		}
	      }
            }
          }
        }   
        return {};
      }, 
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu === "post_assault_rolls") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('035')) {
	      let assault_spacekey = his_self.game.state.assault.spacekey;
	      let attacker_faction = his_self.game.state.assault.attacker_faction;
	      if (his_self.game.spaces[assault_spacekey].neighbours.length == 0) { return 0; }
	      for (let z = 0; z < his_self.game.state.players_info[his_self.game.player-1].factions.length; z++) {
		if (attacker_faction == his_self.game.state.players_info[his_self.game.player-1].factions[z]) {
	          if (4 >= his_self.returnHopsToFortifiedHomeSpace(assault_spacekey, attacker_faction)) {
		    his_self.assault_overlay.render(his_self.game.state.assault);
	 	    return 1;
	          }
	        }
	      }
              return 0;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu === "post_assault_rolls") {
	  let attacker_faction = his_self.game.state.assault.attacker_faction;
          his_self.addMove("SETVAR\tstate\tassault\tsiege_artillery\t0");
	  his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("035"));
          his_self.addMove("discard\t"+faction+"\t035");
          his_self.addMove("add_assault_bonus_rolls\t"+attacker_faction+"\t2");
          his_self.addMove("SETVAR\tstate\tassault\tsiege_artillery\t1");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("035"));
          his_self.addMove("SETVAR\tstate\tevents\tintervention_post_assault_possible\t0");
	  his_self.endTurn();
	  his_self.updateStatus("acknowledge");
        }
        return 0;
      },
    }
    deck['036'] = { 
      img : "cards/HIS-036.svg" , 
      name : "Swiss Mercenaries" ,
      ops : 1 ,
      turn : 1 ,
      type : "response" ,
      canEvent : function(his_self, faction) { return 1; } ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      onEvent : function(his_self, faction) {

	let target_number = 2;
	let placing_faction = faction;
	if (faction == "ottoman") { placing_faction = "france"; target_number = 4; }
	if (faction == "france") { target_number = 4; }
	his_self.game.queue.push("swiss_mercenaries_place\t"+placing_faction+"\t"+target_number);

	return 1;

      },
      menuOption  :       function(his_self, menu, player, spacekey="") {
        if (menu == "pre_field_battle_rolls" || menu === "assault" || menu === "move") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('036')) {
	      if (spacekey != "") {
                if (his_self.returnFriendlyLandUnitsInSpace(his_self.game.state.players_info[his_self.game.player-1].factions[i], spacekey)) {
                  f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
	          break;
	        }
	      } else {
                f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
                break;
              }
            }
          }
	  if (f != "") {
            return { faction : f , event : '036', html : `<li class="option blink" id="036">swiss mercenaries (${f})</li>` };
          }
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, spacekey) {
        if (menu == "pre_field_battle_rolls" || menu == "assault" || menu === "move") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('036')) {

	      if (menu === "assault") { 
		let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
		if (his_self.returnFriendlyUnbesiegedLandUnitsInSpace(faction, spacekey) > 0) {
		  return 1;
		}
	      }

	      if (menu === "move") { 
		let f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
		if (his_self.returnFactionLandUnitsInSpace(f, spacekey, 1) > 0) {
		  return 1;
	        }
	      }

	      if (menu == "pre_field_battle_rolls") { return 1; }

            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "move" || menu == "assault" || menu == "pre_field_battle_rolls") {
	  let target_faction = faction;
	  let target_number = 2;
	  if (faction == "ottoman" || faction == "france") {
	    target_faction = "france";
	    target_number = 4;
	  }
	  let spacekey = "";
	  if (menu === "pre_field_battle_rolls") { spacekey = his_self.game.state.player_last_spacekey; }

	  his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("036"));
	  if (spacekey != "" && target_faction == faction) {
	    his_self.addMove("add_units_before_field_battle\t"+target_faction+"\t"+"mercenary"+"\t"+target_number+"\t"+spacekey);
          } else {
	    his_self.addMove("swiss_mercenaries_place\t"+target_faction+"\t"+target_number);
	  }
          his_self.addMove("discard\t"+faction+"\t036");
	  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" triggers " + his_self.popup("036"));
	  his_self.endTurn();
	}
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "swiss_mercenaries_place") {

          let faction = mv[1];
          let num = parseInt(mv[2]);
          his_self.game.queue.splice(qe, 1);

	  let player = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == player) {
            his_self.playerPlaceUnitsInSpaceWithFilter("mercenary", num, faction,
	      function(space) {
		for (let f in space.units) {
		  for (let z = 0; z < space.units[f].length; z++) { 
		    if (space.units[f][z].besieged > 0) {
		      if (his_self.returnPlayerCommandingFaction(f) == player) { return 0; }
		    }
	          }
	        }
		if (his_self.returnFactionLandUnitsInSpace(faction, space.key)) { return 1; }
		if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
	        return 0;
	      } ,
	      null ,
	      null ,
	      true
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("036"));
	  }

	  return 0;
        }

	return 1;
      },
    }
    deck['037'] = { 
      img : "cards/HIS-037.svg" , 
      name : "The Wartburg" ,
      ops : 2 ,
      turn : 1 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; } ,
      menuOption  :       function(his_self, menu, player, card="") {

        if (menu == "event") {

	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }

	  let p = his_self.returnPlayerOfFaction();

          if (his_self.game.state.leaders.luther !== 1) { return {}; }
          if (card === "") { return {}; }
          if (!his_self.game.deck[0]) { return {}; }

	  //
	  // card evented
	  //
	  let cardobj = his_self.game.deck[0].cards[card];

	  //
	  // cannot cancel non-papal home cards
	  //
	  if (card === "001" || card == "002" || card == "003" || card == "004") { return {}; }

	  //
	  // cannot cancel these three types of cards
	  //
	  if (cardobj.type === "response") { return {}; }
	  if (cardobj.type === "mandatory") { return {}; }
	  if (cardobj.type === "combat") { return {}; }

          return { faction : "protestant" , event : '037', html : `<li class="option blink" id="037">wartburg (protestant)</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "event") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('037')) {
	      if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player) {
 		return 1;
	      }
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "event") {
	  his_self.addMove("RESETCONFIRMSNEEDED\tall");
          his_self.addMove("NOTIFY\tWartburg Evented");
          his_self.addMove("wartburg");
          his_self.addMove("discard\tprotestant\t037");
          his_self.addMove("commit\tprotestant\tluther-debater");
	  his_self.endTurn();
	  his_self.updateStatus("wartburg acknowledge");
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "wartburg") {

          his_self.game.queue.splice(qe, 1);

	  his_self.displayModal("Protestants cancel event with the Wartburg");

	  his_self.updateStatus(his_self.popup("037") + " triggered");
	  his_self.game.state.events.wartburg = 1;
	  his_self.commitDebater("protestant", "luther-debater", 0);
	  his_self.updateLog(his_self.popup("037") + " triggered");

	  //
	  // remove event from execution and end player turn
	  //
	  for (let i = his_self.game.queue.length-1; i > 0; i--) {
	    let lmv = his_self.game.queue[i].split("\t");
	    // TODO -- test if removes still now we have removed "remove"
	    if (lmv[0] !== "cards_left" && lmv[0] !== "discard" && lmv[0] !== "round" && lmv[0] !== "play" && lmv[0].indexOf("counter_or_acknowledge") != 0 && lmv[0].indexOf("RESOLVE") != 0 && lmv[0].indexOf("HALTED") != 0) { 
	      his_self.game.queue.splice(i, 1);
	    } else {
	      if (lmv[0] === "remove") {
		let x = "discard";
		for (let z = 1; z < lmv.length; z++) { x += "\t"; x += lmv[1]; }
		his_self.game.queue[i] = x;
	      }
	      if (lmv[0] === "round" || lmv[0] === "play") {
		i == 0;
		break;
	      }
	    }
	  }

	  return 1;

        }

	return 1;
      },
    }
    deck['038'] = { 
      img : "cards/HIS-038.svg" , 
      name : "Halley's Comet" ,
      ops : 2 ,
      turn : 3 ,
      type : "response" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      menuOption  :       function(his_self, menu, player) {
        if (menu != "" && menu != "pre_spring_deployment") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }

          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('038')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '038', html : `<li class="option blink" id="038">halley's comet (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu != "" && menu != "pre_spring_deployment") {
	  if (his_self.game.state.active_player === his_self.game.player) { 
	    // not in translation and reformation overlays
	    if (menu.indexOf("lation") > 0 || menu.indexOf("ormation") > 0) {
	      return 0;
	    }
	  }
	  if (!his_self.game.deck) { return 0; }
	  if (!his_self.game.deck[0]) { return 0; }
	  if (!his_self.game.deck[0].fhand) { return 0; }
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('038')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu != "" && menu != "pre_spring_deployment") {

	  let p = his_self.returnPlayerCommandingFaction(faction);
	  if (his_self.game.player == p) {

	    let msg = "Target which Power?";
	    let html = '<ul>';

	    if (faction != "protestant") { html += '<li class="option" id="protestant">Protestant</li>'; }
	    if (faction != "papacy") { html += '<li class="option" id="papacy">Papacy</li>'; }
	    if (his_self.game.players.length > 2) {
	      if (faction != "england") { html += '<li class="option" id="england">England</li>'; }
	      if (faction != "france") { html += '<li class="option" id="france">France</li>'; }
	      if (faction != "hapsburg") { html += '<li class="option" id="hapsburg">Hapsburg</li>'; }
	      if (faction != "ottoman") { html += '<li class="option" id="ottoman">Ottoman</li>'; }
	    }
            html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let target_faction = $(this).attr("id");

  	      let msg = "Force Power to Discard or Skip Turn?";
	      let html = '<ul>';
	      html += '<li class="option" id="discard">discard random card</li>';
	      html += '<li class="option" id="skip">skip next turn</li>';
	      html += '<ul>';

    	      his_self.updateStatusWithOptions(msg, html);

	      $('.option').off();
	      $('.option').on('click', function () {

	        $('.option').off();
	        let action = $(this).attr("id");

	        his_self.updateStatus("submitted");

	        if (action === "discard") {
                  his_self.addMove("discard_random\t"+target_faction);
  	  	  his_self.addMove("remove\t"+faction+"\t038");
  	  	  his_self.addMove("discard\t"+faction+"\t038");
  	          his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to discard a card");
	  	  his_self.endTurn();
	        }

	        if (action === "skip") {
                  his_self.addMove("skip_next_impulse\t"+target_faction);
  	  	  his_self.addMove("remove\t"+faction+"\t038");
  	  	  his_self.addMove("discard\t"+faction+"\t038");
  	          his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to skip next turn");
		  his_self.endTurn();
	        }
	      });
	    });
	  }
        }
        return 0;
      },
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);

	if (player == his_self.game.player) {

	  let msg = "Target which Power?";
	  let html = '<ul>';

	  if (faction != "protestant") { html += '<li class="option" id="protestant">Protestant</li>'; }
	  if (faction != "papacy") { html += '<li class="option" id="papacy">Papacy</li>'; }
	  if (his_self.game.players.length > 2) {
	    if (faction != "england") { html += '<li class="option" id="england">England</li>'; }
	    if (faction != "france") { html += '<li class="option" id="france">France</li>'; }
	    if (faction != "hapsburg") { html += '<li class="option" id="hapsburg">Hapsburg</li>'; }
	    if (faction != "ottoman") { html += '<li class="option" id="ottoman">Ottoman</li>'; }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let target_faction = $(this).attr("id");

  	    let msg = "Force Power to Discard or Skip Turn?";
	    let html = '<ul>';
	    html += '<li class="option" id="discard">discard random card</li>';
	    html += '<li class="option" id="skip">skip next turn</li>';
	    html += '<ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      his_self.updateStatus("submitted");

	      if (action === "discard") {
                his_self.addMove("discard_random\t"+target_faction);
  	        his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to discard a card");
		his_self.endTurn();
	      }

	      if (action === "skip") {
                his_self.addMove("skip_next_impulse\t"+target_faction);
  	        his_self.addMove("NOTIFY\tHalley's Comet forces "+his_self.returnFactionName(target_faction)+" to skip next turn");
		his_self.endTurn();
	      }

	    });
	  });

          return 0;

        }

	return 0;
      },
    }
    deck['039'] = { 
      img : "cards/HIS-039.svg" , 
      warn : ["papacy"] ,
      name : "Augsburg Confession" ,
      ops : 4 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.isCommitted("melanchthon-debater")) { return 0; }
 	return 1;
      } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);

	if (his_self.isCommitted("melanchthon-debater")) { return 1; }
	his_self.game.state.events.augsburg_confession = 1;
	his_self.commitDebater("papacy", "melanchthon-debater", 0); // 0 = no bonus

	return 1;
      },
    }
    deck['040'] = { 
      img : "cards/HIS-040.svg" , 
      name : "Machiavelli: The Prince" ,
      ops : 3 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");

	if (player == his_self.game.player) {

	  let powers = his_self.returnImpulseOrder();
	  let msg = "Declare War on which Power?";

          let html = '<ul>';
	  for (let i = 0; i < powers.length; i++) {
	    if (powers[i] !== faction) {
	      if (!(powers[i] == "protestant" && his_self.game.state.events.schmalkaldic_league != 1)) {
		if (!his_self.areEnemies(powers[i], faction) && !his_self.areAllies(powers[i], faction)) {
                  html += `<li class="option" id="${powers[i]}">${powers[i]}</li>`;
	        }
	      }
	    }
	  }
	  if (html === "") {
            html += `<li class="option" id="skip">skip declaration</li>`;
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");

	    if (action === "skip") { 
              his_self.addMove("ops\t"+faction+"\t"+"040"+"\t"+2);
	      his_self.endTurn();
	      return 0;	
	    }

            his_self.addMove("ops\t"+faction+"\t"+"040"+"\t"+2);
	    his_self.addMove("unexpected_war\t"+faction+"\t"+action);
            his_self.addMove("declare_war\t"+faction+"\t"+action);
	    his_self.endTurn();

	  });

        }

        return 0;
      },
    }

    deck['041'] = { 
      img : "cards/HIS-041.svg" , 
      name : "Marburg Colloquy" ,
      warn : ["papacy"] ,
      ops : 5 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { 
	if (
	  (his_self.isCommitted("luther-debater") != 1 || his_self.isCommitted("melanchthon-debater"))
	  &&
	  (his_self.isCommitted("zwingli-debater") != 1 || his_self.isCommitted("oekolampadius-debater"))
	) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");
	if (his_self.game.player === player) {

	  let msg = "Commit which Debaters?";
          let html = '<ul>';
	  if (his_self.isCommitted("luther-debater") != 1) {
	    if (his_self.isCommitted("zwingli-debater") != 1) {
              html += '<li class="option" id="lz">Luther and Zwingli</li>';
	    }
	    if (his_self.isCommitted("oekolampadius-debater") != 1) {
              html += '<li class="option" id="lo">Luther and Oekolampadius</li>';
	    }
	  }
	  if (his_self.isCommitted("melanchthon-debater") != 1) {
	    if (his_self.isCommitted("zwingli-debater") != 1) {
              html += '<li class="option" id="mz">Melanchthon and Zwingli</li>';
	    }
	    if (his_self.isCommitted("oekolampadius-debater") != 1) {
              html += '<li class="option" id="mo">Melanchthon and Oekolampadius</li>';
	    }
	  }
          html += '</ul>';

    	  his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    let refs = 0;

            his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");

	    if (action === "lz") {
	      his_self.addMove("commit\tprotestant\tluther-debater");
	      his_self.addMove("commit\tprotestant\tzwingli-debater");
	      refs = 7;
	    }
	    if (action === "lo") {
	      his_self.addMove("commit\tprotestant\tluther-debater");
	      his_self.addMove("commit\tprotestant\toekolampadius-debater");
	      refs = 6;
	    }
	    if (action === "mz") {
	      his_self.addMove("commit\tprotestant\tzwingli-debater");
	      his_self.addMove("commit\tprotestant\tmelanchthon-debater");
	      refs = 6;
	    }
	    if (action === "mo") {
	      his_self.addMove("commit\tprotestant\toekolampadius-debater");
	      his_self.addMove("commit\tprotestant\tmelanchthon-debater");
	      refs = 5;
	    }

	    for (let i = 0; i < refs; i++) {
              his_self.prependMove("protestant_reformation\t"+player+"\tall");
	    }
            his_self.prependMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	    his_self.endTurn();

	  });
	}
	return 0;
      },
    }
    deck['042'] = { 
      img : "cards/HIS-042.svg" , 
      name : "Roxelana" ,
      ops : 4 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.roxelana = 1;

	if (faction === "ottoman") {
	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("ottoman")) {
	    his_self.addMove("ops\tottoman\t042\t4");
	    his_self.endTurn();
	  }
	  return 1;
	} else {

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

	    let msg = "Send Suleiman to Istanbul (2 CP)?";
            let html = '<ul>';
                html += '<li class="option" id="yes">yes</li>';
                html += '<li class="option" id="no">no</li>';
                html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      his_self.updateStatus("acknowledge");
	      $('.option').off();
	      let action = $(this).attr("id");

	      let sk = his_self.returnSpaceOfPersonage("ottoman", "suleiman");
	      let sk_idx = his_self.returnIndexOfPersonageInSpace("ottoman", "suleiman", sk);

	      if (action === "yes" && sk != "") {
	        his_self.addMove("ops\t"+faction+"\t042\t2");
	        his_self.addMove("move" + "\t" + "ottoman" + "\t" + "land" + "\t" + sk + "\t" + "istanbul" + "\t" + sk_idx + "\t1");
	      }
	      if (action === "no") {
	        his_self.addMove("ops\t"+faction+"\t042\t4"); 
	      }
	      his_self.endTurn();

	    });
	    return 0;
	  }
	}

	return 0;
      },
    }
    deck['043'] = { 
      img : "cards/HIS-043.svg" , 
      name : "Zwingli Dons Armor" ,
      ops : 3 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");
	let targets = ["zurich","innsbruck","salzberg","linz","graz","regensburg","augsburg","nuremberg","worms","basel","geneva","turin","grenoble","lyon","besancon","dijon","metz","strasburg"];

	//
	// we all remove the reformer
	//
	his_self.removeReformer("protestant", "zurich", "zwingli-reformer");
	his_self.removeDebater("protestant", "zwingli-debater");

        if (player == his_self.game.player) {
          let count = his_self.countSpacesWithFilter(function(space) {
            if (targets.includes(space.key) && his_self.hasCatholicLandUnits(space.key)) {
              return 1
            }
            return 0;
          });

          if (count == 0) { return 1; }

          his_self.playerSelectSpaceWithFilter(
            "Select Space to Remove Catholic Land Unit",
            function(space) {
              if (targets.includes(space.key) && his_self.hasCatholicLandUnits(space.key)) {
                return 1
              }
              return 0;
            },
            function(spacekey) {

              let catholic_land_units = his_self.returnCatholicLandUnitsInSpace(spacekey);
              let msg = "Remove which Unit?";
              let html = '<ul>';
              for (let i = 0; i < catholic_land_units.length; i++) {
                let u = his_self.game.spaces[spacekey].units[catholic_land_units[i].faction][catholic_land_units[i].unit_idx];
                html += `<li class="option" id="${catholic_land_units[i].faction}_${catholic_land_units[i].unit_idx}">${catholic_land_units[i].faction} - ${u.type}</li>`;
              }

	      if (catholic_land_units.length == 1) {
		his_self.addMove("destroy_unit_by_index\t"+catholic_land_units[0].faction+"\t"+spacekey+"\t"+"\t"+catholic_land_units[0].unit_idx);
		his_self.addMove("NOTIFY\tZwingli destroys Catholic unit in " + his_self.returnSpaceName(spacekey));
		his_self.endTurn();
		return 0;
	      }

              his_self.updateStatusWithOptions(msg, html);

	      $('.option').off();
	      $('.option').on('click', function () {
	        $('.option').off();
	        let x = $(this).attr("id").split("_");
		his_self.addMove("destroy_unit_by_index\t"+x[0]+"\t"+spacekey+"\t"+"\t"+x[1]);
		his_self.endTurn();            
	      });
            },
            null,
            true,
          );
        }
	return 0;
      },
    }
    deck['044'] = { 
      img : "cards/HIS-044.svg" , 
      name : "Affair of the Placards" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (his_self.isCommitted("cop-debater")) { return 0; } return 1; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("cop-debater")) { return 1; }

	his_self.commitDebater("protestant", "cop-debater", 0); // no bonus

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("NOTIFY\t"+his_self.popup("044"));

	return 1;
      },
    }
    deck['045'] = { 
      img : "cards/HIS-045.svg" , 
      name : "Calvin Expelled" ,
      ops : 1 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

        let obj = {};
        obj.faction = "protestant";

        his_self.excommunicateReformer("calvin-reformer");
	his_self.commitDebater("protestant", "calvin-debater");
	his_self.removeDebater("protestant", "calvin-debater");

	his_self.displaySpace("geneva");

        return 1;
      },
    }
    deck['046'] = { 
      img : "cards/HIS-046.svg" , 
      name : "Calvin's Institutes" ,
      ops : 5 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (!his_self.isCommitted("calvin-debater")) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("calvin-debater")) { return 1; }

	his_self.commitDebater("protestant", "calvin-debater", 0); // no bonus

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("SETVAR\tstate\tevents\tcalvins_institutes\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("protestant_reformation\tprotestant\tfrench");
	his_self.game.queue.push("SETVAR\tstate\tevents\tcalvins_institutes\t1");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("NOTIFY\tCalvin's Institutes");

	return 1;
      },
    }
    deck['047'] = { 
      img : "cards/HIS-047.svg" , 
      name : "Copernicus" ,
      ops : 6 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

        let home_spaces = his_self.returnSpacesWithFilter(
	  function(spacekey) {
	    if (his_self.game.spaces[spacekey].home === faction) {
	      return 1;
	    }
	    return 0;
	  }
	);

	let total = home_spaces.length;
	let count = 0;
	let double_vp = 0;

	for (let i = 0; i < home_spaces.length; i++) {
	  if (his_self.game.spaces[home_spaces[i]].religion === "protestant") { count++; }
	}

	if (count >= (total/2)) {
	  double_vp = 1;
	}

	if (double_vp == 1) {

	  // faction will gain when counted
	  his_self.game.state.events.copernicus = faction;
	  his_self.game.state.events.copernicus_vp = 2;
	  his_self.updateLog(his_self.returnFactionName(faction) + " earns 2 VP from Copernicus");
	  his_self.displayVictoryTrack();

	  return 1;

	} else {

	  his_self.game.state.events.copernicus = faction;
	  his_self.game.state.events.copernicus_vp = 1;
	  his_self.updateLog(his_self.returnFactionName(faction) + " earns 1 VP from Copernicus");
          his_self.displayVictoryTrack();

	  let p = his_self.returnPlayerOfFaction(faction);

	  //
	  // player processes and adds move / ends turn
	  //
	  if (his_self.game.player == p) {

	    let msg = "Which would you prefer?";
    	    let html = '<ul>';
                html += '<li class="option" id="draw">draw 1 card</li>';
                html += '<li class="option" id="discard">protestants discard</li>';
    		html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      his_self.updateStatus("selected...");

	      let action = $(this).attr("id");
   	      $('.option').off();
	      if (action === "draw") {
	        let cardnum = 1;
                his_self.addMove("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
                his_self.addMove("DEAL\t1\t"+p+"\t"+(cardnum));
		his_self.endTurn();
	      } else {
                his_self.addMove("discard_random\tprotestant");
		his_self.endTurn();
	      }
	    });

	  }
	}

	return 0;

      },

    }
    deck['048'] = { 
      img : "cards/HIS-048.svg" , 
      name : "Galleons" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	if (his_self.game.state.galleons['france'] == 0 || his_self.game.state.galleons['england'] == 0 || his_self.game.state.galleons['hapsburg'] == 0) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player == p) {

	    let msg = "Which Faction gets Galleons?";
    	    let html = '<ul>';
	    if (his_self.game.state.galleons['france'] == 0) {
                html += '<li class="option" id="france">France</li>';
 	    }  
	    if (his_self.game.state.galleons['england'] == 0) {
                html += '<li class="option" id="england">England</li>';
 	    }  
	    if (his_self.game.state.galleons['hapsburg'] == 0) {
                html += '<li class="option" id="hapsburg">Hapsburgs</li>';
 	    }  
 		html += '</ul>';

    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {
	      his_self.updateStatus("acknowledge");
	      let action = $(this).attr("id");
	      his_self.addMove("display_new_world");
	      his_self.addMove("SETVAR\tstate\tgalleons\t"+action+"\t1");
	      his_self.endTurn();
	    });
	}

	return 0;

      },
    }
    deck['049'] = { 
      img : "cards/HIS-049.svg" , 
      name : "Huguenot Raiders" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	for (let key in his_self.game.spaces) {

	  let space = his_self.game.spaces[key];

	  if (space.home == "protestant") { if (his_self.game.state.raiders['protestant'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }
	  if (space.home == "england") { if (his_self.game.state.raiders['england'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }
	  if (space.home == "france") { if (his_self.game.state.raiders['france'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { return 1; } } }

	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

	  let valid_for_protestant = false;
	  let valid_for_england    = false;
	  let valid_for_france     = false;

	  for (let key in his_self.game.spaces) {
	    let space = his_self.game.spaces[key];
	    let skip_keys = ["innsbruck","linz","vienna","graz","zurich","basel"];
	    if (space.home == "protestant" || (space.language == "german" && !skip_keys.includes(key))) { if (his_self.game.state.raiders['protestant'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { valid_for_protestant = true; } } }
	    if (space.home == "england") { if (his_self.game.state.raiders['england'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { valid_for_england = true; } } }
	    if (space.home == "france") { if (his_self.game.state.raiders['france'] == 0 && space.ports.length > 0) { if (space.religion == "protestant") { valid_for_france = true; } } }
	  }

 	  let msg = "Choose Faction for Huguenot Raiders?";
          let html = '<ul>';
	  if (valid_for_protestant) {
	    html += '<li class="option" id="protestant">Protestant</li>';
	  }
	  if (valid_for_england) {
	    html += '<li class="option" id="england">England</li>';
	  }
	  if (valid_for_france) {
	    html += '<li class="option" id="france">France</li>';
	  }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
            his_self.game.queue.push("SETVAR\tstate\traiders\t"+action+"\t1");
            his_self.game.queue.push("NOTIFY\tHuguenot Raiders active for "+his_self.returnFactionName(action));
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " selecting Raiders");
	}

	return 0;
      },
    }
    deck['050'] = { 
      img : "cards/HIS-050.svg" , 
      name : "Mercator's Map" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { if (his_self.game.state.may_explore['hapsburg'] == 1 || his_self.game.state.may_explore['france'] == 1 || his_self.game.state.may_explore['england'] == 1) { return 1; } return 0; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Launch Voyage of Discovery for Whom?";
          let html = '<ul>';
          if (his_self.game.state.may_explore['england'] == 1) { 
	    html += '<li class="option" id="england">England</li>';
          }
          if (his_self.game.state.may_explore['france'] == 1) { 
	    html += '<li class="option" id="france">France</li>';
          }
          if (his_self.game.state.may_explore['hapsburg'] == 1) { 
            html += '<li class="option" id="hapsburg">Hapsburg</li>';
          }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

            his_self.addMove("explore\t"+action);
	    his_self.addMove("display_new_world");
            his_self.addMove("SETVAR\tstate\tmay_explore\t"+action+"\t1");
            his_self.addMove("SETVAR\tstate\tevents\tmercators_map\t"+action);
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing Mercator's Map");
	}

	return 0;
      },
    }
    deck['051'] = { 
      img : "cards/HIS-051.svg" , 
      name : "Michael Servetus" ,
      ops : 4 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	his_self.updateLog(his_self.returnFactionName(faction) + " +1 VP from Michael Servetus");
	his_self.game.state.events.michael_servetus = faction;
	his_self.game.queue.push("discard_random\tprotestant");

	return 1;

      }
    }
    deck['052'] = { 
      img : "cards/HIS-052.svg" , 
      name : "Michelangelo" ,
      ops : 4 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let x = his_self.rollDice(6);
	let y = his_self.rollDice(6);

	his_self.updateLog("Papacy rolls "+x+" and "+y);

	his_self.game.queue.push("build_saint_peters_with_cp\t"+(x+y));

        return 1;
          
      },
    }
    deck['053'] = { 
      img : "cards/HIS-053.svg" , 
      name : "Plantations" ,
      ops : 2 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.plantations['england'] == 0) { return 1; }
	if (his_self.game.state.plantations['hapsburg'] == 0) { return 1; } 
	if (his_self.game.state.plantations['france'] == 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Choose Faction for Plantations?";
          let html = '<ul>';
	  if (his_self.game.state.plantations['england'] == 0) {
	    html += '<li class="option" id="england">England</li>';
	  }
	  if (his_self.game.state.plantations['france'] == 0) {
	    html += '<li class="option" id="france">France</li>';
	  }
	  if (his_self.game.state.plantations['hapsburg'] == 0) {
	    html += '<li class="option" id="hapsburg">Hapsburg</li>';
	  }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
            his_self.addMove("SETVAR\tstate\tplantations\t"+action+"\t1");
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " building Plantations");
	}

	return 0;
      },
    }
    deck['054'] = { 
      img : "cards/HIS-054.svg" , 
      name : "Potosi Silver Mines " ,
      ops : 3 ,
      turn : 4 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === p) {

 	  let msg = "Who Discovers the Potosi Silver Mines?";
          let html = '<ul>';
          html += '<li class="option" id="england">England</li>';
          html += '<li class="option" id="france">France</li>';
          html += '<li class="option" id="hapsburg">Hapsburg</li>';
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

	  $('.option').off();
	  $('.option').on('click', function () {

	    $('.option').off();
	    let action = $(this).attr("id");
	    his_self.updateStatus("acknowledge");

	    his_self.addMove("display_new_world");
	    his_self.addMove("SETVAR\tstate\tevents\tpotosi_silver_mines\t"+action);
	    his_self.addMove("NOTIFY\t"+his_self.returnFactionName(action)+" discovers Potosi Silver Mines");
            his_self.endTurn();

	  });
	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " placing Potosi Silver Mines");
	}

	return 0;
      },
    }
    deck['055'] = { 
      img : "cards/HIS-055.svg" , 
      name : "Jesuit Education" ,
      ops : 3 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { if (his_self.game.state.events.society_of_jesus) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {
	if (his_self.game.state.events.society_of_jesus) { his_self.game.queue.push("jesuit_education"); }
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "jesuit_education") {

          his_self.game.queue.splice(qe, 1);

	  if (!his_self.game.state.events.society_of_jesus) {
	    return 1;
	  }

	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select Catholic Space for 1st Jesuit University",
	      function(space) { if (space.religion === "catholic" && space.university != 1) { return 1; } return 0; },
	      function(spacekey) {
	        his_self.game.spaces[spacekey].university = 1;
	        his_self.displaySpace(spacekey);
		his_self.addMove("found_jesuit_university\t"+spacekey);
		let first_spacekey = spacekey;
	
	        his_self.playerSelectSpaceWithFilter(
	          "Select Catholic Space for 2nd Jesuit University",
	          function(space) { if (space.key != first_spacekey && space.religion === "catholic" && space.university != 1) { return 1; } return 0; },
	          function(spacekey) {
		    his_self.updateStatus("building universities...");
	            his_self.game.spaces[spacekey].university = 1;
	            his_self.displaySpace(spacekey);
		    his_self.addMove("found_jesuit_university\t"+spacekey);
		    his_self.endTurn();
		  },
		  null,
		  true
		);

	      },
	      null ,
	      true
	    );

	  } else {
	    his_self.updateStatus("Papacy building Jesuit Universities");
	  }

	  return 0;

        }
        return 1;
      }


    }
    deck['056'] = { 
      img : "cards/HIS-056.svg" , 
      warn : ["protestant"] ,
      name : "Papal Inquistion" ,
      ops : 5 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	if (his_self.isCommitted("caraffe-debater")) { return 1; }

	if (his_self.game.player == his_self.returnPlayerOfFaction("papacy")) {

	  his_self.commitDebater("papacy", "caraffe-debater", 0); // no bonus
	  his_self.addMove("papal_inquisition_target_player");
	  his_self.addMove("papal_inquisition_convert_spaces");
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "papal_inquisition_convert_spaces") {

	  let player = his_self.returnPlayerOfFaction("papacy");
          his_self.game.queue.splice(qe, 1);

	  let count = his_self.countSpacesWithFilter(function(space) {
	    if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0;
	  });
	  if (count == 0) { return 1; }

	  if (his_self.game.player === player) {

	    his_self.playerSelectSpaceWithFilter(
	      "Select Protestant Space to Convert",
	      function(space) { if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0; },
	      function(spacekey) {
		his_self.addMove("convert\t"+spacekey+"\tcatholic");
		if (count == 1) { his_self.endTurn(); return 0; }

	        his_self.playerSelectSpaceWithFilter(
	          "Select Protestant Space to Convert",
	          function(space) { if (space.language === "italian" && space.religion === "protestant") { return 1; } return 0; },
	          function(spacekey) {
		    his_self.addMove("convert\t"+spacekey+"\tcatholic");
		    his_self.endTurn();
		  },
		  null,
		  true
		);
	      },
	      null ,
	      true
	    );

	  } else {
	    his_self.updateStatus("Papal Inquisition - Religion Conversion");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_target_player") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {

 	    let msg = "Choose Player to Reveal Cards:";
            let html = '<ul>';
            html += '<li class="option" id="protestant">Protestant</li>';
            if (his_self.game.players.length > 2) { html += '<li class="option" id="england">England</li>'; }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      his_self.updateStatus("selecting...");
	      let action = $(this).attr("id");

              his_self.addMove("papal_inquisition_card_draw\t"+action);
              his_self.addMove("request_reveal_hand\tpapacy\t"+action);
              his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus("Papal Inquisition - Selecting Target");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_card_draw") {

	  let target = mv[1];
	  let player = his_self.returnPlayerOfFaction("papacy");

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player === player) {

 	    let msg = "Choose Action:";
            let html = '<ul>';
            html += `<li class="option" id="draw">draw ${target} card</li>`;
            html += '<li class="option" id="recover">recover from discard pile</li>';
            html += '<li class="option" id="debate">initiate debate +2 dice</li>';
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "draw") {
		his_self.updateStatus("drawing card...");
                his_self.addMove("pull_card\tpapacy\t"+target);
                his_self.endTurn();
	      }
	      if (action === "recover") {
		his_self.updateStatus("recovering discard...");
                his_self.addMove("papal_inquisition_recover_discard");
                his_self.endTurn();
	      }
	      if (action === "debate") {
		his_self.updateStatus("commencing debate...");
                his_self.addMove("papal_inquisition_debate");
                his_self.endTurn();
	      }
	    });
	  } else {
	    his_self.updateStatus("Papal Inquisition - Follow-Up Action");
	  }

	  return 0;

	}

        if (mv[0] == "papal_inquisition_recover_discard") {

	  let player = his_self.returnPlayerOfFaction("papacy");

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player == player) {

            let msg = "Retrieve Card from Discard Pile: ";
            let html = '<ul>';
            for (let key in his_self.game.deck[0].discards) {
              html += `<li class="option" id="${key}">${his_self.game.deck[0].cards[key].name}</li>`;
            }
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {
              $('.option').off();
              let card = $(this).attr("id");
	      his_self.updateStatus("recovering...");
              his_self.addMove("papal_inquisition_recover_card\t"+card);
              his_self.endTurn();
            });

	  } else {
	    his_self.updateStatus("Papal Inquisition - Recovering Card");
	  }

	  return 0;
        }

        if (mv[0] == "papal_inquisition_recover_card") {

          let card = mv[1];

          if (his_self.game.deck[0].discards[card]) {

            let p = his_self.returnPlayerOfFaction("papacy");

            //
            // player returns to hand
            //
            if (his_self.game.player === p) {
              let fhand_idx = his_self.returnFactionHandIdx(p, faction);
              his_self.game.deck[0].fhand[fhand_idx].push(card);
            }

            //
            // everyone removes from discards
            //
            delete his_self.game.deck[0].discards[card];

          }

	  return 1;

	}

        if (mv[0] == "papal_inquisition_debate") {

          his_self.game.queue.splice(qe, 1);
	  his_self.game.state.events.papal_inquisition_debate_bonus = 1;
	  his_self.game.queue.push("SETVAR\tstate\tevents\tpapal_inquisition_debate_bonus\t0");
	  his_self.game.queue.push("papal_inquisition_call_theological_debate");
	  return 1;

	}
        if (mv[0] == "papal_inquisition_call_theological_debate") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("papacy");

	  if (his_self.game.player == player) {
	    his_self.playerCallTheologicalDebate(his_self, player, "papacy");
	  } else {
	    his_self.updateStatus("Papacy calling Theological Debate");
	  }
 
	  return 0;

        }

      return 1;

      }
    }
    deck['057'] = { 
      img : "cards/HIS-057.svg" , 
      name : "Philip of Hesse's Bigamy" ,
      ops : 2 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	his_self.game.queue.push("philip_of_hesse_bigamy");
	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "remove_philip_of_hesse") {

	  let ph = his_self.returnSpaceOfPersonage("protestant", "philip-hesse");

	  his_self.removeArmyLeader("protestant", ph, "philip-hesse");
	  his_self.displaySpace(ph);
	  his_self.updateLog("Philip of Hesse removed from game");
          his_self.game.queue.splice(qe, 1);

	  return 1;

	}

        if (mv[0] == "philip_of_hesse_bigamy") {

          his_self.game.queue.splice(qe, 1);
	  let player = his_self.returnPlayerOfFaction("protestant");
	  let ph = his_self.returnSpaceOfPersonage("protestant", "philip-hesse");

	  if (his_self.game.player === player) {

 	    let msg = "Choose Action: ";
            let html = '<ul>';
            html += '<li class="option" id="discard">discard card</li>';

	    let adequate_cards_to_discard = false;
            let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, "protestant");
            for (let i = 0; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	      if (parseInt(his_self.game.deck[0].fhand[fhand_idx][i]) > 7) { adequate_cards_to_discard = true; } 
	    };

            if (ph && adequate_cards_to_discard == true) { html += '<li class="option" id="hesse">remove Philip of Hesse</li>'; }
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {

	      $('.option').off();
	      let action = $(this).attr("id");

	      if (action === "hesse") {
		his_self.addMove("remove_philip_of_hesse");
		his_self.endTurn();
	      }

	      if (action === "discard") {
		his_self.addMove("discard_random\tprotestant");
		his_self.endTurn();
	      }

	    });
	  } else {
	    his_self.updateStatus("Protestants - Philip of Hesse's Bigamy");
	  }

	  return 0;

	}

        return 1;

      }
    }
    deck['058'] = { 
      img : "cards/HIS-058.svg" , 
      warn : ["protestant"] ,
      name : "Spanish Inquisition" ,
      ops : 5 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let count = his_self.countSpacesWithFilter(function(space) {
	      if (space.religion == "protestant" && space.language == "spanish") {
		return 1;
	      }
	      return 0;
	  });

          if (count > 0) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select First Space to Convert", 
	      function(space) {
	        if (space.religion == "protestant" && space.language == "spanish") {
		  return 1;
	        }
	        return 0;
	      },

	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
	        let first_choice = space.key;
	        let spaces = his_self.returnSpacesWithFilter(
          	  function(spacekey) {
		    let s2 = his_self.game.spaces[spacekey];
	            if (s2.religion == "protestant" && s2.language == "spanish" && s2.key != first_choice) {
		      return 1;
	            }
	            return 0;
	  	  }
	        );

	        if (spaces.length == 0) {
		  his_self.addMove("spanish_inquisition_secondary\t"+faction);
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
		  his_self.endTurn();
		  return 0;
	        }

                if (count > 1) {
	          his_self.playerSelectSpaceWithFilter(

	            "Select Second Space to Convert", 

	            function(space2) {
	              if (s2.religion == "protestant" && s2.language == "spanish" && s2.key != first_choice) {
		        return 1;
	              }
	              return 0;
		    },

	            function(second_choice) {
		      his_self.addMove("spanish_inquisition_secondary\t"+faction);
		      his_self.addMove("convert\t"+second_choice+"\tcatholic");
		      his_self.addMove("convert\t"+first_choice+"\tcatholic");
		      his_self.endTurn();
	            },
		    null , 
		    true 
	          );
	  	} else {
		  his_self.addMove("spanish_inquisition_secondary\t"+faction);
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
	          his_self.endTurn();
	        }
	      },
	      null ,
	      true 
	    );
	  } else {
	    his_self.updateStatus("No acceptable Protestant targets for Spanish Inquisition");
	    his_self.addMove("spanish_inquisition_secondary\t"+faction);
	    his_self.endTurn();
	  }
        } else {
          his_self.updateStatus("Papacy playing "+his_self.popup("067"));
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "show_hand_and_save") {

          let faction_taking = mv[1];
          let faction_giving = mv[2];

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player == p2) {
            let fhand_idx = his_self.returnFactionHandIdx(p2, faction_giving);
            his_self.addMove("share_hand_and_save\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;

        }

        if (mv[0] === "share_hand_and_save") {

          let faction_taking = mv[1];
          let faction_giving = mv[2];
          let cards = JSON.parse(mv[3]);

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);

          if (his_self.game.player == p1) {
            for (let i = 0; i < cards.length; i++) {
	      his_self.game.state.pulled_cards.push({ faction : faction_giving , card : cards[i] });
            }
          }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


        if (mv[0] === "select_from_saved_and_discard") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  let protcards = [];
	  let engcards = [];
	  let pcards = [];
	  for (let z = 0; z < his_self.game.state.pulled_cards.length; z++) { 
	    if (his_self.game.state.pulled_cards[z].faction == "protestant") {
	      protcards.push(his_self.game.state.pulled_cards[z].card);
	    }
	    if (his_self.game.state.pulled_cards[z].faction == "england") {
	      engcards.push(his_self.game.state.pulled_cards[z].card);
	    }
	    let c = his_self.game.state.pulled_cards[z].card;
	    let d = his_self.returnDeck(true);
	    if (d[c]) {
	      if (d[c].type != "mandatory" && parseInt(c) > 9) {
	        pcards.push(c);
	      } 
	    }
	  }

	  if (his_self.game.player == p) {

	    let prothtml = "";
	    let enghtml = "";

	    for (let z = 0; z < protcards.length; z++) {
	      if (z > 0) { prothtml += ", "; }
	      prothtml += his_self.popup(protcards[z]);
	    }
	    for (let z = 0; z < engcards.length; z++) {
	      if (z > 0) { enghtml += ", "; }
	      enghtml += his_self.popup(protcards[z]);
	    }

	    his_self.updateLog("England hand: " + enghtml);
	    his_self.updateLog("Protestant hand: " + prothtml);

	    if (pcards.length == 0) {
	      his_self.updateLog("No cards available to discard...");
	      his_self.endTurn();
	      return;
	    }

	    his_self.playerSelectCardFromArrayWithFilter(
	      "Select Card to Discard",
	      pcards,
	      function(card) {
	        return 1;
	      },
	      function(card) {
	        let f = "";
	        for (let i = 0; i < his_self.game.state.pulled_cards.length; i++) {
	          if (card === his_self.game.state.pulled_cards[i].card) { f = his_self.game.state.pulled_cards[i].faction; }
	        }
	        his_self.game.state.pulled_cards = [];
                his_self.addMove("discard\t"+f+"\t"+card);
	        his_self.endTurn();
	      }
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " giving card to Papacy");
	  }

          return 0;

	}


        if (mv[0] === "spanish_inquisition_secondary") {

          his_self.game.queue.splice(qe, 1);

          let faction = mv[1];
          let p = his_self.returnPlayerOfFaction(faction);
          let hp = his_self.returnPlayerOfFaction("hapsburg");

	  // debate piggy-backs off papal inquisition
          his_self.game.queue.push("papal_inquisition_call_theological_debate");
          his_self.game.queue.push("hand_to_fhand\t1\t"+hp+"\t"+"hapsburg"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+hp+"\t"+1);
	  his_self.game.queue.push("select_from_saved_and_discard\thapsburg");
	  his_self.game.queue.push("show_hand_and_save\thapsburg\tengland");
	  his_self.game.queue.push("show_hand_and_save\thapsburg\tprotestant");
	  his_self.game.state.pulled_cards = [];

	  return 1;
        }

	return 1;
      },
    }
    deck['059'] = { 
      img : "cards/HIS-059.svg" , 
      name : "Lady Jane Grey" ,
      ops : 3 ,
      turn : 6 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.england_changed_rulers_this_turn != 0) { 
	  let expected = 0;
	  if (!his_self.game.deck[0].discards['003']) { let expected = 1; }
	  if (his_self.game.state.cards_left["england"] > expected) { return 1; }
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p1 = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player == p1) {
          his_self.addMove("lady_jane_grey_papacy_discard\t"+faction);
          his_self.addMove("hand_to_fhand\t1\t"+p1+"\t"+faction+"\t1");
          his_self.addMove("DEAL\t1\t"+p1+"\t"+1);
          his_self.addMove("pull_card\t"+faction+"\tengland");
          his_self.endTurn();
	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "lady_jane_grey_papacy_discard") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  if (his_self.game.player == p) {

 	      his_self.playerFactionSelectCardWithFilter(
	        faction,
	        "Select Card to Give Away",
	        function(card) {
                  let fhand_idx = his_self.returnFactionHandIdx(p, faction);
		  let handlen = his_self.game.deck[0].fhand[fhand_idx].length;
		  let card1 = his_self.game.deck[0].fhand[fhand_idx][handlen-1];
		  let card2 = his_self.game.deck[0].fhand[fhand_idx][handlen-2];
	          if (card === card1 || card === card2) { return 1; }
		  return 0;
	        },
	        function(card) {

                  let msg = "Give " + his_self.popup(card) + " to Which Faction?";
                  let html = '<ul>';
                  html += `<li class="option" id="papacy">Papacy</li>`;
                  html += `<li class="option" id="protestant">Protestant</li>`;
   	          html += '</ul>';

       	          his_self.updateStatusWithOptions(msg, html);

	           $('.option').off();
	           $('.option').on('click', function () {

	             let target = $(this).attr("id");
	             $('.option').off();

                     his_self.updateStatus("giving card...");
                     his_self.addMove("give_card\t"+target+"\t"+faction+"\t"+card);
	             his_self.endTurn();

	           });

	       }
	     );

	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("059"));
	  }

	  return 0;
	}

	return 1;
      },
    }
    deck['060'] = { 
      img : "cards/HIS-060.svg" , 
      name : "Maurice of Saxony" ,
      ops : 4 ,
      turn : 6 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction="") {

        let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
        let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");

	if (
	  (his_self.game.player == his_self.returnPlayerCommandingFaction("hapsburg") && pms != "") ||
	  (his_self.game.player == his_self.returnPlayerCommandingFaction("protestant") && hms != "")
	) { return 1; }

	return 0; 

      } ,
      onEvent : function(his_self, faction) {

        if (faction == "papacy") { faction = "hapsburg"; }

	if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

  	  his_self.playerSelectSpaceWithFilter(
	    "Select Fortified Space for Maurice of Saxony" ,
	    function(space) {
	      if (his_self.isSpaceControlled(space.key, faction) && his_self.isSpaceFortified(space.key)) {
	        return 1;
	      }
	      return 0;
	    },
	    function(spacekey) {
	      his_self.addMove("maurice_of_saxony\t"+faction+"\t"+spacekey);
	      his_self.endTurn();
	    },
	    null,
	    true
	  );

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("060"));
	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "maurice_of_saxony") {

	  let faction = mv[1];
	  let spacekey = mv[2];

          for (let i = 0; i < his_self.game.players.length; i++) {
            let p = his_self.game.state.players_info[i];
            for (let z = 0; z < p.captured.length; z++) {
	      if (p.captured[z].type == "maurice-of-saxony") {
		p.captured[z].splice(z, 1);
	      }
	    }
          }

          his_self.game.queue.splice(qe, 1);
          let ms = his_self.returnSpaceOfPersonage(his_self.game.state.events.maurice_of_saxony, "maurice-of-saxony");

	  if (his_self.game.state.events.maurice_of_saxony != "" || ms != "") {

	    let current_owner = his_self.game.state.events.maurice_of_saxony;
            let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
            let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");
	    if (pms) { ms = pms; current_owner = "protestant"; }
	    if (hms) { ms = hms; current_owner = "hapsburg"; }

	    let loop_length = his_self.game.spaces[ms].units[current_owner].length;
	    for (let i = 0; i < loop_length; i++) {
	      let u = his_self.game.spaces[ms].units[current_owner][i];
	      if (u.type === "mercenary" || u.type === "maurice-of-saxony") {
	        his_self.game.spaces[spacekey].units[faction].push(u);
	        his_self.game.spaces[ms].units[current_owner].splice(i, 1);
		i--;
	        loop_length = his_self.game.spaces[ms].units[current_owner].length;
		if (u.type === "maurice-of-saxony") {
		  u.img = "Maurice_Hapsburg.svg";
		  if (faction === "protestant") {
		    u.img = "Maurice_Protestant.svg";
		  }
		}
	      }
	    }

	  } else {

	    his_self.addArmyLeader(faction, spacekey, "maurice-of-saxony");

	    let current_owner = "protestant";
            let pms = his_self.returnSpaceOfPersonage("protestant", "maurice-of-saxony");
            let hms = his_self.returnSpaceOfPersonage("hapsburg", "maurice-of-saxony");
	    if (pms) { ms = pms; current_owner = "protestant"; }
	    if (hms) { ms = hms; current_owner = "hapsburg"; }

	    let ms_idx = his_self.returnIndexOfPersonageInSpace(faction, "maurice-of-saxony", ms);
	    let u = his_self.game.spaces[ms].units[faction][ms_idx];
	    u.img = "Maurice_Hapsburg.svg";
	    if (faction === "protestant") { u.img = "Maurice_Protestant.svg"; }

	  }
	
	  his_self.game.state.events.maurice_of_saxony = faction;
	  return 1;

	}

	return 1;
      }
    }
    deck['061'] = { 
      img : "cards/HIS-061.svg" , 
      warn : ["protestant"] ,
      name : "Mary Defies Council" ,
      ops : 1 ,
      turn : 7 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
	his_self.game.queue.push("catholic_counter_reformation\tpapacy\tenglish");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['062'] = { 
      img : "cards/HIS-062.svg" , 
      name : "Book of Common Prayer" ,
      warn : ["papacy"] ,
      ops : 2 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { if (!his_self.isDebaterCommitted("cranmer-debater")) { return 1; } return 0; } ,
      onEvent : function(his_self, faction) {

	let d = his_self.rollDice(6);

	his_self.game.queue.push("NOTIFY\t"+his_self.popup("062")+" rolls "+d);

        if (d == 3 || d == 4) {
	  his_self.game.queue.push("player_add_unrest\t"+faction+"\tenglish\tcatholic");
	}        
        if (d == 5) {
	  his_self.game.queue.push("player_add_unrest\t"+faction+"\tenglish\tcatholic");
	} 
        if (d == 6) {
	  for (let spacekey in his_self.game.spaces) {
	    if (his_self.game.spaces[spacekey].language == "english" && his_self.game.spaces[spacekey].religion == "catholic") {
	      his_self.game.queue.push("unrest\t"+spacekey);
	    }
          }
	}

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("commit\tengland\tcranmer-debater");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    let dom_img = "cards/HIS-063.svg";
    if (this.game.players.length == 2) { dom_img = "cards/HIS-063-2P.svg"; }
    if (parseInt(this.game.options['game-wizard-players-select']) == 2) {
      dom_img = "cards/HIS-063-2P.svg";
    }
    deck['063'] = { 
      img : dom_img , 
      name : "Dissolution of the Monasteries" ,
      ops : 4 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {
	
	if (his_self.game.players.length > 2) {
	  let eng = his_self.returnPlayerCommandingFaction("england");
	  his_self.game.queue.push("hand_to_fhand\t1\t"+eng+"\t"+"england"+"\t1"); // 1 = overlay
          his_self.game.queue.push(`DEAL\t1\t${eng}\t2`);
        }

	his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
	his_self.game.queue.push("protestant_reformation\tprotestant\tenglish");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	if (his_self.game.players.length == 2) {
	  his_self.game.queue.push("discard_random\tpapacy");
	}

	return 1;
      }
    }
    deck['064'] = { 
      img : "cards/HIS-064.svg" , 
      name : "Pilgrimage of Grace" ,
      ops : 3 ,
      turn : 0 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; } ,
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player === player) {

	    let already_selected = [];

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

	    his_self.playerSelectSpaceWithFilter(
	      "Select English Space to throw into Unrest" ,
	      function(space) { if (!already_selected.includes(space.key) && space.home === "england"){ return 1;} return 0; } ,
	      function(spacekey) {

	        already_selected.push(spacekey);
		his_self.game.spaces[spacekey].unrest = 1;
		his_self.displaySpace(spacekey);
		his_self.addMove("unrest\t"+spacekey);

		his_self.endTurn();

	   }, null, true);
	   }, null, true);
	   }, null, true);
	   }, null, true);
	   }, null, true);

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("064"));
	}

	   return 0;
      },
    }
    deck['065'] = { 
      img : "cards/HIS-065.svg" , 
      warn : ["papacy"] ,
      name : "A Mighty Fortress" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.isDebaterCommitted("luther-debater")) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let player = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
	his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.game.queue.push("commit\tprotestant\tluther-debater");

	return 1;
      },
    }
    deck['066'] = { 
      img : "cards/HIS-066.svg" , 
      name : "Akinji Raiders" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	let enemies = his_self.returnEnemies("ottoman");
	let neighbours = [];
	let valid_spaces_with_cavalry = [];
	let valid_spaces_with_enemies = [];
	let valid_target_factions = [];
	let spaces = his_self.returnSpacesWithFilter(
	  function(spacekey) {
	    if (his_self.game.spaces[spacekey].units["ottoman"].length > 0) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units["ottoman"].length; z++) {
	        if (his_self.game.spaces[spacekey].units["ottoman"][z].type === "cavalry") {
	          if (his_self.isSpaceControlled(spacekey, "ottoman")) {
		    return 1;
		  }
	        }
	      }
	    }
	  }
        );

	//
	// 
	//
	for (let i = 0; i < spaces.length; i++) {
	  valid_spaces_with_cavalry.push(spaces[i]);
	}

	//
	// spaces contains all spaces with Ottoman Cavalry
	//
	// two hops !
	//
	for (let i = 0; i < spaces.length; i++) {
	  let s = his_self.game.spaces[spaces[i]];
	  for (let ii = 0; ii < s.neighbours.length; ii++) {
	    if (his_self.isSpaceControlled(s.neighbours[ii], "ottoman")) {
	      if (!neighbours.includes(s.neighbours[ii])) {
	        neighbours.push(s.neighbours[ii]);
	      }
	    } else {
	      for (let iii = 0; iii < enemies.length; iii++) {
	        if (his_self.isSpaceControlled(s.neighbours[ii], enemies[iii])) {
		  valid_target_factions.push(enemies[iii]);
	          valid_spaces_with_enemies.push(neighbours[ii]);
	        }
	      }
	    }
	  }
	}
	for (let i = 0; i < neighbours.length; i++) {
	  let s = his_self.game.spaces[neighbours[i]];
	  for (let ii = 0; ii < s.neighbours.length; ii++) {
	    for (let iii = 0; iii < enemies.length; iii++) {
	      if (his_self.isSpaceControlled(s.neighbours[ii], enemies[iii])) {
		valid_target_factions.push(enemies[iii]);
	        valid_spaces_with_enemies.push(neighbours[ii]);
	      }
	    }
	  }
	}

	if (valid_spaces_with_enemies.length > 0) { return 1; }

	return 0;

      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerCommandingFaction(faction);
	if (his_self.game.player != p) { return 0; }

	let enemies = his_self.returnEnemies("ottoman");
	let neighbours = [];
	let valid_spaces_with_cavalry = [];
	let valid_spaces_with_enemies = [];
	let valid_target_factions = [];
	let spaces = his_self.returnSpacesWithFilter(
	  function(spacekey) {
	    if (his_self.game.spaces[spacekey].units["ottoman"].length > 0) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units["ottoman"].length; z++) {
	        if (his_self.game.spaces[spacekey].units["ottoman"][z].type === "cavalry") {
	          if (his_self.isSpaceControlled(spacekey, "ottoman")) {
		    return 1;
		  }
	        }
	      }
	    }
	  }
        );

	for (let i = 0; i < spaces.length; i++) {
	  valid_spaces_with_cavalry.push(spaces[i]);
	}

	//
	// two hops !
	//
	for (let i = 0; i < spaces.length; i++) {
	  let s = his_self.game.spaces[spaces[i]];
	  for (let ii = 0; ii < s.neighbours.length; ii++) {
	    if (his_self.isSpaceControlled(s.neighbours[ii], "ottoman")) {
	      if (!neighbours.includes(s.neighbours[ii])) {
	        neighbours.push(s.neighbours[ii]);
	      }
	    } else {
	      for (let iii = 0; iii < enemies.length; iii++) {
	        if (his_self.isSpaceControlled(s.neighbours[ii], enemies[iii])) {
		  valid_target_factions.push(enemies[iii]);
	          valid_spaces_with_enemies.push(neighbours[ii]);
	        }
	      }
	    }
	  }
	}
	for (let i = 0; i < neighbours.length; i++) {
	  let s = his_self.game.spaces[neighbours[i]];
	  for (let ii = 0; ii < s.neighbours.length; ii++) {
	    if (his_self.isSpaceControlled(s.neighbours[ii], "ottoman")) {
	      if (!neighbours.includes(s.neighbours[ii])) {
		neighbours.push(s.neighbours[ii]);
	      }
	    } else {
	      for (let iii = 0; iii < enemies.length; iii++) {
	        if (his_self.isSpaceControlled(s.neighbours[ii], enemies[iii])) {
		  valid_target_factions.push(enemies[iii]);
	          valid_spaces_with_enemies.push(neighbours[ii]);
	        }
	      }
	    }
	  }
	}

        let msg = "Steal Random Card from Which Faction?";
        let html = '<ul>';
	let options_provided = [];
        for (let i = 0; i < valid_target_factions.length; i++) {
	   if (!options_provided.includes(valid_target_factions[i])) {
	     options_provided.push(valid_target_factions[i]);
             html += `<li class="option" id="${valid_target_factions[i]}">${valid_target_factions[i]}</li>`;
	  }
	}
	html += '</ul>';

    	his_self.updateStatusWithOptions(msg, html);

	$('.option').off();
	$('.option').on('click', function () {

	  his_self.updateStatus("submitting...");
	  let action = $(this).attr("id");
	  his_self.addMove("pull_card\tottoman\t"+action);
          his_self.endTurn();

	});

        return 0;
      }
    }
    deck['067'] = { 
      img : "cards/HIS-067.svg" , 
      warn : ["protestant"] ,
      name : "Anabaptists" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let count = his_self.countSpacesWithFilter(function(space) {
	      if (space.religion == "protestant" && his_self.isOccupied(space) == 0 && !his_self.isElectorate(space)) {
		return 1;
	      }
	      return 0;
	  });

          if (count > 0) {
	    his_self.playerSelectSpaceWithFilter(
	      "Select First Space to Convert", 
	      function(space) {
	        if (space.religion == "protestant" && his_self.isOccupied(space) == 0 && !his_self.isElectorate(space)) {
		  return 1;
	        }
	        return 0;
	      },

	      function(spacekey) {
	        let space = his_self.game.spaces[spacekey];
	        let first_choice = space.key;
	        let spaces = his_self.returnSpacesWithFilter(
          	  function(spacekey) {
		    let s2 = his_self.game.spaces[spacekey];
	            if (s2.religion == "protestant" && his_self.isOccupied(s2.key) == 0 && !his_self.isElectorate(s2.key) && s2.key != first_choice) {
		      return 1;
	            }
	            return 0;
	  	  }
	        );

	        if (spaces.length == 0) {
		  his_self.addMove("convert\t"+first_choice+"\tcatholic");
		  his_self.endTurn();
		  return 0;
	        }

                if (count > 1) {
	          his_self.playerSelectSpaceWithFilter(

	            "Select Second Space to Convert", 

	            function(space2) {
	              if (space2.key !== first_choice && space2.religion == "protestant" && his_self.isOccupied(space2.key) == 0 && !his_self.isElectorate(space2.key)) {
		        return 1;
	              }
	              return 0;
		    },

	            function(second_choice) {
		      his_self.addMove("convert\t"+second_choice+"\tcatholic");
		      his_self.addMove("convert\t"+first_choice+"\tcatholic");
		      his_self.endTurn();
	            },
		    null , 
		    true 
	          );
	  	} else {
	          his_self.updateStatus("No acceptable targets for Anabaptists");
	          his_self.endTurn();
	        }
	      },
	      null ,
	      true 
	    );
	  } else {
	    his_self.updateStatus("No acceptable targets for Anabaptists");
	    his_self.endTurn();
	  }
        } else {
          his_self.updateStatus("Papacy playing "+his_self.popup("067"));
        }
        return 0;
      },
    }
    deck['068'] = { 
      img : "cards/HIS-068.svg" , 
      name : "Andrea Doria" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("genoa");
	if (faction == "ottoman" || faction == "protestant" || faction == "england") { return 0; }
	if (faction !== f) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("genoa");
	his_self.deactivateMinorPower(f, "genoa");
	his_self.activateMinorPower(faction, "genoa");
	return 1;
      },
    }
    deck['069'] = { 
      img : "cards/HIS-069.svg" , 
      name : "Auld Alliance" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("scotland");
        if (faction === "france") {
	  return 1;
	}
        if (faction === "england" && f !== "") {
	  return 1;
	} 
	return 0;
      },
      onEvent : function(his_self, faction) {
        let f = his_self.returnAllyOfMinorPower("scotland");
	if (faction === "england") {
 	  if (f !== "") {
	    his_self.deactivateMinorPower(f, "scotland");
	  }
	}
	if (faction === "france") {
	  if (f == "" || f == "scotland") {
	    his_self.activateMinorPower(faction, "scotland");
	  } else {
	    if (f === "france") {

	      let p = his_self.returnPlayerOfFaction("france");
	      if (p === his_self.game.player) {

	        //
	        // add upto 3 new French regulars in any Scottishhome space under French control that isnot under siege.
	        //
   	        his_self.playerSelectSpaceWithFilter(

	  	  "Select Unbesieged Scottish Home Space Under French Control", 

		  function(space) {
		    if (space.home == "scotland") {
		      if (his_self.isSpaceControlled(space.key, "france") || his_self.isSpaceControlled(space.key, "scotland")) {
		        if (!space.besieged) {
		          return 1;
		        }
		      }
		    }
		  },

		  function(spacekey) {
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
	            his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
		    his_self.endTurn();
		  }
	        );

		return 0;

	      } else {
		return 0;
	      }
	    } else {
	      his_self.deactivateMinorPower(f, "scotland");
	    }
	  }
	}
	return 1;
      },
    }
    deck['070'] = { 
      img : "cards/HIS-070.svg" , 
      name : "Charles Bourbon" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
        if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league != 1) { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (p == his_self.game.player) {

	  his_self.playerSelectSpaceWithFilter(

	    "Select Unbesieged Space You Control",

	    function(space) {
	      if (his_self.game.state.events.schmalkaldic_league == 0) { if (space.type == "electorate") { return 0; } } 
	      // 2P must be German or Iralian space
	      if (his_self.game.players.length == 2) { if (space.language != "italian" && space.language != "german") { return 0; } }
	      if (space.besieged) { return 0; }
	      if (his_self.isSpaceControlled(space, faction)) { return 1; }
	      // if at war with France, unoccupied near Lyon is OK
	      if (his_self.areEnemies(faction, "france")) {
	        if (space.neighbours.includes("lyon") && his_self.isUnoccupied(space)) { return 1; }
	      }
	      return 0;
	    },

	    function(spacekey) {
	      let space = his_self.game.spaces[spacekey];
	      his_self.addMove("add_army_leader\t"+faction+"\t"+spacekey+"\t"+"renegade");
	      if (spacekey === "avignon" || spacekey === "grenoble" || spacekey === "geneva" || spacekey === "dijon" || spacekey === "orleans" || spacekey === "limoges") {
                his_self.addMove("control\t"+faction+"\t"+spacekey);
	      }
	      if (faction != "ottoman") {
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
	      } else {
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
	      }
	      his_self.endTurn();
	    },

	    null,

	    true 

	  );
	} else {
	  his_self.updateStatus(his_self.popup("070") + " entering play");
	}

	return 0;
      },
    }
    let csr_img = "cards/HIS-071.svg";
    if (this.game.players.length == 2) { csr_img = "cards/HIS-071-2P.svg"; }
    deck['071'] = { 
      img : csr_img , 
      name : "City State Rebels" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.players.length == 2) {
	  if (his_self.game.state.events.schmalkaldic_league == 1) { 
	    for (let key in his_self.game.spaces) {
	      let space = his_self.game.spaces[key];
              if (his_self.game.players.length == 2 && space.type == "electorate" && space.political == "hapsburg") { return 1; }
	      if (key == "metz" && !his_self.isSpaceControlled("metz", "independent")) { return 1; }
	      if (his_self.game.spaces[key].language == "italian" || his_self.game.spaces[key].language == "german") {
		if (his_self.game.spaces[key].type == "key") {
		  if (!his_self.isSpaceControlled(key, his_self.game.spaces[key].home)) { return 1; }
		}
	      }
	    }
	  } else {
	    for (let spacekey in his_self.game.spaces) {
	      let space = his_self.game.spaces[spacekey];
	      if (space.type == "key" && space.home === "independent" && (space.key == "metz" || space.language == "german" || space.language == "italian") && (space.political !== space.home && space.political !== "" && space.political)) { return 1; }
	    }
	  }
	  return 0;
	}
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (p == his_self.game.player) {

	  his_self.playerSelectSpaceWithFilter(

	    "Select Occupied Territory",

	    function(space) {

	      if (his_self.isSpaceBesieged(space.key)) { return 0; }

	      //
	      // 2P game - may be played against electorate under Hapsburg Control
	      //
	      if (his_self.game.players.length == 2) {
if (space.key == "milan") {
  console.log("#");
  console.log("#");
  console.log("#");
  console.log("MILAN CSR: " + JSON.stringify(space));
}
		if (his_self.game.state.events.schmalkaldic_league == 1) { if (space.type == "electorate" && space.political == "hapsburg") { return 1; } }
	        if (space.type == "key" && space.home === "independent" && (space.key == "metz" || space.language == "german" || space.language == "italian") && (space.political !== space.home && space.political !== "" && space.political)) { return 1; }
	        return 0;
	      }

	      if (space.type == "key" && space.home === "independent" && (space.political !== space.home && space.political !== "" && space.political)) { return 1; }

	      if (space.home !== space.political && space.political !== "" && space.type == "key") {
		if (!space.besieged) {
	          if (!his_self.areAllies(space.home, space.political)) { 
		    if (space.home !== "" && space.political !== "") { return 1; }
		  }
	        }
	      }

	      //
	      // electorate under hapsburg control
	      //
	      if (his_self.game.state.events.schmalkaldic_league == 1 && his_self.game.players.length == 2) {
		if (his_self.isElectorate(space.key)) {
		  if (his_self.isSpaceControlled(space.key, "hapsburg")) { return 1; }
		}
	      }

	      return 0;
	    },

	    function(spacekey) {
	      his_self.updateStatus("selected");
	      his_self.addMove("city-state-rebels\t"+faction+"\t"+spacekey);
	      his_self.endTurn();
	    },

	    null,

	    true

	  );
	} else {
	  his_self.updateStatus("Opponent playing " + his_self.popup("071"));
	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "city-state-rebels") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let respondent = his_self.returnFactionControllingSpace(spacekey);

          his_self.game.queue.splice(qe, 1);


	  let hits = 0;
	  for (let i = 0; i < 5; i++) {
	    let roll = his_self.rollDice(6);
            his_self.updateLog(` ... roll ${5-i}: ${roll}`);
	    if (roll >= 5) {
	      hits++;
	    }
	  }

          his_self.updateLog(` ... hits: ${hits}`);
          his_self.updateLog(his_self.returnFactionName(faction) + " plays " + his_self.popup("071") + " against " + his_self.returnSpaceName(spacekey));

	  let p = his_self.returnPlayerCommandingFaction(respondent);
	  if (p == 0) {
	    for (let z = 0, assigned_hits = 0; assigned_hits < hits && z < his_self.game.spaces[spacekey].units[respondent].length; z++) {
	      try {
	        if (his_self.game.spaces[spacekey].units[respondent][z].type == "regular") {
		  his_self.game.spaces[spacekey].units[respondent].splice(z, 1);
		  z--;
	      } } catch (err) {
	      }
	    }
	    his_self.game.queue.push("finish-city-state-rebels\t"+faction+"\t"+respondent+"\t"+spacekey);
	    return 1;
	  }
	  if (his_self.game.player == p) {
	    his_self.addMove("finish-city-state-rebels\t"+faction+"\t"+respondent+"\t"+spacekey);
	    his_self.playerAssignHits(respondent, spacekey, hits, 1);
	  }
	  
	  return 0;
        }


	if (mv[0] === "finish-city-state-rebels") {

          his_self.game.queue.splice(qe, 1);

	  let faction    = mv[1];
	  let respondent = mv[2];
	  let spacekey   = mv[3];
	  let space      = his_self.game.spaces[spacekey];

	  //
	  // do land or naval units remain
	  //
	  let anything_left = 0; 
	  for (let i = 0; i < space.units[respondent].length; i++) {
	    let u = space.units[respondent][i];
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
	      anything_left = 1;
	    }
	  }

	  if (!anything_left) {
            for (let i = 0; i < space.units[faction].length; i++) {
              his_self.captureLeader(faction, respondent, spacekey, space.units[faction][i]);
              space.units[faction].splice(i, 1);
              i--;
            }

	    let who_gets_control = space.home;

	    //
	    // 2P includes electorates
	    //
	    if (spacekey == "mainz") { space.home == "protestant"; who_gets_control = "protestant"; }
	    if (spacekey == "cologne") { space.home == "protestant"; who_gets_control = "protestant"; }
	    if (spacekey == "trier") { space.home == "protestant"; who_gets_control = "protestant"; }
	    if (spacekey == "augsburg") { space.home == "protestant"; who_gets_control = "protestant"; }
	    if (spacekey == "wittenberg") { space.home == "protestant"; who_gets_control = "protestant"; }
	    if (spacekey == "brandenburg") { space.home == "protestant"; who_gets_control = "protestant"; }

	    his_self.controlSpace(who_gets_control, space.key);
            his_self.addRegular(space.home, space.key, 1);
          }

	  his_self.displaySpace(spacekey);

	  return 1;
	}

	return 1;

      },
    }
    deck['072'] = { 
      img : "cards/HIS-072.svg" , 
      name : "Cloth Prices Fluctuate" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	if (his_self.isSpaceControlled("calais", "england") && his_self.isSpaceControlled("antwerp", "hapsburg")) {

          let p1 = his_self.returnPlayerOfFaction("england");
          let p2 = his_self.returnPlayerOfFaction("hapsburg");

          his_self.game.queue.push("cloth-prices-fluctuate-option1\t"+faction);

          his_self.game.queue.push("hand_to_fhand\t1\t"+p1+"\t"+"england"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p1+"\t"+1);

          his_self.game.queue.push("hand_to_fhand\t1\t"+p2+"\t"+"hapsburg"+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p2+"\t"+1);

	} else {

          his_self.game.queue.push("cloth-prices-fluctuate-option2\t"+faction);

	}

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "cloth-prices-fluctuate-option1") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);

	  if (p == his_self.game.player) {

	    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league != 1) {
	      his_self.addMove("NOTIFY\tProtestants cannot place mercenaries yet...");
	      his_self.endTurn();
	      return 0;
	    }

	    if (faction === "ottoman") {

	      //
	      // place 2 cavalry in home space not under siege
	      //
	      his_self.playerSelectSpaceWithFilter(
	        "Select Home Space not under Siege",
	        function(space) {
	          if (space.besieged) { return 0; }
	          if (space.type == "electorate" && his_self.game.state.events.schmalkaldic_league != 1) { return 0; }
	          if (his_self.isSpaceControlled(space, faction) && his_self.isSpaceHomeSpace(space, faction)) { return 1; }
	          return 0;
	        },
	        function(spacekey) {
	          let space = his_self.game.spaces[spacekey];
                  his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
                  his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+spacekey);
	          his_self.endTurn();
	        },
	        null,
	        true
	      );

	    } else {

	      //
	      // place 2 mercenaries in home space not under siege
	      //
	      his_self.playerSelectSpaceWithFilter(
	        "Select Home Space not under Siege",
	        function(space) {
	          if (space.besieged) { return 0; }
	          if (space.type == "electorate" && his_self.game.state.events.schmalkaldic_league != 1) { return 0; }
	          if (his_self.isSpaceControlled(space, faction) && his_self.isSpaceHomeSpace(space, faction)) { return 1; }
	          return 0;
	        },
	        function(spacekey) {
	          let space = his_self.game.spaces[spacekey];
                  his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
                  his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+spacekey);
	          his_self.endTurn();
	        },
		null,
		true
	      );
	    }
	  }
	  return 0;

        }


        if (mv[0] == "cloth-prices-fluctuate-option2") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let f = his_self.returnFactionControllingSpace("antwerp");
	  if (f === "") { f = his_self.game.spaces["antwerp"].home; }

	  // f discards a card
          his_self.addMove("discard_random\t"+f);

	  //
	  // add unrest
	  //
          his_self.playerSelectSpaceWithFilter(
	    "Add Unrest",
	    function(space) {
	      if (space.key == "antwerp") { return 1; }
	      if (space.key == "brussels") { return 1; }
	      if (space.key == "amsterdam") { return 1; }
	      if (space.language == "italian") { return 1; }
	      if (space.home == "hapsburg" && space.language == "italian") { return 1; }
	      if (space.home == "hapsburg" && space.language == "german") { return 1; }
	      return 0;
	    },
	    function(unrest_spacekey1) {
              his_self.addMove("unrest\t"+unrest_spacekey1);
              his_self.playerSelectSpaceWithFilter(
  	        "Add Unrest",
	        function(space) {
	          if (space.key == unrest_spacekey1) { return 1; }
	          if (space.key == "antwerp") { return 1; }
	          if (space.key == "brussels") { return 1; }
	          if (space.key == "amsterdam") { return 1; }
	          if (space.language == "italian") { return 1; }
	          if (space.home == "hapsburg" && space.language == "italian") { return 1; }
	          if (space.home == "hapsburg" && space.language == "german") { return 1; }
	        return 0;
	        },
	        function(unrest_spacekey2) {
                  his_self.addMove("unrest\t"+unrest_spacekey2);
	          his_self.endTurn();
	        }
              );
	    }
          );
	  return 0;
	}

	return 1;

      },
    }
    deck['073'] = { 
      img : "cards/HIS-073.svg" , 
      name : "Diplomatic Marriage" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let anyone_allied = false;
	if (faction == "ottoman") { return 0; } 
	if (faction == "protestant") { return 0; } 
	if ("genoa" != his_self.returnControllingPower("genoa")) { anyone_allied = true; }
	if ("scotland" != his_self.returnControllingPower("scotland")) { anyone_allied = true; }
	if ("venice" != his_self.returnControllingPower("venice")) { anyone_allied = true; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player == p) {

	  let mp = his_self.returnMinorPowers();
	  let ca = [];
	  let cd = [];

	  for (let i = 0; i < mp.length; i++) {
	    if (his_self.canFactionActivateMinorPower(faction, mp[i])) {
	      if (his_self.returnAllyOfMinorPower(mp[i]) == faction) {
	        cd.push(mp[i]);
	      } else {
	        ca.push(mp[i]);
	      }
	    }
	  }
	
	  let msg = 'Activate or De-activate a Minor Power?';
    	  let html = '<ul>';
	  for (let i = 0; i < ca.length; i++) {
            html += `<li class="option" id="${ca[i]}">activate ${ca[i]}</li>`;
	  }
	  for (let i = 0; i < cd.length; i++) {
            html += `<li class="option" id="${cd[i]}">deactivate ${cd[i]}</li>`;
	  }
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {
	    let action = $(this).attr("id");
	    if (ca.includes(action)) {
	      if (faction === "hapsburg" && action == "hungary") {
		his_self.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance = 1;
	      }
	      his_self.addMove("activate_minor_power\t"+faction+"\t"+action);
	    } else {
	      his_self.addMove("deactivate_minor_power\t"+faction+"\t"+action);
	    }
	    his_self.endTurn();
	  });
	}

	return 0;
      },
    }
    deck['074'] = { 
      img : "cards/HIS-074.svg" , 
      name : "Diplomatic Overture" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
        if (his_self.game.player != 0) {

	  // deal 2 cards to faction
	  his_self.game.queue.push("diplomatic-overture\t"+faction);
          his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
          his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
          his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);

	}

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "diplomatic-overture") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
	  let does_player_have_non_mandatory_card = false;
	  let does_player_have_non_home_card = false;

	  for (let i = 0; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (his_self.game.deck[0].cards[his_self.game.deck[0].fhand[fhand_idx][i]].type != "mandatory") { does_player_have_non_mandatory_card = true; }
	    if (parseInt(his_self.game.deck[0].fhand[fhand_idx][i]) > 8) { does_player_have_non_home_card = true; }
	  }

	  if (his_self.game.player == p) {

	    his_self.playerSelectFactionWithFilter(
	      "Select Faction to Give Card",
	      function(f) { if (f !== faction) { return 1; } },
	      function(recipient) {
 	        his_self.playerFactionSelectCardWithFilter(
	          faction,
	          "Select Card to Give Away",
	          function(card) {
		    // no to home cards
		    if (parseInt(card) < 9) { return 0; }
		    // no to mandatory events unless I only have them
		    if (his_self.game.deck[0].cards[card].type == "mandatory" && does_player_have_non_mandatory_card) { return 0; }
		    // otherwise yes
		    return 1; 
		  },
	          function(card) {
                    his_self.addMove("give_card\t"+recipient+"\t"+faction+"\t"+card);
	  	    his_self.endTurn();
	          }
	        );
	      }
	    );
	  }
	  return 0;
	}
	return 1;
      },
    }
    deck['075'] = { 
      img : "cards/HIS-075.svg" , 
      name : "Erasmus" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (his_self.game.state.round < 3) {

	  let player = his_self.returnPlayerOfFaction("protestant");

          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("protestant_reformation\t"+player+"\tall");
          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	} else {

	  let player = his_self.returnPlayerOfFaction("papacy");   

          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("catholic_counter_reformation\t"+player+"\tall");
          his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	}

	return 1;
      },
    }
    deck['076'] = { 
      img : "cards/HIS-076.svg" , 
      name : "Foreign Recruits" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction === "protestant") { 
	  if (his_self.game.state.events.schmalkaldic_league == 1) { return 1; }
          if (his_self.game.state.activated_powers[faction].length > 0) { return 1; }
	  return 0;
        };
	return 1;
      },
      onEvent : function(his_self, faction) {

	if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

	  //
	  //
	  //
  	  if (his_self.game.state.activated_powers[faction].length > 0) {

	    let msg = "Which Faction gets Recruits?";
    	    let html = '<ul>';
	    if (!(faction == "protestant" && his_self.game.state.events.schmalkaldic_league != 1)) {
              html += `<li class="option" id="${faction}">${his_self.returnFactionName(faction)}</li>`;
	    }
	    for (let i = 0; i < his_self.game.state.activated_powers[faction].length; i++) {
	      let f = his_self.game.state.activated_powers[faction][i];
              html += `<li class="option" id="${f}">${his_self.returnFactionName(f)}</li>`;
 	    }  
 	    html += '</ul>';
    	    his_self.updateStatusWithOptions(msg, html);

	    $('.option').off();
	    $('.option').on('click', function () {
	      his_self.updateStatus("acknowledge");
	      let action = $(this).attr("id");
	      his_self.game.state.events.foreign_recruits = action;
  	      his_self.playerPlayOps("", action, 4, "build");
	    });

	    return 0;
	  }

	  //
	  // if no activated factions, must be us
	  //
	  his_self.game.state.events.foreign_recruits = faction;
  	  his_self.playerPlayOps("", faction, 4, "build");

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("076"));
	}

	return 0;
      },
    }
    deck['077'] = { 
      img : "cards/HIS-077.svg" , 
      name : "Fountain of Youth" ,
      ops : 2 ,
      turn : 2 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.explorations.length > 0 || his_self.game.state.conquests.length > 0) { 
	  for (let z = 0; z < his_self.game.state.explorations.length; z++) {
	    let e = his_self.game.state.explorations[z];
	    if (e.round == his_self.game.state.round) { return 1; }
	  }
	  for (let z = 0; z < his_self.game.state.conquests.length; z++) {
	    let c = his_self.game.state.conquests[z];
	    if (c.round == his_self.game.state.round) { return 1; }
	  }
	  return 1;
	}
	return 0;
      },
      onEvent(his_self, faction) {

        let player = his_self.returnPlayerCommandingFaction(faction);

        if (his_self.game.player === player) { 

	  let cabot_england_found = 0;
	  let cabot_france_found = 0;
	  let cabot_hapsburg_found = 0;

	  let msg = "Cancel Which Expedition / Conquest?";
          let html = '<ul>';
	  let cabot_found = 0;

	  for (let i = 0; i < his_self.game.state.explorations.length; i++) {

	    let exp = his_self.game.state.explorations[i];

            if (exp.cabot == 1) {
              if (exp.faction == "england") { cabot_england_found = 1; }
              if (exp.faction == "france") { cabot_france_found = 1; }
              if (exp.faction == "hapsburg") { cabot_hapsburg_found = 1; }
            }

	    if (exp.round == his_self.game.state.round) {
              html += `<li class="option" id="${his_self.game.state.explorations[i].faction}">${his_self.returnFactionName(his_self.game.state.explorations[i].faction)} (exploration)</li>`;
	    }
	    if (cabot_found == 0 && his_self.game.state.events.cabot_england == 1 && cabot_england_found == 0) {
              html += `<li class="option" id="cabot_england">sebastian cabot (england)</li>`;
	      cabot_found = 1;
	    }
	    if (cabot_found == 0 && his_self.game.state.events.cabot_france == 1 && cabot_france_found == 0) {
              html += `<li class="option" id="cabot_france">sebastian cabot (france)</li>`;
	      cabot_found = 1;
	    }
	    if (cabot_found == 0 && his_self.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0) {
              html += `<li class="option" id="cabot_hapsburg">sebastian cabot (haps)</li>`;
	      cabot_found = 1;
	    }
	  }
	  for (let i = 0; i < his_self.game.state.conquests.length; i++) {
	    if (his_self.game.state.conquests[i].round == his_self.game.state.round) {
              html += `<li class="option" id="conquest-${his_self.game.state.conquests[i].faction}">${his_self.returnFactionName(his_self.game.state.conquests[i].faction)} (conquest)</li>`;
	    }
	  }
          html += '</ul>';

 	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    his_self.addMove("display_new_world");
	    if (action == "conquest-england" || action == "conquest-france" || action == "conquest-hapsburg") {
	      if (action == "conquest-england") {
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels English conquest");
	        his_self.addMove("remove_conquest\tengland"); 
	      }
	      if (action == "conquest-france") {
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels French conquest");
	        his_self.addMove("remove_conquest\tfrance"); 
	      }
	      if (action == "conquest-hapsburg") {
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels Hapsburg conquest");
	        his_self.addMove("remove_conquest\thapsburg"); 
	      }
	      his_self.endTurn();
	      return 0;
	    }
	    if (action == "cabot_england" || action == "cabot_hapsburg" || action == "cabot_france") {
	      if (action === "cabot_england") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_england\t0"); }
	      if (action === "cabot_hapsburg") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_hapsburg\t0"); }
	      if (action === "cabot_france") {  his_self.addMove("SETVAR\tstate\tevents\tcabot_france\t0"); }
	    } else {
	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" cancels "+his_self.returnFactionName(action)+" exploration");
	      his_self.addMove("remove_exploration\t"+action); 
	    }

	    his_self.endTurn();

	  });
	}
        return 0;
      },
    }
    deck['078'] = { 
      img : "cards/HIS-078.svg" , 
      warn : ["papacy"] ,
      name : "Frederick the Wise" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("protestant");

	//
	// protestants get wartburg card if in discards
	//
        if (his_self.game.deck[0].discards["037"]) {
	  his_self.game.deck[0].cards["037"] = his_self.game.deck[0].discards["037"];
	  delete his_self.game.deck[0].discards["037"];
	  if (his_self.game.player == p) {
            let fhand_idx = his_self.returnFactionHandIdx(p, "protestant");
	    his_self.game.deck[0].fhand[fhand_idx].push("037");
	  }
	}

	//
	// protestants can convert german-language space closest to wittenberg
	//
	his_self.game.queue.push("frederick_the_wise\t2");
	his_self.game.queue.push("frederick_the_wise\t1");
	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "frederick_the_wise") {

          his_self.game.queue.splice(qe, 1);
	  let faction = "protestant";
	  let num = mv[1];

	  res = his_self.returnNearestSpaceWithFilter(
	    "wittenberg",
	    function(spacekey) {
	      if (his_self.game.spaces[spacekey].religion == "catholic" && his_self.game.spaces[spacekey].language == "german") { return 1; }
	      return 0;
	    },
	    function(propagation_filter) {
	      return 1;
	    },
	    0,
	    1,
	  );

	  //
	  // if no options, skip
	  //
	  if (res.length <= 0) { 
	    his_self.updateLog("No viable spaces for Frederick the Wise");
	    return 1;
	  }

	  //
	  // otherwise pick closest space
	  //
	  if (his_self.game.player == his_self.returnPlayerOfFaction("protestant")) {
 	    his_self.playerSelectSpaceWithFilter(
  	      "Select Towns to Convert Protestant: ",
	      (space) => {
	        for (let i = 0; i < res.length; i++) { if (space.key == res[i].key) { return 1; } }
	        return 0;
	      },
	      (spacekey) => {
	        his_self.addMove("convert" + "\t" + spacekey + "\t" + "protestant");
	        his_self.endTurn();
	      },
	      null,
	      true
	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName("protestant") + " playing " + his_self.popup("078"));
	  }

	  return 0;

	}

	return 1;
      }
    }
    deck['079'] = { 
      img : "cards/HIS-079.svg" , 
      name : "Fuggers" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	for (let z = 0; z < his_self.game.queue.length; z++) {
	  let c = his_self.game.queue[z].split("\t");
	  if (c[0] == "cards_left") { c.splice(z, 1); }
	}
      
        his_self.game.queue.push("cards_left\t"+faction+"\t"+(parseInt(his_self.game.state.cards_left[faction])+2));
        his_self.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+faction+"\t1");
        his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
        his_self.game.queue.push("DEAL\t1\t"+p+"\t"+1);
	his_self.game.state.events.fuggers = faction;

	return 1;
      },
    }
    deck['080'] = { 
      img : "cards/HIS-080.svg" , 
      name : "Gabelle Revolt" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (his_self.game.player == p) {

	  let space1 = "";
	  let space2 = "";

          his_self.playerSelectSpaceWithFilter(
	    "Select 1st Unoccupied French Home Space: ",
	    function(space) {
	      if (
		space.home === "france" &&
		(!his_self.isOccupied(space) && !space.unrest)
	      ) {
		return 1;
	      }
	      return 0;
	    },
	    function(spacekey) {

	      space1 = spacekey;

	      his_self.addUnrest(space1);
	      his_self.displaySpace(space1);

              his_self.playerSelectSpaceWithFilter(
	        "Select 2nd Unoccupied French Home Space: ",
	        function(space) {
	          if (
	  	    space.home === "france" &&
	  	    space.key != space1 &&
		    (!his_self.isOccupied(space) && !space.unrest)
	          ) {
		    return 1;
	          }
	          return 0;
	        },
		function(spacekey2) {
		  his_self.updateStatus("adding unrest...");
		  space2 = spacekey2;

	          his_self.addUnrest(space2);
	          his_self.displaySpace(space2);

		  his_self.addMove("unrest\t"+space1);
		  his_self.addMove("unrest\t"+space2);
		  his_self.endTurn();
		},
		null,
		true
	      );
	    },
	    null,
	    true,
	  );
        }

        return 0;
      },
    }
    deck['081'] = { 
      img : "cards/HIS-081.svg" , 
      name : "Indulgence Vendor" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	his_self.game.queue.push("indulgence-vendor\t"+faction);
	his_self.game.queue.push("pull_card\t"+faction+"\tprotestant");

        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "indulgence-vendor") {

	  let faction = mv[1];
  
          his_self.game.queue.splice(qe, 1);
	  if (his_self.game.state.last_pulled_card == undefined || his_self.game.state.last_pulled_card === "" || his_self.game.state.last_pulled_card === "undefined") {
	    his_self.updateLog("Protestants have no cards to pull...");
	    return 1;
	  }

	  let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
	  let card = his_self.game.state.last_pulled_card;

	  if (card) {
  	    let deck = his_self.returnDeck(true);
	    let ops = deck[card].ops;

  	    his_self.game.queue.push("show_overlay\tfaction\tpapacy");
	    for (let i = 0; i < ops; i++) {
  	      his_self.game.queue.push("build_saint_peters");
	    }
  	    his_self.game.queue.push("discard\t"+faction+"\t"+card);
	  }
	  
	  return 1;

        }

	return 1;

      },
    }
    deck['082'] = { 
      img : "cards/HIS-082.svg" , 
      name : "Janissaries Rebel" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let at_war = false;
	let f = his_self.returnImpulseOrder();
	for (let i = 0; i < f.length; i++) {
	  if (f[i] !== "ottoman") {
	    if (his_self.areEnemies(f[i], "ottoman")) {
	      at_war = true;
	    }
	  }
	}

	his_self.game.state.janissaries_spaces = [];

	let spaces_to_select = 4;
	if (at_war) { spaces_to_select = 2; }

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].home == "ottoman") { return 1; }
	    return 0;
	  });

	  if (res.length < spaces_to_select) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("janissaries_rebel\t"+faction+"\t"+(spaces_to_select-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "janissaries_rebel") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
		if (his_self.game.state.janissaries_spaces.includes(space.key)) { return 0; }
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].home == "ottoman") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
		his_self.game.state.janissaries_spaces.push(spacekey);
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("088"));
	  }
  
	  return 0;

	}

	return 1;
      },
    }
    deck['083'] = { 
      img : "cards/HIS-083.svg" , 
      name : "John Zapolya" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	//
	//
	//
	if (his_self.game.spaces["buda"].besieged > 0) {

	} else {

	  if (his_self.game.spaces["buda"].political == "" || his_self.game.spaces["buda"].political === "hungary") {
	    his_self.addRegular("hungary", "buda", 4);
	  } else {
	    his_self.addRegular(his_self.game.spaces["buda"].political, "buda", 4);
	  }
	}

	return 1;
      },
    }
    deck['084'] = { 
      img : "cards/HIS-084.svg" , 
      name : "Julia Gonzaga" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.barbary_pirates) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {
	his_self.game.state.events.julia_gonzaga_activated = 1;
	his_self.game.state.events.julia_gonzaga = "ottoman";

	return 1;
      },
    }
    deck['085'] = { 
      img : "cards/HIS-085.svg" , 
      name : "Katherina Bora" ,
      warn : ["papacy"] ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (!his_self.isDebaterCommitted("luther-debater")) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	//
	// protestant player gets 5 Reformation Attempts
	//
	let p = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	//
	// and commit luther
	//
	his_self.commitDebater("protestant", "luther-debater");
	  
	return 1;
      },
    }
    deck['086'] = { 
      img : "cards/HIS-086.svg" , 
      name : "Knights of St. John" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	//
	// knights are on map
	//
	if (his_self.game.state.knights_of_st_john != "") {

	  let space = his_self.game.spaces[his_self.game.state.knights_of_st_john];

	  let connected = false;
	  if (!space.besieged) {
            for (let i = 0; i < space.ports.length; i++) {
              let sea = his_self.game.navalspaces[space.ports[i]];
              for (let z = 0; z < sea.ports.length; z++) {
                if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
                  connected = true;
                }
              }
            }
          }

	  if (connected) {
	    his_self.game.queue.push("knights_ottoman_pull\tpapacy");
            his_self.game.queue.push("pull_card\tpapacy\tottoman");
	  }

        } else {

	  let p = his_self.returnPlayerOfFaction("hapsburg");
	  if (his_self.game.player === p) {

 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to place Knights of St. John`,

	      (space) => {
		if (space.home === "hapsburg") {
		  if (space.ports.length > 0) { 
		    if (his_self.isSpaceControlled(space.key, "hapsburg")) {
		      return 1;
		    }
		  }
		}
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("knightify_space\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	    
	  } else {
	    his_self.updateStatus("Hapsburgs placing Knights of St. John");
	  }

	  return 0;

	}

        return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "knightify_space") {

          his_self.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let space = his_self.game.spaces[spacekey];

	  space.home = "independent";
	  space.political = "independent";
	  his_self.game.state.knights_of_st_john = spacekey;
	  his_self.game.queue.push("fortify\t"+spacekey);

	  return 1;

	}

        if (mv[0] == "knights_ottoman_pull") {

          let faction = mv[1];
          his_self.game.queue.splice(qe, 1);

          let p = his_self.returnPlayerOfFaction(faction);
          let fhand_idx = his_self.returnFactionHandIdx(p, faction);
          let card = his_self.game.state.last_pulled_card;
          let ops = his_self.game.deck[0].cards[card].ops;

          his_self.game.queue.push("show_overlay\tfaction\tpapacy");
          for (let i = 0; i < ops; i++) {
            his_self.game.queue.push("build_saint_peters");
          }
          his_self.game.queue.push("discard\t"+faction+"\t"+card);

          return 1;

	}

	return 1;
      },
    }
    deck['087'] = { 
      img : "cards/HIS-087.svg" , 
      name : "Mercenaries Demand Pay" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);

	if (his_self.game.player == p) {

	  // pick a faction
  	  his_self.playerSelectFactionWithFilter(

	    "Select Faction to Target: ",

	    function(f) {
	      if (f !== faction) { return 1; }
	      return 0;
	    },

	    function (target) {
	      his_self.addMove("check_for_stranded_leaders\t"+target);
	      his_self.addMove("mercenaries-demand-pay\t"+target+"\t"+faction);
	      his_self.addMove("NOTIFY\t"+his_self.popup("087")+" targets "+his_self.returnFactionName(target));
	      his_self.endTurn();
	    }
	  );
	}
	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "mercenaries-demand-pay") {

          his_self.game.queue.splice(qe, 1);

	  let target = mv[1];
	  let faction = mv[2];
	  let player = his_self.returnPlayerOfFaction(target);

	  his_self.displayModal(his_self.returnFactionName(faction) + " plays Mercenaries Demand Pay");
	  his_self.updateStatus(his_self.returnFactionName(target) + " discarding card...");

	  if (player == his_self.game.player) {

	    //
	    // do we have any cards we can discard ?
	    //
            let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, target);
	    let valid_options = 0;
	    let invalid_options = 0;
	    let home_card_option = 0;

	    for (let i = 0; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	      let card = his_self.game.deck[0].fhand[fhand_idx][i];
	      if (parseInt(card) <= 8) { home_card_option++ };
	      if (his_self.game.deck[0].cards[card].type != "mandatory" && parseInt(card) > 8) { valid_options++; } else {
		invalid_options++;
	      }
	    }

	    //
	    // if only invalid options, skip discard
	    //
	    if (valid_options == 0 && invalid_options == 0) {
	      if (home_card_option == 0) {
	        his_self.addMove("destroy_all_mercenaries\t"+target);
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(target) + " must destroy_all_mercenaries");
	        his_self.endTurn();
	        return 0;
	      }
	    }

	    if (valid_options == 0 && invalid_options > 0) {
	      if (home_card_option == 0) {
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(target) + " cannot be forced to discard cards in hand.");
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(target) + " mercenaries survive.");
	        his_self.endTurn();
	        return 0;
	      }
	    }


            his_self.playerFactionSelectCardWithFilter(

	      target,

	      "Select Card to Discard: ",

	      function(card) {
		let c = his_self.game.deck[0].cards[card];
	        if (c.type === "mandatory") { return 0; }
		return 1;
	      },

	      function(card) {

		//
		// can always opt not to discard
		//
		if (card == "pass"){ 
		  his_self.addMove("destroy_all_mercenaries\t"+target);
	          his_self.addMove("NOTIFY\t"+his_self.returnFactionName(target) + " must destroy_all_mercenaries");
	          his_self.endTurn();
		  return 0;
		}

		let c = his_self.game.deck[0].cards[card].ops;	      

  	  	his_self.addMove("discard\t"+target+"\t"+card);
		his_self.addMove("NOTIFY\t" + his_self.returnFactionName(target) + " discards " + his_self.popup(card));

		let retained = 2;
		if (c == 2) { retained = 4; }
		if (c == 3) { retained = 6; }
		if (c == 4) { retained = 10; }
		if (c >= 5) {
		  his_self.endTurn();
		  return;
		}

		//
		// player must discard down to N (retained) mercenaries
		//
		his_self.playerRetainUnitsWithFilter(
		  target,
		  function(spacekey, unit_idx) {
		    if (his_self.game.spaces[spacekey].units[target][unit_idx].type == "mercenary") { return 1; }
		    return 0;
		  },
		  retained
		);
	      },

	      null ,

	      true // permit passing/no-selection

	    );
	  }
	  return 0;
        }
	return 1;
      }
    }
    deck['088'] = { 
      img : "cards/HIS-088.svg" , 
      name : "Peasants' War" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
        let res = his_self.returnSpacesWithFilter(function(spacekey) {
	  if (his_self.isOccupied(spacekey)) { return 0; }
	  if (his_self.game.spaces[spacekey].language == "german") { return 1; }
	  return 0;
	});
	if (res.length > 0) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].language == "german") { return 1; }
	    return 0;
	  });


	  let spaces_to_select = 5;
	  if (res.length < 5) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("peasants_war\t"+faction+"\t"+(5-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "peasants_war") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (!his_self.game.state.peasants_war) {
	    his_self.game.state.peasants_war = [];
	  }
	  if (parseInt(num) == 1) {
	    his_self.game.state.peasants_war = [];
	  }

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

	    //
	    // pick unit on map with player land units and select one to remove
	    //
 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
	        if (his_self.game.state.peasants_war) { if (his_self.game.state.peasants_war.includes(space.key)) { return 0; } }
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].language == "german") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
	        his_self.game.state.peasants_war.push(spacekey);
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("088"));
	  }
  
	  return 0;

	}

	return 1;
      }
    }
    deck['089'] = { 
      img : "cards/HIS-089.svg" , 
      name : "Pirate Haven" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	if (his_self.game.state.events.barbary_pirates == 1) {

	  let target_oran = false;
	  let target_tripoli = false;

	  if (his_self.isUnoccupied("oran") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("oran"))) {
	    let oran = his_self.game.spaces["oran"];
	    for (let i = 0; i < oran.ports.length; i++) {
	      let sea = his_self.game.navalspaces[oran.ports[i]];
	      for (let z = 0; z < sea.ports.length; z++) {
	        if (his_self.game.spaces[sea.ports[z]].fortress == 1 || his_self.game.spaces[sea.ports[z]].type == "key") {
	          if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
	  	    target_oran = true;
		  }
	        }
	      }
	    }
	  }
	  if (his_self.isUnoccupied("tripoli") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("tripoli"))) {
	    let tripoli = his_self.game.spaces["tripoli"];
	    for (let i = 0; i < tripoli.ports.length; i++) {
	      let sea = his_self.game.navalspaces[tripoli.ports[i]];
	      for (let z = 0; z < sea.ports.length; z++) {
	        if (his_self.game.spaces[sea.ports[z]].fortress == 1 || his_self.game.spaces[sea.ports[z]].type == "key") {
	          if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
		    target_tripoli = true;
		  }
	        }
	      }
	    }
	  }

	  if (target_oran == true || target_tripoli == true) {
	    return 1;
	  }

	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction("ottoman");

	if (his_self.game.player == p) {
	let target_oran = false;
	let target_tripoli = false;

        if (his_self.isUnoccupied("oran") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("oran"))) {
          let oran = his_self.game.spaces["oran"];
          for (let i = 0; i < oran.ports.length; i++) {
            let seakey = oran.ports[i];
            let sea = his_self.game.navalspaces[seakey];
            for (let z = 0; z < sea.ports.length; z++) {
              if (his_self.game.spaces[sea.ports[z]].fortress == 1 || his_self.game.spaces[sea.ports[z]].type == "key") {
                if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
                  target_oran = true;
                }
              }
            }
          }
        }
        if (his_self.isUnoccupied("tripoli") && his_self.areEnemies("ottoman", his_self.returnFactionControllingSpace("tripoli"))) {
          let tripoli = his_self.game.spaces["tripoli"];
          for (let i = 0; i < tripoli.ports.length; i++) {
            let seakey = tripoli.ports[i];
            let sea = his_self.game.navalspaces[seakey];
            for (let z = 0; z < sea.ports.length; z++) {
              if (his_self.game.spaces[sea.ports[z]].fortress == 1 || his_self.game.spaces[sea.ports[z]].type == "key") {
                if (his_self.returnFactionControllingSpace(sea.ports[z]) == "ottoman") {
                  target_tripoli = true;
                }
              }
            }
          }
        }

   	let msg = "Convert Space into Pirate Haven: ";
        let html = '<ul>';
  	if (target_oran)    { html += `<li class="option" id="oran">Oran</li>`; }
  	if (target_tripoli) { html += `<li class="option" id="tripoli">Tripoli</li>`; }
    	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

   	$('.option').off();
	$('.option').on('click', function () {

   	  $('.option').off();
	  let action2 = $(this).attr("id");
	  his_self.updateStatus("converting...");

	  his_self.addMove("pirate_haven\t"+action2);
	  his_self.endTurn();

	});
	}
	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "pirate_haven") {

          his_self.game.queue.splice(qe, 1);
	  let spacekey = mv[1];

	  his_self.addRegular("ottoman", spacekey, 1);
	  his_self.addCorsair("ottoman", spacekey, 2);
	  his_self.game.spaces[spacekey].pirate_haven = 1;
	  if (spacekey != "oran" && spacekey != "tripoli") {
	    his_self.game.spaces[spacekey].fortified = 1;
	  }

	  his_self.controlSpace("ottoman", spacekey);
	  his_self.displaySpace(spacekey);

	  return 1;

	}

        return 1;
      },
    }
    deck['090'] = { 
      img : "cards/HIS-090.svg" , 
      warn : ["papacy"] ,
      name : "Printing Press" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

        his_self.game.state.printing_press_active = 1;

	let p = his_self.returnPlayerOfFaction("protestant");

        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
	his_self.game.queue.push("protestant_reformation\t"+p+"\tall");
        his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	return 1;
      },
    }
    deck['091'] = { 
      img : "cards/HIS-091.svg" , 
      name : "Ransom" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	  if (his_self.game.state.players_info[i].captured.length > 0) {
	    return 1;
	  } 	
	}	
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

  	  //
	  // list of all captured leaders
	  //
	  let captured_leaders = [];
	  let options = [];

	  for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	    for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
	      captured_leaders.push({ faction : his_self.game.state.players_info[i].captured[ii].faction , leader : his_self.game.state.players_info[i].captured[ii].type , player : i , idx : ii });
	      options.push(his_self.game.state.players_info[i].captured[ii].type);
	    } 	
	  }	

   	  let msg = "Select Leader to Ransom: ";
	  let html = '<ul>';
	  for (let i = 0; i < options.length; i++) { html += `<li class="option" id="${i}">${options[i]}</li>`; }
    	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

   	  $('.option').off();
	  $('.option').on('click', function () {
   	    $('.option').off();

	    his_self.updateStatus("sending");

	    let options_idx = $(this).attr("id");
	    his_self.addMove("ransom\t"+options[options_idx]);
	    his_self.addMove("NOTIFY\t" + options[options_idx] + " ransomed...");
	    his_self.endTurn();
	  });

	}

	return 0;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "ransom_placement") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let spacekey = mv[2];

	  if (his_self.game.state.ransomed_leader != null) {
	    his_self.game.spaces[spacekey].units[faction].push(his_self.game.state.ransomed_leader);
	    his_self.game.state.ransomed_leader = null;
	  } 

	  return 1;

	}

        if (mv[0] == "ransom") {

          his_self.game.queue.splice(qe, 1);

	  his_self.game.state.ransomed_leader = null;
	  let ransomed_leader_type = mv[1];
	  let ransomed_leader = null;

	  for (let i = 0; i < his_self.game.state.players_info.length; i++) {
	    for (let ii = 0; ii < his_self.game.state.players_info[i].captured.length; ii++) {
	      if (his_self.game.state.players_info[i].captured[ii].type == ransomed_leader_type) {
	        ransomed_leader = his_self.game.state.players_info[i].captured[ii];
		his_self.game.state.players_info[i].captured.splice(ii, 1);
	      }
	    } 	
	  }	

	  if (ransomed_leader === null) { return; }

	  his_self.game.state.ransomed_leader = ransomed_leader;

	  let player = his_self.returnPlayerOfFaction(ransomed_leader.owner);

	  if (player == his_self.game.player) {

            his_self.playerSelectSpaceWithFilter(

	      "Select Fortified Home Space: ",

	      function(space) {
		if ((space.type == "fortress" || space.type == "electorate" || space.type == "key") && space.home == ransomed_leader.owner) {
		  if (his_self.isSpaceControlled(space.key, ransomed_leader.owner)) {
		    return 1;
		  }
		}
		return 0;
	      },

	      function(spacekey) {
		his_self.addMove("ransom_placement\t"+ransomed_leader.owner+"\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true 

	    );
	  }
	  return 0;
        }
	return 1;
      }
    }
    deck['092'] = { 
      img : "cards/HIS-092.svg" , 
      warn : ["ottoman"] ,
      name : "Revolt in Egypt" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.revolt_in_egypt == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayEgypt();

        his_self.addRegular("independent", "egypt", 1);
        his_self.addRegular("independent", "egypt", 1);
        his_self.addRegular("independent", "egypt", 1);

        his_self.game.state.events.revolt_in_egypt = 1;

        his_self.game.queue.push("check_for_broken_sieges");
        his_self.game.queue.push("revolt_in_egypt_leader_removal\tottoman");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t3");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t2");
        his_self.game.queue.push("revolt_in_egypt_troop_removal\tottoman\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_in_egypt_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

   	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      if (key != "persia" && key != "egypt" && key != "ireland") {
	        let space = his_self.game.spaces[key];
                for (let i = 0; i < space.units["ottoman"].length; i++) {
                  let u = space.units["ottoman"][i];
	          if (u.army_leader) {
	  	    options.push({ spacekey : key , idx : i , name : u.name });
	          }
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

   	      $('.option').off();
	      his_self.updateStatus("moving...");
	      let options_idx = $(this).attr("id");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tottoman\tland\t"+options[options_idx].spacekey+"\tegypt\t"+options[options_idx].idx);
              his_self.endTurn();

	    });

	  } else {
	    his_self.updateStatus("Ottomans selecting Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "revolt_in_egypt_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["ottoman"].length > 0) {
		  for (let z = 0; z < space.units["ottoman"].length; z++) {
		    let u = space.units["ottoman"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["corsair", "squadron"];
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                if (space.units["ottoman"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["ottoman"][i].type) && space.units["ottoman"][i].army_leader != true && space.units["ottoman"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["ottoman"][i].type}">${space.units["ottoman"][i].type}</li>`;
		    unittypes.push(space.units["ottoman"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
		  return 0;
		}

          	his_self.removeUnit("ottoman", spacekey, unittype);

		his_self.displaySpace(spacekey);

          	console.log("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tottoman\t"+unittype+"\tegypt");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}

        return 1;
      }
    }
    deck['093'] = { 
      img : "cards/HIS-093.svg" , 
      name : "Revolt in Ireland" ,
      warn : ["england"] ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.revolt_in_ireland == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayIreland();

        his_self.addRegular("independent", "ireland", 1);
        his_self.addRegular("independent", "ireland", 1);
        his_self.addRegular("independent", "ireland", 1);

        his_self.game.state.events.revolt_in_ireland = 1;

	if (faction == "france" || faction == "hapsburg") {
          his_self.game.queue.push("revolt_in_ireland_bonus_resistance\t"+faction);
	}

        his_self.game.queue.push("check_for_broken_sieges");
        his_self.game.queue.push("revolt_in_ireland_leader_removal\tengland");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t4");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t3");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t2");
        his_self.game.queue.push("revolt_in_ireland_troop_removal\tengland\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_in_ireland_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
  
	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

 	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      if (key != "persia" && key != "egypt" && key != "ireland") {
	        let space = his_self.game.spaces[key];
                for (let i = 0; i < space.units["england"].length; i++) {
                  let u = space.units["england"][i];
	          if (u.army_leader) {
	  	    options.push({ spacekey : key , idx : i , name : u.name });
	          }
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

	      let options_idx = $(this).attr("id");
   	      $('.option').off();

	      his_self.updateStatus("shifting forces to Ireland...");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tengland\tland\t"+options[options_idx].spacekey+"\tireland\t"+options[options_idx].idx);
              his_self.endTurn();

	    });

	  } else {
	    his_self.updateStatus("England choosing Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "revolt_in_ireland_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["england"].length > 0) {
		  for (let z = 0; z < space.units["england"].length; z++) {
		    let u = space.units["england"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["corsair", "squadron"];
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["england"].length; i++) {
                if (space.units["england"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["england"][i].type) && space.units["england"][i].army_leader != true && space.units["england"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["england"][i].type}">${space.units["england"][i].type}</li>`;
		    unittypes.push(space.units["england"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
		  return 0;
		}

          	his_self.removeUnit("england", spacekey, unittype);

		his_self.displaySpace(spacekey);

          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"england"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tengland\t"+unittype+"\tireland");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}

        if (mv[0] == "revolt_in_ireland_bonus_resistance") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  let p = his_self.returnPlayerCommandingFaction(faction);

	  if (his_self.game.player === p) {

            let msg = "Remove 1 Land Unit to Fortify Irish Resistance?";
            let html = '<ul>';
            html += '<li class="option" id="yes">yes</li>';
            html += '<li class="option" id="no">no</li>';
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");

	      his_self.updateStatus("acknowledge");

              if (action == "yes") {
		
		//
		// pick unit on map with player land units and select one to remove
		//
 	 	his_self.playerSelectSpaceWithFilter(

		  "Select Space to Remove 1 Land Unit",

		  (space) => { if (his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0) { return 1; } else { return 0; } },

		  (spacekey) => {
		    
      		    let opts = his_self.returnFactionLandUnitsInSpace(faction, spacekey);
		    let space = his_self.game.spaces[spacekey];

            	    let msg = "Remove which Land Unit?";
            	    let html = '<ul>';

		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "cavalry") {
   	                html += `<li class="option" id="${i}">cavalry</li>`;
			break;
		      }
		    }
		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "regular") {
   	                html += `<li class="option" id="${i}">regular</li>`;
			break;
		      }
		    }
		    for (let i = 0; i < space.units[faction].length; i++) {
		      if (space.units[faction][i].type === "mercenary") {
   	                html += `<li class="option" id="${i}">mercenary</li>`;
			break;
		      }
		    }

            	    html += '</ul>';

            	    his_self.updateStatusWithOptions(msg, html);

	            $('.option').off();
        	    $('.option').on('click', function () {

	              let action = parseInt($(this).attr("id"));

		      his_self.updateStatus("removing unit...");
          	      his_self.addMove("build\tland\tindependent\tregular\tireland");
		      his_self.addMove(	"remove_unit" + "\t" +
					"land" + "\t" +
					faction + "\t" +
					space.units[faction][action].type + "\t" +
					space.key );
		      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" removes unit from " + space.key);
		      his_self.endTurn();

		    });
		  },
		);
		return 0;
	      }
              if (action === "no") {
		his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" does not support Irish rebels");
		his_self.endTurn();
	      }
	    });
	  }
	  return 0;
        }
        return 1;
      }
    }
    deck['094'] = { 
      img : "cards/HIS-094.svg" , 
      name : "Revolt of the Communeros" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let res = his_self.returnSpacesWithFilter(function(spacekey) {
	    if (his_self.isOccupied(spacekey)) { return 0; }
	    if (his_self.game.spaces[spacekey].language == "spanish") { return 1; }
	    return 0;
	  });


	  let spaces_to_select = 3;
	  if (res.length < 3) { spaces_to_select = res.length; }
	  for (let i = 0; i < spaces_to_select; i++) {
	    his_self.addMove("revolt_of_the_communeros\t"+faction+"\t"+(3-i));
	  }
	  his_self.endTurn();

	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "revolt_of_the_communeros") {

          his_self.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let num = mv[2];

	  if (his_self.game.player == his_self.returnPlayerOfFaction(faction)) {

	    //
	    // pick unit on map with player land units and select one to remove
	    //
 	    his_self.playerSelectSpaceWithFilter(

	      `Select Space to Add Unrest / #${num}`,

	      (space) => {
	        if (his_self.isOccupied(space.key)) { return 0; }
	        if (his_self.game.spaces[space.key].language == "spanish") { return 1; }
	        return 0;
	      },

	      (spacekey) => {
      		his_self.addMove("unrest\t"+spacekey);
		his_self.endTurn();
	      },

	      null,

	      true

	    );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("094"));
	  }
  
	  return 0;

	}

	return 1;
      }
    }
    deck['095'] = { 
      img : "cards/HIS-095.svg" , 
      warn : ["papacy"] ,
      name : "Sack of Rome" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {

	let regulars_in_rome = 0;
	let sack_of_rome = false;
	for (let i = 0; i < his_self.game.spaces["rome"].units.length; i++) {
	  let u = his_self.game.spaces["rome"].units[i];
	  if (u.type == "regular") { regulars_in_rome++; }
	}

	let max_non_papal_mercenaries = 0;
	let spacekey = "";
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].language == "italian") {
	    let non_papal_mercenaries = 0;
	    for (let f in his_self.game.spaces[key].units) {
	      if (f != "papacy" && his_self.isAlliedMinorPower(f, "papacy") != true) {
		for (let i = 0; i < his_self.game.spaces[key].units[f].length; i++) {
		  let u = his_self.game.spaces[key].units[f][i];
		  if (u.type == "mercenary") {
		    non_papal_mercenaries++;  
		  }
	        }
	      }
	    }
	    if (non_papal_mercenaries > regulars_in_rome && non_papal_mercenaries > max_non_papal_mercenaries) {
	      spacekey = key;
	      max_non_papal_mercenaries = non_papal_mercenaries;
	      sack_of_rome = true;
	    }
	  }
	}
	return sack_of_rome;
      },
      onEvent : function(his_self, faction) {

	his_self.game.state.events.sack_of_rome = 1;

	let regulars_in_rome = 0;
	let sack_of_rome = false;
	for (let i = 0; i < his_self.game.spaces["rome"].units.length; i++) {
	  let u = his_self.game.spaces["rome"].units[i];
	  if (u.type == "regular") { regulars_in_rome++; }
	}

	let max_non_papal_mercenaries = 0;
	let spacekey = "";
	let fact = "";
	for (let key in his_self.game.spaces) {
	  if (his_self.game.spaces[key].language == "italian") {
	    let non_papal_mercenaries = 0;
	    for (let f in his_self.game.spaces[key].units) {
	      if (f != "papacy" && his_self.isAlliedMinorPower(f, "papacy") != true) {
		for (let i = 0; i < his_self.game.spaces[key].units[f].length; i++) {
		  let u = his_self.game.spaces[key].units[f][i];
		  if (u.type == "mercenary") {
		    non_papal_mercenaries++;  
		    fact = f;
		  }
	        }
	      }
	    }
	    if (non_papal_mercenaries > regulars_in_rome && non_papal_mercenaries > max_non_papal_mercenaries) {
	      spacekey = key;
	      max_non_papal_mercenaries = non_papal_mercenaries;
	      sack_of_rome = true;
	    }
	  }
	}

	if (!sack_of_rome) { return 1; }

	//
	// otherwise we have a field battle
	//
	for (let f in his_self.game.spaces[spacekey].units) {
	  if (f == fact || his_self.returnControllingPower(f) == his_self.returnControllingPower(fact)) {
	    his_self.game.spaces["rome"].units[f] = his_self.game.spaces[spacekey].units[f];
	  }
	}
 	his_self.game.spaces[spacekey].units[fact] = [];
	his_self.game.queue.push("post_sack_of_rome_retreat\t"+fact+"\t"+spacekey);
	his_self.game.queue.push("field_battle\trome\t"+fact);

	return 1;

      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "post_sack_of_rome_retreat") {

          let faction = mv[1];
          let spacekey = mv[2];
	  let power_controlling_rome = his_self.returnFactionControllingSpace("rome");

	  for (let f in his_self.game.spaces["rome"].units) {
	    if (f != power_controlling_rome && his_self.returnControllingPower(f) != his_self.returnControllingPower(power_controlling_rome)) {
 	      his_self.game.spaces[spacekey].units[f] = his_self.game.spaces["rome"].units[f];
 	      if (spacekey != "rome") { his_self.game.spaces["rome"].units[faction] = []; }
	    }
	  }
	 
	  //
	  // 2P game give cards to Protestants
	  //
	  if (his_self.game.players.length == 2) { faction = "protestant"; }

	  //
	  // if the papacy lost
	  //
	  if (his_self.game.state.field_battle.attacker_hits > his_self.game.state.field_battle.defender_hits) {

	    //
	    // remove this card from game
	    //
	    his_self.removeCardFromGame("095");

	    //
	    // deduct vp
	    //
	    let total_to_deduct = 5;
            his_self.game.state.saint_peters_cathedral['state'] -= total_to_deduct;
            if (his_self.game.state.saint_peters_cathedral['state'] < 0) {
	      let surplus = his_self.game.state.saint_peters_cathedral['state'] * -1;
	      if (his_self.game.state.saint_peters_cathedral['vp'] > 0) {
		his_self.game.state.saint_peters_cathedral['vp']--;
		his_self.game.state.saint_peters_cathedral['state'] = 5 - surplus;
	      } else {
		his_self.game.state.saint_peters_cathedral['state'] = 0;
	      }
	    }

	    //
	    // pull two cards
	    //
	    let faction_cards_left = his_self.game.state.cards_left[faction];
	    if (his_self.game.players.length == 2 || (faction != "hapsburg" || faction != "france")) {
	      let expected = 4;
	      if (!his_self.game.deck[0].discards['005']) { expected--; }
	      if (!his_self.game.deck[0].discards['006']) { expected--; }
	      if (his_self.game.state.cards_left["papacy"] < expected) { expected--; }
	      if (his_self.game.state.cards_left["papacy"] < expected) { expected--; }
	      if (expected >= 2) {
  	        his_self.game.queue.push("sack_of_rome_if_two_surplus_cards_discard\t"+faction+"\t"+faction_cards_left);
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	      }
	      if (expected == 1) {
	        his_self.game.queue.push("NOTIFY\tPapacy has one card available for pull...");
	        his_self.game.queue.push("pull_card\t"+faction+"\t"+"papacy");
	      }
	      if (expected == 0) {
	        his_self.game.queue.push("NOTIFY\tPapacy has no cards available for pull...");
	      }
	    } else {
	      his_self.game.queue.push("discard_random\tpapacy");
	      his_self.game.queue.push("discard_random\tpapacy");
	    }

	  }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


	if (mv[0] === "sack_of_rome_if_two_surplus_cards_discard") {

	  let faction = mv[1];
	  let faction_cards_left = parseInt(mv[2]);
	  let cards = [];
	  let surplus_cards = 0;

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
	    for (let i = faction_cards_left; i < his_self.game.deck[0].fhand[fhand_idx].length; i++) {
	      surplus_cards++;
	      cards.push(his_self.game.deck[0].fhand[fhand_idx][i]);
	    }

	    while (surplus_cards > 2) { cards.shift(); surplus_cards--; }
	  
	    if (surplus_cards == 2) {
	      his_self.addMove("select_and_discard\t"+faction+"\t"+JSON.stringify(cards));
	    }
	    his_self.endTurn();
	  }

          return 0;

	}

	return 1;

      },
    }
    deck['096'] = { 
      img : "cards/HIS-096.svg" , 
      name : "Sale of Moluccas" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.newworld['circumnavigation'].faction) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let f = his_self.game.state.newworld['circumnavigation'].faction;
	let p = his_self.returnPlayerCommandingFaction(f);

        his_self.game.queue.push('hand_to_fhand\t1\t' + p + '\t' + f + "\t1");
        his_self.game.queue.push('DEAL\t1\t' + p + '\t' + 2);
	
	return 1;
      }
    }
    deck['097'] = { 
      img : "cards/HIS-097.svg" , 
      name : "Scots Raid" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 1; } ,
      canEvent : function(his_self, faction) {
	if (his_self.areAllies("france", "scotland")) { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	//
	// displace from Stirling
	//
	for (let i = 0; i < his_self.game.spaces["stirling"].units["england"].length; i++) {
	  his_self.game.spaces["london"].units["england"].push(his_self.game.spaces["stirling"].units["england"][i]);
	}
	his_self.game.spaces["stirling"].units["england"] = [];

	if (his_self.game.player === his_self.returnPlayerOfFaction("france")) {

	  //
	  // choose between 3 and 6 OPs
	  //
	  let msg = "Scots Raid: move French Army Leader to Scotland?";
          let html = '<ul>';
          html += '<li class="option" id="yes">Yes (3 OPs)</li>';
          html += '<li class="option" id="no">No (6 OPs)</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

     	  $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");
 	    his_self.updateStatus("acknowledge");

	    if (action === "yes") {

              let msg = "Move Army Leader: ";
              let options = [];
              for (let key in his_self.game.spaces) {
                let space = his_self.game.spaces[key];
                for (let i = 0; i < space.units["france"].length; i++) {
                  let u = space.units["france"][i];
                  if (u.army_leader) {
                    options.push({ spacekey : key , idx : i , name : u.name });
                  }
                }
              }

              let html = '<ul>';
              for (let i = 0; i < options.length; i++) {
                html += `<li class="option" id="${i}">${options[i].name}</li>`;
              }
              html += `<li class="option" id="skip">skip</li>`;
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let options_idx = $(this).attr("id");
		his_self.updateStatus("acknowledge");

                his_self.addMove("SETVAR\tstate\tevents\tscots_raid\t0");
                his_self.addMove("ops\tfrance\t097\t3");
                his_self.addMove("SETVAR\tstate\tevents\tscots_raid\t1");
                his_self.addMove("move\tfrance\tland\t"+options[options_idx].spacekey+"\tstirling\t"+options[options_idx].idx);
                his_self.endTurn();

              });
	    }

	    if (action === "no") {
              his_self.addMove("SETVAR\tstate\tevents\tscots_raid\t0");
              his_self.addMove("ops\tfrance\t097\t6");
              his_self.addMove("SETVAR\tstate\tevents\tscots_raid\t1");
	      his_self.endTurn();
	    }

	  });
	}

	return 0;

      },
    }
    deck['098'] = { 
      img : "cards/HIS-098.svg" , 
      name : "Search for Cibola" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.events.cabot_england == 1) { return 1; }
	if (his_self.game.state.events.cabot_france == 1) { return 1; }
	if (his_self.game.state.events.cabot_hapsburg == 1) { return 1; }
	if (his_self.game.state.colonies.length > 0) { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {

        let player = his_self.returnPlayerCommandingFaction(faction);
        if (his_self.game.player === player) { 

	  let cabot_england_found = 0;
	  let cabot_france_found = 0;
	  let cabot_hapsburg_found = 0;

	  let msg = "Cancel Which Expedition / Conquest?";
          let html = '<ul>';
	  for (let i = 0; i < his_self.game.state.explorations.length; i++) {

	    let exp = his_self.game.state.explorations[i];

            if (exp.cabot == 1) {
              if (exp.faction == "england") { cabot_england_found = 1; }
              if (exp.faction == "france") { cabot_france_found = 1; }
              if (exp.faction == "hapsburg") { cabot_hapsburg_found = 1; }
            }

	    if (his_self.game.state.explorations[i].round == his_self.game.state.round) {
              html += `<li class="option" id="${his_self.game.state.explorations[i].faction}">${his_self.returnFactionName(his_self.game.state.explorations[i].faction)} (exploration)</li>`;
	    }
	  }
	  if (his_self.game.state.events.cabot_england == 1 && cabot_england_found == 0) {
            html += `<li class="option" id="cabot_england">sebastian cabot (england - exploration)</li>`;
	  }
	  if (his_self.game.state.events.cabot_france == 1 && cabot_france_found == 0) {
            html += `<li class="option" id="cabot_france">sebastian cabot (france - exploration)</li>`;
	  }
	  if (his_self.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0) {
            html += `<li class="option" id="cabot_hapsburg">sebastian cabot (haps - exploration)</li>`;
	  }
	  for (let i = 0; i < his_self.game.state.conquests.length; i++) {
	    if (his_self.game.state.conquests[i].round == his_self.game.state.round) {
              html += `<li class="option" id="conquest-${his_self.game.state.conquests[i].faction}">${his_self.returnFactionName(his_self.game.state.conquests[i].faction)} (conquest)</li>`;
	    }
	  }
          html += '</ul>';

 	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    if (action === "conquest-england") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels English conquest");
		his_self.addMove("remove_conquest\tengland"); 
	    }
	    if (action === "conquest-france") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels French conquest");
		his_self.addMove("remove_conquest\tfrance"); 
	    }
	    if (action === "conquest-hapsburg") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels Hapsburg conquest");
		his_self.addMove("remove_conquest\thapsburg"); 
	    }
	    if (action === "cabot_england") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels Sebastian Cabot");
		his_self.addMove("SETVAR\tstate\tevents\tcabot_england\t0"); 
	    }
	    if (action === "cabot_hapsburg") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels Sebastian Cabot");
		his_self.addMove("SETVAR\tstate\tevents\tcabot_hapsburg\t0"); 
	    }
	    if (action === "cabot_france") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels Sebastian Cabot");
		his_self.addMove("SETVAR\tstate\tevents\tcabot_france\t0"); 
	    }
	    if (action === "england") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels English exploration");
		his_self.addMove("remove_exploration\tengland"); 
	    }
	    if (action === "hapsburg") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels Hapsburg exploration");
		his_self.addMove("remove_exploration\thapsburg"); 
	    }
	    if (action === "france") {  
		his_self.addMove("NOTIFY\t"+his_self.popup('098')+" cancels French exploration");
		his_self.addMove("remove_exploration\tfrance"); 
	    }

	    his_self.endTurn();

	  });
	}
        return 0;
      },
    }
    deck['099'] = { 
      img : "cards/HIS-099.svg" , 
      name : "Sebastian Cabot" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.cabot_dead == 1) { return 0; }
	if (faction == "protestant" || faction == "england" || faction == "hapsburg") { return 1; }
	return 0;
      },
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction == "england" && his_self.game.state.events.cabot_england == 0) { return 1; }
	if (faction == "france" && his_self.game.state.events.cabot_france == 0) { return 1; }
	if (faction == "hapsburg" && his_self.game.state.events.cabot_hapsburg == 0) { return 1; }
	return 0;
      },
      onEvent(his_self, faction) {
	if (faction == "england") { his_self.game.state.events.cabot_england = 1; }
	if (faction == "france") { his_self.game.state.events.cabot_france = 1; }
	if (faction == "hapsburg") { his_self.game.state.events.cabot_hapsburg = 1; }
	his_self.displayExploration();
        return 1;
      },
    }
    deck['100'] = { 
      img : "cards/HIS-100.svg" , 
      name : "Shipbuilding" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (faction == "protestant") { return 0; }
	return 1;
      },
      onEvent(his_self, faction) {
        his_self.game.queue.push("shipbuilding_action_phase_event\t"+faction+"\t2");
        his_self.game.queue.push("shipbuilding_action_phase_event\t"+faction+"\t1");
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {
    
        if (mv[0] == "shipbuilding_action_phase_event") {
    
          his_self.game.queue.splice(qe, 1);
          let faction = mv[1];
	  let num = parseInt(mv[2]);

          let player = his_self.returnPlayerCommandingFaction(faction);

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }

          if (his_self.game.player === player) { 

	    let msg = `Select Space to add ${num} Squadron`;
	    if (faction == "ottoman") { msg = `Select Space to add ${num} Squadron/Corsairs`; }

            his_self.playerSelectSpaceWithFilter(

              msg ,

              (space) => {
                if (his_self.isSpaceControlled(space.key, faction) && space.home === faction) {
	          if (space.ports.length > 0) {
		    if (!his_self.isSpaceUnderSiege(space.key)) {
	   	      return 1;
		    }
		  }
		}
		return 0;
	      },

              (spacekey) => {

                let space = his_self.game.spaces[spacekey];

	        if (faction === "ottoman") {
		  if (spacekey === "algiers" || space.pirate_haven == 1) {
                    his_self.addMove("build\tland\t"+faction+"\t"+"corsair"+"\t"+spacekey);
                    his_self.addMove("build\tland\t"+faction+"\t"+"corsair"+"\t"+spacekey);
		    his_self.endTurn();
		  } else {

	  	    let msg = "Produce 2 Corsairs instead of Squadron?";
          	    let html = '<ul>';
          	    html += '<li class="option" id="corsair">Corsairs</li>';
          	    html += '<li class="option" id="squadron">Squadron</li>';
          	    html += '</ul>';

 		    his_self.updateStatusWithOptions(msg, html);

          	    $('.option').off();
	  	    $('.option').on('click', function () {

          	      $('.option').off();
	  	      let unittype = $(this).attr("id");
		      if (unittype == "corsair") {
                        his_self.addMove("build\tland\t"+faction+"\t"+unittype+"\t"+spacekey);
		      }
                      his_self.addMove("build\tland\t"+faction+"\t"+unittype+"\t"+spacekey);
		      his_self.endTurn();

		    });
		  }
		} else {
                  his_self.addMove("build\tland\t"+faction+"\t"+"squadron"+"\t"+spacekey);
		  his_self.endTurn();
		}
	      },
   	      null ,
	      true
	    );
          }
	  return 0;
	}
	return 1;
      },
    }
    deck['101'] = { 
      img : "cards/HIS-101.svg" , 
      name : "Smallpox" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (
		(faction == "england" && his_self.game.state.may_conquer["england"] == 1) ||
		(faction == "france" && his_self.game.state.may_conquer["france"] == 1) ||
		(faction == "hapsburg" && his_self.game.state.may_conquer["hapsburg"] == 1) 
	) {	
		return 1; 
	}
	return 0;
      },
      onEvent(his_self, faction) {
	his_self.game.queue.push("conquer\t"+faction);
	his_self.game.state.events.smallpox = faction;
        return 1;
      },
    }
    deck['102'] = { 
      img : "cards/HIS-102.svg" , 
      name : "Spring Preparations" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      menuOption  :  function(his_self, menu, player) {
        if (menu == "pre_spring_deployment") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('102')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '102', html : `<li class="option" id="102">spring preparations (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "pre_spring_deployment") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('102')) {
	      if (his_self.returnPlayerOfFaction("protestant") == his_self.game.player && his_self.game.players.length == 2) { 
 		return 0;
	      }
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_spring_deployment") {
	  if (his_self.game.player === player) {
            his_self.addMove("spring_preparations\t"+faction);
	    his_self.endTurn();
	  }
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "spring_preparations") {

          let faction = mv[1];

	  let capitals = his_self.returnCapitals(faction);
	  for (let i = 0; i < capitals.length; i++) {
	    his_self.addRegular(faction, capitals[i], 1);
	    his_self.displaySpace(capitals[i]);
	  }

          his_self.game.state.spring_deploy_across_passes.push(faction);
          his_self.game.state.spring_deploy_across_seas.push(faction);
          his_self.game.state.events.spring_preparations = faction;

	  // hide so that it will re-appear...
	  if (his_self.spring_deployment_overlay) { his_self.spring_deployment_overlay.hide(); }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }

	return 1;

      },
    }
    deck['103'] = { 
      img : "cards/HIS-103.svg" , 
      name : "Threat to Power" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let msg = "Target Which Minor Army Leader?";
          let html = '<ul>';
	  if (his_self.returnSpaceOfPersonage("england", "charles-brandon") != "" && his_self.game.state.leaders.henry_viii == 1) {
            html += '<li class="option" id="charles-brandon">Charles Brandon (England)</li>';
	  }
	  if (his_self.returnSpaceOfPersonage("hapsburg", "duke-of-alva") != "") {
            html += '<li class="option" id="duke-of-alva">Duke of Alva (Hapsburgs)</li>';
          }
	  if (his_self.returnSpaceOfPersonage("france", "montmorency") != "") {
            html += '<li class="option" id="montmorency">Montmorency (France)</li>';
          }
	  if (his_self.returnSpaceOfPersonage("ottoman", "ibrahim-pasha") != "") {
            html += '<li class="option" id="ibrahim-pasha">Ibrahim Pasha (Ottomans)</li>';
          }
	  html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
	  $('.option').on('click', function () {

            $('.option').off();
	    let action = $(this).attr("id");

	    his_self.addMove("threat_to_power\t"+action);
	    his_self.endTurn();


	  });
	}

	return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "threat_to_power") {

          his_self.game.queue.splice(qe, 1);

	  let leader = mv[1];
	  let faction = "";
	  let leader_found = false;
	  let leader_name = "";

	  if (leader == "charles-brandon") 	{ leader = "charles-brandon"; leader_name = "Charles Brandon"; faction = "england"; }
	  if (leader == "duke-of-alva") 	{ leader = "duke-of-alva"; leader_name = "Duke of Alva"; faction = "hapsburg"; }
	  if (leader == "montmorency") 		{ leader = "montmorency"; leader_name = "Montmorency"; faction = "france"; }
	  if (leader == "ibrahim-pasha") 	{ leader = "ibrahim-pasha"; leader_name = "Ibrahim Pasha"; faction = "ottoman"; }

	  let r = his_self.rollDice(6);

	  his_self.updateLog(his_self.popup("103") + " rolls " + r);

	  let idx = -1;
	  let s = his_self.returnSpaceOfPersonage(faction, leader);
	  if (s) {
	    idx = his_self.returnIndexOfPersonageInSpace(faction, leader, s); 
	    leader_found = true;
	  }

	  //
	  // permanently removed from game
	  //
	  if (r >= 4) {

	    his_self.updateLog(leader_name + " removed from game...");
	    salert(leader_name + " removed from game...");

	    if (leader_found) {
	      his_self.game.spaces[s].units[faction].splice(idx, 1);
	      his_self.displaySpace(s);
	    }

	  //
	  // temporarily removed from game
	  //
	  } else {

	    his_self.updateLog(leader_name + " removed until next turn...");
	    salert(leader_name + " removed until next turn...");

            if (s !== "") {
              idx = his_self.returnIndexOfPersonageInSpace(faction, leader, s);
            }

            let obj = {};
            obj.space = s;
            obj.faction = faction;
	    if (his_self.game.spaces[s]) {
              obj.leader = his_self.game.spaces[s].units[faction][idx];
              if (idx != -1) {
                his_self.game.spaces[s].units[faction].splice(idx, 1);
              }
              his_self.game.state.military_leaders_removed_until_next_round.push(obj);
	    }

	    his_self.displaySpace(s);

	  }
        }

	return 1;
      }
    }
    deck['104'] = { 
      img : "cards/HIS-104.svg" , 
      name : "Trace Italienne" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	//if (his_self.game.state.events.schmalkaldic_league != 1 && faction == "protestant") { return 0; }
	return 1;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          his_self.playerSelectSpaceWithFilter(

            "Select Space to Fortify" ,

            function(space) {
              if (space.type != "fortress" && space.type != "electorate" && space.type != "key") { return 1; }
	      return 0;
            },

            function(spacekey) {
	      his_self.updateStatus("selected...");
	      let s = his_self.game.spaces[spacekey];
	      if (s.home === "independent" && s.political === "") {
	      } else {
		let controller = s.political;
		if (controller == "") { controller = s.home; }
		if (controller == "") { controller = "independent"; }
                his_self.addMove("build\tland\t"+controller+"\t"+"regular"+"\t"+spacekey);
	      }
	      his_self.addMove(`NOTIFY\t${his_self.returnFactionName(faction)} adds fortress to ${his_self.returnName(spacekey)}`);
              his_self.addMove("fortify\t"+spacekey);
	      his_self.endTurn();
            },

	    null,

	    true

          );
        } else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("104"));;
	}

        return 0;
      },
    }
    deck['105'] = { 
      img : "cards/HIS-105.svg" , 
      name : "Treachery!" ,
      ops : 5 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let spaces_under_siege = his_self.countSpacesWithFilter(
	  function(space) {
	    if (
	      space.besieged > 0
	    ) {
	      return 1;
	    }
	    return 0;
	  }
	);
	if (spaces_under_siege > 0) {
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          his_self.playerSelectSpaceWithFilter(

            "Select Space Under Siege:" ,

            function(space) {
              if (space.besieged > 0) { return 1; }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let attacker = "";

	      for (let key in space.units) {
		for (let i = 0; i < space.units[key].length; i++) {
		  let u = space.units[key][i];
		  if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
		    if (space.units[key][i].besieged != 1 && space.units[key][i].besieged != true) {
		      attacker = key;
		      if (attacker == "protestant" || attacker == "papacy" || attacker == "hapsburg" || attacker == "ottoman" || attacker == "england" || attacker == "france") { break; }
		    }
		  }
		}
	      }
	      // emergency sanity check -- anyone
	      if (attacker == "") {
		for (let key in space.units) {
		  for (let z = 0; z < space.units[key].length; z++) {
		    let u = space.units[key][z];
		    if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { attacker = key; }
		  }
	        }
	      }	      


	      if (attacker != "") {
                his_self.addMove("remove_siege\t"+spacekey);
                his_self.addMove("treachery\t"+attacker+"\t"+spacekey);
	        his_self.addMove("assault\t"+attacker+"\t"+spacekey);
                his_self.endTurn();
	      } else {
                his_self.addMove("NOTIFY\t"+his_self.popup("105") + " cannot find attacker in siege");
                his_self.endTurn();
	      }
            }
          );

          return 0;
        }
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "treachery") {

          his_self.game.queue.splice(qe, 1);
	  
	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = "";

	  let defenders = [];
	  let space = his_self.game.spaces[spacekey];

	  let total_attackers = 0;
	  let total_defenders = 0;

	  for (let key in space.units) {
	    if (space.units[key].length > 0) {
	      if (space.units[key][0].besieged > 0) {
		total_defenders += his_self.returnFactionLandUnitsInSpace(key, spacekey);
		defenders.push(key);
	      }
	      if (space.units[key][0].besieged == 0) {
		total_attackers += his_self.returnFactionLandUnitsInSpace(key, spacekey);
	      }
	    }
	  }

	  if (total_defenders < total_attackers && total_attackers > 0) {
	    his_self.game.queue.push(`control\t${attacker}\t${spacekey}`);
	    his_self.updateLog(his_self.popup("105") + " - besiegers capture defenders and control space");
	    for (let i = 0; i < defenders.length; i++) {
	      his_self.game.queue.push(`purge_units_and_capture_leaders\t${defenders[i]}\t${attacker}\t${spacekey}`);
	    }
	  }

	}

        return 1;
      },
    }
    deck['106'] = { 
      img : "cards/HIS-106.svg" , 
      name : "Unpaid Mercenaries" ,
      ops : 3 ,
      turn : 3 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	let spaces_with_mercenaries = his_self.countSpacesWithFilter(
	  function(space) {
	    for (let key in space.units) {
	      for (let i = 0; i < space.units[key].length; i++) {
		if (space.units[key][i].type == "mercenary") { return 1; }
	      }
	    }
	    return 0;
	  }
	);
	if (spaces_with_mercenaries > 0) { 
	  return 1;
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

          let sswf_function = () => {

          his_self.playerSelectSpaceWithFilter(
	
            "Select Space With Unpaid Mercenaries" ,

            function(space) {
	      for (let key in space.units) {
	        for (let i = 0; i < space.units[key].length; i++) {
	  	  if (space.units[key][i].type == "mercenary") { return 1; }
	        }
	      }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let factions = [];

	      for (let key in space.units) {
		for (let i = 0; i < space.units[key].length; i++) {
		  if (space.units[key][i].type == "mercenary") {
		    if (!factions.includes(key)) {
		      factions.push(key);
		    }
		  }
		}
	      }

	      if (factions.length > 0) {

 	        let msg = "Choose Faction to Lose Mercenaries:";
                let html = '<ul>';
	        for (let i = 0; i < factions.length; i++) {
                  html += `<li class="option" id="${factions[i]}">${factions[i]}</li>`;
		}
                html += `<li class="option" id="switch">change target</li>`;
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

 		$('.option').off();
	  	$('.option').on('click', function () {

 		  $('.option').off();
	    	  let action = $(this).attr("id");

		  // we can switch if we want now
		  if (action == "switch") { sswf_function(); return; }

                  his_self.addMove("maybe_evacuate_or_capture_leaders\t"+action+"\t"+spacekey);
		  his_self.addMove(`unbesiege_if_empty\t${spacekey}\t${action}`);
		  for (let z = 0; z < his_self.game.spaces[spacekey].units[action].length; z++) {
		    if (his_self.game.spaces[spacekey].units[action][z].type === "mercenary") {
		      his_self.addMove(`destroy_unit_by_index\t${action}\t${spacekey}\t${z}`);
		    }
		  }
		  his_self.addMove(`NOTIFY\t${his_self.popup("106")} destroys all mercenaries in ${his_self.returnSpaceName(spacekey)}`);
		  his_self.endTurn();
		});

	      } else {
                his_self.addMove("maybe_evacuate_or_capture_leaders\t"+factions[0]+"\t"+spacekey);
		his_self.addMove(`unbesiege_if_empty\t${spacekey}\t${factions[0]}`);
		for (let z = 0; z < his_self.game.spaces[spacekey].units[factions[0]].length; z++) {
		  if (his_self.game.spaces[spacekey].units[factions[0]][z].type === "mercenary") {
		    his_self.addMove(`destroy_unit_by_index\t${factions[0]}\t${spacekey}\t${z}`);
		  }
		}
		his_self.endTurn();
	      }
            },

	    null,

	    true
          );
	} // sswf_function
	sswf_function();

        }

        return 0;
      },
    }
    deck['107'] = { 
      img : "cards/HIS-107.svg" , 
      name : "Unsanitary Camp" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerOfFaction(faction);
	if (p == his_self.game.player) {

	  let sswf_function = () => {

          his_self.playerSelectSpaceWithFilter(

            "Select Space With Land Units" ,

            function(space) {
	      for (let key in space.units) {
	        if (his_self.returnFactionLandUnitsInSpace(key, space.key) > 0) { return 1; }
	      }
	      return 0;
            },

            function(spacekey) {

	      let space = his_self.game.spaces[spacekey];
	      let factions = [];

	      for (let key in space.units) {
	        if (his_self.returnFactionLandUnitsInSpace(key, space.key) > 0) { factions.push(key); }
	      }

	      if (factions.length > 0) {

 	        let msg = "Choose Faction to Suffer Losses:";
                let html = '<ul>';
		let op = 0;
	        for (let i = 0; i < factions.length; i++) {
		  op++;
                  html += `<li class="option" id="${factions[i]}">${factions[i]}</li>`;
		}
                html += `<li class="option" id="switch">change target</li>`;
    	        html += '</ul>';

                his_self.updateStatusWithOptions(msg, html);

 		$('.option').off();
	  	$('.option').on('click', function () {

 		  $('.option').off();
	    	  let action = $(this).attr("id");

		  if (action == "switch") {
		    sswf_function(); return;
		  }

		  if (his_self.game.player == his_self.returnPlayerCommandingFaction(action)) {
                    let c = confirm("Unorthodox! Are you sure you want to sicken your own men?");
                    if (!c) { sswf_function(); return; }
            	  }

		  let total_units = 0;
		  let regular_units = 0;
		  let total_to_delete = 0;
		  let regulars_to_delete = 0;
		  let nonregulars_to_delete = 0;

		  for (let f in his_self.game.spaces[spacekey].units) {
		    if (his_self.returnControllingPower(f) == his_self.returnControllingPower(action)) {
		      for (let z = his_self.game.spaces[spacekey].units[f].length-1; z >= 0; z--) {
		        let u = his_self.game.spaces[spacekey].units[f][z];
		        if (u.type == "regular") { regular_units++; }
		        if (u.type == "cavalry" || u.type == "regular" || u.type == "mercenary") { total_units++; }
		      }
		    }
		  }

		  total_to_delete = Math.ceil(total_units/3);
		  regulars_to_delete = Math.ceil(total_to_delete/2);
		  nonregulars_to_delete = total_to_delete - regulars_to_delete;
		
	          his_self.addMove("check_for_stranded_leaders\t"+faction);

		  for (let f in his_self.game.spaces[spacekey].units) {
		    if (his_self.returnControllingPower(f) == his_self.returnControllingPower(action)) {
		      for (let z = his_self.game.spaces[spacekey].units[f].length-1; z >= 0; z--) {
		        let u = his_self.game.spaces[spacekey].units[f][z];
		        if (u.type == "regular" && regulars_to_delete > 0) {
		          his_self.addMove(`destroy_unit_by_type\t${f}\t${spacekey}\t${u.type}`);
		          regulars_to_delete--;
		        }
		        if (u.army_leader != true && u.navy_leader != true && u.type != "regular" && (u.type == "mercenary" || u.type == "cavalry") && nonregulars_to_delete > 0) {
		          his_self.addMove(`destroy_unit_by_type\t${f}\t${spacekey}\t${u.type}`);
		          nonregulars_to_delete--;
		        }
		      }
		    }
		  }

		  if (total_to_delete > 1) {
		    his_self.addMove(`SALERT\tUnsanitary Camp destroys ${total_to_delete} ${his_self.returnFactionName(action)} units in ${his_self.returnSpaceName(spacekey)}`); 
		  } else {
		    his_self.addMove(`SALERT\tUnsanitary Camp destroys ${total_to_delete} ${his_self.returnFactionName(action)} units in ${his_self.returnSpaceName(spacekey)}`); 
		  }
		  his_self.addMove(`NOTIFY\t${his_self.popup("107")} strikes ${his_self.returnSpaceName(spacekey)}`); 
		  his_self.endTurn();
		});

	        // auto-submit if only 1 choice
                if (op == 1) { $('.option').click(); }

	      } else {

		let action = factions[0];
		let total_units = 0;
		let regular_units = 0;
		let total_to_delete = 0;
		let regulars_to_delete = 0;
		let nonregulars_to_delete = 0;

		for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		  let u = his_self.game.spaces[spacekey].units[action][z];
		  if (u.type == "regular") { regular_units++; }
		  if (u.type == "cavalry" || u.type == "regular" || u.type == "mercenary") { total_units++; }
		}

		total_to_delete = Math.ceil(total_units/3);
		regulars_to_delete = Math.ceil(total_to_delete/2);
		nonregulars_to_delete = total_to_delete - regulars_to_delete;
		
		for (let z = his_self.game.spaces[spacekey].units[action].length-1; z >= 0; z--) {
		  let u = his_self.game.spaces[spacekey].units[action][z];
		  if (u.army_leader != true) {
		    if (u.type == "regular" && regulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		    }
		    if ((u.type != "regular" && (u.type == "mercenary" || u.type == "cavalry")) && nonregulars_to_delete > 0) {
		      his_self.addMove(`destroy_unit_by_type\t${action}\t${spacekey}\t${u.type}`);
		      nonregulars_to_delete--;
		    }
		  }
		}
		his_self.endTurn();
	      }
            },

	    null,

	    true
          );

	  } // sswf
	  sswf_function();

        } else {
	  his_self.updateLog(his_self.returnFactionName(faction) + " playing " + his_self.popup("107"));
	}
        return 0;
      },
    }
    deck['108'] = { 
      img : "cards/HIS-108.svg" , 
      name : "Venetian Alliance" ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { 
	if (faction == "papacy") { return 1; }
	if (faction == "ottoman") { return 1; }
	return 0;
      },
      onEvent : function(his_self, faction) {

	let ally = his_self.returnAllyOfMinorPower("venice");

	if ((ally === "" || ally === "venice") && faction === "papacy") {
	  his_self.activateMinorPower("papacy", "venice");
	} else {
	  if (faction === "papacy" || faction === "ottoman") {
	    his_self.deactivateMinorPower(ally, "venice");
	  }
	}
	his_self.displayWarBox();

	return 1;

      },
    }
    deck['109'] = { 
      img : "cards/HIS-109.svg" , 
      name : "Venetian Informant" ,
      ops : 1 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 0; },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "pre_spring_deployment") {
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('109')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '109', html : `<li class="option" id="109">venetian informant (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "pre_spring_deployment") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('109')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "pre_spring_deployment") {
	  if (his_self.game.player === player) {
            his_self.addMove("discard\t"+faction+"\t109");
            his_self.addMove("venetian_informant\t"+faction);
            his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" plays " + his_self.popup("109"));
	    his_self.endTurn();
	  }
        }
        return 0;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] === "show_hand") {
        
          let faction_taking = mv[1];
          let faction_giving = mv[2];
          
          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);
          
          if (his_self.game.player == p2) {
            let fhand_idx = his_self.returnFactionHandIdx(p2, faction_giving);
            his_self.addMove("share_hand\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
            his_self.endTurn();
          }

          his_self.game.queue.splice(qe, 1);
          return 0;

        }

        if (mv[0] === "share_hand") {
        
          let faction_taking = mv[1];
          let faction_giving = mv[2];
          let cards = JSON.parse(mv[3]);

          let p1 = his_self.returnPlayerOfFaction(faction_taking);
          let p2 = his_self.returnPlayerOfFaction(faction_giving);
          
          if (his_self.game.player == p1) {
	    for (let i = 0; i < cards.length; i++) {
	      his_self.updateLog(his_self.returnFactionName(faction_giving) + ": " + his_self.popup(cards[i]));
	    }
	    his_self.deck_overlay.render("Venetian Informant", cards);
          }

          his_self.game.queue.splice(qe, 1);
          return 1;

        }


        if (mv[0] == "venetian_informant") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = his_self.returnPlayerOfFaction(faction);

	  if (player == his_self.game.player) {

	    if (his_self.game.players.length == 2) {

	      if (faction === "protestant") {
	        his_self.addMove("show_hand\tprotestant\tpapacy");
	        his_self.endTurn();
	      } else {
	        his_self.addMove("show_hand\tpapacy\tprotestant");
	        his_self.endTurn();
	      }

	      return 0;

	    } else {

	      let powers = his_self.returnImpulseOrder();
	      let msg = "View which Faction Cards?";

              let html = '<ul>';
	      for (let i = 0; i < powers.length; i++) {
	        if (powers[i] != faction && his_self.returnPlayerCommandingFaction(powers[i]) > 0) {
                  html += `<li class="option" id="${powers[i]}">${his_self.returnFactionName(powers[i])}</li>`;
	        }
	      }
              html += '</ul>';

    	      his_self.updateStatusWithOptions(msg, html);

	      $('.option').off();
	      $('.option').on('click', function () {
	        $('.option').off();
	        let action = $(this).attr("id");
	        his_self.addMove("show_hand\t"+faction+"\t"+action);
	        his_self.endTurn();
	      });

	    }

	  }

	  return 0;

        }

	return 1;

      },
    }
    deck['110'] = { 
      img : "cards/HIS-110.svg" , 
      name : "War in Persia" ,
      warn : ["ottoman"] ,
      ops : 4 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent(his_self, faction) {
        if (his_self.game.state.events.war_in_persia == 1) { return 0; }
        return 1;
      },
      onEvent(his_self, faction) {

	his_self.displayPersia();

        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);
        his_self.addRegular("independent", "persia", 1);

        his_self.game.state.events.war_in_persia = 1;

        his_self.game.queue.push("check_for_broken_sieges");
        his_self.game.queue.push("war_in_persia_leader_removal\tottoman");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t5");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t4");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t3");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t2");
        his_self.game.queue.push("war_in_persia_troop_removal\tottoman\t1");

	return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

        if (mv[0] == "war_in_persia_leader_removal") {

          his_self.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

   	    let msg = "Move Army Leader: ";
	    let options = [];
	    for (let key in his_self.game.spaces) {
	      if (key != "persia" && key != "egypt" && key != "ireland") {
	        let space = his_self.game.spaces[key];
                for (let i = 0; i < space.units["ottoman"].length; i++) {
                  let u = space.units["ottoman"][i];
	          if (u.army_leader) {
	            options.push({ spacekey : key , idx : i , name : u.name });
	          }
	        }
	      }
	    }

            let html = '<ul>';
	    for (let i = 0; i < options.length; i++) {
  	      html += `<li class="option" id="${i}">${options[i].name}</li>`;
	    }
  	    html += `<li class="option" id="skip">skip</li>`;
    	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

   	    $('.option').off();
	    $('.option').on('click', function () {

   	      $('.option').off();
	      let options_idx = $(this).attr("id");

	      if (options_idx === "skip") {
                his_self.endTurn();
	        return 0;
	      }

              his_self.addMove("move\tottoman\tland\t"+options[options_idx].spacekey+"\tpersia\t"+options[options_idx].idx);
              his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus("Ottomans selecting Foreign War Leader...");
	  }

	  return 0;

        }

	//
	// this copies the logic from Plague
	//
        if (mv[0] == "war_in_persia_troop_removal") {

	  let faction = mv[1];
	  let num = parseInt(mv[2]);
	  let player = his_self.returnPlayerOfFaction(faction);

          his_self.game.queue.splice(qe, 1);

	  if (his_self.game.player != player) { return 0; }

	  if (num == 1) { num = "1st"; }
	  if (num == 2) { num = "2nd"; }
	  if (num == 3) { num = "3rd"; }
	  if (num == 3) { num = "4th"; }
	  if (num == 3) { num = "5th"; }

          his_self.playerSelectSpaceOrNavalSpaceWithFilter(

            `Select Space to Remove ${num} Unit` ,

            function(space) {
	      if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	      if (space.units["ottoman"].length > 0) {
		  for (let z = 0; z < space.units["ottoman"].length; z++) {
		    let u = space.units["ottoman"][z];
		    if (u.type === "regular") { return 1; }
		    if (u.type === "mercenary") { return 1; }
		    if (u.type === "cavalry") { return 1; }
		  }
	      }
	      return 0;
            },

            function(spacekey) {

	      let land_or_sea = "land";
	      let space = null;

	      if (his_self.game.navalspaces[spacekey]) {
		land_or_sea = "sea";
		space = his_self.game.navalspaces[spacekey];
	      } else {
		space = his_self.game.spaces[spacekey];
	      }
	   
	      if (space == null) {
		alert("ERROR: not sure where you clicked - reload to continue");
		return 1;
	      }
	      
   	      let msg = "Remove Which Unit: ";
              let unittypes = ["squadron","corsair"]; // avoids listing these units
	      let unit_destroyed = 0;
              let html = '<ul>';
	      let du = -1;
              for (let i = 0; i < space.units["ottoman"].length; i++) {
                if (space.units["ottoman"][i].command_value == 0) {
		  if (!unittypes.includes(space.units["ottoman"][i].type) && space.units["ottoman"][i].army_leader != true && space.units["ottoman"][i].personage != true) {
		    if (du == -1) { du = i; } else { du = -2; }
  		    html += `<li class="option nonskip" id="${space.units["ottoman"][i].type}">${space.units["ottoman"][i].type}</li>`;
		    unittypes.push(space.units["ottoman"][i].type);
		  }
		}
	      }

  	      html += `<li class="option" id="skip">skip</li>`;
    	      html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

   	      $('.option').off();
	      $('.option').on('click', function () {

   	        $('.option').off();
	        let unittype = $(this).attr("id");
		if (unit_destroyed == 1) { return; }	
		unit_destroyed = 1;

		if (unittype === "skip") {
//          	  his_self.endTurn();
//		  return 0;
		}

          	his_self.removeUnit("ottoman", spacekey, unittype);

		his_self.displaySpace(spacekey);

		if (num === "5th") { 
		  return 0;
		}

          	his_self.addMove("remove_unit\t"+land_or_sea+"\t"+"ottoman"+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
          	his_self.addMove("build\tland\tottoman\t"+unittype+"\tpersia");
          	his_self.endTurn();
	      });

	      // auto-submit if only 1 choice
	      if (du > -1) { $('.nonskip').click(); }

            },

            null, 

	    true

	  );

          return 0;

	}

        return 1;
      }
    }
    deck['111'] = { 
      img : "cards/HIS-111.svg" , 
      name : "Colonial Governor/Native Uprising" ,
      ops : 2 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerCommandingFaction(faction);

	if (his_self.game.player == p) {

          let html = '<ul>';
              html += `<li class="option" id="governor">Colonial Governor</li>`;
              html += `<li class="option" id="uprising">Native Uprising</li>`;
              html += '</ul>';

          his_self.updateStatusWithOptions("Select Colony-Roll Modifier:", html);

 	  $('.option').off();
	  $('.option').on('click', function () {

	    his_self.updateStatus("selecting...");
 	    $('.option').off();
	    let modifier = $(this).attr("id");

	    if (modifier == "governor") {

              let html = '<ul>';
                  html += `<li class="option" id="hapsburg">Hapsburg Governor</li>`;
                  html += `<li class="option" id="england">English Governor</li>`;
                  html += `<li class="option" id="france">French Governor</li>`;
                  html += '</ul>';
              his_self.updateStatusWithOptions("Select Colonial Governor", html);

 	      $('.option').off();
	      $('.option').on('click', function () {
	        his_self.updateStatus("selecting...");
 	        $('.option').off();
	        let action = $(this).attr("id");
	        his_self.addMove("display_new_world");
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" selected " + his_self.returnFactionName(action) + " governor");
	        his_self.addMove("SETVAR\tstate\tevents\tcolonial_governor\t"+action);
	        his_self.addMove("SETVAR\tstate\tevents\tnative_uprising\t0");
	        his_self.endTurn();	    
	      });

	    } else {

              let html = '<ul>';
                  html += `<li class="option" id="hapsburg">Destablize Hapsburg Colonies</li>`;
                  html += `<li class="option" id="england">Destabilize English Colonies</li>`;
                  html += `<li class="option" id="france">Destabilize French Colonies</li>`;
                  html += '</ul>';
              his_self.updateStatusWithOptions("Select Target for Native Uprising:", html);

 	      $('.option').off();
	      $('.option').on('click', function () {
	        his_self.updateStatus("selecting...");
 	        $('.option').off();
	        let action = $(this).attr("id");
	        his_self.addMove("display_new_world");
	        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" targets " + his_self.returnFactionName(action) + " colonies");
	        his_self.addMove("SETVAR\tstate\tevents\tcolonial_governor\t0");
	        his_self.addMove("SETVAR\tstate\tevents\tnative_uprising\t"+action);
	        his_self.endTurn();	    
	      });
	    }
	  });
        } else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing Colonial Governor");
	}

	return 0;

      },
    }
    deck['112'] = { 
      img : "cards/HIS-112.svg" , 
      name : "Thomas More" ,
      ops : 3 ,
      turn : 1 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	if (faction === "protestant" || faction === "england") {

	  let p = his_self.returnPlayerCommandingFaction("england");

          his_self.game.state.events.more_executed_limits_debates = 1;
	  his_self.game.state.events.more_executed = 1;

	  if (p > 0) {
            his_self.game.queue.push('remove\t'+faction+'\t112');
            his_self.game.queue.push('select_and_discard\t' + faction);
            his_self.game.queue.push('hand_to_fhand\t1\t' + p + '\t' + faction + "\t1");
            his_self.game.queue.push('DEAL\t1\t' + p + '\t' + 2);
	  }
          his_self.game.queue.push("NOTIFY\tThomas More prevents debates in England this turn");

	} else {

	  his_self.game.state.events.more_bonus = 1;
	  if (his_self.game.state.events.henry_viii_marital_status >= 2) {
            his_self.game.queue.push('remove\t'+faction+'\t112');
	  }

	  //
	  // pope gets to call a debate and gets +1 bonus dice in England 
	  // or +3 bonus dice in England.
	  //
	  if (his_self.returnPlayerCommandingFaction("papacy") == his_self.game.player) {

            let msg = "Convene Theological Debate?";
            let html = '<ul>';
            html += `<li class="option" id="yes">yes</li>`;
            html += `<li class="option" id="no">no</li>`;
            html += '</ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action2 = $(this).attr("id");
              his_self.updateStatus("submitting...");

              if (action2 === "yes") {
                his_self.playerCallTheologicalDebate(his_self, his_self.game.player, "papacy");
                return 0;
              }

              // no
              his_self.updateLog("Papacy refrains from holding debate");
              his_self.endTurn();

            });

	  }

	  return 0;

	}

	return 1;
      },

    }
    deck['113'] = { 
      img : "cards/HIS-113.svg" , 
      name : "Imperial Coronation" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) {
	let s = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	if (s) { if (s.language == "italian") { return 1; } }
	return 0;
      },
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let s = his_self.returnSpaceOfPersonage("hapsburg", "charles-v");
	if (s) {
	  try { if (his_self.game.spaces[s]) { s = his_self.game.spaces[s]; } } catch (err) {}
	  if (s.language == "italian") {

    	    let hp = his_self.returnPlayerOfFaction("hapsburg");
  	    let pf = his_self.returnPlayerOfFaction(faction);

	    if (faction !== "hapsburg") {
	      if (his_self.game.players.length != 2) {
	        his_self.game.queue.push("hand_to_fhand\t1\t"+hp+"\t"+"hapsburg"+"\t1");
                his_self.game.queue.push(`DEAL\t1\t${hp}\t1`);
	      } else {
	        his_self.game.queue.push("hand_to_fhand\t1\t"+pf+"\t"+faction+"\t1");
                his_self.game.queue.push(`DEAL\t1\t${pf}\t1`);
	      }
	    } else {
	      his_self.game.queue.push("hand_to_fhand\t1\t"+pf+"\t"+"hapsburg"+"\t1");
              his_self.game.queue.push(`DEAL\t1\t${pf}\t1`);
              his_self.game.queue.push(`DEAL\t1\t${pf}\t1`);
	    }
	  }
	}

	return 1;
      },
    }
    deck['114'] = { 
      img : "cards/HIS-114.svg" , 
      name : "La Forets's Embassy in Istanbul" ,
      ops : 2 ,
      turn : 3 ,
      type : "mandatory" ,
      removeFromDeckAfterPlay : function(his_self, player) { if (his_self.areAllies("ottoman", "france")) { return 1; } return 0; } ,
      canEvent : function(his_self, faction) { if (his_self.areAllies("ottoman", "france")) { return 1; }; return 0; },
      onEvent : function(his_self, faction) {

	if (his_self.areAllies("ottoman", "france")) {

  	  let fp = his_self.returnPlayerOfFaction("france");
  	  let op = his_self.returnPlayerOfFaction("ottoman");

	  his_self.game.queue.push("hand_to_fhand\t1\t"+op+"\t"+"ottoman" + "\t1");
          his_self.game.queue.push(`DEAL\t1\t${op}\t1`);
	  his_self.game.queue.push("hand_to_fhand\t1\t"+fp+"\t"+"france" + "\t1");
          his_self.game.queue.push(`DEAL\t1\t${fp}\t1`);
	
	}

	return 1;
      },
    }
    deck['115'] = { 
      img : "cards/HIS-115.svg" , 
      name : "Thomas Cromwell" ,
      ops : 3 ,
      turn : 4 ,
      type : "response" ,
      canEvent : function(his_self, faction) { return 1; },
      onEvent : function(his_self, faction) {

	let p = his_self.returnPlayerCommandingFaction(faction);

	if (his_self.game.player == p) {

   	let msg = "Which Action?";
        let html = '<ul>';
        if (his_self.game.deck[0].discards["063"]) {
          html += '<li class="option showcard" id="063">retrieve Dissolution of the Monasteries</li>';
        }
        html += '<li class="option" id="treatise">publish treatise in England</li>';
    	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

	$('.option').off();
	$('.option').on('click', function () {

	  $('.option').off();
	  let action = $(this).attr("id");
	  his_self.updateStatus("processing");

	  if (action === "063") {
	    his_self.addMove("thomas_cromwell_retrieves_monasteries");
	    his_self.endTurn();
	  }

	  if (action === "treatise") {
	    his_self.addMove("SETVAR\tstate\tevents\tcromwell\t1");
	    his_self.addMove("player_publish_treatise\tengland");
	    his_self.endTurn();
	  }

	  return 0;
	});

	} else {
	  his_self.updateStatus(his_self.returnFactionName(faction) + " playing " + his_self.popup("115") );
	}
	return 0;
      },
      removeFromDeckAfterPlay : function(his_self, player) {
	if (his_self.game.state.henry_viii_rolls.includes(1)) { return 1; }
	if (his_self.game.state.henry_viii_rolls.includes(2)) { return 1; }
	if (his_self.game.state.henry_viii_rolls.includes(3)) { return 1; }
	return 0;
      },
      menuOption  :       function(his_self, menu, player) {
        if (menu == "papal_bull_cranmer_excommunication") {
	  if (his_self.game.state.active_player === his_self.game.player) { return {}; }
          let f = "";
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('115')) {
              f = his_self.game.state.players_info[his_self.game.player-1].factions[i];
              break;
            }
          }
          return { faction : f , event : '115', html : `<li class="option blink" id="115">thomas cromwell (${f})</li>` };
        }
        return {};
      },
      menuOptionTriggers:  function(his_self, menu, player, extra) {
        if (menu == "papal_bull_cranmer_excommunication") {
          for (let i = 0; i < his_self.game.deck[0].fhand.length; i++) {
            if (his_self.game.deck[0].fhand[i].includes('115')) {
              return 1;
            }
          }
        }
        return 0;
      },
      menuOptionActivated:  function(his_self, menu, player, faction) {
        if (menu == "papal_bull_cranmer_excommunication") {
	  his_self.addMove(`thomas_cromwell_cancels_bull`);
  	  his_self.addMove("discard\t"+faction+"\t"+"115");
	  his_self.endTurn();
        }
        return 1;
      },
      handleGameLoop : function(his_self, qe, mv) {

	if (mv[0] === "thomas_cromwell_retrieves_monasteries") {
          if (his_self.game.deck[0].discards["063"]) {
	    his_self.game.deck[0].cards["063"] = his_self.game.deck[0].discards["063"];
	    delete his_self.game.deck[0].discards["063"];
	    if (his_self.game.player == his_self.returnPlayerCommandingFaction("england")) {
              let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, "england");
	      his_self.game.deck[0].fhand[fhand_idx].push("063");
	    }
	  }
	  his_self.game.queue.splice(qe, 1);
	  return 1;
	}

        if (mv[0] === "thomas_cromwell_cancels_bull") {
	  his_self.updateLog("Thomas Cromwell cancels Cranmer Excommunication");
          his_self.game.queue.splice(qe, 1);
	  // cancel the excommunication and fall through
	  for (let z = his_self.game.queue.length-1; z >= 1; z--) {
	    let lmv = his_self.game.queue[z].split("\t");
	    if (lmv[0] != "continue" && lmv[0] != "cards_left" && lmv[0] != "play" && lmv[0] != "discard") {
              his_self.game.queue.splice(z, 1);
	    }
	  } 
	  return 1;
	}

	return 1;
      },
    }
    deck['116'] = { 
      img : "cards/HIS-116.svg" , 
      name : "Rough Wooing" ,
      ops : 3 ,
      turn : 5 ,
      type : "normal" ,
      removeFromDeckAfterPlay : function(his_self, player) { return 0; } ,
      canEvent : function(his_self, faction) {
	if (his_self.game.state.henry_viii_healthy_edward == 1 || his_self.game.state.henry_viii_sickly_edward == 1) {
	  if (his_self.areAllies("france", "scotland")) {
	    return 1;
	  }
	}
	return 0;
      },
      onEvent : function(his_self, faction) {

	let england_roll = his_self.rollDice(6);
	let france_roll = his_self.rollDice(6);
	let spaces = ["stirling","glasgow","edinburgh"];

	let english_units = 0;
	let french_units = 0;

	for (let i = 0; i < spaces.length; i++) {
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["england"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["england"][z];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { english_units++; }
	  }
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["france"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["france"][z];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { french_units++; }
	  }
	  for (let z = 0; z < his_self.game.spaces[spaces[i]].units["scotland"].length; z++) {
	    let u = his_self.game.spaces[spaces[i]].units["scotland"][z];
	    if (u.type == "squadron" || u.type == "mercenary" || u.type == "regular") { french_units++; }
	  }
	}
	
	his_self.updateLog("French roll: " + france_roll + " (+2)");
	his_self.updateLog("English roll: " + england_roll);

	if ((2+french_units) <= english_units) {
	  his_self.unsetAllies("france","scotland");
	  his_self.setAllies("england","scotland");
	  for (let i = 0; i < spaces.length; i++) {
	    for (let z = 0; z < his_self.game.spaces[spaces[i]].units["france"].length; z++) {
	      if (his_self.game.spaces[spaces[i]].units["france"][z].type == "squadron") {
	        his_self.game.spaces["paris"].units["rouen"].push(his_self.game.spaces[spaces[i]].units["france"][z]);
	      } else {
	        his_self.game.spaces["paris"].units["france"].push(his_self.game.spaces[spaces[i]].units["france"][z]);
	      }
	    }
	    his_self.game.spaces[spaces[i]].units["france"] = [];
	  }
	  his_self.updateLog("Scotland becomes an English ally...");
	}

	return 1;

      },
      removeFromDeckAfterPlay : function(his_self, player) { return 1; }
    }


    //
    // cards removed from 2P game
    //
if (this.game.players.length == 2) {
    delete deck["001"];
    delete deck["002"];
    delete deck["003"];
    delete deck["004"];
    delete deck["009"];
    delete deck["018"];
    delete deck["030"];
    delete deck["034"];
    delete deck["040"];
    delete deck["042"];
    delete deck["048"];
    delete deck["049"];
    delete deck["050"];
    delete deck["053"];
    delete deck["054"];
    delete deck["058"];
    delete deck["059"];
    delete deck["066"];
    delete deck["068"];
    delete deck["069"];
    delete deck["072"];
    delete deck["073"];
    delete deck["074"];
    delete deck["077"];
    delete deck["080"];
    delete deck["082"];
    delete deck["083"];
    delete deck["084"];
    delete deck["086"];
    delete deck["087"];
    delete deck["089"];
    delete deck["092"];
    delete deck["093"];
    delete deck["094"];
    delete deck["096"];
    delete deck["097"];
    delete deck["098"];
    delete deck["099"];
    delete deck["100"];
    delete deck["101"];
    delete deck["103"];
    delete deck["108"];
    delete deck["110"];
    delete deck["111"];
    delete deck["112"];
    delete deck["113"];
    delete deck["114"];
    delete deck["115"];
    delete deck["116"];

}
if (this.game.options.scenario === "1532" && include_removed == false) {

    delete deck["008"];
    delete deck["009"];
    delete deck["010"];
    delete deck["011"];
    // deleted on creation
    delete deck["013"];
    delete deck["038"];
    delete deck["039"];
    delete deck["041"];
    delete deck["043"];
    delete deck["078"];
    delete deck["083"];
    delete deck["085"];
    delete deck["088"];
    delete deck["095"];
    delete deck["096"];
    delete deck["112"];
    delete deck["113"];
}
if (this.game.state) {
  if (this.game.state.removed && include_removed == false) {
    for (let z = 0; z < this.game.state.removed.length; z++) {
console.log("DELETING Z: " + z);
      try { delete deck[this.game.state.removed[z]]; } catch (err) {}
    }
  }
}


    for (let key in deck) {
      deck[key].key = key;
      deck[key] = this.addEvents(deck[key]);
      if (!deck[key].warn) { deck[key].warn = []; }
    }

    return deck;

  }



  returnSpaceName(spacekey="") {
    if (this.game.spaces[spacekey]) { return this.game.spaces[spacekey].name; }
    if (this.game.navalspaces[spacekey]) { return this.game.navalspaces[spacekey].name; }
    return spacekey;
  }



 
  moveFactionUnitsInSpaceToCapitalIfPossible(faction, spacekey) {

    let space = this.game.spaces[spacekey];
    let cap = this.returnControlledCapitals(faction);
    let cap_idx = 0;
    
    //
    // do not control capital? remove
    //
    if (cap.length == 0) {
      for (let z = 0; z < space.units[faction].length; z++) {
        let u = space.units[faction][z];
        if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "corsair" || u.type == "squadron") {
          space.units[faction].splice(z, 1);
          z--;
        }
      }
      return;
    }

    //
    // otherwise move to capital, randomly
    //
    for (let ii = 0; ii < space.units[faction].length; ii++) {
      let u = space.units[faction][ii];
      if (u.type === "cavalry" || u.type === "regular" || u.type === "mercenary") {
        if (cap.length > 0) {
          let selected_capital = cap[cap_idx];
          cap_idx++;
          if ((cap_idx+1) > cap.length) { cap_idx = 0; }
          this.game.spaces[selected_capital].units[faction].push(u);
        }
        space.units[faction].splice(ii, 1);
        ii--;
      }
    }
  }       

 

  resetBesiegedSpaces() {
    for (let space in this.game.spaces) {
      if (space.besieged == 2) { space.besieged = 1; }
    }
  }
  removeBesiegedSpaces() { this.removeSieges(); }
  removeSieges() {
    for (let space in this.game.spaces) {
      if (space.besieged > 0) {
        this.removeSiege(space);
	this.displaySpace(space);
      }
    }
  }
  removeSiege(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.besieged = 0;
    for (let key in space.units) {
      for (let i = 0; i < space.units[key].length; i++) {
        space.units[key][i].besieged = 0;
        space.units[key][i].relief_force = 0;
      }
    }
  }

  resetLockedTroops() {
    for (let space in this.game.spaces) {
      for (let f in this.game.spaces[space].units) {
        for (let z = 0; z < this.game.spaces[space].units[f].length; z++) {
          this.game.spaces[space].units[f][z].locked = 0;
          this.game.spaces[space].units[f][z].lost_field_battle = 0;
          if (this.game.spaces[space].units[f][z].spacekey) { this.game.spaces[space].units[f][z].spacekey = ""; }
          if (this.game.spaces[space].units[f][z].destination) { this.game.spaces[space].units[f][z].destination = ""; }
        }
      }
    }
    for (let space in this.game.navalspaces) {
      for (let f in this.game.navalspaces[space].units) {
        for (let z = 0; z < this.game.navalspaces[space].units[f].length; z++) {
          this.game.navalspaces[space].units[f][z].spacekey = "";
          this.game.navalspaces[space].units[f][z].destination = "";
          this.game.navalspaces[space].units[f][z].locked = 0;
          this.game.navalspaces[space].units[f][z].lost_naval_battle = 0;
        }
      }
    }
  }

  addUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.unrest = 1;
  }

  removeUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.unrest = 0;
  }

  hasProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units["protestant"].length; i++) {
      let unit = space.units["protestant"][i];
      if (unit.reformer) { return true; }
    }
    for (let i = 0; i < space.units["england"].length; i++) {
      let unit = space.units["england"][i];
      if (unit.reformer) { return true; }
    }
    for (let i = 0; i < space.units["france"].length; i++) {
      let unit = space.units["france"][i];
      if (unit.reformer) { return true; }
    }
    return false;
  }



  hasProtestantLandUnits(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    //
    // only protestant units count
    //
    for (let i = 0; i < space.units["protestant"].length; i++) {
      let unit = space.units["protestant"][i];
      if (unit.type == "regular" || unit.type == "mercenary") { return true; }
    }

    //
    // unless Edward VI or Elizabeth I are on the throne
    //
    if (this.game.state.leaders.edward_vi == 1 || this.game.state.leaders.elizabeth_i == 1) {

      //
      // then british mercenaries and regulars count
      //
      for (let i = 0; i < space.units["england"].length; i++) {
        let unit = space.units["england"][i];
        if (unit.type == "regular" || unit.type == "mercenary") { return true; }
      }

      //
      // or Scottish ones if Scotland is allied to England
      //
      if (this.areAllies("england", "scotland")) {
        for (let i = 0; i < space.units["scotland"].length; i++) {
          let unit = space.units["scotland"][i];
          if (unit.type == "regular" || unit.type == "mercenary") { return true; }
        }
      }

    }

    return false;

  }

  returnCatholicLandUnitsInSpace(space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let units = [];

    for (let f in space.units) {
      if (f != "protestant" && f != "ottoman") {
	if (f == "england" && (this.game.state.leaders.edward_vi != 1 || this.game.state.leaders.elizabeth_i != 1)) {
          for (let z = 0; z < space.units[f].length; z++) {
	    let u = space.units[f][z];
	    if (u.type === "regular" || u.type === "mercenary" || u.type === "cavalry") { units.push({ faction : f , unit_idx : z }); }
	  }
	} else {
          for (let z = 0; z < space.units[f].length; z++) {
	    let u = space.units[f][z];
	    if (u.type === "regular" || u.type === "mercenary" || u.type === "cavalry") { units.push({ faction : f , unit_idx : z }); }
	  }
	}
      }
    }

    return units;

  }

  hasCatholicLandUnits(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != "protestant" && f != "ottoman") {
	if (f == "england" && (this.game.state.leaders.henry_viii != 1 && this.game.state.leaders.edward_vi != 1 && this.game.state.leaders.elizabeth_i != 1)) {
          if (this.returnFactionLandUnitsInSpace(f, space)) { return true; }
	} else {
	  if (f == "england") {
            if (this.returnFactionLandUnitsInSpace(f, space)) { return false; }
	  } else {
            if (this.returnFactionLandUnitsInSpace(f, space)) { return true; }
	  }
	}
      }
    }

    return false;
  }


  isUnoccupied(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space];  } } catch (err) {}
    for (let key in space.units) {
      if (this.returnFactionLandUnitsInSpace(key, space.key) > 0) { return 0; }
    }
    return 1;
  }

  doesNavalSpaceHaveNonFactionShip(space, faction) {
    return this.doesNavalSpaceHaveNonFactionShips(space, faction);
  }
  doesNavalSpaceHaveNonFactionShips(space, faction) {

    // if a port, must be controlled by faction
    try {
      if (this.game.spaces[space]) { 
	space = this.game.spaces[space];  
        if (space.language != undefined) { return this.isSpaceFriendly(space, faction); }
      }
    } catch (err) {}

    // if naval space, must have no non-faction ship
    try { 
      if (this.game.navalspaces[space]) {
	space = this.game.navalspaces[space]; 
        for (let f in space.units) {
          if (space.units[f].length > 0) {
	    if (this.returnPlayerCommandingFaction(f) != this.returnPlayerCommandingFaction(faction)) { 
	      return 1;
	    }
          }
        }
	for (let z = 0; z < space.ports.length; z++) {
	  let s = this.game.spaces[space.ports[z]];
	  for (let ff in s.units) {
	    for (let zz = 0; zz < s.units[ff].length; zz++) {
	      let u = s.units[ff][zz];
	      if (u.type == "corsair" || u.type == "squadron") {
		if (this.returnPlayerCommandingFaction(ff) != this.returnPlayerCommandingFaction(faction)) {
		  return 1;
		}
	      }
	    }
	  }
	}
      } 
    } catch (err) {}

    // no, no non-faction ships
    return 0;

  }

  doesNavalSpaceHaveFriendlyShip(space, faction) {

    // if a port, must be controlled by faction
    try {
      if (this.game.spaces[space]) { 
	space = this.game.spaces[space];  
        if (space.language != undefined) { return this.isSpaceFriendly(space, faction); }
      }
    } catch (err) {}

    // if naval space, must have friendly ship
    try { 
      if (this.game.navalspaces[space]) {
	space = this.game.navalspaces[space]; 
        for (let f in space.units) {
          if (space.units[f].length > 0) {
	    if (this.areAllies(f, faction, 1)) { return 1; }
          }	
        }
      } 
    } catch (err) {}

    return 0;

  }

  isNavalSpaceFriendly(space, faction) {
   
    // if a port, must be controlled by faction
    try {
      if (this.game.spaces[space]) { 
	space = this.game.spaces[space];  
        if (space.language != undefined) { return this.isSpaceFriendly(space, faction); }
      }
    } catch (err) {}

    // if naval space, must not have enemy of faction
    try { 
      if (this.game.navalspaces[space]) {
	space = this.game.navalspaces[space]; 
        for (let f in space.units) {
          if (space.units[f].length > 0) {
	    if (this.areEnemies(f, faction)) { return 0; }
          }	
        }
      } 
    } catch (err) {}

    return 1;

  }


  canFactionMoveIntoSpace(faction, space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);

    //
    // we can always move into spaces where we already have land units
    //
    if (this.returnFactionLandUnitsInSpace(faction, space, 1) > 0) { return 1; }

    //
    // we can move into spaces controlled by minor powers we control
    //
    if (this.isMinorPower(cf)) { cf = this.returnControllingPower(cf); }
    if (cf == faction) { return 1; }

    //
    // if we're enemies with the faction that controls the space
    //
    if (this.areEnemies(faction, cf)) { 

      //
      // ... we can normally move into this space, unless there are besieging units
      // with whom we are not allied, or other powers with whom we are not at war?
      //
      // so check with each faction
      //
      for (let f in space.units) {

	//
	// if this faction is an ally of the controlling space
	//
	if (this.areAllies(f, cf)) {

	  //
	  // ... and it has units in the space
	  //
	  let fluis = this.returnFactionLandUnitsInSpace(f, space.key);
	  if (fluis > 0) {

	    //
	    // ... then we need to be enemies with them to move in
	    //
	    if (!this.areEnemies(f, faction)) { return 0; }
	  }
	}

	//
	// ... if this faction is an enemy of the controlling space
	//
	if (this.areEnemies(f, cf)) {
	
	  //
	  // ... and it has units in the space
	  //
	  let fluis = this.returnFactionLandUnitsInSpace(f, space.key);
	  if (fluis > 0) {

	    //
	    // ... then we need to be allies with them to move in
	    //
	    if (!this.areAllies(f, faction)) { return 0; }

	  }
	}
      }

      return 1;

    }
    if (this.areAllies(faction, cf)) { return 1; }
    if (this.isSpaceIndependent(space.key)) {

      // if besieged, we cannot enter
      if (this.isSpaceBesieged(space.key)) { return 0; }

      // if controlled by non-independent, we cannot enter
      if (cf !== "independent") { return 0; }

      let is_empty = true;
      for (let key in space.units) {
	if (key != "independent") {
	  // don't let ourselves be blocked by non-controlling allies/enemies
          if (!this.areAllies(faction, key) && !this.areEnemies(faction, key)) {
            if (space.units[key].length > 0) {
              if (this.returnFactionLandUnitsInSpace(key, space.key, 1)) {
                is_empty = false;
  	        if (!this.areEnemies(faction, key) && !this.areAllies(faction, key)) { return 0; }
	      }
	    }
          }
        }
      }
      if (is_empty) { return 1; }
    }
    return 0;
  }

  isSpaceFriendly(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);
    if (cf === faction) { return true; }
    return this.areAllies(cf, faction);
  }

  isSpaceHostileOrIndependent(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (this.isSpaceHostile(space, faction)) { return true; }
    if (this.isSpaceIndependent(space)) { return true; }
    return false;
  }

  isSpaceIndependent(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.political === "independent") { return true; }
    if (space.home === "independent") { return true; }
    return false;
  }

  isSpaceHomeSpace(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.home === faction) { return true; }
    return false;
  }

  doesSpaceHaveNonFactionNavalUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != faction) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "squadron") { return true; }
	  if (u.type == "corsair") { return true; }
        }
      }
    }
    return false;
  }

  doesSpaceHaveNonFactionUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f != faction) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "regular") { return true; }
	  if (u.type == "mercenary") { return true; }
	  if (u.type == "cavalry") { return true; }
        }
      }
    }
    return false;
  }

  doesSpaceHaveEnemyUnits(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      let cp = this.returnControllingPower(f);
      if (this.areEnemies(faction, cp)) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.reformer == true) {} else {
	    if (u.army_leader || u.navy_leader) { return true; }
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") { return true; }
          }
        }
      }
    }
    return false;
  }

  // works both if faction is "hassburg" or "genoa"/"independent"
  doesSpaceHaveNonAlliedIndependentUnits(space, faction) {
    let am_i_independent = false;
    if (["independent","genoa","scotland","hungary","venice"].includes(faction)) { am_i_independent = true; }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (space.units[f].length > 0) {
        if (!this.areAllies(faction, f)) {
          if (am_i_independent) { return true; }
          if (["independent","genoa","scotland","hungary","venice"].includes(f)) { return true; }
        }
      }
    }
    return false;
  }

  isSpaceHostile(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let cf = this.returnFactionControllingSpace(space);
    if (cf === faction) { return false; }
    return this.areEnemies(cf, faction);
  }


  //
  // transit_seas 1 ==> default (no enemy ships, no requirement for my own)
  // transit_seas 3 ==> assault
  // transit_seas 2 ==> spring deployment
  //
  doesSpaceHaveLineOfControl(space, faction, transit_passes=1, transit_seas=3) { return this.isSpaceInLineOfControl(space, faction, transit_passes, transit_seas); }
  isSpaceInLineOfControl(space, faction, transit_passes=1, transit_seas=3) { // transit_seas=3 ==> my ships need to be in any connecting navalspace


    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let already_routed_through = {};

    //
    // path of spaces and sea-zones from that space to friendly-controlled, 
    // fortified space that is a home space for that power or one of its allies 
    // (this even includes home spaces of minor powers allied to your major 
    // power allies). All spaces on the path (except the space where the path 
    // ends) must be:
    //
    // â¢ friendly-controlled,
    // â¢ free of enemy units (including naval units and leaders)
    // â¢ free of unrest.
    //

    let res = this.returnNearestSpaceWithFilter(

      space.key ,

      // fortified home spaces are good destinations
      function(spacekey) {
        let value_to_return = 0;
        if (his_self.isSpaceFortified(spacekey)) {
	  if (his_self.isSpaceHomeSpace(spacekey, faction)) { 
	    if (!his_self.isSpaceBesieged(spacekey) && !his_self.isSpaceInUnrest(spacekey)) { 
	      if (his_self.game.state.events.schmalkaldic_league != 1 && his_self.isSpaceElectorate(spacekey)) {
	      } else {
	        value_to_return = 1;
	      }
	    }
	  } else {
	    let x = his_self.game.spaces[spacekey].home;
	    if (x != "independent") {
	      let cp = his_self.returnControllingPower(x);
	      if (his_self.isSpaceHomeSpace(spacekey, x)) { 
		if (his_self.areAllies(cp, faction)) {
	          if (!his_self.isSpaceBesieged(spacekey) && !his_self.isSpaceInUnrest(spacekey)) { 
	            if (his_self.game.state.events.schmalkaldic_league != 1 && his_self.isSpaceElectorate(spacekey)) {
		      value_to_return = 1;
		    } else {
        	      if (his_self.areAllies(x, faction, 1)) { value_to_return = 1; }
	            }
	          }
	        }	
	      }	
	    }
	  }
	}
        if (!his_self.isSpaceFriendly(spacekey, faction)) { value_to_return = 0; }
        return value_to_return;
      },

      // route through this?
      function(spacekey) {
        if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
        if (his_self.isSpaceFriendly(spacekey, faction) && his_self.doesSpaceHaveEnemyUnits(spacekey, faction) == false && his_self.isSpaceInUnrest(spacekey) != true) {
	  return 1;
	}
	return 0;
      },

      // include source?
      0,

      // transit passes? 0
      transit_passes,

      // transit seas?
      transit_seas,

      // faction? optional
      faction,

      // already crossed sea zone optional
      0
    );

    //
    // we put the neighbours immediately into the search space for the 
    // above function, so we do a sanity check on any ports to ensure we
    // are not fully blockaded if the only results are overseas.
    //
    let all_overseas = true;
    for (let i = 0; i < res.length; i++) {
      if (res[i].overseas != true) { all_overseas = false; }
    }
    if (all_overseas == true) {
      let are_we_blockaded = true;
      if (space.ports) {
        for (let z = 0; z < space.ports.length; z++) {
	  if (his_self.isNavalSpaceFriendly(space.ports[z], faction)) {
	    are_we_blockaded = false;
	  }
        }
      }
      if (are_we_blockaded) { return 0; }
    }

    return res.length;

  }

  isSpaceControlled(space, faction) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    // home spaces that have not fallen to another power.
    if (space.home == faction && space.political == "") { return true; }

    // home spaces that have not fallen to another power.
    if (space.home == faction && space.political == faction) { return true; }

    if (space.home == "" && space.political == faction) { return true; }

    // independent (gray) spaces seized by the power.
    if (space.home == "independent" && space.political == faction) { return true; }

    // home spaces of other powers seized by the power.
    if (space.home != faction && space.political == faction) { return true; }
    if (space.home == faction && space.political == faction) { return true; }

    // home spaces of allied minor powers. 
    if ((space.political == "" || space.political == faction || space.political == space.home) && space.home != faction && this.isAlliedMinorPower(space.home, faction)) { return true; }

    return false;
  }

  isSpaceFortified(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.type == "electorate" || space.type == "key" || space.type == "fortress") { return true; }
    if (space.fortified == 1 || space.fortified == true) { return true; }
    return false;
  }

  isSpaceFortress(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.type == "electorate" || space.type == "key") { return false; }
    if (space.type == "fortress") { return true; }
    if (space.fortified == 1 || space.fortified == true) { return true; }
    if (space.key == this.game.state.knights_of_st_john) { return true; }
    return false;
  }

  returnHopsToFortifiedHomeSpace(source, faction) {
    let his_self = this;
    try { if (this.game.spaces[source]) { source = this.game.spaces[source]; } } catch (err) {}
    return this.returnHopsBetweenSpacesWithFilter(source, function(spacekey) {
      if (his_self.isSpaceFortified(his_self.game.spaces[spacekey])) {
	if (his_self.isSpaceControlled(spacekey, faction)) {
	  if (his_self.game.spaces[spacekey].home === faction) {
	    return 1;
	  }
	}
      }
      return 0;
    });
  }
  returnHopsToDestination(source, destination) {
    try { if (this.game.spaces[source]) { destination = this.game.spaces[source]; } } catch (err) {}
    try { if (this.game.spaces[destination]) { destination = this.game.spaces[destination]; } } catch (err) {}
    return this.returnHopsBetweenSpacesWithFilter(source, function(spacekey) {
      if (spacekey === destination.key) { return 1; }
      return 0;  
    });
  }

  returnHopsBetweenSpacesWithFilter(space, filter_func) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let map = {};
    let sources = [];
    let hop = 0;

    let addHop = function(sources, hop) {

      hop++;
      
      let new_neighbours = [];

      for (let i = 0; i < sources.length; i++) {
	for (let z = 0; z < his_self.game.spaces[sources[i]].neighbours.length; z++) {
	  let sourcekey = his_self.game.spaces[sources[i]].neighbours[z];
	  if (!map[sourcekey]) {
	    map[sourcekey] = 1;
	    new_neighbours.push(sourcekey);

	    //
	    // if we have a hit, it's this many hops!
	    //
	    if (filter_func(sourcekey)) { return hop; }
	  }
	}
      }

      if (new_neighbours.length > 0) {
	return addHop(new_neighbours, hop);
      } else {
	return 0;
      }

    }

    return addHop(space.neighbours, 0);   

  }

  //
  // similar to above, except it can cross a sea-zone
  //
  isSpaceConnectedToCapitalSpringDeployment(space, faction, transit_seas=1, specific_capital="") {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let capitals = this.returnCapitals(faction);
    let already_routed_through = {};
    let transit_passes = 0;
    let hostile_sea_passes = 0;
    if (specific_capital != "") { capitals = [ specific_capital ]; }

    if (this.game.state.spring_deploy_across_seas.includes(faction)) {
      hostile_sea_passes = 1;
    } else {
      transit_seas = 2;
    }
    if (this.game.state.spring_deploy_across_passes.includes(faction)) {
      transit_passes = 1;
    }

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // capitals are good destinations
      function(spacekey) {
        if (capitals.includes(spacekey)) { return 1; }
        return 0;
      },


      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
	if (his_self.isSpaceInUnrest(spacekey)) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	return 0;
      },

      0, // include source

      // transit passes? 0
      transit_passes,

      // transit seas? 1 = enemy ships block, 2 = all other ships block, 3 = friendly ships required (2 for SD)
      transit_seas,
     
      // faction? optional
      faction,

      // already crossed sea zone optional
      0,

      // is spring deployment
      1
    );

    if (res.length > 0) {
      return 1;
    }

    return 0;

  }

  isSpaceAdjacentToReligion(space, religion) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.neighbours.length; i++) {
      if (this.game.spaces[space.neighbours[i]].religion === religion) {
	return true;
      }
    }
    return false;
  }

  isSpaceAdjacentToProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let z = 0; z < space.neighbours.length; z++) {
      if (this.doesSpaceContainProtestantReformer(space.neighbours[z])) { return true; }
    }
    return false;
  }

  // either in port or in adjacent sea
  returnNumberOfSquadronsProtectingSpace(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let number_of_squadrons_in_port = 0;
    let number_of_squadrons_at_sea = 0;

    //
    // in port
    //
    for (let f in space.units) {
      for (let i = 0; i < space.units[f].length; i++) {
        if (space.units[f][i].type == "squadron") {
	  number_of_squadrons_in_port++;
	}
      }
    }

    //
    // adjacent sea
    //
    for (let p = 0; p < space.ports.length; p++) {

      let sea = this.game.navalspaces[space.ports[p]];

      for (let f in sea.units) {

	if (this.isSpaceFriendly(space, f)) {
	  for (let i = 0; i < sea.units[f].length; i++) {
	    if (sea.units[f][i].type == "squadron") {

	      //
	      // any squadrons in ANY space mean not-assaultable
	      //
	      number_of_squadrons_at_sea += 10000;
	    }
	  }
	}
      }
    }

    return (number_of_squadrons_in_port + number_of_squadrons_at_sea);

  }
  doesSpaceContainProtestantReformer(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units["protestant"].length; i++) {
      if (space.units["protestant"][i].reformer == true) { return true; }
    }
    return false;
  }

  isSpaceAPortInTheSameSeaZoneAsACatholicPort(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let seas = [];
    for (let i = 0; i < space.ports.length; i++) {
      if (!seas.includes(space.ports[i])) { seas.push(space.ports[i]); }
    }
    for (let s in this.game.spaces) {
      let sp = this.game.spaces[s];
      if (sp.religion == "catholic" && sp.ports.length > 0) {
	for (let z = 0; z < sp.ports.length; z++) {
	  if (seas.includes(sp.ports[z])) { return true; }
	}
      }
    }  
    return false;
  }

  isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let seas = [];
    for (let i = 0; i < space.ports.length; i++) {
      if (!seas.includes(space.ports[i])) { seas.push(space.ports[i]); }
    }
    for (let s in this.game.spaces) {
      let sp = this.game.spaces[s];
      if (sp.religion == "protestant" && sp.ports.length > 0) {
	for (let z = 0; z < sp.ports.length; z++) {
	  if (seas.includes(sp.ports[z])) { return true; }
	}
      }
    }  
    return false;
  }


  returnSpacesWithFilter(filter_func) {
    let spaces = [];
    for (let spacekey in this.game.spaces) {
      if (filter_func(spacekey) == 1) { spaces.push(spacekey); }
    }
    return spaces;
  }

  isSpaceFactionCapital(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let capitals = this.returnCapitals(faction);
    for (let i = 0; i < capitals.length; i++) {
      if (capitals[i] === space.key) { return true; }
    }
    return false;
  }

  isSpaceInUnrest(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.unrest == 1) { return true; }
    return false;
  }

  isSpaceUnderSiege(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (space.besieged > 0) { return true; }
    return false;
  }

  isSpaceConnectedToCapital(space, faction) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let his_self = this;
    let capitals = this.returnCapitals(faction);
    let already_routed_through = {};

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // capitals are good destinations
      function(spacekey) {
        if (capitals.includes(spacekey)) { return 1; }
        return 0;
      },

      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	return 0;
      }
    );

    return 1;
  }

  returnFactionControllingSpace(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let factions = this.returnImpulseOrder(); 
    for (let i = 0; i < factions.length; i++) {
      if (this.isSpaceControlled(space.key, factions[i])) { return factions[i]; }
    }
    if (space.political) { return space.political; }
    return space.home;
  }

  returnSpaceOfPersonage(faction, personage) {
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i]) {
	    if (this.game.spaces[key].units[faction][i].type === personage) {
  	      return key;
            }
          }
        }
      }
    }
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
	  if (this.game.navalspaces[key].units[faction][i]) {
	    if (this.game.navalspaces[key].units[faction][i].type === personage) {
  	      return key;
            }
          }
        }
      }
    }
    return "";
  }

  returnIndexOfPersonageInSpace(faction, personage, spacekey="") {
    if (spacekey === "") { return -1; }
    if (this.game.spaces[spacekey]) {
      for (let i = 0; i < this.game.spaces[spacekey].units[faction].length; i++) {
        if (this.game.spaces[spacekey].units[faction][i].type === personage) {
          return i;
        }
      }
    }
    if (this.game.navalspaces[spacekey]) {
      for (let i = 0; i < this.game.navalspaces[spacekey].units[faction].length; i++) {
        if (this.game.navalspaces[spacekey].units[faction][i].type === personage) {
          return i;
        }
      }
    }
    return -1;
  }

  returnNavalTransportDestinations(faction, space, ops) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let viable_destinations = [];
    let viable_navalspaces = [];
    let options = [];
    let ops_remaining = ops-1;    

    for (let i = 0; i < space.ports.length; i++) {
      if (this.doesFactionHaveNavalUnitsInSpace(faction, space.ports[i])) {
	viable_navalspaces.push({key : space.ports[i] , ops_remaining : ops_remaining});
      }
    }

    //
    // this loop through the graph and finds all of the spaces that can theoretically
    // be reached given the OPS available to the user and the presence of a naval unit
    // in the connecting sea spaces. these destinations are put into "viable_navalspaces"
    //
    while (ops_remaining > 1) {
      ops_remaining--;
      for (let i = 0; i < viable_navalspaces.length; i++) {
	for (let z = 0; z < this.game.navalspaces[viable_navalspaces[i].key].neighbours.length; z++) {
	  let ns = this.game.navalspaces[viable_navalspaces[i].key].neighbours[z];
          if (this.doesFactionHaveNavalUnitsInSpace(faction, ns)) {
	    let already_included = 0;
	    for (let z = 0; z < viable_navalspaces.length; z++) {
	      if (viable_navalspaces[z].key == ns) { already_included = 1; }
	    }
	    if (already_included == 0) {
	      viable_navalspaces.push({ key : ns , ops_remaining : ops_remaining });
	    }
	  }
	}
      }
    }

    //
    // we now look for ports that are in these viable navalspaces, and list ones which 
    // are valid movement destinations. this means allied or independent or enemies of 
    // the active power that is moving.
    //
    for (let i = 0; i < viable_navalspaces.length; i++) {
      let key = viable_navalspaces[i].key;
      for (let z = 0; z < this.game.navalspaces[key].ports.length; z++) {      
	let port = this.game.navalspaces[key].ports[z];
	if (port != space.key) {

	  //
          // you cannot move into spaces that are not allied or enemies
	  //
          if (this.canFactionMoveIntoSpace(faction, port)) { 
	    viable_destinations.push({ key : port , cost : (viable_navalspaces[i].ops_remaining-1)});
	  }
	}
      }
    }

    return viable_destinations;

  }


  returnFactionNavalUnitsToMove(faction) {

    let units = [];

    //
    // include minor-activated factions
    //
    let fip = [];
    fip.push(faction);
    if (this.game.state.activated_powers[faction]) {
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
        if (!fip.includes(this.game.state.activated_powers[faction][i])) { fip.push(this.game.state.activated_powers[faction][i]); }
      }
    }

    //
    // if this is the 2P game, include any major activated units
    //
    if (faction != "independent" && faction != "scotland" && faction != "genoa" && faction != "venice" && faction != "hungary") {
      if (this.game.players.length == 2) {
        if (this.areAllies(faction, "hapsburg") && faction != "hapsburg") { if (!fip.includes("hapsburg")) { fip.push("hapsburg"); } }
        if (this.areAllies(faction, "protestant") && faction != "protestant") { if (!fip.includes("protestant")) { fip.push("protestant"); } }
        if (this.areAllies(faction, "france") && faction != "france") { if (!fip.includes("france")) { fip.push("france"); } }
        if (this.areAllies(faction, "england") && faction != "england") if (!fip.includes("england")) { { fip.push("england"); } }
        if (this.areAllies(faction, "papacy") && faction != "papacy") { if (!fip.includes("papacy")) { fip.push("papacy"); } }
        if (this.areAllies(faction, "ottoman") && faction != "ottoman") { if (!fip.includes("ottoman")) { fip.push("ottoman"); } }
      }
    }

    //
    // find units
    //
    for (let i = 0; i < fip.length; i++) {
      for (let key in this.game.spaces) {

	//
	// we only care about units in ports
	//
	if (this.game.spaces[key].ports) {
	if (this.game.spaces[key].ports.length > 0) {
	  let ships = [];
	  let leaders = [];
	  for (let z = 0; z < this.game.spaces[key].units[fip[i]].length; z++) {

	    //
	    // only add leaders if there is a ship in port
	    //
	    let u = this.game.spaces[key].units[fip[i]][z];
	    u.idx = z;

	    if (u.navy_leader == true) {
	      leaders.push(u);
	    } else {
	      if (u.land_or_sea === "sea" || u.land_or_sea === "both") {
		ships.push(u);
	      }
	    }
	  }

	  //
	  // add and include location
	  //
	  if (ships.length > 0) {
	    for (let y = 0; y < ships.length; y++) {
	      if (!ships.locked) { 
	        ships[y].spacekey = key;
	        ships[y].faction = fip[i];
	        units.push(ships[y]);
	      }
	    }
	    for (let y = 0; y < leaders.length; y++) {
	      if (!leaders.locked) {
		leaders[y].spacekey = key;
	        leaders[y].faction = fip[i];
	        units.push(leaders[y]);
	      }
	    }
	  }
	}
        }
      }
    }

    //
    // add ships and leaders out-of-port
    //
    for (let i = 0; i < fip.length; i++) {
      for (let key in this.game.navalspaces) {
	for (let z = 0; z < this.game.navalspaces[key].units[fip[i]].length; z++) {
	  if (!this.game.navalspaces[key].units[fip[i]][z].locked) {
	    let u = this.game.navalspaces[key].units[fip[i]][z];
	    u.spacekey = key;
	    u.faction = fip[i];
	    u.idx = z;
	    units.push(u);
	  }
	}
      }
    }

    return units;
  }






  returnOverstackedUnitsToCapitals() {

    for (let i in this.game.spaces) {
      if (this.isSpaceFortified(this.game.spaces[i])) {

        let space = this.game.spaces[i];
        let f = this.returnFactionControllingSpace(i);

        let num_friendly_units = this.returnFriendlyLandUnitsInSpace(f, space);
        let num_faction_units = this.returnFactionLandUnitsInSpace(f, space);
        let capitals = this.returnCapitals(f);

        if (num_friendly_units > 4 && !capitals.includes(i)) {

          let units_preserved = 0;
          for (let q in space.units) {

	    //
	    // minor powers don't worry about overstacking if in fortified spaces
	    //
	    if (this.isMinorPower(q) && space.home == q) {


	    } else {

	      //
              //  capital of unit is
	      //
              let cap = this.returnControlledCapitals(q);
              let cap_idx = 0;

              for (let ii = 0; ii < space.units[q].length; ii++) {
                let u = space.units[q][ii];
                if (u.type === "cavalry" || u.type === "regular" || u.type === "mercenary") {
                  units_preserved++;
                  if (units_preserved > 4) {
                    if (cap.length > 0) {
                      let selected_capital = cap[cap_idx];
                      this.game.spaces[selected_capital].units[q].push(space.units[q][ii]);
                      cap_idx++;
                      if ((cap_idx+1) > cap.length) {
                        cap_idx = 0;
                      }
                      this.displaySpace(selected_capital);
                      this.displaySpace(space.key);
                    }
                    space.units[q].splice(ii, 1);
                    ii--;
                  }
                }
              }
            }
          }
          this.updateLog("OVERSTACKING in " + this.returnName(i) + " (some units returned to capital)");
          this.displaySpace(i);
        }
      }
    }

  }


  // max-units is number of units permitted, usually passed as 4 to find spaces that are not over-capacity
  returnNearestFriendlyFortifiedSpacesTransitPasses(faction, space, max_units=0, include_source=1) {
    return this.returnNearestFriendlyFortifiedSpaces(faction, space, 1, max_units, include_source);
  }
  returnNearestFriendlyFortifiedSpaces(faction, space, transit_passes = 0, max_units=0, include_source=1) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    let original_spacekey = space.key;
    let his_self = this;
    let already_routed_through = {};

    let res = this.returnNearestSpaceWithFilter(

      space.key,

      // fortified spaces
      function(spacekey) {

	//
	//
	//
	if (include_source != 1) {
	  if (spacekey == original_spacekey) { return 0; }
	}

	//
	// non-protestants can't move into electorates, so they aren't friendly fortified spaces 
	// for anyone at this point.
	//
	if (faction !== "protestant" && his_self.game.state.events.schmalkaldic_league != 1) {
	  if (his_self.isElectorate(spacekey)) { return 0; }
	}

	//
	// we provide an exception for capitals as they can hold more than MAX_UNITS
	//
	if (max_units > 0) {
	  if (spacekey != "paris" && spacekey != "london" && spacekey != "istanbul" && spacekey != "vienna" && spacekey != "valladolid" && spacekey != "rome") {
	    if (his_self.returnFactionLandUnitsInSpace(faction, spacekey, 1) >= max_units) { return 0; }
	  }
	}

        //
        // unrest is a "no"
        //
	if (his_self.game.spaces[spacekey].unrest == 1) { return 0; }

        if (his_self.isSpaceFortified(his_self.game.spaces[spacekey])) {
	  if (his_self.isSpaceControlled(spacekey, faction)) {
	    return 1;
	  }
	  if (his_self.isSpaceFriendly(spacekey, faction)) {
	    return 1;
	  }
	}
        return 0;
      },

      // route through this?
      function(spacekey) {
	if (already_routed_through[spacekey] == 1) { return 0; }
        if (his_self.game.spaces[spacekey].unrest == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	if (his_self.isSpaceFriendly(spacekey, faction)) { return 1; }
	if (spacekey == original_spacekey) { return 1; }
	return 0;
      }, 

      true , // include source

      transit_passes, // cross passes?
    );

    return res;

  }


  returnNearestFactionControlledPorts(faction, spacekey) {

    let space = spacekey;

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}

    let his_self = this;
    let already_routed_through = {};

    let res = this.returnNearestNavalSpaceOrPortWithFilter(

      space.key,

      // ports
      function(spacekey) {
        if (his_self.game.spaces[spacekey]) {
	  if (his_self.isSpaceControlled(spacekey, faction)) {
	    return 1;
	  }
	}
        return 0;
      },

      // route through this
      function(spacekey) {	
        if (his_self.game.spaces[spacekey]) { return 0; }
	if (already_routed_through[spacekey] == 1) { return 0; }
        already_routed_through[spacekey] = 1;
	return 1;
      }
    );

    return res;

  }


  canFactionRetreatToSpace(faction, space, attacker_comes_from_this_space="") {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.spaces[attacker_comes_from_this_space]) { attacker_comes_from_this_space = this.game.spaces[attacker_comes_from_this_space]; } } catch (err) {}
    if (space === attacker_comes_from_this_space) { return 0; }
    if (this.isSpaceInUnrest(space) == 1) { return 0; }
    for (let z in space.units) {
      if (this.returnFactionLandUnitsInSpace(z, space.key)) {
	if (!this.areAllies(z, faction, 1)) { return 0; }
      }
    }
    if (this.isSpaceControlled(space, faction) == 1) { return 1; }
    if (this.isSpaceFriendly(space, faction) == 1) { return 1; }
    return 0;
  }

  canFactionRetreatToNavalSpace(faction, space) {
    let is_port_space = false;
    try { if (this.game.spaces[space]) { is_port_space = true; space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    if (is_port_space == true) {
      let fac = this.returnFactionControllingSpace(space);
      if (this.areEnemies(fac, faction)) { return 0; }
      if (this.areAllies(fac, faction, 1)) { return 1; } else { return 0; }
    } else {
      for (let z in space.units) {
        if (this.returnFactionNavalUnitsInSpace(z, space.key)) {
	  if (this.areEnemies(z, faction, 1)) { return 0; }
        }
      }
    }
    if (this.isNavalSpaceFriendly(space, faction) == 1) { return 1; }
    if (this.isSpaceFriendly(space, faction) == 1) { return 1; }
    return 0;
  }

  convertSpace(religion, space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    if (religion === "papacy") { religion = "catholic"; }
    space.religion = religion;
    this.displayBoard();
  }

  controlSpace(faction, space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.political = faction;
    space.occupier = faction;

    if (space.key === "oran" || space.key === "tripoli") {
      if (faction === "ottoman") {
	space.home = "ottoman";
      }
      if (faction === "hapsburg") {
	space.home = "hapsburg";
      }
    }

    //
    // check if triggers defeat of Hungary Bohemia
    //
    if (this.game.step.game > 5) {
      let lmv = this.game.queue[this.game.queue.length-1].split("\t");
      if (lmv[0] !== "is_testing") {;
        this.triggerDefeatOfHungaryBohemia();
      }
    }

  }


  returnDefenderFaction(attacker_faction, space) {
    // called in combat, this finds whichever faction is there but isn't allied to the attacker
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      let luis = 0;
      if (space.language == undefined) {
        luis = this.returnFactionSeaUnitsInSpace(f, space.key);
      } else {
        luis = this.returnFactionLandUnitsInSpace(f, space.key);
      }
      if (luis > 0) {
        if (!this.areAllies(attacker_faction, f) && f !== attacker_faction) {
	  return this.returnControllingPower(f);
	}
      }
    }
    // no-one is here, so defender must be controlling the space
    return this.returnControllingPower(this.returnFactionControllingSpace(space.key));
  }

  returnNonFactionLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (f !== faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnHostileOrIndependentLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (!this.areAllies(faction, f, 1)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnHostileLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areEnemies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnFriendlyUnbesiegedLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areAllies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
	  if (!space.units[f][i].besieged) {
            if (space.units[f][i].type === "regular") { luis++; }
            if (space.units[f][i].type === "mercenary") { luis++; }
            if (space.units[f][i].type === "cavalry") { luis++; }
          }
        }
      }
    }
    return luis;
  }

  returnFriendlyLandUnitsInSpace(faction, space) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (this.areAllies(faction, f)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnFactionLandUnitsAndLeadersInSpace(faction, space, include_minor_allies=false) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
          if (space.units[f][i].navy_leader == true || space.units[f][i].army_leader == true) { luis++; }
        }
      } else {
	if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
          for (let i = 0; i < space.units[f].length; i++) {
            if (space.units[f][i].type === "regular") { luis++; }
            if (space.units[f][i].type === "mercenary") { luis++; }
            if (space.units[f][i].type === "cavalry") { luis++; }
            if (space.units[f][i].navy_leader == true || space.units[f][i].army_leader == true) { luis++; }
          }
        }
      }
    }
    return luis;
  }
  returnUnbesiegedFactionLandUnitsInSpace(faction, space, include_minor_allies=false) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].besieged == 0) {
            if (space.units[f][i].type === "regular") { luis++; }
            if (space.units[f][i].type === "mercenary") { luis++; }
            if (space.units[f][i].type === "cavalry") { luis++; }
          }
        }
      }
      if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].besieged == 0) {
            if (space.units[f][i].type === "regular") { luis++; }
            if (space.units[f][i].type === "mercenary") { luis++; }
            if (space.units[f][i].type === "cavalry") { luis++; }
          }
        }
      }
    }
    return luis;
  }

  returnFactionLandUnitsInSpace(faction, space, include_minor_allies=false) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
      if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular") { luis++; }
          if (space.units[f][i].type === "mercenary") { luis++; }
          if (space.units[f][i].type === "cavalry") { luis++; }
        }
      }
    }
    return luis;
  }

  returnFactionNavalUnitsInSpace(faction, space, include_minor_allies=false) {

    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}

    for (let f in space.units) {
      if (include_minor_allies == false && f == faction) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "squadron") { luis++; }
          if (space.units[f][i].type === "corsair") { luis++; }
        }
      } else {
	if (include_minor_allies == true && (f == faction || this.isAlliedMinorPower(f, faction))) {
          for (let i = 0; i < space.units[f].length; i++) {
            if (space.units[f][i].type === "squadron") { luis++; }
            if (space.units[f][i].type === "corsair") { luis++; }
          }
        }
      }
    }
    return luis;
  }

  returnFactionSeaUnitsInSpace(faction, space, only_unlocked=0) {
    let luis = 0;
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (only_unlocked) {
        if (!space.units[faction][i].locked) {
          if (space.units[faction][i].type === "squadron") { luis++; }
          if (space.units[faction][i].type === "corsair") { luis++; }
	}
      } else {
        if (space.units[faction][i].type === "squadron") { luis++; }
        if (space.units[faction][i].type === "corsair") { luis++; }
      }
    }
    return luis;
  }

  doesOtherFactionHaveNavalUnitsInSpace(exclude_faction, key, ignore_independent_factions=0) {
    if (this.game.spaces[key]) {
      for (let f in this.game.spaces[key].units) {
	if (f != exclude_faction) {
          if (this.game.spaces[key].units[f]) {
            for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
              if (this.game.spaces[key].units[f][i].type === "squadron" || this.game.spaces[key].units[f][i].type === "corsair") {
		if (ignore_independent_factions == 1) {
		  if (f == "independent") {}
		  if (f == "venice") { if (this.returnControllingPower("venice") != "venice") { return 1; }}
		  if (f == "genoa") { if (this.returnControllingPower("genoa") != "genoa") { return 1; }}
		  if (f == "hungary") { if (this.returnControllingPower("hungary") != "hungary") { return 1; }}
		  if (f == "scotland") { if (this.returnControllingPower("scotland") != "scotland") { return 1; }}
		} else {
  	          return 1;
		}
              }
            }
	  }
	}
      }
      return 0;
    }
    if (this.game.navalspaces[key]) {
      for (let f in this.game.navalspaces[key].units) {
	if (f != exclude_faction) {
          if (this.game.navalspaces[key].units[f]) {
            for (let i = 0; i < this.game.navalspaces[key].units[f].length; i++) {
              if (this.game.navalspaces[key].units[f][i].type === "squadron" || this.game.navalspaces[key].units[f][i].type === "corsair") {
		if (ignore_independent_factions == 1) {
		  if (f == "independent") {}
		  if (f == "venice") { if (this.returnControllingPower("venice") != "venice") { return 1; }}
		  if (f == "genoa") { if (this.returnControllingPower("genoa") != "genoa") { return 1; }}
		  if (f == "hungary") { if (this.returnControllingPower("hungary") != "hungary") { return 1; }}
		  if (f == "scotland") { if (this.returnControllingPower("scotland") != "scotland") { return 1; }}
		} else {
  	          return 1;
		}
              }
            }
	  }
	}
      }
      return 0;
    }
    return 0;
  }

  doesPlayerHaveLandUnitsInSpace(p1, spacekey) {
    for (let f in this.game.spaces[spacekey].units) {
      if (this.returnPlayerCommandingFaction(f) == p1) {
        for (let i = 0; i < this.game.spaces[spacekey].units[f].length; i++) {
          if (
	    this.game.spaces[spacekey].units[f][i].type == "regular" || 
	    this.game.spaces[spacekey].units[f][i].type == "cavalry" || 
	    this.game.spaces[spacekey].units[f][i].type == "mercenary") 
	  {
            return 1;
          }
        }
      }
    }
    return 0;
  }
  doesFactionHaveLandUnitsInSpace(faction, key, include_minor_allies=false) {
    if (this.game.spaces[key]) {
      for (let f in this.game.spaces[key].units) { 
	let analyse_faction = false;
	if (include_minor_allies == true && (this.returnControllingPower(f) == faction)) { analyse_faction = true; }
	if (include_minor_allies == false) { if (faction == f) { analyse_faction = true; } }
	if (analyse_faction) {
          if (this.game.spaces[key].units[f]) {
            for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
              if (this.game.spaces[key].units[f][i].type === "regular" || this.game.spaces[key].units[f][i].type === "cavalry" || this.game.spaces[key].units[f][i].type === "mercenary") {
  	        return 1;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  doesFactionHaveFriendlyNavalUnitsInSpace(faction, key) {
    if (this.game.spaces[key]) {
      for (let f in this.game.spaces[key].units) {
	if (this.areAllies(f, faction)) {
          if (this.game.spaces[key].units[f]) {
            for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
              if (this.game.spaces[key].units[f][i].type === "squadron" || this.game.spaces[key].units[f][i].type === "corsair") {
  	        return 1;
              }
            }
          }
        }
      }
    }
    if (this.game.navalspaces[key]) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let f in this.game.navalspaces[key].units) {
	  if (this.returnControllingPower(f) == faction || f == faction) {
            for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
              if (this.game.navalspaces[key].units[faction][i].type === "squadron" || this.game.navalspaces[key].units[faction][i].type === "corsair") {
  	        return 1;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  doesFactionHaveNavalUnitsInSpace(faction, key) {
    if (this.game.spaces[key]) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
          if (this.game.spaces[key].units[faction][i].type === "squadron" || this.game.spaces[key].units[faction][i].type === "corsair") {
  	    return 1;
          }
        }
      }
    }
    if (this.game.navalspaces[key]) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
          if (this.game.navalspaces[key].units[faction][i].type === "squadron" || this.game.navalspaces[key].units[faction][i].type === "corsair") {
  	    return 1;
          }
        }
      }
    }
    return 0;
  }

  doesFactionHaveUnlockedNavalUnitsOnBoard(faction) {
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
	  if (this.game.navalspaces[key].units[faction][i].locked != 1) { return 1; }
	}
      }
    }
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i].land_or_sea === "sea") {
	    if (this.game.spaces[key].units[faction][i].locked != 1) { return 1; }
	  }
	}
      }
    }
    return 0;
  }

  doesFactionHaveNavalUnitsOnBoard(faction) {
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units[faction]) {
        for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
	  return 1;
	}
      }
    }
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
        for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i].land_or_sea === "sea") {
	    return 1;
	  }
	}
      }
    }
    return 0;
  }

  returnNavalFactionMap(space, faction1, faction2) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let faction_map = {};

    for (let f in space.units) {
      if (this.returnControllingPower(f) == this.returnControllingPower(faction1)) {
        faction_map[f] = faction1;
      }
      if (this.returnControllingPower(f) == this.returnControllingPower(faction2)) {
        faction_map[f] = faction2;
      }
    }
    return faction_map;
  }


  

  returnFactionMap(space, faction1, faction2) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let faction_map = {};

    for (let f in space.units) {
      if (this.returnFactionLandUnitsInSpace(f, space)) {
        if (f == faction1) {
          faction_map[f] = faction1;
        } else {
          if (f == faction2) {
            faction_map[f] = faction2;
          } else {
            if (this.areAllies(f, faction1)) {
              faction_map[f] = faction1;
            }
            if (this.areAllies(f, faction2)) {
              faction_map[f] = faction2;
            }
            if (this.returnControllingPower(f) == faction1) {
              faction_map[f] = faction1;
	    }
            if (this.returnControllingPower(f) == faction2) {
              faction_map[f] = faction2;
	    }
            if (this.returnPlayerCommandingFaction(f) === this.returnPlayerCommandingFaction(faction1)) {
              faction_map[f] = faction1;
	    }
            if (this.returnPlayerCommandingFaction(f) === this.returnPlayerCommandingFaction(faction2)) {
              faction_map[f] = faction2;
	    }
          }
        }
      }
    }
    // ensures factions are listed even if their spaces are empty
    if (!faction_map[faction1]) { faction_map[faction1] = faction1; }
    if (!faction_map[faction2]) { faction_map[faction2] = faction2; }
    return faction_map;
  }

  returnHomeSpaces(faction) {

    let spaces = [];

    for (let i in this.game.spaces) {
      if (this.game.spaces[i].home === faction) { spaces.push(i); }
    }

    return spaces;

  }

  //
  // transit seas calculates neighbours across a sea zone
  //
  // if transit_seas and faction is specified, we can only cross if
  // there are no ports in a zone with non-faction ships.
  //
  returnNeighboursAsArrayOfKeys(space, transit_passes=1, transit_seas=0, faction="") {
    let res = [];
    let x = this.returnNeighbours(space, transit_passes, transit_seas, faction);
    for (let i = 0; i < x.length; i++) {
      res.push(x[i].neighbour);
    }
    return res;
  }

  //
  // transit_seas == 1 , any sea with no adjacent enemy ships (default)
  // transit_seas == 2 , any sea with no adjacent enemy or independent ships (spring deployment)
  // transit_seas == 3 , must have friendly ships, which implies no enemy ships (LOC assault)
  //
  returnNeighbours(space, transit_passes=1, transit_seas=0, faction="", is_spring_deployment=0) {

//try {

    let is_naval_space = false;

    // not a naval space
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; is_naval_space = true; } } catch (err) {}
    try { if (this.game.navalspaces[space.key]) { is_naval_space = true; } } catch (err) {}

    if (transit_seas == 0 && is_naval_space != true) {
      if (transit_passes == 1) {
	let res = [];
	for (let z = 0; z < space.neighbours.length; z++) {
	  res.push({ neighbour : space.neighbours[z] , overseas : false });
	} 
        return res;
      }
      let neighbours = [];
      for (let i = 0; i < space.neighbours.length; i++) {
        let x = space.neighbours[i];      
	if (space.pass) {
          if (!space.pass.includes(x)) {
  	    neighbours.push({ neighbour : x , overseas : false });
          }
        }
      }
      return neighbours;

    } else {

      let neighbours = [];

      if (transit_passes == 1 && is_naval_space != true) {
	for (let z = 0; z < space.neighbours.length; z++) {
	  neighbours.push({ neighbour : space.neighbours[z] , overseas : false });
	}
      } else {
        for (let i = 0; i < space.neighbours.length; i++) {
          let x = space.neighbours[i];
	  if (is_naval_space != true) {
            if (!space.pass.includes(x)) {
              neighbours.push({ neighbour : x , overseas : false });
            }
          }
        }
      }

      //
      // any ports ?
      //
      if (space.ports) {
        if (space.ports.length > 0) {
	  for (let i = 0; i < space.ports.length; i++) {
	    let navalspace = "";

	    if (this.game.navalspaces[space.ports[i]]) {
	      navalspace = this.game.navalspaces[space.ports[i]];
	    } else {
	      navalspace = this.game.spaces[space.ports[i]];
	    }

	    let any_unfriendly_ships = false;
	    let any_of_my_ships = false;

	    let ignore_non_hostiles = true;
	    let ignore_hostiles = false;

	    //
	    // transit_seas == 1 , any sea with friendly ships and no enemy ships, in-or-adjacent (assault, LOC)
	    // transit_seas == 2 , any sea with adjacent no enemy or independent ships (spring deployment)
	    // transit_seas == 3 , all seas must have friendly ships (assault)
	    //
	    // Spring Deployment card permits ignoring all ships, even hostiles
	    //
	    if (this.game.state.spring_deploy_across_passes.includes(faction) && is_spring_deployment == 1) { ignore_hostiles = true; }

	    if (navalspace.ports) {
	      if (faction != "") {
	        for (let z = 0; z < navalspace.ports.length; z++) {

		  if (transit_seas == 1) {
	            if (this.doesOtherFactionHaveNavalUnitsInSpace(faction, navalspace.ports[z], 1)) { // 1 = ignore independent/unaligned
	 	      if (this.game.state.events.spring_preparations != faction) {
	                if (ignore_hostiles == false) {
		          any_unfriendly_ships = true;
		        }
		      }
		    }
		    if (any_unfriendly_ships != true) {
	              let already_listed = false;
                      for (let z = 0; z < navalspace.ports.length; z++) {
	                for (let zz = 0; zz < neighbours.length; zz++) {
	                  if (neighbours[zz].neighbour === navalspace.ports[z]) {
		            already_listed = true;
		          }
		        }
	                if (already_listed == false) {
	                  neighbours.push({ neighbour : navalspace.ports[z] , overseas : true });
	                }
 		      }
		    }
		  }

		  if (transit_seas == 2) {
		    if (this.doesNavalSpaceHaveNonFactionShips(navalspace.key, faction) || this.doesNavalSpaceHaveNonFactionShips(navalspace.ports[z], faction)) {
	 	      if (this.game.state.events.spring_preparations != faction) {
	                if (ignore_hostiles == false) {
		          any_unfriendly_ships = true;
		        }
		      }
		    }
		  }

		  if (any_unfriendly_ships != true) {
	            let already_listed = false;
                    for (let z = 0; z < navalspace.ports.length; z++) {
	              for (let zz = 0; zz < neighbours.length; zz++) {
	                if (neighbours[zz].neighbour === navalspace.ports[z]) {
		          already_listed = true;
		        }
		      }
	              if (already_listed == false) {
	                neighbours.push({ neighbour : navalspace.ports[z] , overseas : true });
	              }
 		    }
		  }
	        }
	      }
	      if (transit_seas == 3) {
		if (this.doesFactionHaveFriendlyNavalUnitsInSpace(faction, navalspace.key)) {
	          let already_listed = false;
                  for (let z = 0; z < navalspace.ports.length; z++) {
	            for (let zz = 0; zz < neighbours.length; zz++) {
	              if (neighbours[zz].neighbour === navalspace.ports[z]) {
		        already_listed = true;
		      }
		    }
	            if (already_listed == false) {
	              neighbours.push({ neighbour : navalspace.ports[z] , overseas : true });
	            }
 		  }
		}
	      }
	    }
 	  }
        }
      }

      return neighbours;
    }

//} catch (err) {
//  alert("return neighbours bug? this won't kill the game, but it would be useful to know if there is an error message here ---> " + JSON.stringify(err));
//}
    return [];
  }


  //
  // only calculates moves from naval spaces, not outbound from ports
  //
  returnNavalNeighbours(space, transit_passes=1) {
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    let neighbours = [];
    for (let i = 0; i < space.ports.length; i++) {
      let x = space.ports[i];
      neighbours.push(x);
    }
    for (let i = 0; i < space.neighbours.length; i++) {
      let x = space.neighbours[i];
      neighbours.push(x);
    }

    return neighbours;
  }




  //
  // returns adjacent naval and port spaces
  //
  returnNavalAndPortNeighbours(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}

    let key = space.key;
    let neighbours = [];

    //
    // ports add only naval spaces
    //
    if (this.game.spaces[key]) {
      for (let i = 0; i < space.ports.length; i++) {
        let x = space.ports[i];
        neighbours.push(x);
      }
    }

    //
    // naval spaces add ports
    //
    if (this.game.navalspaces[key]) {
      for (let i = 0; i < space.ports.length; i++) {
        let x = space.ports[i];
        neighbours.push(x);
      }
      for (let i = 0; i < space.neighbours.length; i++) {
        let x = space.neighbours[i];
        neighbours.push(x);
      }
    }

    return neighbours;
  }


  //
  // returns both naval and port movement options
  //
  returnNavalMoveOptions(spacekey) {

    let neighbours = [];

    if (this.game.navalspaces[spacekey]) {
      for (let i = 0; i < this.game.navalspaces[spacekey].neighbours.length; i++) {
	neighbours.push(this.game.navalspaces[spacekey].neighbours[i]);
      }
      for (let i = 0; i < this.game.navalspaces[spacekey].ports.length; i++) {
	neighbours.push(this.game.navalspaces[spacekey].ports[i]);
      }
    } else {
      if (this.game.spaces[spacekey]) {
        for (let i = 0; i < this.game.spaces[spacekey].ports.length; i++) {
	  neighbours.push(this.game.spaces[spacekey].ports[i]);
        }
      }
    }

    return neighbours;
  }


  //
  // find the nearest destination.
  //
  returnNearestNavalSpaceOrPortWithFilter(sourcekey, destination_filter, propagation_filter, include_source=1) {

    //
    // return array with results + hops distance
    //
    let results = [];
    let searched_spaces = {};
    let pending_spaces = {};

    //
    // if the source matches our destination, return it
    //
    if (include_source == 1) {
      if (destination_filter(sourcekey)) {
        results.push({ space : sourcekey , hops : 0 });
        return results;
      }
    }

    //
    // put the neighbours into pending
    //
    let n = this.returnNavalNeighbours(sourcekey);

    for (let i = 0; i < n.length; i++) {
      pending_spaces[n[i]] = { hops : 0 , key : n[i] };
    }

    //
    // otherwise propagate outwards searching pending
    //
    let continue_searching = 1;
    while (continue_searching) {

      let count = 0;
      for (let key in pending_spaces) {

	count++;
	let hops = pending_spaces[key].hops;

	if (destination_filter(key)) {
	  results.push({ hops : (hops+1) , key : key });	
	  continue_searching = 0;
	  if (searched_spaces[key]) {
	    // we've searched for this before
	  } else {
	    searched_spaces[key] = { hops : (hops+1) , key : key };
	  }

	} else {

	  if (this.game.navalspaces[key] && results.length == 0) {
	    for (let z = 0; z < this.game.navalspaces[key].ports.length; z++) {

	      let k = this.game.navalspaces[key].ports[z];
	      if (destination_filter(k)) {
	  	results.push({ hops : (hops+1) , key : k });	
	  	continue_searching = 0;
	  	if (searched_spaces[k]) {
	  	  // we've searched for this before
	  	} else {
	  	  searched_spaces[k] = { hops : (hops+1) , key : k };
	  	}
	      }
	    }
	  }
        }

	if (continue_searching) {
	  if (propagation_filter(key)) {
    	    for (let i = 0; i < this.game.navalspaces[key].neighbours.length; i++) {
	      if (searched_spaces[this.game.navalspaces[key].neighbours[i]]) {
		// don't add to pending as we've transversed before
	      } else {
      	        pending_spaces[this.game.navalspaces[key].neighbours[i]] = { hops : (hops+1) , key : this.game.navalspaces[key].neighbours[i] };
	      }
    	    }
	  }
	  searched_spaces[key] = { hops : (hops+1) , key : key };
	}
	delete pending_spaces[key];

      }
      if (count == 0) {
	continue_searching = 0;
	for (let newkey in pending_spaces) {
	  if (pending_spaces[newkey]) { continue_searching = 1; }
	}
      }
    }

    //
    // at this point we have results or not 
    //
    return results;

  }

  //
  // find the nearest destination.
  //
  // transit_seas = filters on spring deploment criteria of two friendly ports on either side of the zone + no uncontrolled ships in zone
  //
  // res = {
  //  hops : N ,   
  //  key : spacekey ,
  //  overseas : 1/0 ,
  // }
  //
  returnNearestSpaceWithFilter(sourcekey, destination_filter, propagation_filter, include_source=1, transit_passes=0, transit_seas=0, faction="", already_crossed_sea_zone=0, is_spring_deployment=0) {

    //
    // return array with results + hops distance
    //
    let results = [];
    let searched_spaces = {};
    let pending_spaces = {};


    //
    // if the source matches our destination, return it
    //
    if (include_source == 1) {
      if (destination_filter(sourcekey)) {
        results.push({ key : sourcekey , space : sourcekey , hops : 0 });
        return results;
      }
    }

    //
    // put the neighbours into pending
    //
    let n = this.returnNeighbours(sourcekey, transit_passes, transit_seas, faction, is_spring_deployment);

    //
    // add any spaces with naval connection
    //
    let s = this.game.spaces[sourcekey];
    let vns = [];
    let pending_vns = [];
    if (s) {
      if (s.ports.length > 0) {
	if (transit_seas) {
	  for (let i = 0; i < s.ports.length; i++) {
	    if (transit_seas == 2) {
	      if (!this.doesNavalSpaceHaveNonFactionShips(s.ports[i], faction)) {
	        vns.push(s.ports[i]);
	      }
	    }
	    if (transit_seas == 1) {
	      if (this.doesNavalSpaceHaveFriendlyShip(s.ports[i], faction)) {
	        vns.push(s.ports[i]);
	      }
	    }
	  }
	  let vnslen = vns.length;

	  for (let i = 0; i < vnslen; i++) {
	    let x = this.game.navalspaces[vns[i]];
	    if (x) {
	      for (let ii = 0; ii < x.neighbours.length; ii++) {
	        if (this.doesNavalSpaceHaveFriendlyShip(x.neighbours[ii], faction)) {        
		  if (!vns.includes(x.neighbours[ii])) {
		    vns.push(x.neighbours[ii]);
		    vnslen++;
		  }
	        }
	      }
	    }
	  }

	  //
	  // any space in port on vns is a starting point too!
	  //
	  for (let i = 0; i < vns.length; i++) {
	    let ns = this.game.navalspaces[vns[i]];
	    for (let i = 0; i < ns.ports.length; i++) {
              if (transit_seas == 2) {
                if (!this.doesNavalSpaceHaveNonFactionShips(this.game.spaces[vns[i]], faction)) {
	          n.push({"neighbour": ns.ports[i],"overseas":true});
                }
              }
              if (transit_seas == 1) {
                if (this.doesNavalSpaceHaveFriendlyShip(vns[i], faction)) {
	          n.push({"neighbour": ns.ports[i],"overseas":true});
                }
              }
	    }
	  }
        }
      }
    }

    for (let i = 0; i < n.length; i++) {
      if (transit_passes == 1) {
        pending_spaces[n[i].neighbour] = { hops : 0 , key : n[i] , overseas : n[i].overseas };
      } else {
	if (!s.pass.includes(n[i].neighbour)) {
          pending_spaces[n[i].neighbour] = { hops : 0 , key : n[i] , overseas : n[i].overseas };
	}
      }
    }

    //
    // otherwise propagate outwards searching pending
    //
    let continue_searching = 1;
    while (continue_searching) {

      let count = 0;
      for (let key in pending_spaces) {

	count++;
	let hops = pending_spaces[key].hops;

	if (destination_filter(key)) {

	  // found results? this is last pass
	  results.push({ hops : (hops+1) , key : key , overseas : pending_spaces[key].overseas });	
	  continue_searching = 0;
	  if (searched_spaces[key]) {
	    // we've searched for this before
	  } else {
	    searched_spaces[key] = { hops : (hops+1) , key : key };
	  }
	} else {

	  if (propagation_filter(key)) {

	    let nn = [];
	    if (pending_spaces[key].overseas) {
	      nn = this.returnNeighbours(key, transit_passes, 0, faction);
	    } else {
	      nn = this.returnNeighbours(key, transit_passes, transit_seas, faction);
	    }

    	    for (let i = 0; i < nn.length; i++) {
	      if (searched_spaces[nn[i].neighbour]) {
		// don't add to pending as we've transversed before
	      } else {
		if (!pending_spaces[nn[i].neighbour]) {
      	          pending_spaces[nn[i].neighbour] = { hops : (hops+1) , key : this.game.spaces[key].neighbours[i] , overseas : nn[i].overseas };
	        } else {
		  if (pending_spaces[key].overseas == false) {
		    if (this.game.spaces[key].neighbours.includes(nn[i].neighbour)) {    
		      pending_spaces[nn[i].neighbour].overseas = false;
		    }
		  }
		}
	      }
    	    }
	  }
	  searched_spaces[key] = { hops : (hops+1) , key : key , overseas : 0 };
	}
	delete pending_spaces[key];
      }

      if (count == 0) {
	continue_searching = 0;
	for (let newkey in pending_spaces) {
	  if (pending_spaces[newkey]) { continue_searching = 1; }
	}
      }
    }

    //
    // at this point we have results or not 
    //
    return results;

  }

  isSpaceElectorate(spacekey) {
    if (spacekey === "augsburg") { return true; }
    if (spacekey === "mainz") { return true; }
    if (spacekey === "trier") { return true; }
    if (spacekey === "cologne") { return true; }
    if (spacekey === "wittenberg") { return true; }
    if (spacekey === "brandenburg") { return true; }
    return false;
  }

  returnNumberOfCatholicElectorates() {
    let controlled_keys = 0;
    if (!this.isSpaceControlled('augsburg', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('mainz', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('trier', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('cologne', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys++; }
    if (!this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfProtestantElectorates() {
    let controlled_keys = 0;
    if (this.isSpaceControlled('augsburg', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('mainz', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('trier', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('cologne', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys++; }
    if (this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys++; }
    return controlled_keys;
  }
  returnProtestantElectorates() {
    let controlled_keys = [];
    if (this.isSpaceControlled('augsburg', "protestant")) { controlled_keys.push("augsburg"); }
    if (this.isSpaceControlled('mainz', "protestant")) { controlled_keys.push("mainz"); }
    if (this.isSpaceControlled('trier', "protestant")) { controlled_keys.push("trier"); }
    if (this.isSpaceControlled('cologne', "protestant")) { controlled_keys.push("cologne"); }
    if (this.isSpaceControlled('wittenberg', "protestant")) { controlled_keys.push("wittenberg"); }
    if (this.isSpaceControlled('brandenburg', "protestant")) { controlled_keys.push("brandenburg"); }
    return controlled_keys;
  }
  returnNumberOfElectoratesControlledByCatholics(political_control=0) {
    let controlled_keys = 0;
    if (political_control == 1) {
      if (this.game.spaces['augsburg'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['mainz'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['trier'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['cologne'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['wittenberg'].political != "protestant") { controlled_keys++; }
      if (this.game.spaces['brandenburg'].political != "protestant") { controlled_keys++; }
      return controlled_keys;
    }
    if (this.game.spaces['augsburg'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['mainz'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['trier'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['cologne'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['wittenberg'].religion === "catholic") { controlled_keys++; }
    if (this.game.spaces['brandenburg'].religion === "catholic") { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfElectoratesControlledByProtestants(political_control=0) {
    let controlled_keys = 0;
    if (political_control == 1) {
      if (this.game.spaces['augsburg'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['mainz'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['trier'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['cologne'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['wittenberg'].political === "protestant") { controlled_keys++; }
      if (this.game.spaces['brandenburg'].political === "protestant") { controlled_keys++; }
      return controlled_keys;
    }
    if (this.game.spaces['augsburg'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['mainz'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['trier'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['cologne'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['wittenberg'].religion === "protestant") { controlled_keys++; }
    if (this.game.spaces['brandenburg'].religion === "protestant") { controlled_keys++; }
    return controlled_keys;
  }
  returnNumberOfKeysControlledByFaction(faction) {
    let controlled_keys = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].type === "key") {
        let owner = this.game.spaces[key].political;
        if (owner == "") { owner = this.game.spaces[key].home; }
        owner = this.returnControllingPower(owner);
        if (owner == faction) {
          controlled_keys++;
        }
      }
    }

    return controlled_keys;
  }
  returnNumberOfKeysControlledByPlayer(player_num) {
    let faction = this.game.state.players_info[player_num-1].faction;
    let controlled_keys = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].type === "key") {
        if (this.game.spaces[key].political === this.factions[faction].key || (this.game.spaces[key].political === "" && this.game.spaces[key].home === this.factions[faction].key)) {
          controlled_keys++;
        }
      }
    }
    return controlled_keys;
  }

  returnNumberOfCatholicSpacesInLanguageZone(language="", do_not_count_unrest = 0) {  
    let catholic_spaces = 0;
    for (let key in this.game.spaces) {
      if (do_not_count_unrest == 0) {
        if ((this.game.spaces[key].unrest == 1 && this.game.spaces[key].religion == "protestant") || this.game.spaces[key].religion === "catholic") {
  	  if (language == "" || language == "all" || this.game.spaces[key].language == language) {
	    catholic_spaces++;
	  }
	}
      } else {
        if (this.game.spaces[key].religion === "catholic") {
  	  if (language == "" || language == "all" || this.game.spaces[key].language == language) {
	    catholic_spaces++;
	  }
        }
      }
    }
    return catholic_spaces;
  }

  returnNumberOfProtestantSpacesInLanguageZone(language="", do_not_count_unrest = 0) {  
    let protestant_spaces = 0;
    for (let key in this.game.spaces) {
      if (do_not_count_unrest == 0) {
        if (this.game.spaces[key].religion === "protestant" && this.game.spaces[key].unrest == 0) {
	  if (language == "all" || language == "" || this.game.spaces[key].language == language) {
	    protestant_spaces++;
	  }
        }
      } else {
        if (this.game.spaces[key].religion === "protestant") {
	  if (language == "all" || language == "" || this.game.spaces[key].language == language) {
	    protestant_spaces++;
	  }
        }
      }
    }
    return protestant_spaces;
  }



  returnNavalSpaces() {

    let seas = {};

    seas['irish'] = {
      top : 775 ,
      left : 1100 ,
      name : "Irish Sea" ,
      ports : ["glasgow","bristol"] ,
      neighbours : ["biscay","north","channel"] ,
    }
    seas['biscay'] = {
      top : 1500 ,
      left : 1400 ,
      name : "Bay of Biscay" ,
      ports : ["brest", "nantes", "bordeaux", "corunna" ] ,
      neighbours : ["irish","channel","atlantic"] ,
    }
    seas['atlantic'] = {
      top : 2700 ,
      left : 850 ,
      name : "Atlantic Ocean" ,
      ports : ["gibraltar" , "seville" , "corunna"] ,
      neighbours : ["biscay"] ,
    }
    seas['channel'] = {
      top : 1020 ,
      left : 1450 ,
      name : "English Channel" ,
      ports : ["brest", "plymouth", "portsmouth", "rouen", "boulogne", "calais" ] ,
      neighbours : ["irish","biscay","north"] ,
    }
    seas['north'] = {
      top : 350 ,
      left : 2100 ,
      name : "North Sea" ,
      ports : ["london", "norwich", "berwick", "edinburgh", "calais", "antwerp", "amsterdam", "bremen", "hamburg" ] ,
      neighbours : ["irish","channel","baltic"] ,
    }
    seas['baltic'] = {
      top : 50 ,
      left : 3150 ,
      name : "Baltic Sea" ,
      ports : ["lubeck", "stettin" ] ,
      neighbours : ["north"] ,
    }
    seas['gulflyon'] = {
      top : 1930 ,
      left : 2430 ,
      name : "Gulf of Lyon" ,
      ports : ["cartagena", "valencia", "palma", "barcelona" , "marseille", "nice" , "genoa", "bastia" ] ,
      neighbours : ["barbary","tyrrhenian"] ,
    }
    seas['barbary'] = {
      top : 2330 ,
      left : 2430 ,
      name : "Barbary Coast" ,
      ports : ["gibraltar", "oran", "cartagena", "algiers" , "tunis", "cagliari" , "palma" ] ,
      neighbours : ["gulflyon","tyrrhenian","ionian","africa"] ,
    }
    seas['tyrrhenian'] = {
      top : 2260 ,
      left : 3300 ,
      name : "Tyrrhenian Sea" ,
      ports : ["genoa" , "bastia" , "rome" , "naples" , "palermo" , "cagliari" , "messina" ] ,
      neighbours : ["barbary","gulflyon"] ,
    }
    seas['africa'] = {
      top : 2770 ,
      left : 4200 ,
      name : "North African Coast" ,
      ports : ["tunis" , "tripoli" , "malta" , "candia" , "rhodes" ] ,
      neighbours : ["ionian","barbary","aegean"] ,
    }
    seas['aegean'] = {
      top : 2470 ,
      left : 4450 ,
      name : "Aegean Sea" ,
      ports : ["rhodes" , "candia" , "coron" , "athens" , "salonika" , "istanbul" ] ,
      neighbours : ["black","africa","ionian"] ,
    }
    seas['ionian'] = {
      top : 2390 ,
      left : 3750 ,
      name : "Ionian Sea" ,
      ports : ["malta" , "messina" , "coron", "lepanto" , "corfu" , "taranto" ] ,
      neighbours : ["barbary","africa","aegean","adriatic"] ,
    }
    seas['adriatic'] = {
      top : 1790 ,
      left : 3400 ,
      name : "Adriatic Sea" ,
      ports : ["corfu" , "durazzo" , "scutari" , "ragusa" , "trieste" , "venice" , "ravenna" , "ancona" ] ,
      neighbours : ["ionian"] ,
    }
    seas['black'] = {
      top : 1450 ,
      left : 4750 ,
      name : "Black Sea" ,
      ports : ["istanbul" , "varna" ] ,
      neighbours : ["aegean"] ,
    }

    for (let key in seas) {
      seas[key].units = {};
      seas[key].units['england'] = [];
      seas[key].units['france'] = [];
      seas[key].units['hapsburg'] = [];
      seas[key].units['ottoman'] = [];
      seas[key].units['papacy'] = [];
      seas[key].units['protestant'] = [];
      seas[key].units['venice'] = [];
      seas[key].units['genoa'] = [];
      seas[key].units['hungary'] = [];
      seas[key].units['scotland'] = [];
      seas[key].units['independent'] = [];
      seas[key].key = key;
    }

    return seas;
  }


  returnSpacesInUnrest() {
    let spaces_in_unrest = [];
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].unrest == 1) { spaces_in_unrest.push(key); }
    }
    return spaces_in_unrest;
  }

  returnSpacesWithAdjacentFactionInfantry(faction) {
    return this.returnSpacesWithFactionInfantry(faction, true);
  }

  returnSpacesWithFactionInfantry(faction, adjacency_ok=false) {
    let spaces_with_infantry = [];
    for (let key in this.game.spaces) {
      let added = false;
      if (this.game.spaces[key].units[faction].length > 0) {
        for (let z = 0; added != true && z < this.game.spaces[key].units[faction].length; z++) {
	  let u = this.game.spaces[key].units[faction][z];
	  if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") { 
            spaces_with_infantry.push(key);
            added = true;
	  }
	} 
      }
      if (adjacency_ok == true && added == false) {
        for (let i = 0; i < this.game.spaces[key].neighbours.length; i++) {
          let n = this.game.spaces[key].neighbours[i];
	  if (added == false && this.game.spaces[n].units[faction].length > 0) {
            for (let z = 0; added != true && z < this.game.spaces[n].units[faction].length; z++) {
	      let u = this.game.spaces[n].units[faction][z];
	      if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") { 
	        spaces_with_infantry.push(key);
	        added = true;
	      }
	    }
	  }
	}
      }
    }
    return spaces_with_infantry;
  }

  returnSpaces() {

    let spaces = {};

    spaces['stirling'] = {
      top: 70,
      left: 1265,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["irish"],
      neighbours: ["glasgow","edinburgh"],
      language: "english",
      type: "fortress"
    }
    spaces['glasgow'] = {
      top: 225,
      left: 1285,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["irish"],
      neighbours: ["stirling","edinburgh","carlisle"],
      language: "english",
      type: "town"
    }
    spaces['edinburgh'] = {
      top: 125,
      left: 1420,
      home: "scotland",
      political: "scotland",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["stirling","glasgow","berwick"],
      language: "english",
      type: "key"
    }
    spaces['berwick'] = {
      top: 183,
      left: 1572,
      home: "england",
      political: "england",
      ports: ["north"],
      neighbours: ["edinburgh","carlisle","york"],
      language: "english",
      religion: "catholic",
      type: "town"
    }
    spaces['carlisle'] = {
      top: 276,
      left: 1447,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["glasgow","berwick","york","shrewsbury"],
      language: "english",
      type: "town"
    }
    spaces['york'] = {
      top: 375,
      left: 1595,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["berwick","carlisle","shrewsbury","lincoln"],
      language: "english",
      type: "key"
    }
    spaces['wales'] = {
      top: 633,
      left: 1398,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["shrewsbury","bristol"],
      language: "english",
      type: "town"

    }
    spaces['shrewsbury'] = {
      top: 521,
      left: 1535,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["wales","carlisle","york","london","bristol"],
      language: "english",
      type: "town"
    }
    spaces['lincoln'] = {
      top: 531,
      left: 1706,
      home: "england",
      political: "england",
      religion: "catholic",
      neighbours: ["london","york"],
      language: "english",
      type: "town"
    }
    spaces['norwich'] = {
      top: 538,
      left: 1896,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["north"],
      neighbours:["london"],
      language: "english",
      type: "town"
    }
    spaces['bristol'] = {
      top: 688,
      left: 1554,
      home: "england",
      political: "england",
      religion: "catholic",
      language: "english",
      ports: ["irish"],
      neighbours: ["shrewsbury","wales","plymouth","portsmouth","london"],
      type: "key"
    }
    spaces['london'] = {
      top: 706,
      left: 1785,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["norwich","lincoln","bristol","portsmouth","shrewsbury"],
      language: "english",
      type: "key"
    }
    spaces['plymouth'] = {
      top: 898,
      left: 1398,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["bristol","portsmouth"],
      language: "english",
      type: "town"
    }
    spaces['portsmouth'] = {
      top: 821,
      left: 1661,
      home: "england",
      political: "england",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["plymouth","bristol","london"],
      language: "english",
      type: "town"
    }
    spaces['calais'] = {
      top: 745,
      left: 2022,
      home: "england",
      political: "england",
      religion: "catholic",
      ports:["north", "channel"], 
      neighbours: ["boulogne","brussels","antwerp"],
      language: "french",
      type: "key"
    }

    spaces['boulogne'] = {
      top: 880,
      left: 1955,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["channel"],
      neighbours: ["calais","rouen","paris","stquentin"],
      language: "french",
      type: "town"
    }
    spaces['stquentin'] = {
      name: "St. Quentin",
      top: 933,
      left: 2093,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["brussels","stdizier","paris","boulogne"],
      language: "french",
      type: "town"
    }
    spaces['stdizier'] = {
      name: "St. Dizier",
      top: 1043,
      left: 2205,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["brussels","stquentin","paris","dijon","metz"],
      language: "french",
      type: "town"
    }
    spaces['paris'] = {
      top: 1063,
      left: 2009,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["rouen","boulogne","stquentin","stdizier","dijon","orleans"],
      language: "french",
      type: "key"
    }
    spaces['rouen'] = {
      top: 1000,
      left: 1805,
      home: "france",
      political: "france",
      ports: ["channel"],
      religion: "catholic",
      neighbours: ["boulogne","paris","tours","nantes"],
      language: "french",
      type: "key"
    }
    spaces['orleans'] = {
      top: 1217,
      left: 2018,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["paris","tours","dijon","lyon"],
      language: "french",
      type: "town"
    }
    spaces['dijon'] = {
      top: 1205,
      left: 2204,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["stdizier","paris","orleans","lyon","besancon"],
      language: "french",
      type: "town"
    }
    spaces['limoges'] = {
      top: 1398,
      left: 1975,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["tours","bordeaux","lyon"],
      language: "french",
      type: "town"
    }
    spaces['tours'] = {
      top: 1277,
      left: 1849,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["rouen","nantes","bordeaux","limoges","orleans"],
      language: "french",
      type: "town"
    }
    spaces['nantes'] = {
      top: 1310,
      left: 1650,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["biscay"],
      neighbours: ["brest","rouen","tours","bordeaux"],
      language: "french",
      type: "town"
    }
    spaces['brest'] = {
      top: 1173,
      left: 1409,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["channel","biscay"],
      neighbours: ["nantes"],
      language: "french",
      type: "town"
    }
    spaces['bordeaux'] = {
      top: 1568,
      left: 1780,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["biscay"],
      neighbours: ["toulouse", "navarre", "nantes","tours","limoges"],
      pass: ["navarre"],
      language: "french",
      type: "key"
    }
    spaces['lyon'] = {
      top: 1445,
      left: 2312,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["avignon","limoges","orleans","dijon","geneva","grenoble"],
      language: "french",
      type: "key"
    }
    spaces['grenoble'] = {
      top: 1590,
      left: 2437,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["turin","lyon","geneva"],
      pass: ["turin"],
      language: "french",
      type: "town"
    }
    spaces['avignon'] = {
      top: 1645,
      left: 2292,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["barcelona","toulouse","lyon","marseille"],
      pass: ["barcelona"],
      language: "french",
      type: "town"
    }
    spaces['marseille'] = {
      top: 1781,
      left: 2390,
      home: "france",
      political: "france",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["avignon","nice"],
      language: "french",
      type: "key"
    }
    spaces['toulouse'] = {
      top: 1740,
      left: 1990,
      home: "france",
      political: "france",
      religion: "catholic",
      neighbours: ["barcelona","bordeaux","avignon"],
      pass: ["barcelona"],
      language: "french",
      type: "town"
    }

    spaces['munster'] = {
      top: 537,
      left: 2500,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["bremen","kassel","cologne","amsterdam"],
      language: "german",
      type: "town"
    }
    spaces['bremen'] = {
      top: 422,
      left: 2595,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["north"],
      neighbours:["munster","brunswick","hamburg"],
      language: "german",
      type: "town"
    }
    spaces['hamburg'] = {
      top: 345,
      left: 2758,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["bremen","brunswick","lubeck"],
      language: "german",
      type: "town"
    }
    spaces['lubeck'] = {
      top: 258,
      left: 2985,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["baltic"],
      neighbours: ["hamburg","magdeburg","brandenburg","stettin"],
      language: "german",
      type: "town"
    }
    spaces['stettin'] = {
      top: 310,
      left: 3214,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      ports: ["baltic"],
      neighbours: ["lubeck","brandenburg"],
      language: "german",
      type: "town"
    }
    spaces['brandenburg'] = {
      top: 467,
      left: 3080,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["stettin","lubeck","magdeburg","wittenberg","breslau"],
      language: "german",
      type: "electorate"
    }
    spaces['wittenberg'] = {
      top: 610,
      left: 3133,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["brandenburg","magdeburg","leipzig","prague","breslau"],
      language: "german",
      type: "electorate"
    }
    spaces['magdeburg'] = {
      top: 536,
      left: 2935,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["lubeck","brandenburg","wittenberg","erfurt","brunswick"],
      language: "german",
      type: "town"
    }
    spaces['brunswick'] = {
      top: 568,
      left: 2722,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["bremen","hamburg","magdeburg","kassel"],
      language: "german",
      type: "town"
    }
    spaces['cologne'] = {
      top: 726,
      left: 2500,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["munster","mainz","liege"],
      language: "german",
      type: "electorate"
    }
    spaces['kassel'] = {
      top: 714,
      left: 2665,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["munster","brunswick","erfurt","nuremberg","mainz"],
      language: "german",
      type: "town"
    }
    spaces['erfurt'] = {
      top: 750,
      left: 2824,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["magdeburg","kassel","leipzig"],
      language: "german",
      type: "town"
    }
    spaces['leipzig'] = {
      top: 690,
      left: 2983,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["wittenberg","prague","nuremberg","erfurt"],
      language: "german",
      type: "town"
    }
    spaces['regensburg'] = {
      top: 956,
      left: 3033,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["nuremberg","augsburg","salzburg","linz"],
      language: "german",
      type: "town"
    }
    spaces['salzburg'] = {
      top: 1108,
      left: 3147,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["graz","linz","regensburg","augsburg","innsbruck"],
      pass: ["graz"],
      language: "german",
      type: "town"
    }
    spaces['augsburg'] = {
      top: 1084,
      left: 2864,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["innsbruck","worms","nuremberg","regensburg","salzburg"],
      pass: ["innsbruck"],
      language: "german",
      type: "electorate"
    }
    spaces['nuremberg'] = {
      top: 930,
      left: 2837,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["augsburg","worms","mainz","kassel","leipzig","regensburg"],
      language: "german",
      type: "town"
    }
    spaces['mainz'] = {
      top: 872,
      left: 2668,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["trier","cologne","kassel","nuremberg","worms"],
      language: "german",
      type: "electorate"
    }
    spaces['trier'] = {
      top: 897,
      left: 2521,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["liege","metz","mainz"],
      language: "german",
      type: "electorate"
    }
    spaces['strasburg'] = {
      top: 1070,
      left: 2578,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["metz","besancon","basel","worms"],
      language: "german",
      type: "town"
    }
    spaces['worms'] = {
      top: 1009,
      left: 2704,
      home: "",
      political: "hapsburg",
      religion: "catholic",
      neighbours: ["strasburg","mainz","nuremberg","augsburg"],
      language: "german",
      type: "town"
    }
    spaces['navarre'] = {
      top: 1814,
      left: 1702,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["bordeaux","zaragoza","bilbao"],
      pass: ["bordeaux"],
      language: "spanish",
      type: "key"
    }
    spaces['bilbao'] = {
      top: 1825,
      left: 1533,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["corunna","valladolid","zaragoza","navarre"],
      language: "spanish",
      type: "town"
    }
    spaces['corunna'] = {
      top: 1870,
      left: 1015,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["biscay","atlantic"],
      neighbours: ["bilbao","valladolid"],
      language: "spanish",
      type: "town"
    }
    spaces['valladolid'] = {
      top: 2058,
      left: 1394,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["corunna","bilbao","madrid"],
      language: "spanish",
      type: "key"
    }
    spaces['zaragoza'] = {
      top: 2025,
      left: 1777,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["navarre","bilbao","madrid","barcelona"],
      language: "spanish",
      type: "town"
    }
    spaces['barcelona'] = {
      top: 2062,
      left: 2106,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["toulouse","avignon","zaragoza","valencia"],
      pass: ["toulouse","avignon"],
      language: "spanish",
      type: "key"
    }
    spaces['palma'] = {
      top: 2266,
      left: 2211,
      home: "hapsburg",
      political: "",
      ports: ["gulflyon","barbary"],
      neighbours: [],
      language: "spanish",
      religion: "catholic",
      type: "town"
    }
    spaces['madrid'] = {
      top: 2236,
      left: 1550,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["cordoba","valladolid","zaragoza","valencia"],
      language: "spanish",
      type: "town"
    }
    spaces['valencia'] = {
      top: 2333,
      left: 1871,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["cartagena","madrid","barcelona"],
      language: "spanish",
      type: "town"
    }
    spaces['cartagena'] = {
      top: 2593,
      left: 1830,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","barbary"],
      neighbours: ["granada","valencia"],
      language: "spanish",
      type: "town"
    }
    spaces['granada'] = {
      top: 2657,
      left: 1558,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["cordoba","gibraltar","cartagena"],
      language: "spanish",
      type: "town"
    }
    spaces['seville'] = {
      top: 2642,
      left: 1319,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["atlantic"],
      neighbours: ["cordoba","gibraltar"],
      language: "spanish",
      type: "key"
    }
    spaces['cordoba'] = {
      top: 2530,
      left: 1446,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["madrid","seville","granada"],
      language: "spanish",
      type: "town"
    }
    spaces['gibraltar'] = {
      top: 2814,
      left: 1374,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["atlantic","barbary"],
      neighbours: ["seville","granada"],
      language: "spanish",
      type: "fortress"
    }
    spaces['oran'] = {
      top: 2822,
      left: 1902,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["barbary"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['algiers'] = {
      top: 2656,
      left: 2275,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["barbary"],
      neighbours: [],
      language: "other",
      type: "key"
    }
    spaces['tunis'] = {
      top: 2599,
      left: 2945,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["barbary","africa"],
      neighbours: [],
      language: "other",
      type: "key"
    }
    spaces['cagliari'] = {
      top: 2320,
      left: 2828,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports:["tyrrhenian","barbary"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['palermo'] = {
      top: 2421,
      left: 3260,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["messina"],
      language: "italian",
      type: "town"
    }
    spaces['messina'] = {
      top: 2429,
      left: 3475,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian","ionian"],
      neighbours: ["palermo","naples","taranto"],
      language: "italian",
      type: "town"
    }
    spaces['cerignola'] = {
      top: 1915,
      left: 3426,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["taranto","ancona","rome"],
      language: "italian",
      type: "town"
    }
    spaces['taranto'] = {
      top: 2080,
      left: 3597,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["ionian"],
      neighbours: ["cerignola","naples","messina"],
      language: "italian",
      type: "town"
    }
    spaces['naples'] = {
      top: 2087,
      left: 3358,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["rome","taranto","messina"],
      language: "italian",
      type: "key"
    }
    spaces['malta'] = {
      top: 2715,
      left: 3380,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["ionian","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['vienna'] = {
      top: 1020,
      left: 3474,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["brunn","linz","graz","pressburg"],
      language: "german",
      type: "key"
    }
    spaces['linz'] = {
      top: 1045,
      left: 3288,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["prague","regensburg","salzburg","vienna"],
      language: "german",
      type: "town"
    }
    spaces['graz'] = {
      top: 1210,
      left: 3377,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["salzburg","vienna","mohacs","agram","trieste"],
      pass: ["salzburg"],
      language: "german",
      type: "town"
    }
    spaces['trieste'] = {
      top: 1392,
      left: 3257,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["graz","agram","zara","venice"],
      language: "italian",
      type: "town"
    }
    spaces['innsbruck'] = {
      top: 1170,
      left: 3016,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["augsburg","trent","zurich","salzburg"],
      pass: ["augsburg","trent"],
      language: "german",
      type: "town"
    }
    spaces['tripoli'] = {
      top: 3030,
      left: 3316,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["africa"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['candia'] = {
      top: 2670,
      left: 4484,
      home: "venice",
      political: "",
      religion: "catholic",
      ports: ["aegean","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['rhodes'] = {
      top: 2524,
      left: 4730,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["aegean","africa"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['corfu'] = {
      top: 2210,
      left: 3868,
      home: "venice",
      political: "",
      religion: "catholic",
      ports: ["ionian", "adriatic"],
      neighbours: [],
      language: "other",
      type: "fortress"
    }
    spaces['coron'] = {
      top: 2510,
      left: 4146,
      home: "ottoman",
      political: "",
      religion: "other",
      ports:["ionian","aegean"],
      neighbours: ["athens"],
      language: "other",
      type: "town"
    }
    spaces['athens'] = {
      top: 2346,
      left: 4286,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["aegean"],
      neighbours: ["larissa","lepanto","coron"],
      language: "other",
      type: "key"
    }
    spaces['lepanto'] = {
      top: 2320,
      left: 4057,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["ionian"],
      neighbours: ["larissa","athens"],
      language: "other",
      type: "town"
    }
    spaces['larissa'] = {
      top: 2184,
      left: 4130,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["durazzo","lepanto","athens","salonika"],
      pass: ["durazzo"],
      language: "other",
      type: "town"
    }
    spaces['salonika'] = {
      top: 2010,
      left: 4164,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["aegean"],
      neighbours: ["sofia","larissa","edirne"],
      pass: ["sofia"],
      language: "other",
      type: "key"
    }
    spaces['durazzo'] = {
      top: 2040,
      left: 3844,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["adriatic"],
      neighbours: ["larissa","scutari"],
      pass: ["larissa"],
      language: "other",
      type: "town"
    }
    spaces['scutari'] = {
      top: 1860,
      left: 3819,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["adriatic"],
      neighbours: ["nezh","ragusa","durazzo"],
      pass: ["nezh"],
      language: "other",
      type: "fortress"
    }
    spaces['edirne'] = {
      top: 1840,
      left: 4532,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["varna","istanbul","salonika","sofia",],
      language: "other",
      type: "key"
    }
    spaces['istanbul'] = {
      top: 1890,
      left: 4775,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["black","aegean"],
      neighbours: ["edirne","varna"],
      language: "other",
      type: "key"
    }
    spaces['varna'] = {
      top: 1620,
      left: 4653,
      home: "ottoman",
      political: "",
      religion: "other",
      ports: ["black"],
      neighbours: ["bucharest","edirne","istanbul"],
      language: "other",
      type: "town"
    }
    spaces['bucharest'] = {
      top: 1430,
      left: 4459,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["nicopolis","varna"],
      language: "other",
      type: "town"
    }
    spaces['nicopolis'] = {
      top: 1570,
      left: 4336,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["szegedin","sofia","bucharest","belgrade"],
      pass: ["szegedin","sofia"],
      language: "other",
      type: "town"
    }
    spaces['sofia'] = {
      top: 1765,
      left: 4275,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["salonika","nicopolis","nezh","edirne"],
      pass: ["salonika","nicopolis"],
      language: "other",
      type: "town"
    }
    spaces['nezh'] = {
      top: 1652,
      left: 4070,
      home: "ottoman",
      political: "",
      religion: "other",
      neighbours: ["scutari","belgrade","sofia"],
      pass: ["scutari"],
      language: "other",
      type: "town"
    }


    spaces['belgrade'] = {
      top: 1450,
      left: 3894,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["ragusa","szegedin","mohacs","agram","nezh","nicopolis"],
      pass: ["ragusa"],
      language: "other",
      type: "key"
    }
    spaces['szegedin'] = {
      top: 1268,
      left: 3846,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["nicopolis","buda","belgrade"],
      pass: ["nicopolis"],
      language: "other",
      type: "town"
    }
    spaces['mohacs'] = {
      top: 1353,
      left: 3710,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["buda","graz","agram","belgrade"],
      language: "other",
      type: "town"
    }
    spaces['agram'] = {
      top: 1373,
      left: 3460,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["zara","graz","trieste","belgrade","mohacs"],
      pass: ["zara"],
      language: "other",
      type: "town"
    }
    spaces['buda'] = {
      top: 1104,
      left: 3746,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["pressburg","mohacs","szegedin"],
      language: "other",
      type: "key"
    }
    spaces['pressburg'] = {
      top: 1080,
      left: 3613,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["vienna","buda"],
      language: "other",
      type: "town"
    }
    spaces['brunn'] = {
      top: 840,
      left: 3526,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["breslau","prague","vienna"],
      language: "other",
      type: "town"
    }
    spaces['breslau'] = {
      top: 640,
      left: 3466,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["brandenburg","wittenberg","brunn"],
      language: "other",
      type: "town"
    }
    spaces['prague'] = {
      top: 785,
      left: 3230,
      home: "hungary",
      political: "",
      religion: "catholic",
      neighbours: ["brunn", "wittenberg","leipzig","linz"],
      language: "other",
      type: "key"
    }
    spaces['amsterdam'] = {
      top: 546,
      left: 2244,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["antwerp","munster"],
      language: "other",
      type: "town"
    }
    spaces['antwerp'] = {
      top: 669,
      left: 2168,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      ports: ["north"],
      neighbours: ["antwerp","liege","brussels","calais"],
      language: "other",
      type: "key"
    }
    spaces['brussels'] = {
      top: 823,
      left: 2201,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["antwerp","calais","stquentin","stdizier","liege"],
      language: "french",
      type: "fortress"
    }
    spaces['liege'] = {
      top: 783,
      left: 2351,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["cologne","trier","metz","brussels","antwerp"],
      language: "french",
      type: "town"
    }
    spaces['metz'] = {
      top: 995,
      left: 2384,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["liege","trier","strasburg","besancon","stdizier"],
      language: "french",
      type: "key"
    }
    spaces['besancon'] = {
      top: 1169,
      left: 2390,
      home: "hapsburg",
      political: "",
      religion: "catholic",
      neighbours: ["metz","dijon","geneva","basel","strasburg"],
      language: "french",
      type: "fortress"
    }
    spaces['basel'] = {
      top: 1211,
      left: 2558,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["strasburg","besancon","geneva","zurich"],
      language: "german",
      type: "town"
    }
    spaces['zurich'] = {
      top: 1216,
      left: 2712,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["basel","innsbruck"],
      language: "german",
      type: "town"
    }
    spaces['geneva'] = {
      top: 1367,
      left: 2474,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["basel","besancon","lyon","turin","grenoble"],
      pass: ["turin"],
      language: "french",
      type: "town"
    }
    spaces['milan'] = {
      top: 1373,
      left: 2746,
      home: "independent",
      political: "france",
      religion: "catholic",
      neighbours: ["trent","modena","pavia","turin"],
      language: "italian",
      type: "key"
    }
    spaces['trent'] = {
      top: 1310,
      left: 2933,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["innsbruck","milan","modena","venice"],
      pass: ["innsbruck"],
      language: "italian",
      type: "town"
    }
    spaces['modena'] = {
      top: 1486,
      left: 2951,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["trent","milan","pavia","florence","ravenna","venice"],
      language: "italian",
      type: "town"
    }
    spaces['pavia'] = {
      top: 1505,
      left: 2800,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["milan","turin","genoa","modena"],
      language: "italian",
      type: "town"
    }
    spaces['turin'] = {
      top: 1530,
      left: 2585,
      home: "independent",
      political: "france",
      religion: "catholic",
      neighbours: ["milan","pavia","geneva","grenoble","genoa"],
      pass: ["grenoble","geneva"],
      language: "italian",
      type: "town"
    }
    spaces['nice'] = {
      top: 1733,
      left: 2580,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["gulflyon"],
      neighbours: ["genoa","marseille"],
      pass: ["genoa"],
      language: "french",
      type: "town"
    }
    spaces['florence'] = {
      top: 1642,
      left: 2976,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["modena","genoa","siena"],
      language: "italian",
      type: "key"
    }
    spaces['siena'] = {
      top: 1805,
      left: 2988,
      home: "independent",
      political: "",
      religion: "catholic",
      neighbours: ["genoa","florence","rome"],
      language: "italian",
      type: "town"
    }
    spaces['bastia'] = {
      top: 1829,
      left: 2784,
      home: "genoa",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","tyrrhenian"],
      neighbours: [],
      language: "other",
      type: "town"
    }
    spaces['genoa'] = {
      top: 1626,
      left: 2726,
      home: "genoa",
      political: "",
      religion: "catholic",
      ports: ["gulflyon","tyrrhenian"],
      neighbours: ["florence", "nice","pavia","turin","siena"],
      pass: ["nice"],
      language: "italian",
      type: "key"
    }
    spaces['rome'] = {
      top: 1924,
      left: 3125,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["tyrrhenian"],
      neighbours: ["siena","ancona","cerignola","naples"],
      language: "italian",
      type: "key"
    }
    spaces['ancona'] = {
      top: 1754,
      left: 3238,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["ravenna","rome","cerignola"],
      language: "italian",
      type: "town"
    }
    spaces['ravenna'] = {
      top: 1596,
      left: 3130,
      home: "papacy",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["venice","modena","ancona"],
      language: "italian",
      type: "key" 
    }
    spaces['venice'] = {
      top: 1399,
      left: 3086,
      home: "venice",
      political: "",
      religion: "catholic",
      ports:["adriatic"],
      neighbours: ["trent","modena","ravenna","trieste"],
      language: "italian",
      type: "key"
    }
    spaces['zara'] = {
      top: 1571,
      left: 3374,
      home: "venice",
      political: "",
      religion: "catholic",
      neighbours: ["agram","ragusa","trieste"],
      pass: ["agram"],
      language: "other",
      type: "town"
    }
    spaces['ragusa'] = {
      top: 1750,
      left: 3660,
      home: "independent",
      political: "",
      religion: "catholic",
      ports: ["adriatic"],
      neighbours: ["belgrade","zara","scutari"],
      pass: ["belgrade"],
      language: "italian",
      type: "town"
    }

    //
    // foreign war cards are spaces
    //
    spaces['egypt'] = {
      top: 800,
      left: 4500,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }
    spaces['ireland'] = {
      top: 800,
      left: 4125,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }
    spaces['persia'] = {
      top: 500,
      left: 3800,
      home: "independent",
      political: "",
      religion: "",
      ports: [],
      neighbours: [],
      pass: [],
      language: "",
      type: "war"
    }

    for (let key in spaces) {
      spaces[key].key = key;
      spaces[key].units = {};
      spaces[key].units['england'] = [];
      spaces[key].units['france'] = [];
      spaces[key].units['hapsburg'] = [];
      spaces[key].units['ottoman'] = [];
      spaces[key].units['papacy'] = [];
      spaces[key].units['protestant'] = [];
      spaces[key].units['venice'] = [];
      spaces[key].units['genoa'] = [];
      spaces[key].units['hungary'] = [];
      spaces[key].units['scotland'] = [];
      spaces[key].units['independent'] = [];
      spaces[key].university = 0;
      spaces[key].unrest = 0;
      if (!spaces[key].ports) { spaces[key].ports = []; }
      if (!spaces[key].pass) { spaces[key].pass = []; }
      if (!spaces[key].name) { spaces[key].name = key.charAt(0).toUpperCase() + key.slice(1); }
      if (!spaces[key].key) { spaces[key].key = key; }
      if (!spaces[key].besieged) { spaces[key].besieged = 0; }
      if (!spaces[key].besieged_factions) { spaces[key].besieged_factions = []; }
    }

    return spaces;

  }


  isOccupied(space) {

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}

    for (let key in space.units) {
      if (space.units[key].length > 0) { return 1; }
    }

    return 0;
  }

  isElectorate(spacekey) {

    try { if (spacekey.key) { spacekey = spacekey.key; } } catch (err) {}

    if (spacekey === "augsburg") { return 1; }
    if (spacekey === "trier") { return 1; }
    if (spacekey === "cologne") { return 1; }
    if (spacekey === "wittenberg") { return 1; }
    if (spacekey === "mainz") { return 1; }
    if (spacekey === "brandenburg") { return 1; }
    return 0;
  }

  //
  // import space attaches events / functions to spaces if they do not exist
  //
  importSpace(obj, key) {

    let his_self = this;

    obj.key = key;

    if (obj.name == null)               { obj.name = "Unknown"; }
    if (obj.owner == null)              { obj.owner = -1; }          
    if (obj.type == null)               { obj.type = "town"; }     
    if (obj.debaters == null)           { obj.debaters = []; }     
    if (obj.returnView == null)		{ 

      obj.returnView = function () {

	let html = '<div class="space_view" id="">';
	let is_naval_space = false;
	let space = his_self.game.spaces[obj.key];
	if (his_self.game.navalspaces[obj.key]) {
	  space = his_self.game.navalspaces[obj.key];
	  is_naval_space = true;
	}

	let home = obj.home;
	let religion = obj.religion;
	let political = obj.political;
	let language = obj.language;
	if (!political) { political = obj.home; }

	if (political == "genoa" || political == "venice" || political == "scotland" || political == "hungary" || political == "independent") { his_self.game.state.board[political] = his_self.returnOnBoardUnits(political); } else {
	  if (home == "genoa" || home == "venice" || home == "scotland" || home == "hungary" || home == "independent") { his_self.game.state.board[home] = his_self.returnOnBoardUnits(home); }
	}

	if (is_naval_space) {
	  html += `
	    <div class="space_name">${obj.name}</div>
	    <div class="space_units">
	  `;
	} else {
	  html += `
	    <div class="space_name">${obj.name}</div>
	    <div class="space_properties">
	      <div class="religion"><div class="${religion}" style="background-image: url('${his_self.returnReligionImage(religion)}')"></div><div class="label">${religion} religion</div></div>
	      <div class="political"><div class="${political}" style="background-image: url('${his_self.returnControlImage(political)}')"></div><div class="label">${political} control</div></div>
	      <div class="language"><div class="${language}" style="background-image: url('${his_self.returnLanguageImage(language)}')"></div><div class="label">${language} language</div></div>
	      <div class="home"><div class="${home}" style="background-image: url('${his_self.returnControlImage(home)}')"></div><div class="label">${home} home</div></div>
	    </div>
	    <div class="space_units">
	  `;
	}

        for (let key in space.units) {
	  html += his_self.returnArmyTiles(key, obj.key);
	  html += his_self.returnMercenaryTiles(key, obj.key);
	  html += his_self.returnPersonagesTiles(key, obj.key);
	  html += his_self.returnNavalTiles(key, obj.key);
        }

        for (let f in space.units) {
	  if (space.units[f].length > 0) {
            for (let i = 0; i < space.units[f].length; i++) {
	      let b = "";
	      if (space.units[f][i].besieged) { b = ' (besieged)'; }
	      if (space.units[f][i].locked) { b = ' (locked)'; }
	      html += `<div class="space_unit">${f} - ${space.units[f][i].type} ${b}</div>`;
	    }
	  }
	}

	html += `</div>`;
	html += `</div>`;

	return html;

      };

    }

    return obj;

  }


  //
  // Allies
  //
  // are by definition major powers as opposed minor / activated powers, although 
  // if you ask areAllies() or areEnemies() on combinations of faction names that 
  // include minor-activated powers like scotland or genoa these functions will 
  // politely let you know if those minor-powers are activated to an ally or enemy
  //
  returnDeclarationOfWarCost(f1, f2) {
    if (f1 == "ottoman") {
      if (f2 == "ottoman") 	{ return 0; }
      if (f2 == "hapsburg") 	{ return 2; }
      if (f2 == "england") 	{ return 2; }
      if (f2 == "france") 	{ return 2; }
      if (f2 == "papacy") 	{ return 2; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 1; }
    }
    if (f1 == "hapsburg") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 2; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 4; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 2; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 1; }
      if (f2 == "venice") 	{ return 2; }
    }
    if (f1 == "england") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 1; }
      if (f2 == "england") 	{ return 0; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 3; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 1; }
      if (f2 == "venice") 	{ return 0; }
    }
    if (f1 == "france") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 3; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 0; }
      if (f2 == "papacy") 	{ return 3; }
      if (f2 == "protestant") 	{ return 2; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 2; }
      if (f2 == "venice") 	{ return 1; }
    }
    if (f1 == "papacy") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 4; }
      if (f2 == "england") 	{ return 3; }
      if (f2 == "france") 	{ return 3; }
      if (f2 == "papacy") 	{ return 0; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 2; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 2; }
    }
    if (f1 == "protestant") {
      if (f2 == "ottoman") 	{ return 2; }
      if (f2 == "hapsburg") 	{ return 0; }
      if (f2 == "england") 	{ return 2; }
      if (f2 == "france") 	{ return 2; }
      if (f2 == "papacy") 	{ return 0; }
      if (f2 == "protestant") 	{ return 0; }
      if (f2 == "genoa") 	{ return 1; }
      if (f2 == "hungary") 	{ return 0; }
      if (f2 == "scotland") 	{ return 0; }
      if (f2 == "venice") 	{ return 1; }
    }
    return 0;
  }
  returnDeclarationOfWarTargets(faction) {

    let na = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (!this.areAllies(faction, io[i])) { na.push(io[i]); }
      }
    }
    if (!this.areAllies(faction, "genoa")) { na.push("genoa"); }
    if (!this.areAllies(faction, "scotland")) { 
      if (faction != "protestant" && faction != "papacy" && faction != "ottoman") { na.push("scotland"); }
    }
    if (!this.areAllies(faction, "venice")) { 
      if (faction != "england") { na.push("venice"); }
    }

    let rv = [];

    for (let i = 0; i < na.length; i++) {
      if (na[i] != faction) {
        if (this.returnDeclarationOfWarCost(faction, na[i]) > 0) {
	  rv.push({ faction : na[i] , cost : this.returnDeclarationOfWarCost(faction, na[i]) });
        }
      }
    } 

    return rv;
  }

  returnAllies(faction) { 
    let f = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (this.areAllies(faction, io[i])) { f.push(io[i]); }
      }
    }
    if (this.areAllies(faction, "genoa")) { f.push("genoa"); }
    if (this.areAllies(faction, "venice")) { f.push("venice"); }
    if (this.areAllies(faction, "hungary")) { f.push("hungary"); }
    if (this.areAllies(faction, "scotland")) { f.push("scotland"); }
    return f;
  }

  returnEnemies(faction, include_minor_powers=false) { 
    let f = [];
    let io = this.returnImpulseOrder();
    for (let i = 0; i < io.length; i++) {
      if (io[i] !== faction) {
        if (this.areEnemies(faction, io[i])) { f.push(io[i]); }
      }
    }
    if (include_minor_powers) {
      if (this.areEnemies(faction, "hungary")) { f.push("hungary"); }
      if (this.areEnemies(faction, "scotland")) { f.push("scotland"); }
      if (this.areEnemies(faction, "venice")) { f.push("venice"); }
      if (this.areEnemies(faction, "genoa")) { f.push("genoa"); }
    }
    return f;
  }

  areAllies(faction1, faction2, count_minor_activated_factions=1) {
    if (faction1 == faction2) { return 1; }
    try { if (this.game.state.alliances[faction1][faction2].allies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.alliances[faction2][faction1].allies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction1].includes(faction2)) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction2].includes(faction1)) { return 1; } } catch (err) {}
    if (count_minor_activated_factions) {
      if (this.isMinorPower(faction1) || this.isMinorPower(faction2)) {
        let f1cp = this.returnControllingPower(faction1);
        let f2cp = this.returnControllingPower(faction2);
        try { if (this.game.state.alliances[f2cp][f1cp].allies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f1cp][f2cp].allies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f2cp][f1cp].allies == 1) { return 1; } } catch (err) {}
      }
    }
    return 0;
  }

  areEnemies(faction1, faction2, count_minor_activated_factions=1) {

    if (faction1 === faction2) { return 0; }
    try { if (this.game.state.alliances[faction1][faction2].enemies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.alliances[faction2][faction1].enemies == 1) { return 1; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction1].includes(faction2)) { return 0; } } catch (err) {}
    try { if (this.game.state.activated_powers[faction2].includes(faction1)) { return 0; } } catch (err) {}
    if (count_minor_activated_factions) {
      if (this.isMinorPower(faction1) || this.isMinorPower(faction2)) {
        let f1cp = this.returnControllingPower(faction1);
        let f2cp = this.returnControllingPower(faction2);
        try { if (this.game.state.alliances[f1cp][f2cp].enemies == 1) { return 1; } } catch (err) {}
        try { if (this.game.state.alliances[f2cp][f1cp].enemies == 1) { return 1; } } catch (err) {}
      }
    }
    return 0;
  }

  setActivatedPower(faction, activated_power) {
    if (!this.game.state.activated_powers[faction].includes(activated_power)) { 
      this.game.state.activated_powers[faction].push(activated_power);
    }

    //
    // any units not belonging to this activated_power or the faction must be
    // relocated to their capital (if exists) or destroyed.
    //
    for (let key in this.game.spaces) {
      let space = this.game.spaces[key];
      if (space.political == activated_power || (space.political == "" && space.home == activated_power)) {
	for (let f in space.units) {
	  if (f !== faction && f !== activated_power) {
	    if (space.units[f].length > 0) {
	      this.moveFactionUnitsInSpaceToCapitalIfPossible(f, space.key);
	    }
	  }
	}
      }
    }
  }


  unsetActivatedPower(faction, activated_power) {

    if (this.game.state.activated_powers[faction].includes(activated_power)) {
      let x = [];
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
        if (this.game.state.activated_powers[faction][i] !== activated_power) {
          x.push(this.game.state.activated_powers[faction][i]);
        }
      }
      this.game.state.activated_powers[faction] = x;
    }

   
    //
    // any units not belonging to this activated_power must be
    // relocated to their capital (if exists) or destroyed.
    //
    for (let key in this.game.spaces) {
      let space = this.game.spaces[key];
      if (space.political == activated_power || (space.political == "" && space.home == activated_power)) {
        for (let f in space.units) {
          if (f !== faction && f !== activated_power) {
            if (space.units[f].length > 0) {
              this.moveFactionUnitsInSpaceToCapitalIfPossible(f, space.key);
            }
          }
        }
      }
    } 

  }

  isActivatedPower(faction, activated_power) {
    if (this.game.state.activated_powers[faction].includes(activated_power)) {
      return 1;
    }
    return 0;
  }


  setAllies(faction1, faction2, amp=1) {

    if ((faction1 == "hungary" || faction2 == "hungary") && (faction1 == "hapsburg" || faction2 == "hapsburg")) {
     this.game.state.events.defeat_of_hungary_bohemia = 1;

      if (this.areEnemies("hungary", "ottoman") && !this.areEnemies("ottoman", "hapsburg"))    {
	if (this.game.state.events.defeat_of_hungary_bohemia == 0) { 
	  this.game.queue.push("natural_enemy_intervention\tottoman\thungary\thapsburg");
	}
      }
      if (this.areEnemies("hungary", "protestant") && !this.areEnemies("protestant", "hapsburg")) { this.game.queue.push("natural_enemy_intervention\tprotestant\thungary\thapsburg"); }
      if (this.areEnemies("hungary", "france") && !this.areEnemies("france", "hapsburg"))     { this.game.queue.push("natural_enemy_intervention\tfrance\thungary\thapsburg"); }
      if (this.areEnemies("hungary", "papacy") && !this.areEnemies("papacy", "hapsburg"))     { this.game.queue.push("natural_enemy_intervention\tpapacy\thungary\thapsburg"); }
      if (this.areEnemies("hungary", "england") && !this.areEnemies("england", "hapsburg"))    { this.game.queue.push("natural_enemy_intervention\tengland\thungary\thapsburg"); }
    }
    if ((faction1 == "scotland" || faction2 == "scotland") && (faction1 == "france" || faction2 == "france")) {
      if (this.areEnemies("scotland", "ottoman") && !this.areEnemies("ottoman", "france"))    { this.game.queue.push("natural_enemy_intervention\tottoman\tscotland\tfrance"); }
      if (this.areEnemies("scotland", "protestant") && !this.areEnemies("protestant", "france")) { this.game.queue.push("natural_enemy_intervention\tprotestant\tscotland\tfrance"); }
      if (this.areEnemies("scotland", "hapsburg") && !this.areEnemies("hapsburg", "france"))   { this.game.queue.push("natural_enemy_intervention\thapsburg\tscotland\tfrance"); }
      if (this.areEnemies("scotland", "papacy") && !this.areEnemies("papacy", "france"))     { this.game.queue.push("natural_enemy_intervention\tpapacy\tscotland\tfrance"); }
      if (this.areEnemies("scotland", "england") && !this.areEnemies("england", "france"))    { this.game.queue.push("natural_enemy_intervention\tengland\tscotland\tfrance"); }
    }
    if ((faction1 == "venice" || faction2 == "venice") && (faction1 == "papacy" || faction2 == "papacy")) {
      if (this.areEnemies("venice", "ottoman") && !this.areEnemies("ottoman", "papacy"))    { this.game.queue.push("natural_enemy_intervention\tottoman\tvenice\tpapacy"); }
      if (this.areEnemies("venice", "protestant") && !this.areEnemies("protestant", "papacy")) { this.game.queue.push("natural_enemy_intervention\tprotestant\tvenice\tpapacy"); }
      if (this.areEnemies("venice", "france") && !this.areEnemies("france", "papacy"))     { this.game.queue.push("natural_enemy_intervention\tfrance\tvenice\tpapacy"); }
      if (this.areEnemies("venice", "hapsburg") && !this.areEnemies("hapsburg", "papacy"))     { this.game.queue.push("natural_enemy_intervention\thapsburg\tvenice\tpapacy"); }
      if (this.areEnemies("venice", "england") && !this.areEnemies("england", "papacy"))    { this.game.queue.push("natural_enemy_intervention\tengland\tvenice\tpapacy"); }
    }

    try { this.game.state.alliances[faction1][faction2].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].allies = 1; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].allies = 1; } catch (err) {}

    //
    // in the 2P game, Hapsburgs are an activated power for the Papacy
    //
    if (this.game.state.events.schmalkaldic_league == 1 && this.game.players.length == 2 && (faction1 == "papacy" || faction1 == "hapsburg") && (faction1 == "hapsburg" || faction2 == "papacy")) {
      if (!this.game.state.activated_powers["papacy"].includes("hapsburg")) {
        this.setActivatedPower("papacy", "hapsburg");
      }
    }

    if (amp == 1) {
      if (this.isMinorPower(faction1)) {
        if (!this.isMinorPower(faction2)) {
  	  this.activateMinorPower(faction2, faction1);
        }
      }
      if (this.isMinorPower(faction2)) {
        if (!this.isMinorPower(faction1)) {
	  this.activateMinorPower(faction1, faction2);
        }
      }
    }

    this.displayWarBox();

  }

  unsetAllies(faction1, faction2, amp=1) {

    //
    // hungary and hapsburgs locked-for-life
    //
    if (this.game.state.events.defeat_of_hungary_bohemia == 1 && (faction1 == "hapsburg" || faction2 == "hapsburg") && (faction1 == "hungary" || faction2 == "hungary")) {
      return 0;
    }

    //
    // some conditions prevent deactivating alliances
    //
    if (this.game.players.length == 2) { if (faction1 === "hapsburg" && faction2 === "papacy") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Papacy must remain allied in 2P game after Schmalkaldic League formed");
	return 1;
      }
    } } 
    if (this.game.players.length == 2) { if (faction2 === "hapsburg" && faction1 === "papacy") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Papacy must remain allied in 2P game after Schmalkaldic League formed");
	return 1;
      }
    } }

    //
    // and... no longer allies
    //
    try { this.game.state.alliances[faction2][faction1].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].allies = 0; } catch (err) {}


    //
    // remove activated powers if set
    //
    try {
      this.unsetActivatePower(faction1, faction2);
      this.unsetActivatePower(faction2, faction1);
    } catch (err) {}


    if (amp == 1) {
      if (this.isMinorPower(faction1)) {
        if (!this.isMinorPower(faction2)) {
  	  this.activateMinorPower(faction2, faction1);
        }
      }
      if (this.isMinorPower(faction2)) {
        if (!this.isMinorPower(faction1)) {
	  this.activateMinorPower(faction1, faction2);
        }
      }
    }

    this.displayWarBox();

  }

  setEnemies(faction1, faction2) {
    try { this.game.state.alliances[faction1][faction2].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].allies = 0; } catch (err) {}
    try { this.game.state.alliances[faction1][faction2].enemies = 1; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 1; } catch (err) {}
    this.displayWarBox();
  }

  unsetEnemies(faction1, faction2) {

    //
    // undo excommunication
    //
    if (faction1 == "papacy") {
      if (this.game.state.excommunicated_factions[faction2] == 1) {
	this.unexcommunicateFaction(faction2);
      }
    }
    if (faction2 == "papacy") {
      if (this.game.state.excommunicated_factions[faction1] == 1) {
	this.unexcommunicateFaction(faction1);
      }
    }

    if (this.game.players.length == 2) { if (faction1 === "hapsburg" && faction2 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction2 === "hapsburg" && faction1 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Hapsburg and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction1 === "papacy" && faction2 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Papacy and Protestants must remain at war in 2P variant");
      }
    } }
    if (this.game.players.length == 2) { if (faction2 === "papacy" && faction1 === "protestant") {
      if (this.game.state.events.schmalkaldic_league) { 
	this.updateLog("NOTE: Papacy and Protestants must remain at war in 2P variant");
      }
    } }


    try { this.game.state.alliances[faction1][faction2].enemies = 0; } catch (err) {}
    try { this.game.state.alliances[faction2][faction1].enemies = 0; } catch (err) {}

    this.displayWarBox();

  }


  returnPlayerCommandingFaction(defender) {

    //
    // by default factions control themselves
    //

    //
    // maybe this is a minor power controlled by a larger one
    //
    if (defender == "venice" || defender == "independent" || defender == "genoa" || defender == "scotland" || defender == "hungary") {
      defender = this.returnControllingPower(defender);
    }

    //
    // defender now controlling power or itself
    //
    for (let p = 0; p < this.game.players.length; p++) {

      //
      // does player command this faction
      //
      let player_factions = this.returnPlayerFactions((p+1));

      let i_command_this_faction = false;
      for (let i = 0; i < player_factions.length; i++) { 
	if (player_factions[i] === defender) { 
	  return (p+1);
	}

        if (this.game.state.activated_powers[player_factions[i]].includes(defender)) { 
	  return (p+1);
	}
        for (let z = 0; z < this.game.state.activated_powers[player_factions[i]]; z++) {
          if (this.game.state.activated_powers[player_factions[i]][z] === defender) {
	    return (p+1);
	  }
        }
      }
    }

    //
    // no-one controls this faction
    //
    return 0;

  }



  isMajorPower(power) {
    if (power === "france" || power === "hapsburg" || power === "england" || power === "protestant" || power === "ottoman" || power === "papacy") { return true; }
    return false;
  }

  isMinorPower(power) {
    if (power === "genoa" || power === "hungary" || power === "scotland" || power === "venice") { return 1; }
    return 0;
  }

  isAlliedMinorPower(mp, faction) {
    if (faction === this.returnAllyOfMinorPower(mp)) { return true; }
    return false;
  }

  returnMinorPowers() {
    return ["genoa", "hungary", "scotland", "venice"];
  }

  returnControllingPower(power) {
    return this.returnAllyOfMinorPower(power);
  }

  returnAllyOfMinorPower(power) {
    if (this.isMajorPower(power)) { return power; }
    for (let key in this.game.state.activated_powers) {
      if (this.game.state.activated_powers[key].includes(power)) {
	return key;
      }
    }
    if (this.areAllies(power, "papacy", 0)) { return "papacy"; }
    if (this.areAllies(power, "protestant", 0)) { return "protestant"; }
    if (this.areAllies(power, "france", 0)) { return "france"; }
    if (this.areAllies(power, "england", 0)) { return "england"; }
    if (this.areAllies(power, "hapsburg", 0)) { return "hapsburg"; }
    if (this.areAllies(power, "ottoman", 0)) { return "ottoman"; }
    return power;
  }

  activateMinorPower(faction, power) {
    if (this.returnAllyOfMinorPower(power) != power) {
      this.deactivateMinorPower(this.returnAllyOfMinorPower(power), power);
    }

    //
    // any home spaces help by the major power are returned to its minor ally
    // on the alliance being formed. this is needed to ensure that Line of 
    // Communications can work properly...
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].home == power) {
        if (this.game.spaces[key].political == faction) {
	  this.game.spaces[key].political = power;
	}
      }
    }

    this.setAllies(faction, power, 0);
    this.game.state.activated_powers[faction].push(power);
    this.game.state.minor_activated_powers.push(power);
    this.displayBoard();
    this.displayVictoryTrack();
  }

  deactivateMinorPower(faction, power) {
    this.unsetAllies(faction, power, 0);
    for (let key in this.game.state.activated_powers) {
      for (let i = 0; i < this.game.state.activated_powers[key].length; i++) {
        if (this.game.state.activated_powers[key][i] === power) {
  	  this.game.state.activated_powers[key].splice(i, 1);
        }
      }
    }
    for (let i = 0; i < this.game.state.minor_activated_powers.length; i++) {
      if (this.game.state.minor_activated_powers[i] === power) {
	this.game.state.minor_activated_powers.splice(i, 1);
      }
    }

    //
    // any home spaces help by the major power are returned to its minor ally
    // on the alliance being disabled. this is needed to ensure that Line of 
    // Communications can work properly...
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].home == power) {
        if (this.game.spaces[key].political == faction) {
          this.game.spaces[key].political = power;
        }
      }
    }
    
    this.displayBoard();
    this.displayVictoryTrack();
  }

  canFactionDeactivateMinorPower(faction, power) {
    if (power == "genoa") { if (faction == "france" || faction == "hapsburg" || faction == "papacy") { return 1; } }
    if (power == "scotland") { if (faction == "england" || faction == "france") { return 1; } }
    if (power == "venice") { if (faction == "france" || faction == "hapsburg" || faction == "papacy") { return 1; } }
    return 0;
  }

  canFactionActivateMinorPower(faction, power) {
    if (power == "genoa") {
      if (faction == "france") { return 1; }
      if (faction == "hapsburg") { return 1; }
      if (faction == "papacy") { return 1; }
    }
    if (power == "hungary") {
      if (faction == "hapsburg") { return 1; }
    }
    if (power == "scotland") {
      if (faction == "france") { return 1; }
      if (faction == "england") { return 1; }
    }
    if (power == "venice") {
      if (faction == "france") { return 1; }
      if (faction == "hapsburg") { return 1; }
      if (faction == "papacy") { return 1; }
    }
    return 0;
  }

  isMinorActivatedPower(power) {
    for (let i = 0; i < this.game.state.minor_activated_powers.length; i++) {
      if (power === this.game.state.minor_activated_powers[i]) {
	return 1;
      }
    }
    return 0;
  }

  isMinorUnactivatedPower(power) {
    if (power === "genoa" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "scotland" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "hungary" && this.isMinorActivatedPower(power) != 1) { return 1; }
    if (power === "venice" && this.isMinorActivatedPower(power) != 1) { return 1; }
    return 0;
  }


  onNewImpulse() {

    //
    // reset player last move
    //
    this.game.state.player_last_move = "";
    this.game.state.player_last_spacekey = "";
    this.game.state.field_battle_relief_battle = false;
    this.game.state.rejected_pre_battle_fortification = [];

    //
    // remove foul weather
    //
    this.game.state.events.foul_weather = 0;
    this.game.state.events.foreign_recruits = "";
    this.game.state.spring_deploy_across_passes = [];
    this.game.state.spring_deploy_across_seas = [];
    this.game.state.foreign_wars_fought_this_impulse = [];
    this.game.state.events.spring_preparations = "";
    this.game.state.events.henry_petitions_for_divorce_grant = 0;
    this.game.state.spaces_assaulted_this_turn = [];
    this.game.state.events.more_executed_limits_debates = 0;
    this.game.state.events.more_bonus = 0;
    this.game.state.events.sack_of_rome = 0;
    this.game.state.events.roxelana = 0;
    this.game.state.loyola_bonus_active = 0;

    //
    // add cranmer if needed
    //
    if (this.game.state.events.cranmer_active == 1) { 
      if (this.game.state.round >= 3) {
        let where_is_cranmer = this.isPersonageOnMap("england", "cranmer-reformer");
        if (where_is_cranmer) { this.game.state.events.cranmer_active = 0; }
      }
    } else {
      if (this.game.state.round >= 3) {
        let where_is_cranmer = this.isPersonageOnMap("england", "cranmer-reformer");
        if (where_is_cranmer) { this.game.state.events.cranmer_active = 1; }
      }
    }

    //
    // reset impulse commits
    //
    this.game.state.debater_committed_this_impulse = {};
    this.game.state.assaulted_this_impulse = 0;
    this.game.state.naval_avoid_battle_bonus = 0;
    this.game.state.naval_intercept_bonus = 0;


    // display cards left
    this.displayCardsLeft();

    //
    // remove gout
    //
    if (this.game.state.events.gout != 0) {
      for (let i in this.game.spaces) {
	let space = this.game.spaces[i];
        for (let f in space.units) {
          for (let z = space.units[f].length-1;  z >= 0; z--) {
	    space.units[f][z].gout = false; 
	    space.units[f][z].relief_force = 0;
  	  }
        }
      }
      this.game.state.events.gout = 0;    
    }

    //
    // remove temporary bonuses and modifiers
    //
    this.game.state.events.augsburg_confession = false;

    // allow stuff to move again
    this.resetLockedTroops();

  }

  onNewRound() {

    //
    // reset piracy markers
    //
    for (let key in this.game.navalspaces) {
      this.hidePiracyMarker(key);
    }

    //
    // add cranmer if needed
    //
    if (this.game.state.events.cranmer_active != 1) { 
      if (this.game.state.round >= 3) {
        let where_is_cranmer = this.isPersonageOnMap("england", "cranmer-reformer");
        if (where_is_cranmer) { this.game.state.events.cranmer_active = 1; }
      }
    }

    //
    // reset variables that permit intervention
    //
    this.game.state.events.intervention_venetian_informant_possible = 0;
    this.game.state.events.intervention_on_movement_possible = 0;
    this.game.state.events.intervention_on_events_possible = 0;
    this.game.state.events.intervention_on_assault_possible = 0;
    this.game.state.events.intervention_post_assault_possible = 0;
    this.game.state.events.intervention_post_naval_battle_possible = 0;
    this.game.state.events.intervention_naval_avoid_battle_possible = 0;
    this.game.state.events.intervention_naval_intercept_possible = 0;

    this.game.state.field_battle_relief_battle = false;

    //
    // reset impulse commits
    //
    this.game.state.debater_committed_this_impulse = {};
    this.game.state.spaces_assaulted_this_turn = [];
    this.game.state.printing_press_active = 0;
    this.game.state.events.sack_of_rome = 0;
    this.game.state.events.julia_gonzaga_activated = 0;
    this.game.state.events.england_changed_rulers_this_turn = 0;
    this.game.state.events.smallpox = "";
    this.game.state.protestant_cards_evented = [];
    this.game.state.cards_evented = [];
    this.game.state.foreign_wars_fought_this_impulse = [];
    this.game.state.henry_viii_pope_approves_divorce = 0;
    this.game.state.events.cromwell = 0;

    this.game.state.may_explore['england'] = 1;
    this.game.state.may_explore['france'] = 1;
    this.game.state.may_explore['hapsburg'] = 1;
    this.game.state.may_conquer['england'] = 1;
    this.game.state.may_conquer['france'] = 1;
    this.game.state.may_conquer['hapsburg'] = 1;
    this.game.state.may_colonize['england'] = 1;
    this.game.state.may_colonize['france'] = 1;
    this.game.state.may_colonize['hapsburg'] = 1;

    this.game.state.cards_issued = {};
    this.game.state.cards_issued['ottoman'] = 0;
    this.game.state.cards_issued['hapsburg'] = 0;
    this.game.state.cards_issued['england'] = 0;
    this.game.state.cards_issued['france'] = 0;
    this.game.state.cards_issued['papacy'] = 0;
    this.game.state.cards_issued['protestant'] = 0;

    this.game.state.ships_destroyed = {};
    this.game.state.ships_destroyed['ottoman'] = 0;
    this.game.state.ships_destroyed['hapsburg'] = 0;
    this.game.state.ships_destroyed['england'] = 0;
    this.game.state.ships_destroyed['france'] = 0;
    this.game.state.ships_destroyed['papacy'] = 0;
    this.game.state.ships_destroyed['protestant'] = 0;
    this.game.state.ships_destroyed['scotland'] = 0;
    this.game.state.ships_destroyed['venice'] = 0;
    this.game.state.ships_destroyed['hungary'] = 0;
    this.game.state.ships_destroyed['genoa'] = 0;

    this.game.state.naval_avoid_battle_bonus = 0;
    this.game.state.naval_intercept_bonus = 0;

    this.game.state.events.ottoman_piracy_wartburg = 0;
    this.game.state.events.ottoman_piracy_attempts = 0;
    this.game.state.events.ottoman_piracy_seazones = [];

    this.game.state.events.intervention_venetian_informant_possible = 0;
    this.game.state.events.intervention_on_movement_possible = 0;
    this.game.state.events.intervention_on_events_possible = 0;
    this.game.state.events.intervention_on_assault_possible = 0;
    this.game.state.events.intervention_post_assault_possible = 0;
    this.game.state.events.intervention_post_naval_battle_possible = 0;
    this.game.state.events.intervention_naval_avoid_battle_possible = 0;
    this.game.state.events.intervention_naval_intercept_possible = 0;

    this.game.state.tmp_reformations_this_turn = [];
    this.game.state.tmp_counter_reformations_this_turn = [];
    this.game.state.tmp_protestant_translation_bonus = 0;
    this.game.state.tmp_protestant_reformation_modifier = 0;
    this.game.state.tmp_protestant_reformation_bonus = 0;
    this.game.state.tmp_protestant_reformation_bonus_spaces = [];
    this.game.state.tmp_catholic_reformation_modifier = 0;
    this.game.state.tmp_catholic_reformation_bonus = 0;
    this.game.state.tmp_catholic_reformation_bonus_spaces = [];
            
    this.game.state.tmp_protestant_counter_reformation_modifier = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus_spaces = [];
    this.game.state.tmp_catholic_counter_reformation_modifier = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus_spaces = [];
    this.game.state.tmp_papacy_may_specify_debater = 0;
    this.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    this.game.state.impulse = 0;
    this.game.state.events.more_executed_limits_debates = 0;
    this.game.state.events.more_bonus = 0;
    this.game.state.events.unexpected_war = 0;
 
    this.game.state.newworld.results.colonies = [];
    this.game.state.newworld.results.explorations = [];
    this.game.state.newworld.results.conquests = [];

 
    //
    // allow stuff to move again
    //
    this.resetLockedTroops();
    this.removeBesiegedSpaces();

    this.displayCardsLeft();
    this.displayTurnTrack();

    try { document.querySelector(".crossing_atlantic").innerHTML = ""; } catch (err) {}

    this.displayNewWorld();
    this.displayVictoryTrack();

  }

  returnLoanedUnits() {
    for (let i in this.game.spaces) {
      space = this.game.spaces[i];
      for (let f in space.units) {
        for (let z = space.units[f].length-1;  z >= 0; z--) {
	  let unit = space.units[f][z];
	  if (unit.loaned != false) {
	    let lender = unit.loaned;
	    space.units[f].splice(z, 1);
	    space.units[lender].push(unit);
	  }
        }
      }
    }
    for (let i in this.game.navalspaces) {
      space = this.game.navalspaces[i];
      for (let f in space.units) {
        for (let z = space.units[f].length-1;  z >= 0; z--) {
	  let unit = space.units[f][z];
	  if (unit.loaned != false) {
	    let lender = unit.loaned;
	    space.units[f].splice(z, 1);
	    space.units[lender].push(unit);
	  }
        }
      }
    }
  }

  isCaptured(faction, unittype) {
    for (let i = 0; i < this.game.players.length; i++) {
      let p = this.game.state.players_info[i];
      for (let z = 0; z < p.captured.length; z++) {
        if (p.captured[z].type == unittype) { return 1; }
      }
    }
    return 0;
  }

  isSpaceBesieged(space) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    let faction_with_units = "";
    let faction_in_control = this.returnFactionControllingSpace(space);
    if (space.besieged == 1 || space.besieged == 2 || space.besieged == true) {
      //
      // are we still besieged? will be unit
      //
      for (let f in space.units) {
        for (let i = 0; i < space.units[f].length; i++) {
  	  if (space.units[f][i].besieged == true || space.units[f][i].besieged == 1) {
	    //
	    // we are still besieged if there are any enemy units here
	    //
	    for (let zf in space.units) {
	      if (zf != f) {
		if (space.units[zf].length > 0) {
		  if (!this.areAllies(zf, f)) {
		    if (this.returnFactionLandUnitsInSpace(zf, space.key) > 0) { return true; }
		  }
		}
	      }
	    }

	    //
	    // no-one else is here, so I guess we aren't anymore
	    //
	    return false;
	  } else {
	    // if not independent (which won't attack) or allies, then someone must be besieged
	    if (f != "independent") {
	      if (!this.areAllies(f, faction_in_control)) { return true; }    
	    }
	  }
        }
      }

      return false; // everyone here is allied or independent and not-besieged
    }
    return false;
  }
  isBesieged(faction, unittype) {
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].besieged) {
	for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (this.game.spaces[key].units[faction][i].type == unittype) {
	    if (this.game.spaces[key].units[faction][i].besieged == true) {
	      return 1;
	    }
	  }
	}
      }
    }
    return 0;
  }

  captureLeader(winning_faction, losing_faction, space, unit = false) {

    if (!unit) { return; }
    if (unit.personage == false && unit.army_leader == false && unit.navy_leader == false && unit.reformer == false) { return; }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    winning_faction = this.returnControllingPower(winning_faction);

    let return_to_nearest_fortified_key = false;

    //
    // special treatment if unaligned minor power captures
    //
    // independent factions cannot capture leaders, so we return them to the nearest
    // friendly, fortified space. edge-case out of rule book. rules determination here
    // by Ed Beach (Oct 29, 2024 on WhatsApp)
    //
    if (["independent","venice","hungary","genoa","scotland"].includes(winning_faction)) {

      let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(losing_faction, space, 0, 0);
      let capitals = this.returnCapitals(losing_faction);

      if (res.length > 0) {
	this.addArmyLeader(losing_faction, res[0].key, unit.type);
	return;
      } else {
	for (let z = 0; z < capitals.length; z++) {
	  if (this.isSpaceControlled(losing_faction, capitals[z])) {
	    this.addArmyLeader(losing_faction, capitals[z], unit.type);
	    return;
	  }
	}
      }

      //
      // no capital? push problem until next round
      //
      // no need to delete, function will sort out after return in this case
      //
      this.game.state.military_leaders_removed_until_next_round.push(unit);
      return;

    }

    let winning_player = this.returnPlayerCommandingFaction(winning_faction);
    if (winning_player > 0) {
      let p = this.game.state.players_info[winning_player-1];
      let unitjson = JSON.stringify(unit);
      for (let z = 0; z < p.captured.length; z++) {
        if (JSON.stringify(p.captured[z]) === unitjson) { return; }
      }
      unit.capturing_faction = winning_faction;
      this.updateLog(this.returnFactionName(winning_faction) + " captures " + unit.name);
      p.captured.push(unit);
    }
  }

  captureNavalLeader(winning_faction, losing_faction, space, unit) {
    if (unit.personage == false && unit.army_leader == false && unit.navy_leader == false && unit.reformer == false) { return; }
    this.game.state.naval_leaders_lost_at_sea.push(unit);
  }

  isPersonageOnMap(faction, personage) {
    for (let s in this.game.spaces) {
      if (this.game.spaces[s].units[faction].length > 0) {
	for (let i = 0; i < this.game.spaces[s].units[faction].length; i++) {
	  let unit = this.game.spaces[s].units[faction][i];
	  if (unit.key === personage) { return unit; }
	}
      }
    }
    return null;
  }

  addUnit(faction, space, type) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.newUnit(faction, type));
    this.updateOnBoardUnits();
  }

  removeUnit(faction, space, type) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = space.units[faction].length - 1; i >= 0; i--) {
      if (space.units[faction][i].type == type) {
        this.updateLog(this.returnFactionName(faction) + " removes " + type + " in " + space.name);
	space.units[faction].splice(i, 1);
        this.updateOnBoardUnits();
	return;
      }
    }
  }

  isLandUnit(unit) {
    if (unit.type === "regular") { return 1; }
    if (unit.type === "mercenary") { return 1; }
    if (unit.type === "cavalry") { return 1; }
    return 0;
  }

  addRegular(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "regular"));
    }
    this.updateOnBoardUnits();
  }

  addMercenary(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "mercenary"));
    }
    this.updateOnBoardUnits();
  }

  addCavalry(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "cavalry"));
    }
    this.updateOnBoardUnits();
  }

  addNavalSquadron(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "squadron"));
    }
    this.updateOnBoardUnits();
  }

  addCorsair(faction, space, num=1) {
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let i = 0; i < num; i++) {
      space.units[faction].push(this.newUnit(faction, "corsair"));
    }
  }

  //
  // figure out how many base points people have
  //
  calculateVictoryPoints() {

    let factions = {};

    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let ii = 0; ii < this.game.state.players_info[i].factions.length; ii++) {
        factions[this.game.state.players_info[i].factions[ii]] = {
	  faction : this.game.state.players_info[i].factions[ii] ,
	  vp_base : 0 ,
	  vp_bonus : 0 ,
	  vp_special : 0 ,
	  vp : 0 ,
	  keys : 0 ,
	  religious : 0 ,
	  victory : 0,	  
	  details : "",
	};
      }
    }

    //
    // let factions calculate their VP
    //
    for (let f in factions) {
      factions[f].vp_base = this.factions[f].calculateBaseVictoryPoints(this);
      factions[f].vp_bonus = this.factions[f].calculateBonusVictoryPoints(this);
      factions[f].vp_special = this.factions[f].calculateSpecialVictoryPoints(this);
      factions[f].vp = (factions[f].vp_base + factions[f].vp_bonus + factions[f].vp_special);
    }

    //
    // calculate keys controlled
    //
    for (let f in factions) {
      factions[f].keys = this.returnNumberOfKeysControlledByFaction(f);
      if (f === "protestant") {
	factions[f].religious = this.returnNumberOfProtestantSpacesInLanguageZone();
      }
    }

    //
    // military victory
    //
    if (factions['hapsburg']) {
      if (factions['hapsburg'].keys >= this.game.state.autowin_hapsburg_keys_controlled) {
        factions['hapsburg'].victory = 1;
        factions['hapsburg'].details = "military victory";
      }
    }
    if (factions['ottoman']) {
      if (factions['ottoman'].keys >= this.game.state.autowin_ottoman_keys_controlled) {
        factions['ottoman'].victory = 1;
        factions['ottoman'].details = "military victory";
      }
    }
    if (factions['france']) {
      if (factions['france'].keys >= this.game.state.autowin_france_keys_controlled) {
        factions['france'].victory = 1;
        factions['france'].details = "military victory";
      }
    }
    if (factions['england']) {
      if (factions['england'].keys >= this.game.state.autowin_england_keys_controlled) {
        factions['england'].victory = 1;
        factions['england'].details = "military victory";
      }
    }
    if (factions['papacy']) {
      if (factions['papacy'].keys >= this.game.state.autowin_papacy_keys_controlled) {
        factions['papacy'].victory = 1;
        factions['papacy'].details = "military victory";
      }
    }

    //
    // religious victory
    //
    if (factions['protestant']) {
      if (factions['protestant'].religious >= 50) {
        factions['papacy'].victory = 1;
        factions['papacy'].details = "religious victory";
      }
    }

    //
    // PROCESS BONUS VP
    //
    // Copernicus (2 VP) or Michael Servetus (1 VP) event
    if (this.game.state.events.michael_servetus) {
      factions[this.game.state.events.michael_servetus].vp_special++;
      factions[this.game.state.events.michael_servetus].vp++;
    }
    if (this.game.state.events.copernicus) {
      factions[this.game.state.events.copernicus].vp_special += parseInt(this.game.state.events.copernicus_vp);
      factions[this.game.state.events.copernicus].vp += parseInt(this.game.state.events.copernicus_vp);
    }

    //
    // War Winner VP
    //
    factions["protestant"].vp += parseInt(this.game.state.protestant_war_winner_vp);
    factions["papacy"].vp     += parseInt(this.game.state.papacy_war_winner_vp);
    try {
      factions["ottoman"].vp    += parseInt(this.game.state.ottoman_war_winner_vp);
      factions["hapsburg"].vp   += parseInt(this.game.state.hapsburg_war_winner_vp);
      factions["england"].vp    += parseInt(this.game.state.england_war_winner_vp);
      factions["france"].vp     += parseInt(this.game.state.france_war_winner_vp);
    } catch (err) {}

    //
    // Master of Italy
    //
    factions["protestant"].vp += parseInt(this.game.state.master_of_italy["protestant"]);
    factions["papacy"].vp += parseInt(this.game.state.master_of_italy["papacy"]);
    try {
      factions["ottoman"].vp += parseInt(this.game.state.master_of_italy["ottoman"]);
      factions["hapsburg"].vp += parseInt(this.game.state.master_of_italy["hapsburg"]);
      factions["england"].vp += parseInt(this.game.state.master_of_italy["england"]);
      factions["france"].vp += parseInt(this.game.state.master_of_italy["france"]);
    } catch (err) {}

    //
    // New World
    //
    for (let key in this.game.state.newworld) {
      if (this.game.state.newworld[key].vp > 0) {
	if (this.game.state.newworld[key].faction) {	  
	  if (this.factions[this.game.state.newworld[key].faction]) {
	    factions[this.game.state.newworld[key].faction].vp += parseInt(this.game.state.newworld[key].vp);
	  }
	}
      }
    }

    //
    //â¢ Bible translation completed (1 VP for each language)    ***
    // protestant faction class
    //â¢ Protestant debater burned (1 per debate rating)         ***
    // protestant faction class
    //â¢ Papal debater disgraced (1 per debate rating)           ***
    // protestant faction class

    //â¢ JuliaGonzaga(1VP)followed by successful Ottoman piracy in Tyrrhenian Sea
    //â¢ War Winner marker received during Peace Segment
    //â¢ Master of Italy VP marker received during Action Phase


    //
    // domination victory (5 more vp than everyone else
    //
    let max_vp = 0;
    let runner_up_vp = 0;
    let lead_required = 5;
    let domination_round = 5;
    if (this.game.players.length == 2) { lead_required = 8; domination_round = 4; }

    let leaders = [];
    for (let key in factions) {
      if (factions[key].vp == max_vp) {
        leaders.push(key);
      }
      if (factions[key].vp > max_vp) {
	runner_up_vp = max_vp;
	max_vp = factions[key].vp;
	leaders = [];
        leaders.push(key);
      }
      if (factions[key].vp < max_vp && factions[key].vp > runner_up_vp) {
	runner_up_vp = factions[key].vp;
      }

    }
    if (max_vp >= (runner_up_vp+lead_required) && this.game.state.round >= domination_round && this.game.players.length > 2) {
      if (leaders.length == 1) {
        factions[leaders[0]].victory = 1;
	factions[leaders[0]].reason = "Domination Victory";
      }
    }

    //
    // final victory if round 9
    //
    if (this.game.state.round >= 9) {
      for (let i = 0; i < leaders.length; i++) {
	factions[leaders[0]].victory = 1;
	factions[leaders[0]].reason = "Final Victory";
      }
    }

    //
    // 8 VP lead in 2P
    //
if (this.game.state.scenario != "is_testing") {
    if (this.game.players.length == 2 && this.game.state.round >= 4) {
      if ((factions["protestant"].vp - factions["papacy"].vp) >= 8) {
	factions["protestant"].victory = 1;
	factions["protestant"].reason = "Commanding 8 VP Lead";
      }
      if ((factions["papacy"].vp - factions["protestant"].vp) >= 8) {
	factions["papacy"].victory = 1;
	factions["papacy"].reason = "Commanding 8 VP Lead";
      }
    }
}

    //
    // tied at 25 VP or higher
    //
    let highest_vp = 0;
    let fs = [];
    if (this.game.state.round > 0) {
      while (this.game.state.vp.length < this.game.state.round) { this.game.state.vp.push({}); }
      for (let key in factions) {
        if (factions[key].vp == highest_vp) {
 	  fs.push(key);
        }
        if (factions[key].vp > highest_vp) {
	  fs = [];
	  fs.push(key);
  	  highest_vp = factions[key].vp;
        }
        this.game.state.vp[this.game.state.round-1][key] = factions[key].vp;
      }
      if (fs.length == 1 && highest_vp >= 25) {
        factions[fs[0]].victory = 1;
        factions[fs[0]].reason = "Standard Victory"; 
      }
      //
      // historical resolution -
      //
      if (fs.length > 1 && highest_vp >= 25) {
        for (let z = 0; z < fs.length; z++) {
          factions[fs[z]].victory = 1;
          factions[fs[z]].reason = "Score Tied";
        }
      }
    }

    return factions;

  }


  //
  // faction is papacy or (anything), since debaters aren't really owned by factions outside
  // papcy and protestants, even if they are tagged as would be historically appropriate
  //
  returnDebatersInLanguageZone(language_zone="german", faction="papacy", committed=-1) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].language_zone === language_zone || this.game.state.debaters[i].language_zone === "any") {
        if (this.game.state.debaters[i].faction === faction || (faction != "papacy" && this.game.state.debaters[i].faction != "papacy")) {
          if (this.game.state.debaters[i].committed === committed || committed == -1) {
	    num++;
          }
        }
      }
    }
    return num;
  }


  canProtestantsReformInLanguageZone(lang="german") {
    let access_spots = [];
    let zone_has_catholic_spaces = false;
    let zone_has_protestant_spaces = false;
    if (lang == "german") { access_spots = ["amsterdam","liege","metz","becanson","geneva","trent","trieste","agram","pressburg","brunn","prague","breslau","antwerp","calais","london","norwich","berwick","edinburgh"]; }
    if (lang == "italian") { access_spots = ["innsbruck","graz","geneva","grenoble","nice","agram","zara","bastia","ragusa","scutari","durazzo","corfu","nice"]; }
    if (lang == "spanish") { access_spots = ["bordeaux","toulouse","avignon","marseille","nice","bastia","palma","cagliari","tunis","algiers","oran","nantes","brest"]; }
    if (lang == "english") { access_spots = ["brest","rouen","boulogne","calais","antwerp","amsterdam","bremen","hamburg"]; }
    if (lang == "french") { access_spots = ["plymouth","portsmouth","london","calais","antwerp","cologne","trier","strasburg","basel","turin","genoa","bastia","palma","valencia","barcelona","navarre","corunna"]; }

    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion == "protestant") {
        if (this.game.spaces[key].language == lang) { zone_has_protestant_spaces = true; }
	if (access_spots.includes(key)) { return 1; }
      } else {
        if (this.game.spaces[key].language == lang) { zone_has_catholic_spaces = true; }
      }
    }

    if (zone_has_protestant_spaces == true && zone_has_catholic_spaces == true) { return 1; }

    //
    // add access to any space with a reformer
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].language == lang) {
        for (let z = 0; z < this.game.spaces[key].units["protestant"].length; z++) {
	  let u = this.game.spaces[key].units["protestant"][z];
	  if (u.reformer == true) {
	    return 1;
	  }
	}
      }
    }

    return 0;
  }

  returnDiplomacyImpulseOrder(faction="") {
    if (faction == "ottoman") {
      return ["hapsburg","england","france","papacy","protestant"];
    }
    if (faction == "hapsburg") {
      return ["england","france","papacy","protestant"];
    }
    if (faction == "england") {
      return ["france","papacy","protestant"];
    }
    if (faction == "france") {
      return ["papacy","protestant"];
    }
    if (faction == "papacy") {
      return ["protestant"];
    }
    return [];
  }

  returnImpulseOrder() {
    return ["ottoman","hapsburg","england","france","papacy","protestant"];
  }

  returnNumberOfUncommittedDebaters(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].owner === faction && this.game.state.debaters[i].committed == 0) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfCommittedDebaters(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].owner === faction && this.game.state.debaters[i].committed == 1) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfUncommittedExplorers(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].owner === faction && this.game.state.explorers[i].committed == 0) {
	num++;
      }
    }
    return num;
  }

  returnNumberOfCommittedExplorers(faction) {
    let num = 0;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].owner === faction && this.game.state.explorers[i].committed == 1) {
	num++;
      }
    }
    return num;
  }

  /////////////////////
  // Core Game State //
  /////////////////////
  returnState() {

    let state = {};

    state.skip_counter_or_acknowledge = 0; // don't skip

    state.scenario = "1517";
    if (this.game.options.scenario) { state.scenario = this.game.options.scenario; }
    state.round = 0;
    state.starting_round = 0; // if we start > 1, set this
    state.vp = [];
    state.newworld = this.returnNewWorld();
    state.impulse = 0;
    state.players = [];
    state.events = {};
    state.removed = []; // removed cards
    state.spaces_assaulted_this_turn = [];
    state.board_updated = new Date().getTime();
    state.board = {}; // units on board
    state.protestant_cards_evented = [];
    state.cards_evented = [];

    state.foreign_wars_fought_this_impulse = [];

    state.assaulted_this_impulse = 0;
    state.alliances = this.returnDiplomacyAlliance();
    state.diplomacy = [];

    // whose turn is it? (attacker)
    state.active_player = -1;

    // which ones are activated
    state.minor_activated_powers = [];

    state.naval_leaders_lost_at_sea = [];

    state.debater_committed_this_impulse = {};

    state.cards_left = {};
    state.rejected_pre_battle_fortification = [];

    state.master_of_italy = {};
    state.master_of_italy['ottoman'] = 0;
    state.master_of_italy['hapsburg'] = 0;
    state.master_of_italy['england'] = 0;
    state.master_of_italy['france'] = 0;
    state.master_of_italy['papacy'] = 0;
    state.master_of_italy['protestant'] = 0;

    state.activated_powers = {};
    state.activated_powers['ottoman'] = [];
    state.activated_powers['hapsburg'] = [];
    state.activated_powers['france'] = [];
    state.activated_powers['england'] = [];
    state.activated_powers['papacy'] = [];
    state.activated_powers['protestant'] = [];
    // following for safety
    state.activated_powers['venice'] = [];
    state.activated_powers['scotland'] = [];
    state.activated_powers['genoa'] = [];
    state.activated_powers['hungary'] = [];
    state.activated_powers['independent'] = [];

    state.events.potosi_silver_mines = "";

    state.translations = {};
    state.translations['new'] = {};
    state.translations['new']['german'] = 0;
    state.translations['new']['french'] = 0;
    state.translations['new']['english'] = 0;
    state.translations['full'] = {};
    state.translations['full']['german'] = 0;
    state.translations['full']['french'] = 0;
    state.translations['full']['english'] = 0;

    state.papacy_card_bonus = 0;
    state.protestant_card_bonus = 0;
    state.ottoman_card_bonus = 0;
    state.france_card_bonus = 0;
    state.england_card_bonus = 0;
    state.hapsburg_card_bonus = 0;

    state.ships_destroyed = {};
    state.ships_destroyed['ottoman'] = 0;
    state.ships_destroyed['hapsburg'] = 0;
    state.ships_destroyed['england'] = 0;
    state.ships_destroyed['france'] = 0;
    state.ships_destroyed['papacy'] = 0;
    state.ships_destroyed['protestant'] = 0;
    state.ships_destroyed['scotland'] = 0;
    state.ships_destroyed['venice'] = 0;
    state.ships_destroyed['hungary'] = 0;
    state.ships_destroyed['genoa'] = 0;

    state.protestant_war_winner_vp = 0;
    state.papacy_war_winner_vp = 0;
    state.ottoman_war_winner_vp = 0;
    state.hapsburg_war_winner_vp = 0;
    state.england_war_winner_vp = 0;
    state.france_war_winner_vp = 0;

    state.bonus_vp = {};
    state.bonus_vp['protestant'] = 0;
    state.bonus_vp['papacy'] = 0;
    state.bonus_vp['england'] = 0;
    state.bonus_vp['france'] = 0;
    state.bonus_vp['hapsburg'] = 0;
    state.bonus_vp['ottoman'] = 0;

    state.cards_issued = {};
    state.cards_issued['ottoman'] = 0;
    state.cards_issued['hapsburg'] = 0;
    state.cards_issued['england'] = 0;
    state.cards_issued['france'] = 0;
    state.cards_issued['papacy'] = 0;
    state.cards_issued['protestant'] = 0;

    state.saint_peters_cathedral = {};
    state.saint_peters_cathedral['state'] = 0;
    state.saint_peters_cathedral['vp'] = 0;    

    state.papal_debaters_disgraced_vp = 0;
    state.protestant_debaters_burned_vp = 0;

    state.events.michael_servetus = "";  // faction that gets VP
    state.events.copernicus = "";        // faction that gets VP
    state.events.copernicus_vp = 0;     // 1 or 2 VP
    state.events.scots_raid = 0;	// 1 if active, limits French activities
    state.events.cromwell = 0;		// 1 if England publishes for 2 CP

    state.french_chateaux_vp = 0;

    state.tmp_reformations_this_turn = [];
    state.tmp_counter_reformations_this_turn = [];
    state.tmp_protestant_reformation_modifier = 0;
    state.tmp_protestant_reformation_bonus = 0;
    state.tmp_protestant_reformation_bonus_spaces = [];
    state.tmp_catholic_reformation_modifier = 0;
    state.tmp_catholic_reformation_bonus = 0;
    state.tmp_catholic_reformation_bonus_spaces = [];

    state.tmp_protestant_counter_reformation_modifier = 0;
    state.tmp_protestant_counter_reformation_bonus = 0;
    state.tmp_protestant_counter_reformation_bonus_spaces = [];
    state.tmp_catholic_counter_reformation_modifier = 0;
    state.tmp_catholic_counter_reformation_bonus = 0;
    state.tmp_catholic_counter_reformation_bonus_spaces = [];
    state.tmp_papacy_may_specify_debater = 0;
    state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    state.tmp_bonus_protestant_translation_german_zone = 0;
    state.tmp_bonus_protestant_translation_french_zone = 0;
    state.tmp_bonus_protestant_translation_english_zone = 0;
    state.tmp_bonus_papacy_burn_books = 0;

    state.events.mercators_map = "";
    state.events.england_changed_rulers_this_turn = 0;
    state.events.colonial_governor = "";

    state.raiders = {};
    state.raiders['protestant'] = 0;
    state.raiders['papacy'] = 0;
    state.raiders['france'] = 0;
    state.raiders['england'] = 0;
    state.raiders['ottoman'] = 0;
    state.raiders['hapsburg'] = 0;
    state.plantations = {};
    state.plantations['protestant'] = 0;
    state.plantations['papacy'] = 0;
    state.plantations['france'] = 0;
    state.plantations['england'] = 0;
    state.plantations['ottoman'] = 0;
    state.plantations['hapsburg'] = 0;

    // bonus cards
    state.new_world_bonus = {};
    state.new_world_bonus['england'] = 0;
    state.new_world_bonus['france'] = 0;
    state.new_world_bonus['hapsburg'] = 0;
    state.new_world_bonus['protestant'] = 0;
    state.new_world_bonus['ottoman'] = 0;
    state.new_world_bonus['papacy'] = 0;

    state.may_explore = {};
    state.may_explore['england'] = 1;
    state.may_explore['france'] = 1;
    state.may_explore['hapsburg'] = 1;
    state.may_explore['protestant'] = 0;
    state.may_explore['papacy'] = 0;
    state.may_explore['ottoman'] = 0;
    state.may_conquer = {};
    state.may_conquer['england'] = 1;
    state.may_conquer['france'] = 1;
    state.may_conquer['hapsburg'] = 1;
    state.may_conquer['protestant'] = 0;
    state.may_conquer['papacy'] = 0;
    state.may_conquer['ottoman'] = 0;
    state.may_colonize = {};
    state.may_colonize['england'] = 1;
    state.may_colonize['france'] = 1;
    state.may_colonize['hapsburg'] = 1;
    state.may_colonize['protestant'] = 0;
    state.may_colonize['papacy'] = 0;
    state.france_uncharted = 1;
    state.hapsburg_uncharted = 1;
    state.england_uncharted = 1;

    state.skip_next_impulse = [];

    //
    // foreign wars
    //
    state.events.war_in_persia = 0;
    state.events.revolt_in_ireland = 0;
    state.events.revolt_in_egypt = 0;

    state.augsburg_electoral_bonus = 0;
    state.mainz_electoral_bonus = 0;
    state.trier_electoral_bonus = 0;
    state.cologne_electoral_bonus = 0;
    state.wittenberg_electoral_bonus = 0;
    state.brandenburg_electoral_bonus = 0;

    state.galleons = {};
    state.galleons['france'] = 0;
    state.galleons['hapsburg'] = 0;
    state.galleons['england'] = 0;

    state.autowin_hapsburg_keys_controlled = 14;
    state.autowin_ottoman_keys_controlled = 11;
    state.autowin_papacy_keys_controlled = 7;
    state.autowin_france_keys_controlled = 11;
    state.autowin_england_keys_controlled = 9;

    state.military_leaders_removed_until_next_round = [];
    state.excommunicated_factions = {};
    state.already_excommunicated = [];
    state.excommunicated = [];
    state.burned = [];
    state.debaters = [];
    state.explorers = [];
    state.conquistadors = [];

    state.leaders = {};
    state.leaders.francis_i = 1;
    state.leaders.henry_viii = 1;
    state.leaders.charles_v = 1;
    state.leaders.suleiman = 1;
    state.leaders.leo_x = 1;
    state.leaders.luther = 1
    state.leaders.clement_vii = 0;
    state.leaders.paul_iii = 0;
    state.leaders.edward_vi = 0;
    state.leaders.henry_ii = 0;
    state.leaders.mary_i = 0;
    state.leaders.julius_iii = 0;
    state.leaders.elizabeth_i = 0;
    state.leaders.calvin = 0;

    state.spring_deploy_across_seas = [];
    state.spring_deploy_across_passes = [];

    state.henry_viii_marital_status = 0;
    state.henry_viii_healthy_edward = 0;
    state.henry_viii_sickly_edward = 0;
    state.henry_viii_add_elizabeth = 0;
    state.henry_viii_auto_reroll = 0;
    state.henry_viii_rolls = [];
    state.henry_viii_wives = [];
    state.henry_viii_pope_approves_divorce = 0;
    state.henry_viii_pope_approves_divorce_round = 0;

    state.knights_of_st_john = "";

    state.events.maurice_of_saxony = "";
    state.events.papacy_may_found_jesuit_universities = 0;
    state.events.edward_vi_born = 0;
    state.events.wartburg = 0;

    // mandatory events
    state.events.schmalkaldic_league = 0;
    state.events.clement_vii = 0;
    state.events.barbary_pirates = 0;
    state.events.paul_iii = 0;
    state.events.society_of_jesus = 0;

    state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance = 0;
    state.events.defeat_of_hungary_bohemia = 0;

    state.events.ottoman_piracy_enabled = 0;
    state.events.ottoman_corsairs_enabled = 0;
    state.events.ottoman_piracy_attempts = 0;
    state.events.ottoman_piracy_seazones = [];
    state.events.ottoman_piracy_vp = 0;

    //
    // {
    //    faction : faction
    //    round   : 0
    //  
    state.colonies = [];
    state.conquests = [];
    state.explorations = [];

    state.events.smallpox = "";
    state.events.cabot_england = 0;
    state.events.cabot_france = 0;
    state.events.cabot_hapsburg = 0;
    state.events.ottoman_julia_gonzaga_vp = 0;

    return state;

  }

  unexcommunicateFaction(faction="") {
    this.game.state.excommunicated_factions[faction] = 0;
    return;
  }

  excommunicateFaction(faction="") {
    this.game.state.already_excommunicated.push(faction);
    this.game.state.excommunicated_factions[faction] = 1;
    return;
  }


  returnJustificationForExcommunication(faction) {
    if (this.areEnemies(faction, "papacy")) { return "Wickedness against Saint Peter's Church and the Kingdom of Heaven"; }
    if (this.areAllies(faction, "ottoman")) { return "Providing Succor to the Enemies of Christendom"; }
    if (faction == "england") {
      if (this.game.state.leaders.henry_viii == 1) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == "england") {
	    if (this.game.spaces[key].religion == "protestant") { return "Tacit Support for the Protestant Sect in England"; }
	  }
	}
      }
    }
    return "";
  }


  canPapacyExcommunicateFaction(faction) {
    if (this.game.state.already_excommunicated.includes(faction)) { return 0; }
    if (this.areEnemies(faction, "papacy")) { return 1; }
    if (this.areAllies(faction, "ottoman")) { return 1; }
    if (faction == "england") {
      if (this.game.state.leaders.henry_viii == 1) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == "england") {
	    if (this.game.spaces[key].religion == "protestant") { return 1; }
	  }
	}
      }
    }
    return 0;
  }

  excommunicateReformer(reformer="") {

    this.game.state.already_excommunicated.push(reformer);
    if (reformer == "") { return; }
    if (this.returnSpaceOfPersonage("protestant", reformer) == "") { return; }

    //
    // debater
    //
    let debater = reformer.replace("-reformer", "-debater");
    let faction = "protestant";
    let s = this.returnSpaceOfPersonage("protestant", reformer);
    let idx = -1;

    if (s === "") { faction = "england"; s = this.returnSpaceOfPersonage("england", reformer); }
    if (s === "") { faction = "france"; s = this.returnSpaceOfPersonage("france", reformer); }

    if (s !== "") {
      idx = this.returnIndexOfPersonageInSpace(faction, reformer, s);
    }

    let obj = {};
    obj.space = s;
    obj.faction = faction;
    obj.idx = idx;
    obj.reformer = this.game.spaces[s].units[faction][idx];

    //
    // remove reformer
    //
    if (idx != -1) {
      this.game.spaces[s].units[faction].splice(idx, 1);
    }

    //
    // remove debater
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {
        // and commit the debater too !
        this.game.state.debaters[i].committed = 1;
        obj.debater = this.game.state.debaters[i];
        obj.debater.committed = 1;
        this.game.state.debaters.splice(i, 1);
      }
    }

    //
    // add to excommunicated list
    //
    this.game.state.excommunicated.push(obj);

    return;

  }

  restoreDebaters() {

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      this.game.state.debaters[i].committed = 0;
    }

  }

  restoreReformers() {

    for (let i = 0; i < this.game.state.excommunicated.length; i++) {
      let obj = this.game.state.excommunicated[i];
      if (obj.reformer) {

        let reformer = obj.reformer;
        let debater = obj.debater;
	let s = obj.space;
        let faction = obj.faction;

	if (reformer) {
	  if (s) {
	    if (faction) {
	      this.game.spaces[s].units[faction].push(reformer);
	    }
	  }
	}

	if (obj.debater) {
	  // debater uncommitted for restoration
	  obj.debater.committed = 0;
          this.game.state.debaters.push(obj.debater);
	}


	this.game.state.excommunicated.splice(i, 1);
	i--;

        this.displaySpace(s);

      }
    }

  }

  //
  // military leader returned to original space or capital (if controlled)
  //
  restoreMilitaryLeaders() {

    for (let i = 0; i < this.game.state.military_leaders_removed_until_next_round.length; i++) {
      let obj = this.game.state.military_leaders_removed_until_next_round[i];
      if (obj.leader) {
        let leader = obj.leader;
	let s = obj.space;
        let faction = obj.faction;

	//	
	// only return to original space if controlled
	//
	let fcs = this.returnFactionControllingSpace(s);

	if (this.returnControllingPower(fcs) == this.returnControllingPower(faction) || this.areAllies(faction, fcs)) {
	} else {
	  let capitals = this.returnCapitals(faction);
	  for (let z = 0; z < capitals.length; z++) {
	    if (this.returnFactionControllingSpace(capitals[0]) == faction) {
	      s = capitals[z];
	    }
	  }
	}

	this.restoreMilitaryLeader(leader, s, faction);

      }
    }

    this.game.state.military_leaders_removed_until_next_round = [];

  }

  restoreMilitaryLeader(leader, spacekey, faction) {

	let s = spacekey;
	let navalspace = false;

        if (faction == "ottoman") {
	  if (leader.navy_leader == true) {
            if (this.isSpaceControlled("algiers", "ottoman")) { s = "algiers"; } else {
              if (this.isSpaceControlled("oran", "ottoman")) { s = "oran"; } else {
                if (this.isSpaceControlled("oran", "ottoman")) { s = "tripoli"; };
              }
            }
          }
        }

	if (leader) {
	  if (faction) {

	    if (s == "") {
	      let capitals = this.returnCapitals(faction);
              for (let z = 0; z < capitals.length; z++) {
                if (this.isSpaceControlled(capitals[z], faction)) {
	          s = capitals[z];
	          z = capitals.length += 2;
	        }
	      }
	    }

	    if (s != "") {
	      leader.spacekey = s;
	      this.game.spaces[s].units[faction].push(leader);
	      this.displaySpace(s);
	    }
	  }
	}

  }

  returnPregnancyChart() {

    let chart = {};

    chart['1'] = {
      top : 1270,
      left : 4075,
    }

    chart['2'] = {
      top : 1185,
      left : 4075,
    }

    chart['3'] = {
      top : 1100,
      left : 4075,
    }

    chart['4'] = {
      top : 1015,
      left : 4075,
    }

    chart['5'] = {
      top : 930,
      left : 4075,
    }

    chart['6'] = {
      top : 810,
      left : 4075,
    }

    return chart;

  }

  returnColonies() {

    let colonies = {};

    colonies['1'] = {
      top : 1007,
      left : 55
    }
    colonies['2'] = {
      top : 1120,
      left : 55
    }
    colonies['3'] = {
      top : 1232,
      left : 55
    }
    colonies['4'] = {
      top : 1344,
      left : 55
    }
    colonies['5'] = {
      top : 1456,
      left : 55
    }
    colonies['6'] = {
      top : 1530,
      left : 55
    }
    colonies['7'] = {
      top : 1680,
      left : 55
    }

    return colonies;

  }


  returnNewWorld() {

    let nw = {};

    nw.results = {};
    nw.results.colonies = [];
    nw.results.explorations = [];
    nw.results.conquests = [];

    nw['england_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Roanoke.svg' ,
    }
    nw['england_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Jamestown.svg' ,
    }
    nw['france_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Charlesbourg.svg' ,
    }
    nw['france_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Montreal.svg' ,
    }
    nw['hapsburg_colony1'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/PuertoRico.svg' ,
    }
    nw['hapsburg_colony2'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Cuba.svg' ,
    }
    nw['hapsburg_colony3'] = {
      type : "colony" ,
      img : '/his/img/tiles/colonies/Hispaniola.svg' ,
    }
    nw['england_conquest1'] = {
      type : "conquest" ,
    }
    nw['england_conquest2'] = {
      type : "conquest" ,
    }
    nw['france_conquest1'] = {
      type : "conquest" ,
    }
    nw['france_conquest2'] = {
      top : 1340 ,
    }
    nw['hapsburg_conquest1'] = {
      type : "conquest" ,
    }
    nw['hapsburg_conquest2'] = {
      type : "conquest" ,
    }
    nw['hapsburg_conquest3'] = {
      type : "conquest" ,
    }
    nw['greatlakes'] = {
      img : "/his/img/vp/GreatLakes1VP.svg",
      type : "discovery" ,
      name : "Great Lakes" ,
      vp : 1
    }
    nw['stlawrence'] = {
      img : "/his/img/vp/StLawrenceRiver1VP.svg",
      type : "discovery" ,
      name : "St. Lawrence River" ,
      vp : 1
    }
    nw['mississippi'] = {
      img : "/his/img/vp/MississippiRiver1VP.svg",
      type : "discovery" ,
      name : "Mississippi" ,
      vp : 1
    }
    nw['aztec'] = {
      img : "/his/img/vp/Aztecs2VP.svg",
      type : "discovery" ,
      name : "Aztec" ,
      vp : 2
    }
    nw['maya'] = {
      img : "/his/img/vp/Maya1VP.svg",
      type : "discovery" ,
      name : "Maya" ,
      vp : 1
    }
    nw['amazon'] = {
      img : "/his/img/vp/AmazonRiver2VP.svg",
      type : "discovery" ,
      name : "Amazon River" ,
      vp : 2
    }
    nw['inca'] = {
      img : "/his/img/vp/Inca2VP.svg",
      type : "discovery" ,
      name : "Inca" ,
      vp : 2
    }
    nw['circumnavigation'] = {
      img : "/his/img/vp/Circumnavigation3VP.svg",
      type : "discovery" ,
      name : "Circumnavigation" ,
      vp : 3
    }
    nw['pacificstrait'] = {
      img : "/his/img/vp/PacificStraight1VP.svg",
      type : "discovery" ,
      name : "Pacific Strait" ,
      vp : 1
    }

    return nw;

  }


  returnConquest() {

    let conquest = {};

    conquest['1'] = {
      top : 1007,
      left : 178
    }
    conquest['2'] = {
      top : 1120,
      left : 178
    }
    conquest['3'] = {
      top : 1232,
      left : 178
    }
    conquest['4'] = {
      top : 1344,
      left : 178
    }
    conquest['5'] = {
      top : 1456,
      left : 178
    }
    conquest['6'] = {
      top : 1530,
      left : 178
    }
    conquest['7'] = {
      top : 1680,
      left : 178
    }

    return conquest;

  }

  returnVictoryPointTrack() {

    let track = {};

    track['0'] = {
      top : 2912,
      left : 2025
    }
    track['1'] = {
      top : 2912,
      left : 2138
    }
    track['2'] = {
      top : 2912,
      left : 2252
    }
    track['3'] = {
      top : 2912,
      left : 2366
    }
    track['4'] = {
      top : 2912,
      left : 2480
    }
    track['5'] = {
      top : 2912,
      left : 2594
    }
    track['6'] = {
      top : 2912,
      left : 2708
    }
    track['7'] = {
      top : 2912,
      left : 2822
    }
    track['8'] = {
      top : 2912,
      left : 2936
    }
    track['9'] = {
      top : 2912,
      left : 3050
    }
    track['10'] = {
      top : 3026,
      left : 884
    }
    track['11'] = {
      top : 3026,
      left : 998
    }
    track['12'] = {
      top : 3026,
      left : 1112
    }
    track['13'] = {
      top : 3026,
      left: 1226,
    }
    track['14'] = {
      top : 3026,
      left : 1340
    }
    track['15'] = {
      top : 3026,
      left : 1454
    }
    track['16'] = {
      top : 3026,
      left : 1569
    }
    track['17'] = {
      top : 3026,
      left : 1682
    }
    track['18'] = {
      top : 3026,
      left : 1796
    }
    track['19'] = {
      top : 3026,
      left : 1910
    }
    track['20'] = {
      top : 3026,
      left : 2024
    }
    track['21'] = {
      top : 3026,
      left : 2138
    }
    track['22'] = {
      top : 3026,
      left : 2252
    }
    track['23'] = {
      top : 3026,
      left : 2366
    }
    track['24'] = {
      top : 3026,
      left : 2480
    }
    track['25'] = {
      top : 3026,
      left : 2594
    }
    track['26'] = {
      top : 3026,
      left : 2708
    }
    track['27'] = {
      top : 3026,
      left : 2822
    }
    track['28'] = {
      top : 3026,
      left : 2936
    }
    track['29'] = {
      top : 3026,
      left : 3050
    }

    return track;
  }


  returnElectorateDisplay() {

    let electorates = {};

    electorates['augsburg'] = {
      top: 190,
      left: 3380,
    }
    electorates['trier'] = {
      top: 190,
      left: 3510,
    }
    electorates['cologne'] = {
      top: 190,
      left: 3642,
    }
    electorates['wittenberg'] = {
      top: 376,
      left: 3380,
    }
    electorates['mainz'] = {
      top: 376,
      left: 3510,
    }
    electorates['brandenburg'] = {
      top: 376,
      left: 3642,
    }

    return electorates;

  }


  returnDiplomacyAlliance() {

    let diplomacy 		= {};
    diplomacy["ottoman"] 	= {
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["england"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["france"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["papacy"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["protestant"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["hapsburg"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["venice"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["genoa"] 		= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["hungary"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
      scotland 		: { allies : 0 , enemies : 0 } ,
    };
    diplomacy["scotland"] 	= {
      ottoman 		: { allies : 0 , enemies : 0 } ,
      england 		: { allies : 0 , enemies : 0 } ,
      france  		: { allies : 0 , enemies : 0 } ,
      papacy  		: { allies : 0 , enemies : 0 } ,
      protestant 	: { allies : 0 , enemies : 0 } ,
      hapsburg 		: { allies : 0 , enemies : 0 } ,
      venice 		: { allies : 0 , enemies : 0 } ,
      genoa 		: { allies : 0 , enemies : 0 } ,
    };

    return diplomacy;
  }

  returnDiplomacyTable() {

    let diplomacy 		= {};
    diplomacy["ottoman"] 	= {};
    diplomacy["england"] 	= {};
    diplomacy["france"] 	= {};
    diplomacy["papacy"] 	= {};
    diplomacy["protestant"] 	= {};
    diplomacy["hapsburg"] 	= {};

    diplomacy["ottoman"]["hapsburg"] = {
        top 	:	170 ,
        left	:	4128 ,
    }
    diplomacy["hapsburg"]["ottoman"] = {
        top 	:	170 ,
        left	:	4128 ,
    }
    diplomacy["ottoman"]["england"] = {
        top 	:	170 ,
        left	:	4222 ,
    }
    diplomacy["england"]["ottoman"] = {
        top 	:	170 ,
        left	:	4222 ,
    }
    diplomacy["ottoman"]["france"] = {
        top 	:       170 ,
        left	:	4310 ,
    }
    diplomacy["france"]["ottoman"] = {
        top 	:       170 ,
        left	:	4310 ,
    }
    diplomacy["ottoman"]["papacy"] = {
        top 	:	170 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["ottoman"] = {
        top 	:	170 ,
        left	:	4400 ,
    }
    diplomacy["ottoman"]["protestant"] = {
        top 	:	170 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["ottoman"] = {
        top 	:	170 ,
        left	:	4490 ,
    }
    diplomacy["ottoman"]["genoa"] = {
        top 	:	170 ,
        left	:	4580 ,
    }
    diplomacy["ottoman"]["hungary"] = {
        top 	:	170 ,
        left	:	4670 ,
    }
    diplomacy["ottoman"]["scotland"] = {
        top 	:	170 ,
        left	:	4760 ,
    }
    diplomacy["ottoman"]["venice"] = {
        top 	:	170 ,
        left	:	4851 ,
    }

    diplomacy["hapsburg"]["england"] = {
        top 	:	260 ,
        left	:	4220 ,
    }
    diplomacy["england"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4220 ,
    }
    diplomacy["hapsburg"]["france"] = {
        top 	:	260 ,
        left	:	4310 ,
    }
    diplomacy["france"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4310 ,
    }
    diplomacy["hapsburg"]["papacy"] = {
        top 	:	260 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4400 ,
    }
    diplomacy["hapsburg"]["protestant"] = {
        top 	:	260 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["hapsburg"] = {
        top 	:	260 ,
        left	:	4490 ,
    }
    diplomacy["hapsburg"]["genoa"] = {
        top 	:	260 ,
        left	:	4580 ,
    }
    diplomacy["hapsburg"]["hungary"] = {
        top 	:	260 ,
        left	:	4670 ,
    }
    diplomacy["hapsburg"]["scotland"] = {
        top 	:	260 ,
        left	:	4760 ,
    }
    diplomacy["hapsburg"]["venice"] = {
        top 	:	260 ,
        left	:	4851 ,
    }


    diplomacy["england"]["france"] = {
        top 	:	350 ,
        left	:	4310 ,
    }
    diplomacy["france"]["england"] = {
        top 	:	350 ,
        left	:	4310 ,
    }
    diplomacy["england"]["papacy"] = {
        top 	:	350 ,
        left	:	4400 ,
    }
    diplomacy["papacy"]["england"] = {
        top 	:	350 ,
        left	:	4400 ,
    }
    diplomacy["england"]["protestant"] = {
        top 	:	350 ,
        left	:	4490 ,
    }
    diplomacy["protestant"]["england"] = {
        top 	:	350 ,
        left	:	4490 ,
    }
    diplomacy["england"]["genoa"] = {
        top 	:	350 ,
        left	:	4580 ,
    }
    diplomacy["england"]["hungary"] = {
        top 	:	350 ,
        left	:	4670 ,
    }
    diplomacy["england"]["scotland"] = {
        top 	:	350 ,
        left	:	4760 ,
    }
    diplomacy["england"]["venice"] = {
        top 	:	350 ,
        left	:	4851 ,
    }

    diplomacy["france"]["papacy"] = {
        top     :       440 ,
        left    :       4400 ,    
    }
    diplomacy["papacy"]["france"] = {
        top     :       440 ,
        left    :       4400 ,    
    }
    diplomacy["france"]["protestant"] = {
        top     :       440 ,
        left    :       4490 ,    
    }
    diplomacy["protestant"]["france"] = {
        top     :       440 ,
        left    :       4490 ,    
    }
    diplomacy["france"]["genoa"] = {
        top     :       440 ,
        left    :       4580 ,    
    }
    diplomacy["france"]["hungary"] = {
        top     :       440 ,
        left    :       4670 ,    
    }
    diplomacy["france"]["scotland"] = {
        top     :       440 ,
        left    :       4760 ,    
    }
    diplomacy["france"]["venice"] = {
        top     :       440 ,
        left    :       4851 ,    
    }


    diplomacy["papacy"]["protestant"] = {
        top     :       530 ,
        left    :       4490 ,    
    }
    diplomacy["protestant"]["papacy"] = {
        top     :       530 ,
        left    :       4490 ,    
    }
    diplomacy["papacy"]["genoa"] = {
        top     :       530 ,
        left    :       4580 ,    
    }
    diplomacy["papacy"]["hungary"] = {
        top     :       530 ,
        left    :       4670 ,    
    }
    diplomacy["papacy"]["scotland"] = {
        top     :       530 ,
        left    :       4760 ,    
    }
    diplomacy["papacy"]["venice"] = {
        top     :       530 ,
        left    :       4851 ,    
    }

    diplomacy["protestant"]["genoa"] = {
        top     :       620 ,
        left    :       4580 ,    
    }
    diplomacy["protestant"]["hungary"] = {
        top     :       620 ,
        left    :       4670 ,    
    }
    diplomacy["protestant"]["scotland"] = {
        top     :       620 ,
        left    :       4760 ,    
    }
    diplomacy["protestant"]["venice"] = {
        top     :       530 ,
        left    :       4851 ,    
    }

    return diplomacy;

  }



  triggerDefeatOfHungaryBohemia() {

    if (this.areAllies("hapsburg", "hungary")) { return false; }
    if (this.game.state.events.defeat_of_hungary_bohemia == 1) { return false; }

    let does_this_trigger_the_defeat_of_hungary_bohemia = false;

    //
    // Hungary-Bohemia has been activated as a Hapsburg ally through Diplomatic Marriage 
    // and the Ottomans control two home keys of Hungary-Bohemia
    //
    let ottoman_controlled_hungarian_home_spaces = 0;
    let hungarian_regulars_remaining_on_map = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].home == "hungary") {
        ottoman_controlled_hungarian_home_spaces++;
      }
      for (let z = 0; z < this.game.spaces[key].units["hungary"].length; z++) {
	if (this.game.spaces[key].units["hungary"][z].type === "regular") {
	  hungarian_regulars_remaining_on_map++;
	}
      }
    }

    if (this.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance == 1 && ottoman_controlled_hungarian_home_spaces >= 2) { 
      does_this_trigger_the_defeat_of_hungary_bohemia = true;
    }

    if (hungarian_regulars_remaining_on_map < 5 && ottoman_controlled_hungarian_home_spaces >= 1) {
      does_this_trigger_the_defeat_of_hungary_bohemia = true;
    }

    if (does_this_trigger_the_defeat_of_hungary_bohemia) {

      this.game.state.events.defeat_of_hungary_bohemia = 1;

      //
      // best friends forever
      //
      if (!this.areAllies("hapsburg", "hungary")) {
        this.setAllies("hapsburg", "hungary");
      }

      //
      // natural ally intervention
      //
      if (this.areAllies("hapsburg", "ottoman")) {
	this.unsetAllies("hapsburg", "ottoman");
      }
      this.setEnemies("hapsburg", "ottoman");


      //
      // turks get control of more spaces
      //
      for (let key in this.game.spaces) {
        if (this.game.spaces[key].home == "hungary") {
	  // ottoman gets the spaces, but not the keys
	  if (this.game.spaces[key].units["ottoman"].length > 0 && this.game.spaces[key].type != "key") {
	    this.game.spaces[key].units["hungary"] = [];
	    this.controlSpace("ottoman", key);
	  }
	}
      }

      //
      // Ottomans points for winning war
      //
      this.updateLog("Hungary-Bohemia are defeated, pulling the Hapsburgs into war with the Ottoman Empire");
      this.game.state.ottoman_war_winner_vp += 2;
      this.displayWarBox();
      this.displayVictoryTrack();

      //
      // add war
      //
      for (let z = this.game.queue.length-1; z >= 0; z--) {
	let lmv = this.game.queue[z].split("\t");
	if (lmv[0] === "cards_left" || lmv[0] == "continue" || lmv[0] == "play" || lmv[0] == "action_phase" || lmv[0] == "discard") {
	  this.game.queue.splice(z, 0, `unexpected_war\thapsburg\tottoman`);
	  z = 0;
	  break;
	}
      }

      // let's notify the player visually
      this.game.queue.push("ACKNOWLEDGE\tThe Hapsburgs are pulled into the War in Hungary");
      this.game.queue.push("display_custom_overlay\tbattle-of-mohacs");

    }
  }



  returnEventObjects() {

    let z = [];

    //
    // factions in-play
    //
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      if (this.factions[this.game.state.players_info[i].faction] != undefined) {
        z.push(this.factions[this.game.state.players_info[i].faction]);
      }
    }


    //
    // cards in the deck can modify gameloop
    //
    for (let key in this.deck) {
      z.push(this.deck[key]);
    }
    for (let key in this.diplomatic_deck) {
      z.push(this.diplomatic_deck[key]);
    }

    //
    // debaters have bonuses which modify gameplay
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      let d = this.game.state.debaters[i];
      let key = d.type;
      z.push(this.debaters[key]);
    }

    return z;

  }



  addEvents(obj) {

    ///////////////////////
    // game state events //
    ///////////////////////
    //
    // these events run at various points of the game. They are attached to objs
    // on object initialization, so that the objects can have these events 
    // triggered at various points of the game automatically.
    //
    //
    // 
    // 1 = fall through, 0 = halt game
    //
    if (obj.onCommit == null) {
      obj.onCommit = function(his_self, faction) { return 1; } // 1 means fall through
    }
    if (obj.onEvent == null) {
      obj.onEvent = function(his_self, player) { return 1; } // 1 means fall-through / no-stop
    }
    if (obj.canEvent == null) {
      obj.canEvent = function(his_self, faction) { return 0; } // 0 means cannot event
    }
    if (obj.handleGameLoop == null) {
      obj.handleGameLoop = function(his_self, qe, mv) { return 1; } // 1 means fall-through / no-stop
    }





    //
    // functions for convenience
    //
    if (obj.removeFromDeck == null) {
      obj.removeFromDeck = function(his_self, player) { return 0; } 
    }
    if (obj.menuOptionTriggers == null) {
      obj.menuOptionTriggers = function(his_self, stage, player, faction) { return 0; }
    }
    if (obj.menuOption == null) {
      obj.menuOption = function(his_self, stage, player, faction) { return 0; }
    }
    if (obj.menuOptionActivated == null) {
      obj.menuOptionActivated = function(his_self, stage, player, faction) { return 0; }
    }

    return obj;

  }




  //
  // Core Game Logic
  //
  async handleGameLoop() {

    let his_self = this;

    if (this.is_first_loop == undefined) {
      this.is_first_loop = 1;
    } else {
      this.is_first_loop = 0;
    }

    ///////////
    // QUEUE //
    ///////////
    if (this.game.queue.length > 0) {

        let qe = this.game.queue.length-1;
        let mv = this.game.queue[qe].split("\t");
	let z = this.returnEventObjects();
        let shd_continue = 1;

console.log("QUEUE: " + JSON.stringify(this.game.queue));
console.log("MOVE: " + mv[0]);

	//
	// entry point for every round in the game
	//
        if (mv[0] === "round") {

	  this.game.state.round++;

          //
          // TODO - sanity placement here as earlier did not catch everything
          // maybe eliminate redundancy in the future.
	  //
          this.returnOverstackedUnitsToCapitals();

this.updateLog(`###############`);
this.updateLog(`### Round ${this.game.state.round} ###`);
this.updateLog(`###############`);

	  this.game.state.cards_left = {};

	  this.onNewRound();
	  this.restoreReformers();
	  this.restoreMilitaryLeaders();

	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    this.resetPlayerRound((i+1));
          }

	  this.game.queue.push("victory_determination_phase");
	  this.game.queue.push("winter_phase");
	  this.game.queue.push("new_world_phase");
	  if (this.game.state.round > 4) { this.game.queue.push("advance_victory_determination_phase"); }
	  this.game.queue.push("ACKNOWLEDGE\tThe Advent of Winter");
	  this.game.queue.push("show_overlay\twinter_phase");
	  this.game.queue.push("action_phase");

//if (this.game.options.scenario != "is_testing") {
	  this.game.queue.push("spring_deployment_phase");
	  this.game.queue.push("NOTIFY\tSpring Deployment is about to start...");
//}

	  //
	  // n.b. check interventions flags if Venetian Informant is playable
	  //
	  this.game.queue.push("check_interventions"); // players check and report cards that need to trigger waiting/check
	  this.game.queue.push("RESETCONFIRMSNEEDED\tall");

	  if (this.game.players.length == 2) {

	    this.game.queue.push("diplomacy_phase_2P");
	    // R1 cards dealt below
	    if (this.game.state.round > 1) {
	      this.game.queue.push("card_draw_phase");
	      this.game.queue.push("winter_retreat_move_units_to_capital\tpapacy");
	    }

	  } else {

	    if (this.game.state.starting_round != this.game.state.round) {

	      if (this.game.state.round > 1) {

  	        if (this.game.state.events.schmalkaldic_league) {
	          this.game.queue.push("make_declarations_of_war\tprotestant");
	        }
	        this.game.queue.push("make_declarations_of_war\tpapacy");
	        this.game.queue.push("make_declarations_of_war\tfrance");
	        this.game.queue.push("make_declarations_of_war\tengland");
	        this.game.queue.push("make_declarations_of_war\thapsburg");
	        this.game.queue.push("make_declarations_of_war\tottoman");
		if (this.game.state.excommunicated_factions["france"] == 1) {
	          this.game.queue.push("remove_excommunication\tfrance");
		}
		if (this.game.state.excommunicated_factions["england"] == 1) {
	          this.game.queue.push("remove_excommunication\tengland");
		}
		if (this.game.state.excommunicated_factions["hapsburg"] == 1) {
	          this.game.queue.push("remove_excommunication\thapsburg");
		}
	        this.game.queue.push("sue_for_peace\tpapacy");
	        this.game.queue.push("sue_for_peace\tfrance");
	        this.game.queue.push("sue_for_peace\tengland");
	        this.game.queue.push("sue_for_peace\thapsburg");
	        this.game.queue.push("sue_for_peace\tottoman");
	        this.game.queue.push("diplomacy_phase");

	        //this.game.queue.push("ACKNOWLEDGE\tProceed to Diplomatic Proposals");

  	        this.game.queue.push("card_draw_phase");


	        if (this.game.players.length == 3) {
                  this.game.queue.push("winter_retreat_move_units_to_capital_faction_array\t"+JSON.stringify(["france","papacy","protestant"]));
                  this.game.queue.push("RESETCONFIRMSNEEDED\tall");
                  this.game.queue.push("winter_retreat_move_units_to_capital_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england"]));
                  this.game.queue.push("RESETCONFIRMSNEEDED\tall");
                }
          
            	if (this.game.players.length == 4) {
            	  this.game.queue.push("winter_retreat_move_units_to_capital_faction_array\t"+JSON.stringify(["papacy","protestant"]));
              	  this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              	  this.game.queue.push("winter_retreat_move_units_to_capital_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france"]));
              	  this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              	  return 1;
                }
          
                if (this.game.players.length >= 5) {
		  this.game.queue.push("winter_retreat_move_units_to_capital_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france","papacy"]));
	          this.game.queue.push("RESETCONFIRMSNEEDED\tall");
		}

	      }
	    }
	  }

	  //
	  // 1532 mode and testing need cards too!
	  //
	  if (this.game.state.round != 1 && (this.game.state.round == this.game.state.starting_round)) {
	    this.game.queue.push("card_draw_phase");
	  } else {

	    //
	    // start the game with the Protestant Reformation
	    //
	    if (this.game.state.round == 1) {

	      if (this.game.options.scenario == "is_testing") {

	        this.game.queue.push("is_testing");
	        this.game.queue.push("card_draw_phase");

	      } else {

	        if (this.game.players.length == 2) {
	          this.game.queue.push("show_overlay\tvp");
	        }

		this.game.state.sp = [];
	        this.game.queue.push("hide_overlay\tdiet_of_worms");
	        this.game.queue.push("resolve_diet_of_worms");
		if (this.game.players.length > 2) { 
	          this.game.queue.push("diet_of_worms_hapsburgs");
		} else {
	          //
        	  // or we flip hapsburg card from deck if 2-player game
        	  //
        	  this.game.queue.push("POOLDEAL\t1\t1\t1"); // deck 1
        	  this.game.queue.push("POOL\t1"); // deck 1
		}
	        this.game.queue.push("diet_of_worms_faction_array");
	        this.game.queue.push("RESETCONFIRMSNEEDED\tall");

	        this.game.queue.push("show_overlay\tdiet_of_worms");
	        this.game.queue.push("card_draw_phase");
	        this.game.queue.push("event\tprotestant\t008");

	      }

	    } else {

	      //
	      // round 2 - zwingli in zurich
	      //
	      if (this.game.state.round == 2) {
	        this.addDebater("protestant", "oekolampadius-debater");
	        this.addDebater("protestant", "zwingli-debater");
	        this.addReformer("protestant", "zurich", "zwingli-reformer");
	        this.convertSpace("protestant", "zurich");
	        this.addDebater("papacy", "contarini-debater");
	      }

	      //
	      // round 3
	      //
	      if (this.game.state.round == 3) {
	        this.addDebater("protestant", "bullinger-debater");
	      }

	      //
	      // round 3 or later ?
	      //
    	      if (this.game.state.round < 5 && this.game.state.henry_viii_marital_status >= 2 && this.game.state.henry_viii_reformation_started != 1) {
	        this.game.state.henry_viii_reformation_started = 1;
	        this.addDebater("protestant", "cranmer-debater");
		this.game.state.events.cranmer_active = 1;
	        this.addDebater("protestant", "latimer-debater");
	        this.addDebater("protestant", "coverdale-debater");
	        this.addReformer("protestant", "london", "cranmer-reformer");
	        this.convertSpace("protestant", "london");
	        this.updateLog("Henry VIII's marriage to Anne Boleyn triggers the start of the British Reformation");
	      }

	      //
	      // round 4 - calvin in genoa
	      //
	      if (this.game.state.round == 4) {

	        //
	        // 1532 starts in R4
	        //
	        if (this.game.options.scenario === "1532") {
	          this.game.queue.push("is_1532");
	        }

	        this.addDebater("protestant", "farel-debater");
	        this.addDebater("protestant", "cop-debater");
	        this.addDebater("protestant", "olivetan-debater");
	        this.addDebater("protestant", "calvin-debater");
	        this.addReformer("protestant", "geneva", "calvin-reformer");
	        this.convertSpace("protestant", "geneva");

	        if (this.game.players.length == 2) {
	          //
	          // Henry VIII marries Anne Boleyn
	          //
	          this.game.state.henry_viii_marital_status = 2;
	        }
	      }

	      //
	      // round 5 - cranmer in london
	      //
	      if (this.game.state.round == 5) {
	        if (this.game.state.henry_viii_reformation_started != 1) {
	          this.addDebater("protestant", "cranmer-debater");
	          this.addDebater("protestant", "latimer-debater");
	          this.addDebater("protestant", "coverdale-debater");
	          this.addReformer("protestant", "london", "cranmer-reformer");
	          this.convertSpace("protestant", "london");
	        }
	        this.addDebater("papacy", "pole-debater");
	        this.addDebater("papacy", "caraffa-debater");
	      }

	      //
	      // round 6 - maurice of saxony
	      //
	      if (this.game.state.round == 6) {
	        this.addDebater("protestant", "wishart-debater");
	        this.addDebater("protestant", "knox-debater");
	        this.game.queue.push("protestants-place-maurice-of-saxony-round-six");
	        this.addDebater("papacy", "loyola-debater");
	        this.addDebater("papacy", "faber-debater");
	        this.addDebater("papacy", "canisius-debater");
	      }

	      //
	      // round 6 or higher - England (Mary, Elizabeth and Edward)
	      //
	      // this logic is implemented in newCards
	      //
	      if (this.game.players.length <= 2) {
	        if (this.game.state.round >= 6 ) {
                  this.game.state.henry_viii_healthy_edward = 1;
                  this.game.state.henry_viii_sickly_edward = 0;
                  this.game.state.henry_viii_add_elizabeth = 0;
	        }
	      }

	      //
	      // round 7
	      //
	      if (this.game.state.round == 7) {
	        this.addDebater("papacy", "gardiner-debater");
	      }
	    }
	  }

	  //
	  // show all - will only trigger for relevant faction
	  //
	  if (this.game.state.round == 1 || (this.game.state.round == this.game.state.starting_round)) {
	    if (this.game.players.length == 2) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	    }
	    if (this.game.players.length == 3) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\tfrance_ottoman");
	      this.game.queue.push("show_overlay\twelcome\thapsburg_papacy");
	    }
	    if (this.game.players.length == 4) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\thapsburg_papacy");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
	    if (this.game.players.length == 5) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant_england");
	      this.game.queue.push("show_overlay\twelcome\thapsburg");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
	    if (this.game.players.length == 6) {
	      this.game.queue.push("show_overlay\twelcome\tprotestant");
	      this.game.queue.push("show_overlay\twelcome\tpapacy");
	      this.game.queue.push("show_overlay\twelcome\thapsburg");
	      this.game.queue.push("show_overlay\twelcome\tengland");
	      this.game.queue.push("show_overlay\twelcome\tfrance");
	      this.game.queue.push("show_overlay\twelcome\tottoman");
	    }
      	    this.game.queue.push("READY");
	  }

          return 1;
        }


        if (mv[0] == "init") {
          this.game.queue.splice(qe, 1);
	  return 1;
        }

	if (mv[0] === "show_overlay") {

          this.game.queue.splice(qe, 1);

	  //
	  // hide any cardbox
	  //
	  this.cardbox.hide();

	  this.displayElectorateDisplay();
	  if (mv[1] === "winter_phase") {
	    this.winter_overlay.render("stage1"); 
	  }
	  if (mv[1] === "welcome") { 
	    let faction = mv[2];
	    let player = this.returnPlayerOfFaction(faction);
	    if (faction === "protestant_england") { player = this.returnPlayerOfFaction("protestant"); }
	    if (faction === "hapsburg_papacy") { player = this.returnPlayerOfFaction("hapsburg"); }
	    if (faction === "france_ottoman") { player = this.returnPlayerOfFaction("france"); }
	    if (this.game.player === player) { 
	      this.welcome_overlay.render(faction); 
	      this.game.queue.push("hide_overlay\twelcome");
	      if (faction === "protestant") { this.game.queue.push("ACKNOWLEDGE\tYou are the Protestants"); }
	      if (faction === "papacy") { this.game.queue.push("ACKNOWLEDGE\tYou are the Papacy"); }
	      if (faction === "hapsburg") { this.game.queue.push("ACKNOWLEDGE\tYou are the Hapsburgs"); }
	      if (faction === "ottoman") { this.game.queue.push("ACKNOWLEDGE\tYou are the Ottomans"); }
	      if (faction === "france") { this.game.queue.push("ACKNOWLEDGE\tYou are the French"); }
	      if (faction === "england") { this.game.queue.push("ACKNOWLEDGE\tYou are the English"); }
	      if (faction === "protestant_england") { this.game.queue.push("ACKNOWLEDGE\tYou are the Protestants and English"); }
	      if (faction === "france_ottoman") { this.game.queue.push("ACKNOWLEDGE\tYou are the French and Ottomans"); }
	      if (faction === "hapsburg_papacy") { this.game.queue.push("ACKNOWLEDGE\tYou are the Hapsburgs and Papacy"); }
	    }
	  }
	  if (mv[1] === "theses") { this.theses_overlay.render(); }
	  if (mv[1] === "diet_of_worms") { this.diet_of_worms_overlay.render(); }
	  if (mv[1] === "council_of_trent") { this.council_of_trent_overlay.render(); }
	  if (mv[1] === "winter") { this.winter_overlay.render(); }
	  if (mv[1] === "faction") { this.faction_overlay.render(mv[2]); }
	  if (mv[1] === "vp") { this.vp_overlay.render(); }
	  if (mv[1] === "zoom") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "burn_books") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "publish_treatise") {
	    let lz = mv[2];
	    this.theses_overlay.render(lz);
          }
	  if (mv[1] === "theological_debate_and_debaters") { 
	    this.debate_overlay.render(his_self.game.state.theological_debate); 
            this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
            this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);
	  }
	  if (mv[1] === "theological_debate") { this.debate_overlay.render(his_self.game.state.theological_debate); }
	  if (mv[1] === "naval_battle") {
	    if (mv[2] === "post_naval_battle_attackers_win") { this.naval_battle_overlay.attackersWin(his_self.game.state.naval_battle); }
	    if (mv[2] === "post_naval_battle_defenders_win") { this.naval_battle_overlay.defendersWin(his_self.game.state.naval_battle); }
	  }
	  if (mv[1] === "field_battle") {
	    if (mv[2] === "post_field_battle_attackers_win") { this.field_battle_overlay.attackersWin(his_self.game.state.field_battle); }
	    if (mv[2] === "post_field_battle_defenders_win") { this.field_battle_overlay.defendersWin(his_self.game.state.field_battle); }
	  }

	  return 1;
	}
	if (mv[0] === "hide_overlay") {
	  this.displayElectorateDisplay();
	  if (mv[1] === "winter") { this.winter_overlay.pushHudUnderOverlay(); this.winter_overlay.hide(); }
	  if (mv[1] === "welcome") { this.welcome_overlay.pushHudUnderOverlay(); this.welcome_overlay.hide(); }
	  if (mv[1] === "faction") { this.faction_overlay.hide(); }
	  if (mv[1] === "theses") { this.theses_overlay.hide(); }
	  if (mv[1] === "zoom") { this.theses_overlay.hide(); }
	  if (mv[1] === "burn_books") { this.theses_overlay.hide(); }
	  if (mv[1] === "publish_treatise") { this.theses_overlay.hide(); }
	  if (mv[1] === "chateaux") { this.chateaux_overlay.hide(); }
	  if (mv[1] === "diet_of_worms") { this.diet_of_worms_overlay.hide(); }
	  if (mv[1] === "council_of_trent") { this.council_of_trent_overlay.hide(); }
	  if (mv[1] === "vp") { this.vp_overlay.hide(); }
	  if (mv[1] === "theological_debate") { this.debate_overlay.pushHudUnderOverlay(); this.debate_overlay.hide(); }
	  if (mv[1] === "spring_deployment") { this.spring_deployment_overlay.hide(); }
	  if (mv[1] === "field_battle") { this.field_battle_overlay.hide(); }
	  if (mv[1] === "siege") { this.assault_overlay.hide(); }
	  if (mv[1] === "assault") { this.assault_overlay.hide(); }
          this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "display_custom_overlay" || mv[0] === "display-custom-overlay") {

          this.game.queue.splice(qe, 1);

	  if (!this.browser_active) { return 1; }

          let card = mv[1];
	  let msg = "";
	  let obj = "";
	  if (mv[2]) { msg = mv[2]; }
	  if (mv[3]) { obj = JSON.parse(mv[3]); }
	  let show_overlay = false;

	  //
	  // everyone shows
	  //
	  if (obj == "") {
	    show_overlay = true;
	  //
	  // object contains show / hide info
	  //
	  } else {
	    for (let i = 0; i < obj.show.length; i++) {
	      let f = obj.show[i];
	      if (f == "all" || this.game.player == this.returnPlayerCommandingFaction(f)) {
	        show_overlay = true;
	      }
	    }
	    for (let i = 0; i < obj.hide.length; i++) {
	      let f = obj.hide[i];
	      if (this.game.player == this.returnPlayerCommandingFaction(f)) {
	        show_overlay = false;
	      }
	    }
	  }

	  if (show_overlay) {
	    this.displayCustomOverlay(card, msg);
	  }

	  return 1;
	}

	if (mv[0] === "remove_cards_left") {

	  for (let i = 0; i < this.game.queue.length; i++) {
	    let lmv = this.game.queue[i].split("\t");
	    if (lmv[0] == "cards_left") {
	      this.game.queue.splice(i, 1);
	    }
	  }

	  this.displayCardsLeft();

          this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "cards_left") {

          let faction = mv[1];
          let cards_left = parseInt(mv[2]);
	  this.game.state.cards_left[faction] = cards_left;

	  //
	  // we don't send this if we aren't playing event or ops, so if cards_left > 0, we 
	  // do not trigger auto-passing. this "unsets" pass if we have passed earlier, allowing
	  // players to pass and then decide to continue later.
	  //
	  let player = this.returnPlayerCommandingFaction(faction);
          for (let z = 0; z < this.game.state.players_info[player-1].factions.length; z++) {
	    if (this.game.state.players_info[player-1].factions[z] == faction) {
	      this.game.state.players_info[player-1].factions_passed[z] = false;
	    }
	  }
	  this.displayCardsLeft();

          this.game.queue.splice(qe, 1);
	  return 1;

	}


	if (mv[0] === "pass") {
 
          let faction = mv[1];

	  let player = this.returnPlayerOfFaction(faction);
	  if (mv[2]) {
            let cards_left = parseInt(mv[2]);
	    this.game.state.cards_left[faction] = cards_left;
	  }

          for (let z = 0; z < this.game.state.players_info[player-1].factions.length; z++) {
	    if (this.game.state.players_info[player-1].factions[z] == faction) {
	      this.game.state.players_info[player-1].factions_passed[z] = true;
	    }
	  }

	  this.updateLog(this.returnFactionName(faction) + " passes");

	  //
	  // Henry VIII reroll on first pass after 3 roll on pregnancy chart
	  //
	  if (this.game.state.henry_viii_auto_reroll == 1 && faction == "england") {
	    this.game.queue.push("advance_henry_viii_marital_status");
	    this.game.state.henry_viii_auto_reroll = 0;
	  }

          this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "build") {

	  let land_or_sea = mv[1];
	  let faction = mv[2];
	  let unit_type = mv[3];
	  let spacekey = mv[4];
          let player_to_ignore = parseInt(mv[5]);

	  this.updateLog(this.returnFactionName(faction) + " builds " + unit_type + " in " + this.returnSpaceName(spacekey), true);

	  //
	  // winterrrr retreat sometimes builds army leaders
	  //
	  if (unit_type == "renegade" || unit_type == "suleiman" || unit_type == "ibrahim-pasha" || unit_type == "charles-v" || unit_type == "duke-of-alva" || unit_type == "ferdinand" || unit_type == "henry-viii" || unit_type == "charles-brandon" || unit_type == "francis-i" || unit_type == "henry-ii" || unit_type == "montmorency" || unit_type == "andrea-doria" || unit_type == "maurice-of-saxony" || unit_type == "dudley" || unit_type == "john-frederick" || unit_type == "philip-hesse") {
	    if (this.game.player != player_to_ignore) {
	      this.addArmyLeader(faction, spacekey, unit_type);
	      this.displaySpace(spacekey);
	      this.game.queue.splice(qe, 1);
	    }
	    return 1;
	  }

	  //
	  // maybe it will try to move navy leaders too
	  //
	  if (unit_type == "barbarossa" || unit_type == "dragut" || unit_type == "andrea-doria") {
	    if (this.game.player != player_to_ignore) {
	      this.addNavyLeader(faction, spacekey, unit_type);
	      this.displaySpace(spacekey);
	      this.game.queue.splice(qe, 1);
	    }
	    return 1;
	  }


	  if (this.game.player != player_to_ignore) {
	    if (land_or_sea === "land") {
	      this.game.spaces[spacekey].units[faction].push(this.newUnit(faction, unit_type));
	    }
	    if (land_or_sea === "sea") {
	      this.game.navalspaces[spacekey].units[faction].push(this.newUnit(faction, unit_type));
	    }
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "activate_minor_power") {

	  let faction = mv[1];
	  let power = mv[2];

	  //
	  // does this trigger the defeat of Hungary-Bohemia? -- will only run once
	  //
          if (faction === "hapsburg" && power == "hungary" && his_self.game.state.events.diplomatic_alliance_triggers_hapsburg_hungary_alliance == 1) {
            this.triggerDefeatOfHungaryBohemia();
	  }

	  this.activateMinorPower(faction, power);
	  this.updateLog(this.returnFactionName(faction) + " now controls " + this.returnFactionName(power));
	  this.displayBoard();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	if (mv[0] === "deactivate_minor_power") {

	  let faction = mv[1];
	  let power = mv[2];

	  this.deactivateMinorPower(faction, power);
	  this.updateLog(this.returnFactionName(faction) + " no longer controls " + this.returnFactionName(power));
	  this.displayBoard();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "remove_unit") {

	  let land_or_sea = mv[1];
	  let faction = mv[2];
	  let unit_type = mv[3];
	  let spacekey = mv[4];
          let player_to_ignore = parseInt(mv[5]);

	  if (this.game.player != player_to_ignore) {
	    if (land_or_sea === "land") {
	      this.removeUnit(faction, spacekey, unit_type);
	    }
	    if (land_or_sea === "sea") {
	      this.removeUnit(faction, spacekey, unit_type);
	    }
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



	if (mv[0] === "winter_retreat_move_units_to_capital_faction_array") {

	  let factions = JSON.parse(mv[1]);
	  let do_i_get_to_move = false;

	  //
	  // skip if we have already confirmed!
	  //
	  if (this.game.confirms_needed[this.game.player-1] == 0) {
	    this.diplomacy_overlay.hide();
	    return 0;
	  }

	  //
	  // exit if overlay open and visible
	  //
	  if (this.theses_overlay.visible) {
	    //
	    // periodically this will trigger when the overlay is NOT visible
	    //
	    let obj = document.querySelector(".theses_overlay");
	    if (obj) { 
	      if (obj.style) { 
	        if (obj.style.display != "none") { return 0; }
	      }
	    }
	  }

	  if (this.moves.length > 0) {
	    console.log("MOVES EXIT: " + JSON.stringify(this.moves));
	    return 0;
	  }

	  this.addMove("RESOLVE\t"+this.publicKey);

	  for (let i = 0; i < factions.length; i++) {
	    let p = this.returnPlayerCommandingFaction(factions[i]);
	    if (this.game.player == p) {
	      this.winter_overlay.hide();
	      this.playerReturnWinterUnits(factions[i]);
	      do_i_get_to_move = true;
	      return 0;
            }
          }

	  //
	  // hey, it's me, not here...
	  //
	  if (do_i_get_to_move == false) {
	     this.endTurn();
	  }

	  // no splice either -- cleared by RESETCONFIRMSNEEDED
	  return 0;

	}


	if (mv[0] === "winter_retreat_move_units_to_capital") {

	  let faction = mv[1];

	  this.game.queue.splice(qe, 1);

	  let p = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player == p) {
	    this.winter_overlay.hide();
	    this.playerReturnWinterUnits(faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " returning units to capital");
	  }

	  return 0;

	}
	if (mv[0] === "winter_retreat_move_units_to_fortresses_faction_array") {

          let factions = JSON.parse(mv[1]);
          let do_i_get_to_move = false;

	  //
	  // first time?
	  //
	  let is_this_our_first_time_hitting_this = true;
	  for (let z = 0; z < this.game.confirms_needed.length; z++) {
	    if (this.game.confirms_needed[z] == 0) { is_this_our_first_time_hitting_this = false; }
	  }
	  if (is_this_our_first_time_hitting_this == true) { this.theses_overlay.hide(); this.theses_overlay.visible = false; }


          //  
          // exit if we are already handling....
          //
          if (this.moves.length > 0) { return 0; }
          if (this.theses_overlay.visible) { return 0; }
 
          //  
          // skip if we have already confirmed!
          //
          if (this.game.confirms_needed[this.game.player-1] == 0) {
            return 0;
          }   
              
          for (let i = 0; i < factions.length; i++) {
            let p = this.returnPlayerCommandingFaction(factions[i]);
            if (this.game.player == p && factions[i] != "protestant") {
	      if (this.winter_retreat_faction != factions[i] && !this.theses_overlay.visible) {
	        this.winter_retreat_faction = factions[i];
                this.addMove("RESOLVE\t"+this.publicKey);
                this.playerPlayWinterRetreatToFortresses(factions[i], this.game.player, "");
                do_i_get_to_move = true;
	      }
            } 
	    if (this.game.player == p && factions[i] == "protestant") {
	      this.winter_retreat_faction = factions[i];
	    }
          }

	  //
          // hey, it's me, protestants
	  //
          if (do_i_get_to_move == false) {
	    let tmpx = 1;
            for (let z = 0; z < this.game.confirms_needed.length; z++) {
	     if (this.game.confirms_needed[z] === 0) { tmpx = 0; }
	    }
	    if (tmpx == 1) {
              this.addMove("RESOLVE\t"+this.publicKey);
              this.endTurn();
	    }
          }

          return 0;

	}

	if (mv[0] === "retreat_to_winter_spaces") {

	  this.game.queue.splice(qe, 1);

	  if (this.game.players.length == 3) {
            this.game.queue.push("winter_retreat_move_units_to_fortresses_faction_array\t"+JSON.stringify(["france","papacy","protestant"]));
            this.game.queue.push("RESETCONFIRMSNEEDED\tall");
            this.game.queue.push("winter_retreat_move_units_to_fortresses_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england"]));
            this.game.queue.push("RESETCONFIRMSNEEDED\tall");
          }
          
          if (this.game.players.length == 4) {
            this.game.queue.push("winter_retreat_move_units_to_fortresses_faction_array\t"+JSON.stringify(["papacy","protestant"]));
            this.game.queue.push("RESETCONFIRMSNEEDED\tall");
            this.game.queue.push("winter_retreat_move_units_to_fortresses_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france"]));
            this.game.queue.push("RESETCONFIRMSNEEDED\tall");
            return 1;
          }
          
          if (this.game.players.length >= 5) {
	    this.game.queue.push("winter_retreat_move_units_to_fortresses_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france","papacy"]));
	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	  }

	  let his_self = this;
	  let moves = [];

	  //
	  // we have handled naval retreat, so we move stranded naval leaders back to capital port
	  // in case there are any still floating around. this is a sanity check rather than something
	  // we particularly want to have in the code here.
	  //
	  for (let spacekey in this.game.navalspaces) {
	    let ns = this.game.navalspaces[spacekey];
	    for (let z in ns.units) {
	      for (let zz = 0; zz < ns.units[z].length; zz++) {
  		if (ns.units[z][zz].navy_leader) {
            	  if (!this.doesFactionHaveFriendlyNavalUnitsInSpace(z)) {
              	    let obj = {};
              	    obj.faction = "";
              	    obj.leader = ns.units[z][zz];
                    if (obj.leader) { if (obj.leader.type == "barbarossa") { obj.space = "istanbul"; obj.faction = "ottoman"; } }
                    if (obj.leader) { if (obj.leader.type == "dragut") { obj.space = "istanbul"; obj.faction = "ottoman"; } }
                    if (obj.leader) { if (obj.leader.type == "andrea-doria") { obj.space = "genoa"; obj.faction = "genoa"; } }

		    //
		    // ottomans prefer algiers if available
		    //
		    if (obj.faction === "ottoman") {
		      if (this.isSpaceControlled("algiers", "ottoman")) { obj.space = "algiers"; } else {
		        if (this.isSpaceControlled("oran", "ottoman")) { obj.space = "oran"; } else {
		          if (this.isSpaceControlled("oran", "ottoman")) { obj.space = "tripoli"; };
		        }
		      }
		    }

                    ns.units[z].splice(zz, 1);
                    this.game.state.military_leaders_removed_until_next_round.push(obj);
		  }
		}
	      }
            } 
          }
        
	  //
	  // this lets independent fill their own capitals before major powers...
	  //
	  let fs = ["venice","hungary","genoa","scotland","independent","ottoman","hapsburg","england","france","papacy","protestant"];

	  //
	  // handle non-naval units
	  //
	  for (let spacekey in this.game.spaces) {
	    for (let mm = 0; mm < fs.length; mm++) {

	      let faction = fs[mm];
	      let space = this.game.spaces[spacekey];

	      let fluis = 0;
	      if (space.units[faction].length > 0 ) { fluis = this.returnFactionLandUnitsInSpace(faction, spacekey, 0); }
	      if (fluis > 0) {

		//
		// we need to retreat from these spaces
		//
		if (  
			((this.isSpaceFortified(spacekey) && !this.isSpaceControlled(spacekey, faction)) || (!this.isSpaceFortified(spacekey)))
			&&
			(!(faction == "protestant" && this.isSpaceElectorate(space.key) && this.game.state.events.schmalkaldic_league != 1))
			&&
			(spacekey != "ireland" && spacekey != "persia" && spacekey != "egypt")
		) {

		  //
		  // remove siege if needed so units not "besieged" when moved
		  //
		  this.removeSiege(space.key);

		  //
		  // for every unit that needs to be moved
		  //
		  for (let fluis_idx = 0; fluis_idx < fluis; fluis_idx++) {

		    if (fluis_idx < 0) { fluis_idx = 0; }

		    //
		    // find the nearest friendly fortified space w/ less than 4 units
		    //
		    let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(faction, spacekey, 4);

		    //
		    // if we cannot find any spaces to receive them
		    //
		    if (res.length == 0) {

		      //
		      // destroy stranded units in 2P version
		      //
		      if ((this.game.players.length == 2 && (faction != "protestant" && faction != "papacy")) || this.returnPlayerCommandingFaction(faction) == 0) {
		        for (let z = 0; z < this.game.spaces[spacekey].units[faction].length; z++) {
		          if (this.game.spaces[spacekey].units[faction][z].personage != true && this.game.spaces[spacekey].units[faction][z].reformer != true) {
			    this.game.spaces[spacekey].units[faction].splice(z, 1);
			    z--;
			    // we have moved one guy...
			    fluis--; fluis_idx--;
			  }
	 	        }
		        this.displaySpace(spacekey);

		      //
		      // otherwise attrition + return to capital
		      //
		      } else {

 			let capitals = this.returnCapitals(faction);
			let unitlen = this.game.spaces[spacekey].units[faction].length;
			let number_to_move = 0;
			let number_of_regulars = 0;
			let number_of_mercenaries = 0;
			let number_to_destroy = 0;

			//
			// calculate who is here
			//
		        for (let z = 0, y = 0; z < unitlen; z++) {
		          if (this.game.spaces[spacekey].units[faction][z].reformer != true) {
		    	    if (y == 0) { number_to_destroy++; y++; } else { y = 0; }
			    if (this.game.spaces[spacekey].units[faction][z].type != "squadron" || this.game.spaces[spacekey].units[faction][z].type != "corsair") {
			      number_to_move++;
			      if (this.game.spaces[spacekey].units[faction][z].type == "regular") {
			        number_of_regulars++;
			      } else {
			        number_of_mercenaries++;
			      }
			    }
			  }
			}

			//
			// shortcut - units with sea access almost always have a clear retreat to 
			// their home capital, so check. this prevents attrition from stranded units
			// on key-less islands.
			//
			if (this.game.spaces[spacekey].ports.length > 0) {
			  number_to_destroy = 0;
			}

			//
			// attrition
			//
			if (number_to_destroy > 0) {
			  this.updateLog(this.returnFactionName(faction) + " units in " + this.returnSpaceName(spacekey) + " suffer attrition");
			}

			//
			// remove mercenaries/cavalry first
			//
			for (let z = unitlen-1; z >= 0 && number_to_destroy > 0 && number_of_mercenaries > 0; z--) {
		          if (this.game.spaces[spacekey].units[faction][z].reformer != true) {
			    if (this.game.spaces[spacekey].units[faction][z].type == "mercenary" || this.game.spaces[spacekey].units[faction][z].type == "cavalry") {
			      number_to_destroy--;
			      number_of_mercenaries--;
			      this.game.spaces[spacekey].units[faction].splice(z, 1);
			      unitlen--;
			    }
			  }
			}

			//
			// remove regulars next
			//
			for (let z = unitlen-1; z >= 0 && number_to_destroy > 0 && number_of_regulars > 0; z--) {
		          if (this.game.spaces[spacekey].units[faction][z].reformer != true) {
			    if (this.game.spaces[spacekey].units[faction][z].type == "regular") {
			      number_to_destroy--;
			      number_of_regulars--;
			      this.game.spaces[spacekey].units[faction].splice(z, 1);
			      unitlen--;
			    }
			  }
			}

			//
			// military leaders last
			//
			for (let z = 0; z < this.game.spaces[spacekey].units[faction].length; z++) {
		          if (this.game.spaces[spacekey].units[faction][z].army_leader == true || this.game.spaces[spacekey].units[faction][z].navy_leader == true) {
			    let leader = this.game.spaces[spacekey].units[faction][z];
			    this.game.spaces[spacekey].units[faction].splice(z, 1);
			    z--;
			    unitlen--;

    			    let obj = {};
			    obj.leader = leader;
        		    obj.space = capitals[0];
        		    obj.faction = faction;
      			    this.game.state.military_leaders_removed_until_next_round.push(obj);

			  }
			}

                        for (let z = 0, y = 0; z < this.game.spaces[spacekey].units[faction].length && z < unitlen; z++) {
                          if (capitals[y]) {
                            if (this.game.spaces[spacekey].units[faction][z].reformer != true && this.game.spaces[spacekey].units[faction][z].type != "squadron" && this.game.spaces[spacekey].units[faction][z].type != "corsair") {
                              this.game.spaces[capitals[y]].units[faction].push(this.game.spaces[spacekey].units[faction][z]);
                              this.game.spaces[spacekey].units[faction].splice(z, 1);
                              z--;
                              // we have moved one guy...
                              fluis--; fluis_idx--;
                            }
                          }
			  y++;
			  if (!capitals[y]) { y = 0; }
			  unitlen = this.game.spaces[spacekey].units[faction].length;
			}
		      }

		    //
		    // res.length > 0, so there are nearby fortified spaces
		    //
		    } else {

		      //
		      // only one destination, so auto-move!
		      //
		      // OR unallied minor power who handle themselves!
		      //
		      if (res.length == 1 || (this.isMinorPower(faction) && this.returnControllingPower(faction) == faction)) {

		        //
		        // how much space do we have?
		        //
		        let options = [];
		        for (let b = 0; b < res.length; b++) {
		          let unit_limit = 4;
		          if (res[b].key == "paris" || res[b].key == "valladolid" || res[b].key == "london" || res[b].key == "vienna" || res[b].key == "istanbul" || res[b].key == "rome") { unit_limit = 1000; } else {
		  	    unit_limit = 4;
			  }
			  options.push(unit_limit - this.returnFactionLandUnitsInSpace(faction, res[b].key, true));
		        }

		        //
		        // fill those spaces
		        //
		        for (let b = 0; b < res.length; b++) {
		  	  for (let zz = 0; zz < options[b]; zz++) {
			    let unitlen = this.game.spaces[spacekey].units[faction].length;
		            for (let zzz = 0, zzy = 0; zzz < unitlen; zzz++, zzy++) {
		              if (this.game.spaces[spacekey].units[faction][zzy].type != "squadron" && this.game.spaces[spacekey].units[faction][zzy].type != "corsair" && this.game.spaces[spacekey].units[faction][zzy].navy_leader != true) {
		                if (this.game.spaces[spacekey].units[faction][zzy].reformer != true) {
			          this.game.spaces[res[b].key].units[faction].push(this.game.spaces[spacekey].units[faction][zzy]);
			          this.game.spaces[spacekey].units[faction].splice(zzy, 1);
			          zzy--;
			          // we have moved one guy...
			          fluis--; fluis_idx--;

			          //
			          // and show new unit!
			          //
			          this.displaySpace(res[b].key);

			        }
			      }
			      unitlen = this.game.spaces[spacekey].units[faction].length;
			    }
			  }
			} 
		      } else {

			//
			// because there are multiple destinations, we fall back to asking the player
			//

		      }
		    }
		  } // fluis_idx loop

		  //
		  // if the space is besieged undo that, and un-besiege defenders
		  //
		  if (space.besieged > 0) {
		    this.removeSiege(space.key);
		  }

		  this.displaySpace(spacekey);

		} // if we need to retreat
	      } // if there are units here
	    } // loop faction
	  } // loop spacekey

	  //
	  // prevents in-memory differences in processing resulting in a different
	  // queue order, resulting in divergent game processing.
	  //
	  moves.sort();
	  for (let i = 0; i < moves.length; i++) {
	    this.game.queue.push(moves[i]);
	  }

          //
          // fortified spaces - any units in excess of stacking limit returned to capital
          //
	  //this.returnOverstackedUnitsToCapitals();

	  return 1;
        }



        if (mv[0] === "decide_if_mary_i_subverts_protestantism_in_6P") {

	  this.game.queue.splice(qe, 1);
	  let card = mv[1];

	  //
	  // no protestant spaces, no messing around with Mary
	  //
	  let english_home_spaces = ["norwich", "london", "portsmouth", "plymouth", "bristol", "wales", "shrewsbury", "lincoln", "york", "carlisle", "berwick"];
	  let any_spaces_protestant = false;
	  for (let i = 0; i < english_home_spaces.length; i++) {
	    if (this.game.spaces[english_home_spaces[i]]) {
	      if (this.game.spaces[english_home_spaces[i]].religion == "protestant") { any_spaces_protestant = true; }
	    }
	  }

	  if (any_spaces_protestant == false) {
	    this.game.queue.push("NOTIFY\t"+this.popup("021") + ": no Catholic home spaces in England");
	    return 1;
	  }

          let x = this.rollDice(6);
          if (x >= 4) {
            this.game.queue.push("mary_i_subverts_protestantism\t"+card+"\t"+x);
            this.game.queue.push("NOTIFY\t"+this.popup("021") + ": Mary I acts against Protestantism");
          }
          this.game.queue.push("NOTIFY\t"+this.popup("021") + ": Mary I rolls " + x);
	  return 1;

	}

        if (mv[0] === "decide_if_mary_i_subverts_protestantism_in_2P") {

	  this.game.queue.splice(qe, 1);

	  //
	  // no protestant spaces, no messing around with Mary
	  //
	  let english_home_spaces = ["norwich", "london", "portsmouth", "plymouth", "bristol", "wales", "shrewsbury", "lincoln", "york", "carlisle", "berwick"];
	  let any_spaces_protestant = false;
	  for (let i = 0; i < english_home_spaces.length; i++) {
	    if (this.game.spaces[english_home_spaces[i]]) {
	      if (this.game.spaces[english_home_spaces[i]].religion == "protestant") { any_spaces_protestant = true; }
	    }
	  }

	  let p = this.returnPlayerOfFaction("papacy");
	  let fhand_idx = 0; // faction hand/pool is necessarily 0 in 2P

	  if (any_spaces_protestant == true) {
	    this.game.queue.push("process_mary_i_subverts_protestantism_in_2P");
            this.game.queue.push("hand_to_fhand\t1\t"+p+"\t"+"papacy"+"\t1"); // 1 = show overlay
            this.game.queue.push("DEAL\t1\t"+p+"\t"+1);
	  } else {
	    this.game.queue.push("NOTIFY\t"+this.popup("021") + ": no Catholic spaces in England");
	  }

	  return 1;
	}

        if (mv[0] === "process_mary_i_subverts_protestantism_in_2P") {

	  this.game.queue.splice(qe, 1);

	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.game.player == player) {

	    let card_pulled = this.game.deck[0].fhand[0][this.game.deck[0].fhand.length-1];
	    let ops_pulled = this.game.deck[0].cards[card_pulled].ops;

	    if (ops_pulled == 1 || ops_pulled == 2) {
	      this.addMove("mary_i_burn_books");
	    }

	    if (ops_pulled == 3 || ops_pulled == 4) {
	      this.addMove("mary_i_theological_debate");
	    }

	    if (ops_pulled == 5 || ops_pulled == 6) {
	      this.addMove("mary_i_burn_books");
	      this.addMove("mary_i_theological_debate");
	    }

	    this.addMove("ACKNOWLEDGE\tMary I pulls "+this.popup(card_pulled) + "("+this.game.deck[0].cards[card_pulled].ops+" ops)");

	    this.endTurn();
	  }

	  return 0;
	}

	if (mv[0] === "mary_i_burn_books") {

	  this.game.queue.splice(qe, 1);

          //
          // no protestant spaces, no messing around with Mary
          //
          let english_home_spaces = ["norwich", "london", "portsmouth", "plymouth", "bristol", "wales", "shrewsbury", "lincoln", "york", "carlisle", "berwick"];
          let any_spaces_protestant = false;
          for (let i = 0; i < english_home_spaces.length; i++) {
            if (this.game.spaces[english_home_spaces[i]]) {
              if (this.game.spaces[english_home_spaces[i]].religion == "protestant") { any_spaces_protestant = true; }
            }
          }

          if (any_spaces_protestant == false) {
            this.game.queue.push("NOTIFY\t"+this.popup("021") + ": skipping Burn Books as no Catholic English home spaces");
            return 1;
          }
          
	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.canPlayerBurnBooksMaryI(this, player, "papacy")) {
	    if (this.game.player == player) {
	      this.playerBurnBooksMaryI(this, player, "papacy");
	    }
	    return 0;
	  }

	  return 1;

	}

	if (mv[0] === "mary_i_theological_debate") {

	  this.game.queue.splice(qe, 1);

	  // thomas more's execution prevents theological debates
          if (this.game.state.events.more_executed_limits_debates == 1) { return 1; }

          //
          // no protestant spaces, no messing around with Mary
          //
          let english_home_spaces = ["norwich", "london", "portsmouth", "plymouth", "bristol", "wales", "shrewsbury", "lincoln", "york", "carlisle", "berwick"];
          let any_spaces_protestant = false;
          for (let i = 0; i < english_home_spaces.length; i++) {
            if (this.game.spaces[english_home_spaces[i]]) {
              if (this.game.spaces[english_home_spaces[i]].religion == "protestant") { any_spaces_protestant = true; }
            }
          }

          if (any_spaces_protestant == false) {
            this.game.queue.push("NOTIFY\t"+this.popup("021") + ": skipping Burn Books as no Catholic English home spaces");
            return 1;
          }

	  let player = this.returnPlayerOfFaction("papacy");
	  if (this.canPlayerCallTheologicalDebateMaryI(this, player, "papacy")) {
	    if (this.game.player == player) {
	      this.playerCallTheologicalDebateMaryI(this, player, "papacy");
	    }
	    return 0;
	  }

	  return 1;
	}


        if (mv[0] === "mary_i_subverts_protestantism") {

	  this.game.queue.splice(qe, 1);
	  let card = mv[1];
	  let roll = mv[2];
	  let player = this.returnPlayerCommandingFaction("papacy");

	  let deck = this.returnDeck(true);

	  let ops_pulled = deck[card].ops;

          if (ops_pulled == 1 || ops_pulled == 2) {
            this.game.queue.push("mary_i_burn_books");
          }

          if (ops_pulled == 3 || ops_pulled == 4) {
            this.game.queue.push("mary_i_theological_debate");
          }

          if (ops_pulled == 5 || ops_pulled == 6) {
            this.game.queue.push("mary_i_burn_books");
            this.game.queue.push("mary_i_theological_debate");
          }

	  return 1;

	}


	if (mv[0] === "retreat_to_winter_spaces_player_select") {

	  this.game.queue.splice(qe, 1);

	  //
	  // make sure up-to-date
	  //
	  this.displayBoard();

	  let x = this.returnPlayerOfFaction(mv[1]);

	  if (this.game.player === x) {
	    this.winter_overlay.hide();
	    this.playerResolveWinterRetreat(mv[1], mv[2]);
	    return 0;
	  } else {
	    this.winter_overlay.render();
	    this.updateStatus(this.returnFactionName(mv[1]) + " handling winter retreat from " + this.returnSpaceName(mv[2]));
	    if (x > 0) { return 0; }
	  }

	  //
	  // non-player controlled factions skip winter retreat
	  //
	  return 1;

        }

        if (mv[0] === "protestants-place-maurice-of-saxony-round-six") {

	  this.game.queue.splice(qe, 1);

	  let player = this.returnPlayerOfFaction("protestant");

	  if (this.game.player === player) {

            if (0 == his_self.playerSelectSpaceWithFilter(

              "Select Protestant Electorate for Maurice of Saxony (army leader)",

              function(space) {
                if (space.type == "electorate" && space.political == "protestant") { return 1; }
  	        return 0;
              },

              function(spacekey) {
		his_self.updateStatus("Maurice of Saxony enters play...");
		his_self.addMove("SETVAR\tgame\tstate\tevents\tmaurice_of_saxony\tprotestant");
                his_self.addMove("add_army_leader\tprotestant\t"+spacekey+"\tmaurice-of-saxony");
                his_self.endTurn();
              },

	      null,

	      true

            )) {
	      his_self.addMove("NOTIFY\tNo valid electorates for Maurice of Saxony to enter - skipping");
	      his_self.endTurn();
	    };

	  } else {
	    this.updateStatus("Protestants placing Maurice of Saxony");
	  }

	  return 0;

	}

	if (mv[0] === "retreat_to_winter_spaces_resolve") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let from = mv[2];
	  let to = mv[3];

          for (let i = this.game.spaces[from].units[faction].length-1; i >= 0; i--) {
	    this.game.spaces[to].units[faction].push(this.game.spaces[from].units[faction][i]);
	    this.game.spaces[from].units[faction].splice(i, 1);
	  }

	  this.displaySpace(from);
	  this.displaySpace(to);

	  return 1;

        }




	if (mv[0] === "retreat_to_winter_ports") {

	  let moves = [];

	  //
	  // make sure board up-to-date
	  //
	  this.displayBoard();

	  this.winter_overlay.render("stage3");
	  this.game.queue.splice(qe, 1);

	  for (let i in this.game.navalspaces) {
	    for (let key in this.game.navalspaces[i].units) {
	      if (this.game.navalspaces[i].units[key].length > 0) {
	        let faction = key;
	        let space = this.game.navalspaces[i];
		let res = this.returnNearestFactionControlledPorts(faction, space);
		if (res.length == 1) {
      	          moves.push("move\t"+faction+"\tport\t"+i+"\t"+res[0].key);
		} else {
		  moves.push("retreat_to_winter_ports_player_select\t"+key+"\t"+space.key+"\t"+JSON.stringify(res));
		}
	      }
	    }
	  }

	  //
	  // prevents in-memory differences in processing resulting in a different
	  // queue order, resulting in divergent game processing.
	  //
	  moves.sort();
	  for (let i = 0; i < moves.length; i++) {
	    this.game.queue.push(moves[i]);
	  }

	  //
	  // anything left gets swept
	  //
	  this.returnOverstackedUnitsToCapitals();

	  return 1;
        }


	if (mv[0] === "retreat_to_winter_ports_player_select") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let navalspace = mv[2];
	  let ports = JSON.parse(mv[3]);
	  let x = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player === x) {
	    this.winter_overlay.hide();
	    this.playerResolveNavalWinterRetreat(faction, navalspace);
	  } else {
	    this.winter_overlay.render();
	    this.updateStatus(this.returnFactionName(mv[1]) + " winter port retreat from " + this.returnSpaceName(mv[2]));
	  }

	  return 0;

        }


	if (mv[0] === "retreat_to_winter_ports_resolve") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let from = mv[2];
	  let to = mv[3];

          for (let i = this.game.navalspaces[from].units[faction].length-1; i >= 0; i--) {
	    this.game.spaces[to].units[faction].push(this.game.navalspaces[from].units[faction][i]);
	    this.game.navalspaces[from].units[faction].splice(i, 1);
	  }

	  this.displayNavalSpace(from);
	  this.displaySpace(to);

	  return 1;

        }

	if (mv[0] === "add_army_leader") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let type = mv[3];

	  //
	  // remove if exists elsewhere
	  //
          let eak = his_self.returnSpaceOfPersonage(faction, type);
          let eak_idx = his_self.returnIndexOfPersonageInSpace(faction, type, eak);
	  if (eak != "") { this.game.spaces[spacekey].units[faction].splice(eak_idx, 1); }

	  this.addArmyLeader(faction, spacekey, type);
	  this.displaySpace(spacekey);

    	  this.game.queue.splice(qe, 1);

	  return 1;
	}




	if (mv[0] === "place_mercenaries") {

    	  this.game.queue.splice(qe, 1);

	  let faction_giving = mv[1];
	  let faction_placing = mv[2];
	  let num = parseInt(mv[3]);

	  if (faction_placing === "france") {
	    if (this.returnControlledCapitals("france").length > 0) {
	      this.addMercenary("france", "paris", num);
	    }
	    return 1;
	  }

	  if (faction_placing === "england") {
	    if (this.returnControlledCapitals("england").length > 0) {
	      this.addMercenary("england", "london", num);
	    }
	    return 1;
	  }

	  if (faction_placing === "hapsburg") {

	    if (this.returnControlledCapitals("hapsburg").length == 1) {
	      this.addMercenary("hapsburg", this.returnControlledCapitals("hapsburg")[0], num);
	      return 1;
	    }

	    if (this.game.player == this.returnPlayerOfFaction(faction_placing)) {

              let msg = "Hapsburg - Select Capital for Mercenaries";
              let html = '<ul>';
              html += `<li class="option" id="vienna">Vienna</li>`;
              html += `<li class="option" id="valladolid">Valladolid</li>`;
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let action2 = $(this).attr("id");

                his_self.updateStatus("acknowledge...");
		for (let z = 0; z < num; z++) {
	          his_self.addMove("build\tland\thapsburg\tmercenary\t"+action2);
		}
		his_self.endTurn();

  	      });
	    }

	    return 0;
	  }


	  if (faction_placing === "protestant") {

	    let es = this.returnProtestantElectorates();

	    if (es.length == 1) {
	      this.addMercenary("protestant", es[0], num);
	      return 1;
	    }

	    if (this.game.player == this.returnPlayerOfFaction(faction_placing)) {

              let msg = "Protestant - Select Electorate for Mercenaries";
              let html = '<ul>';
	      for (let i = 0; i < es.length; i++) {
                html += `<li class="option" id="${es[i]}">${this.returnSpaceName(es[i])}</li>`;
	      }
              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);
              $('.option').off();
              $('.option').on('click', function () {

                $('.option').off();
                let action2 = $(this).attr("id");

                his_self.updateStatus("acknowledge...");
		for (let z = 0; z < num; z++) {
	          his_self.addMove("build\tland\tprotestant\tmercenary\t"+action2);
		}
		his_self.endTurn();

  	      });
	    }

	    return 0;
	  }

	}

	if (mv[0] === "loan_squadron") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let source_spacekey = mv[2];
	  let faction_placing = mv[3];
	  let destination_spacekey = mv[4];

	  this.removeUnit(faction_giving, source_spacekey, "squadron");
	  this.addNavalSquadron(faction_placing, destination_spacekey, 1);
	  let s = his_self.game.spaces[destination_spacekey];
	  let u = s.units[faction_placing][s.units[faction_placing].length-1];
	  u.owner = faction_giving;

	  this.displaySpace(source_spacekey);
	  this.displaySpace(destination_spacekey);

	  return 1;

	}

	if (mv[0] === "give_squadron") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let faction_placing = mv[2];
	  let num = 1;
	  if (mv[3]) { num = parseInt(mv[3]); }

	  let instructions = [];

	  if (this.game.player != this.returnPlayerOfFaction(faction_giving)) {
	    this.updateStatus(this.returnFactionName(faction_giving) + " selecting squadron to give");
	    return 0;
	  }

	  this.winter_overlay.hide();
	  let filter_find_spaces_with_squadrons = function(space) {
	    let s = his_self.game.spaces[space.key];
	    for (let i = 0; i < s.units[faction_giving].length; i++) {
	      let u = s.units[faction_giving][i];
	      if (u.type == "squadron") { return 1; }
	    }
	    return 0;
	  }
	  let command_function_on_picking_a_space = function(source_spacekey) {

	    his_self.playerSelectSpaceWithFilter(
	      "Select Closest Valid Destination for Squadron",
	      (space) => {
	        if (space.ports.length > 0) {
		  if (his_self.isSpaceControlled(space.key, faction_placing)) {
		    return 1;
		  }
		}
		return 0;
	      },
	      (destination_spacekey) => {
		his_self.addMove("loan_squadron\t"+faction_giving+"\t"+source_spacekey+"\t"+faction_placing+"\t"+destination_spacekey);
	        his_self.winter_overlay.render();
		his_self.endTurn();
	      },
	      null,
	      true,
	    );
	  }

	  for (let z = 0; z < num; z++) {
	    await this.playerSelectSpaceWithFilter(
              "Select Squadron to Loan", 
	      filter_find_spaces_with_squadrons,
	      command_function_on_picking_a_space,
	      null,
	      true
	    );
	  }

	  return 0;

	}

	if (mv[0] === "give_mercenaries") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction_giving = mv[1];
	  let faction_placing = mv[2];
	  let num = parseInt(mv[3]);

	  let instructions = [];

	  if (this.game.player != this.returnPlayerOfFaction(faction_giving)) {
	    this.updateStatus(this.returnFactionName(faction_giving) + " selecting mercenaries to give");
	    return 0;
	  }

	  this.winter_overlay.hide();
	  let filter_find_spaces_with_mercenaries = function(space) {
	    let s = space;
	    try { if (his_self.game.spaces[space]) { s = his_self.game.spaces[space]; } } catch (err) {}
	    for (let i = 0; i < s.units[faction_giving].length; i++) {
	      let u = s.units[faction_giving][i];
	      if (u.type == "mercenary") { return 1; }
	    }
	    return 0;
	  }
	  let command_function_on_picking_a_space = function(spacekey) {
	    his_self.removeUnit(faction_giving, spacekey, "mercenary");
	    instructions.push("remove_unit\tland\t"+faction_giving+"\tmercenary\t"+spacekey+"\t"+his_self.game.player);
	  }

	  for (let z = 0; z < num; z++) {
	    await this.playerSelectSpaceWithFilter(

              "Select Mercenary to Remove", 

	      filter_find_spaces_with_mercenaries,

	      command_function_on_picking_a_space,

	      null,

	      true
	    );
	  }

	  for (let z = instructions.length-1; z > 0; z--) {
	    this.addMove(instructions[z]);
	  }
	  this.endTurn();
	  this.winter_overlay.render();
	  return 0;

	}

	if (mv[0] === "add_navy_leader") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let type = mv[3];

	  //
	  // remove if exists elsewhere
	  //
          let eak = his_self.returnSpaceOfPersonage(faction, type);
          let eak_idx = his_self.returnIndexOfPersonageInSpace(faction, type, eak);
	  if (eak != "") { this.game.spaces[spacekey].units[faction].splice(eak_idx, 1); }

	  this.addNavyLeader(faction, spacekey, type);

    	  this.game.queue.splice(qe, 1);
	  return 1;
	}

	if (mv[0] === "remove_conquest") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.conquests.length; i++) {
	    if (this.game.state.round == this.game.state.conquests[i].round && this.game.state.conquests[i].faction == faction) {
	      this.game.state.conquests.splice(i, 1);
	    }
	  }
    	  this.game.queue.splice(qe, 1);
	  this.displayNewWorld();
	  return 1;
	}
	if (mv[0] === "remove_exploration") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.explorations.length; i++) {
	    if (this.game.state.round == this.game.state.explorations[i].round && this.game.state.explorations[i].faction == faction) {
	      this.game.state.explorations.splice(i, 1);
	    }
	  }
	  this.displayNewWorld();
    	  this.game.queue.splice(qe, 1);
	  return 1;
	}
	if (mv[0] === "remove_colony") {
	  let faction = mv[1];
	  for (let i = 0; i < this.game.state.colonies.length; i++) {
	    if (this.game.state.round == this.game.state.colonies[i].round && this.game.state.colonies[i].faction == faction) {
	      this.game.state.colonies.splice(i, 1);
	    }
	  }
	  this.displayNewWorld();
    	  this.game.queue.splice(qe, 1);
	  return 1;
	}
	if (mv[0] === "colonize") {
    	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  this.game.state.colonies.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  let msg = this.returnFactionName(faction) + " founds a colony";
	  this.updateLog(msg);
	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tcolonize\t"+msg);
	  } else {
	    this.displayHudPopup("colonize",msg); // true = as hud popup
	  }
          this.game.state.may_colonize[faction] = 0;
	  this.displayColony();
	  return 1;
	}
	if (mv[0] === "explore") {
	  let faction = mv[1];
    	  this.game.queue.splice(qe, 1);
	  this.game.state.explorations.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  let msg = this.returnFactionName(faction) + " launches an expedition";
	  this.updateLog(msg);
	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\texplore\t"+msg);
          } else {
	    this.displayHudPopup("explore",msg); // true = as hud popup
	  }
	  this.game.state.may_explore[faction] = 0;
	  this.displayExploration();
	  return 1;
	}
        if (mv[0] === "award_exploration_bonus") {

	  this.updateStatus("Determining New World Bonus...");

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let explorer = mv[2];
	  let idx = parseInt(mv[3]);
	  let results_idx = idx;
	  let bonus = mv[4];

	  if (bonus === 'stlawrence') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "St. Lawrence";
	    let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the St. Lawrence (1VP)";
	    this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tstlawrence\t"+msg);
}
	  }
	  if (bonus === 'greatlakes') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Great Lakes";
	    let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Great Lakes (1VP)";
	    this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tgreatlakes\t"+msg);
}
	  }
	  if (bonus === 'mississippi') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 0;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Mississippi";
	    let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Mississippi (1VP)";
	    this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tmississippi\t"+msg);
}
	  }
	  if (bonus === 'pacificstrait') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 1;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Pacific Strait";
	    let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Pacific Strait (2VP)";
	    this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tpacificstrait\t"+msg);
}
	  }
	  if (bonus === 'amazon') {
	    this.game.state.explorations[idx].resolved = 1;
	    this.game.state.explorations[idx].explorer_lost = 1;
	    this.game.state.newworld[bonus].faction = faction;
	    this.game.state.newworld[bonus].claimed = 1;
	    this.game.state.explorations[idx].prize = "Amazon";
	    let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Amazon (2VP)";
	    this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tamazon\t"+msg);
}
	  }
	  if (bonus === 'circumnavigation') {

	    //
	    // circumnavigation attempt requires another roll here to claim
	    //
	    let base_x = this.rollDice(6) + this.rollDice(6);
	    let x = base_x + this.game.state.explorations[results_idx].modifiers;

	    this.updateLog("Circumnavigation Roll: " + x + " (" + base_x + "+" + this.game.state.explorations[idx].modifiers +")");

	    let second_explorer_img = "";
	    if (explorer != "Cabot") { second_explorer_img = this.explorers[explorer].img; }
	    else {
      	      second_explorer_img = "/his/img/tiles/explorers/Cabot_English.svg";
      	      if (faction == "france") { second_explorer_img = "/his/img/tiles/explorers/Cabot_French.svg"; }
      	      if (faction == "hapsburg") { second_explorer_img = "/his/img/tiles/explorers/Cabot_Hapsburg.svg"; }
	    }

	    if (x > 9) {

	      //
	      // if follow-on attempt from Pacific Strait, add new exploration
	      //
	      if (this.game.state.explorations[idx].prize == "Pacific Strait") {
	        this.game.state.explorations.push({
	          faction : faction,
	          resolved :  0 ,
	          round :   this.game.state.round,
		  base_roll : base_x ,
		  modified_roll : x ,
		  explorer : explorer ,
		  explorer_img : second_explorer_img ,
		  base : base_x ,
		  total_hits : x ,
		  modifiers : this.game.state.explorations[idx].modifiers ,
		  prize : "-" , 
	        });
		idx = this.game.state.explorations.length-1;
	      }

	      this.updateLog("Circumnavigation Attempt succeeds: " + x + " rolled");
	      this.game.state.explorations[idx].resolved = 1;
	      this.game.state.explorations[idx].explorer_lost = 1;
	      this.game.state.newworld[bonus].faction = faction;
	      this.game.state.newworld[bonus].claimed = 1;
	      this.game.state.explorations[idx].prize = "Circumnavigation";
	      let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " circumnavigates the globe...";
	      this.updateLog(msg);
	      this.game.queue.push("ACKNOWLEDGE\t"+msg);
	      this.game.queue.push("display_custom_overlay\tcircumnavigation\t"+msg);

	    } else {

	      //
	      // if follow-on attempt from Pacific Strait, add new exploration
	      //
	      if (this.game.state.explorations[idx].prize == "Pacific Strait") {
	        this.game.state.explorations.push({
	          faction : faction,
	          resolved :  0 ,
	          round :   this.game.state.round,
		  base_roll: base_x ,
		  modified_roll: x ,
		  explorer : explorer ,
		  explorer_img : second_explorer_img ,
		  base: base_x ,
		  total_hits : base_x + this.game.state.explorations[idx].modifiers ,
		  modifiers : this.game.state.explorations[idx].modifiers ,
		  prize : "" ,
	        });
	        idx = this.game.state.explorations.length-1;
	      }

	      this.game.state.explorations[idx].resolved = 1;
	      this.game.state.explorations[idx].explorer_lost = 1;
	      if (explorer == "Cabot") {
		this.game.state.cabot_dead = 1;
		this.removeCardFromGame("099");
	      }
	      this.game.state.explorations[idx].prize = "lost at sea";
	      let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " lost at sea...";
	      this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	      this.game.queue.push("ACKNOWLEDGE\t"+msg);
	      this.game.queue.push("display_custom_overlay\tlost-at-sea\t"+msg);
}
	    }
	  }

	  this.displayVictoryTrack();
	  this.displayNewWorld();

	  return 1;
	}

	if (mv[0] === "resolve_new_world_riches_rolls") {

	  this.updateStatus("Resolving New World Riches...");

	  //
	  // show overlay
	  //
	  this.winter_overlay.render("stage1");

	  this.updateLog("************************");
	  this.updateLog("*** New World Riches ***");
	  this.updateLog("************************");

	  // reset expected bonuses
	  this.game.state.new_world_bonus = {};
	  this.game.state.new_world_bonus['england'] = 0;
	  this.game.state.new_world_bonus['france'] = 0;
	  this.game.state.new_world_bonus['hapsburg'] = 0;
	  this.game.state.new_world_bonus['protestant'] = 0;
	  this.game.state.new_world_bonus['ottoman'] = 0;
	  this.game.state.new_world_bonus['papacy'] = 0;
	

	  //////////////
	  // COLONIES //
	  //////////////
	  for (let z = 0; z < this.game.state.colonies.length; z++) {

	    let c = this.game.state.colonies[z];
	    if (!c.destroyed) {

	      let x = this.rollDice(6) + this.rollDice(6);

	      c.base_roll = x;

	      if (this.game.state.plantations[c.faction] == 1) { x++; }
	      if (c.name === "Potosi Silver Mines") { x++; }

	      // modify rolls first so colonial governor
	      if (x >= 8) { 
	        if (this.game.state.galleons[c.faction] == 1) { x++; }
	      }
	      if (x > 4 && x < 9 && c.faction == this.game.state.events.native_uprising) {
	        x = 2;
	        this.updateLog(this.returnFactionName(this.game.state.events.native_uprising) + " hurt by Native Uprising");
	        this.game.state.events.native_uprising = "";
	      }
	      if (x > 4 && x < 9 && c.faction == this.game.state.events.colonial_governor) {
	        x = 10;
	        this.updateLog(this.returnFactionName(this.game.state.events.colonial_governor) + " helped by Colonial Governor");
	        this.game.state.events.colonial_governor = "";
	      }
	      if (x <= 4) { 
	        c.prize = "destroyed";
	        c.round_destroyed = this.game.state.round;
	        c.destroyed = 1; 
	        this.game.state.newworld[c.colony].claimed = 0; 
	        this.updateLog(`${this.returnFactionName(c.faction)} - Colony Fails`);
	        if (this.game.player == this.returnPlayerCommandingFaction(c.faction)) {
	          let msg = this.returnFactionName(c.faction) + " colony fails...";
	          this.updateLog(msg);
	          this.game.queue.push("ACKNOWLEDGE\t"+msg);
	          this.game.queue.push("display_custom_overlay\tdeserted\t"+msg);
	        }
	      }

	      if (x >= 9) { 
	        c.prize = "bonus card";
	        this.game.state.new_world_bonus[c.faction]++;
		this.updateLog(this.returnFactionName(c.faction) + " colony earns bonus card...");
	      }

	      c.modified_roll = x;

	    }
	  }


	  ///////////////
	  // CONQUESTS //
	  ///////////////
	  for (let i = 0; i < this.game.state.conquests.length; i++) {
	    let c = this.game.state.conquests[i];
	    if (!c.prize) { c.prize = ""; }
	    if (c.prize.indexOf("Maya") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 6) {
	        // player pulls card as conquest depleted
		this.game.state.new_world_bonus[c.faction]++;
		c.depleted = 1;
	        this.updateLog(`${this.returnFactionName(c.faction)} - Mayan Empire is Depleted`);
	        if (this.game.player == this.returnPlayerCommandingFaction(c.faction)) {
	          let msg = this.returnFactionName(c.faction) + " - Mayan Empire is Depleted";
	          this.updateLog(msg);
	          this.game.queue.push("ACKNOWLEDGE\t"+msg);
	          this.game.queue.push("display_custom_overlay\tdepleted\t"+msg);
	        }
	      }
	      if ((x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
		this.updateLog(this.returnFactionName(c.faction) + " - Maya conquest earns bonus card...");
	      }
	    }

	    if (c.prize.indexOf("Aztec") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 5) {
		c.depleted = 1;
	        this.updateLog(`${this.returnFactionName(c.faction)} - Aztec Empire is Depleted`);
	        if (this.game.player == this.returnPlayerCommandingFaction(c.faction)) {
	          let msg = this.returnFactionName(c.faction) + " - Aztec Empire is Depleted";
	          this.updateLog(msg);
	          this.game.queue.push("ACKNOWLEDGE\t"+msg);
	          this.game.queue.push("display_custom_overlay\tdepleted\t"+msg);
	        }
	      }
	      if ((x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
		this.updateLog(this.returnFactionName(c.faction) + " - Aztec conquest earns bonus card...");
	      }
	    }

	    if (c.prize.indexOf("Inca") > -1 && c.depleted != 1) {
	      let x = this.rollDice(6) + this.rollDice(6);
	      c.bonus_base_roll = x;
	      if (x <= 5) {
		c.depleted = 1;
	        this.updateLog(`${this.returnFactionName(c.faction)} - Incan Empire is Depleted`);
	        if (this.game.player == this.returnPlayerCommandingFaction(c.faction)) {
	          let msg = this.returnFactionName(c.faction) + " - Incan Empire is Depleted";
	          this.updateLog(msg);
	          this.game.queue.push("ACKNOWLEDGE\t"+msg);
	          this.game.queue.push("display_custom_overlay\tdepleted\t"+msg);
	        }
	      }
	      if (x == 6 || (x == 7 && this.game.state.galleons[c.faction] == 1) || x > 7) {
		this.game.state.new_world_bonus[c.faction]++;
		c.bonus_prize = "bonus card";
		this.updateLog(this.returnFactionName(c.faction) + " - Inca conquest earns bonus card...");
	      }
	    }

	  }

	  //
	  // huguenaut raiders
	  //
	  for (let i = 0; i < this.game.state.new_world_bonus["hapsburg"]; i++) {
	    let stolen = 0;
	    if (parseInt(his_self.game.state.raiders['france']) == 1) {
	      let x = his_self.rollDice(6);
	      his_self.updateLog("French Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("French Raiders eliminated");	
		his_self.game.state.raiders['france'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("French Raiders eliminated");	
		his_self.game.state.raiders['france'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("French Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("French Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['france'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['france']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("French Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['france']++;
		stolen = 1;
	      }
	    }
	    if (stolen == 0 && parseInt(his_self.game.state.raiders['england']) == 1) {
	      let x = his_self.rollDice(6);
	      his_self.updateLog("English Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("English Raiders eliminated");	
		his_self.game.state.raiders['england'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("English Raiders eliminated");	
		his_self.game.state.raiders['england'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("English Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("English Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['england'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['england']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("English Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['england']++;
		stolen = 1;
	      }
	    }
	    if (stolen == 0 && parseInt(his_self.game.state.raiders['protestant']) == 1) {
	      let x = his_self.rollDice(6);
	      his_self.updateLog("Protestant Raiders roll " + x);	
	      if (x == 1) {
	        his_self.updateLog("Protestant Raiders eliminated");	
		his_self.game.state.raiders['protestant'] = 0;
	      }
	      if (x == 2 && his_self.game.state.galleons['hapsburg'] == 1) {
	        his_self.updateLog("Protestant Raiders eliminated");	
		his_self.game.state.raiders['protestant'] = 0;
	      }
	      if (x == 3 || x == 4) {
	        his_self.updateLog("Protestant Raiders unsuccessful");	
	      }
	      if (x == 5) {
	        his_self.updateLog("Protestant Raiders steal Hapsburg shipment");	
		his_self.game.state.raiders['protestant'] = 0;
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['protestant']++;
		stolen = 1;
	      }
	      if (x == 6) {
	        his_self.updateLog("Protestant Raiders steal Hapsburg shipment");	
		his_self.game.state.new_world_bonus['hapsburg']--;
		his_self.game.state.new_world_bonus['protestant']++;
		stolen = 1;
	      }
	    }
	  }

	  this.displayNewWorld();

	  this.newworld_overlay.render("results");
    	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "resolve_new_world_conquests") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Resolving New World Conquests...");
	  return this.resolveConquests();
        }
	if (mv[0] === "resolve_new_world_colonies") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Establishing New World Colonies...");
	  return this.resolveColonies();
        }
	if (mv[0] === "resolve_new_world_explorations") {
    	  this.game.queue.splice(qe, 1);
	  this.updateStatus("Resolving New World Exploration Attempts...");
	  return this.resolveExplorations();
        }

	if (mv[0] === "resolve_conquest") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let idx = parseInt(mv[1]);
	  let faction = this.game.state.conquests[idx].faction;
	  let conquistador = this.game.state.conquests[idx].conquistador;
	  let hits = this.game.state.conquests[idx].hits;
	  let unmodified_hits = hits;
	  this.game.state.conquests[idx].resolved = 1;

	  this.updateLog(this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " rolls " + unmodified_hits);

	  if (hits <= 6) {
	    if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	      this.displayCustomOverlay("killed", faction);
	      let msg = this.returnFactionName(faction) + " conquistador is killed";
	      this.game.queue.push("ACKNOWLEDGE\t"+msg);
	      this.game.queue.push("display_custom_overlay\tkilled\t"+msg);
	    }
	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " killed by natives");
	    this.game.state.conquests[idx].conquistador_lost = 1;
	    this.game.state.conquests[idx].prize = "killed";
	    this.game.state.conquests[idx].active = 0;
	  }
	  if (hits > 6 && hits <= 8) {
	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " makes no conquest");
	    this.game.state.conquests[idx].prize = "-";
	  }
	  if (hits >= 9) {
	    while (hits > 11) { hits--; }
	    if (hits >= 11) {
	      if (this.game.state.newworld['inca'].claimed != 1) {
	        this.game.state.newworld['inca'].claimed = 1;
	        this.game.state.newworld['inca'].faction = faction;
		this.game.state.conquests[idx].prize = "Incan Empire";
	        this.game.state.conquests[idx].active = 1;
	        let msg = this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " conquers the Inca (2VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\tinca\t"+msg);
}
	      } else {
		while (hits > 10) { hits--; }
	      }
	    }
	    if (hits == 10) {
	      if (this.game.state.newworld['aztec'].claimed != 1) {
	        this.game.state.newworld['aztec'].claimed = 1;
	        this.game.state.newworld['aztec'].faction = faction;
		this.game.state.conquests[idx].prize = "Aztec Empire";
	        this.game.state.conquests[idx].active = 1;
	        let msg = this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " conquers the Aztec (2VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\taztec\t"+msg);
}
	      } else { 
		while (hits >= 10) { hits--; }
	      }
	    }
	    if (hits == 9) {
	      if (this.game.state.newworld['maya'].claimed != 1) {
	        this.game.state.newworld['maya'].claimed = 1;
	        this.game.state.newworld['maya'].faction = faction;
		this.game.state.conquests[idx].prize = "Mayan Empire";
	        this.game.state.conquests[idx].active = 1;
	        let msg = this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " conquers the Maya (1VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\tmaya\t"+msg);
}
	      } else {
		this.game.state.conquests[idx].prize = "-";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnConquistadorName(conquistador) + " makes no conquest");
	      }
	    }
	  }

	  // conquests don't offer choice, so return for immediate execution
	  return 1;
        }


	if (mv[0] === "resolve_exploration") {

    	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let idx = parseInt(mv[1]);
	  let results_idx = 0;

	  let faction = this.game.state.explorations[idx].faction;
	  let explorer = this.game.state.explorations[idx].explorer;
	  let hits = this.game.state.explorations[idx].hits;
	  let prize = "";
	  this.game.state.explorations[idx].resolved = 1;

	  this.updateStatus("Resolving "+this.returnFactionName(faction) + " Exploration Attempt...");

	  if (hits <= 4) {

	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " lost at sea");
	    this.game.state.explorations[idx].prize = "lost at sea";
	    this.game.state.explorations[idx].explorer_lost = 1;

	    if (explorer == "Cabot") {
	      this.game.state.cabot_dead = 1;
	      this.removeCardFromGame("099");
	    }

	  }
	  if (hits > 4 && hits <= 6) {
	    this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	  }
	  if (hits > 6 && hits <= 9) {
	    if (hits == 9) {
	      if (this.game.state.newworld['mississippi'].claimed != 1) {
	        this.game.state.newworld['mississippi'].claimed = 1;
	        this.game.state.newworld['mississippi'].faction = faction;
	        this.game.state.explorations[idx].prize = "Mississippi";
	        let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Mississippi (1VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\tmississippi\t"+msg);
}
	      } else { 
		hits--;
	      }
	    }
	    if (hits == 8) {
	      if (this.game.state.newworld['greatlakes'].claimed != 1) {
	        this.game.state.newworld['greatlakes'].claimed = 1;
	        this.game.state.newworld['greatlakes'].faction = faction;
	        this.game.state.explorations[idx].prize = "Great Lakes";
	        let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the Great Lakes (1VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\tgreatlakes\t"+msg);
}
	      } else { 
		hits--;
	      }
	    }
	    if (hits == 7) { 
	      if (this.game.state.newworld['stlawrence'].claimed != 1) {
	        this.game.state.newworld['stlawrence'].claimed = 1;
	        this.game.state.newworld['stlawrence'].faction = faction;
	        this.game.state.explorations[idx].prize = "St. Lawrence";
	        let msg = this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " discovers the St. Lawrence (1VP)";
	        this.updateLog(msg);
if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	        this.game.queue.push("ACKNOWLEDGE\t"+msg);
	        this.game.queue.push("display_custom_overlay\tstlawrence\t"+msg);
}
	      } else {
	        this.game.state.explorations[idx].prize = "-";
	        this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	      }
	    }
	  }

	  if (hits >= 10) {

	    //
	    // nope out if nothing to claim
	    //
	    if (this.game.state.newworld['stlawrence'].claimed == 1 && this.game.state.newworld['greatlakes'].claimed == 1 && this.game.state.newworld['mississippi'].claimed == 1 && this.game.state.newworld['amazon'].claimed == 1 && this.game.state.newworld['circumnavigation'].claimed == 1) {
	      this.updateLog(this.returnFactionName(faction) + ": " + this.returnExplorerName(explorer) + " makes no discovery");
	      this.game.state.explorations[idx].prize = "-";
	      return 1;
	    }

	    //
	    // otherwise we give the successful faction a manual choice
	    //
	    if (this.game.player == this.returnPlayerCommandingFaction(faction)) {

	      let modifications = 0;
	      let explorer_power = 1;
	      let explorer_name = "Cabot";
              if (this.game.state.mercators_map == faction) { modifications+=2; }
	      let msg = `${this.returnFactionName(faction)} - Cabot [+${1+modifications} on roll]:`;
              if (this.game.state[`${faction}_uncharted`] && explorer_name != "Cabot") { modifications--; }
	
	      if (this.explorers[explorer]) {
		explorer_power = this.explorers[explorer].power;
		explorer_name = this.explorers[explorer].name;
	        msg = `${this.returnFactionName(faction)} - ${this.returnExplorerName(explorer)} [+${explorer_power + modifications} on roll]:`;
		if ((explorer_power+modifications) < 0) {
	          msg = `${this.returnFactionName(faction)} - ${this.returnExplorerName(explorer)} [${explorer_power + modifications} on roll]:`;
		}
	      }

	      let html = '<ul>';
	      if (this.game.state.newworld['stlawrence'].claimed != 1) {
		html += '<li class="option" id="stlawrence">St. Lawrence (1 VP)</li>';
	      }
	      if (this.game.state.newworld['greatlakes'].claimed != 1) {
		html += '<li class="option" id="greatlakes">The Great Lakes (1 VP)</li>';
	      }
	      if (this.game.state.newworld['mississippi'].claimed != 1) {
		html += '<li class="option" id="mississippi">The Mississippi (1 VP)</li>';
	      }
	      if (this.game.state.newworld['amazon'].claimed != 1) {
		html += '<li class="option" id="amazon">The Amazon (2VP, explorer retires)</li>';
	      }
	      if (this.game.state.newworld['circumnavigation'].claimed != 1) {
		let vp_at_stake = "3";
		if (this.game.state.newworld['pacificstrait'].claimed != 1) { vp_at_stake = "2-5"; }
		html += `<li class="option" id="circumnavigation">Attempt Circumnavigation (${vp_at_stake}VP, requires 12 and explorer retires)</li>`;
	      }

              his_self.updateStatusWithOptions(msg, html);
	      his_self.winter_overlay.pullHudOverOverlay();


              $('.option').off();
              $('.option').on('click', function () {
                $('.option').off();
                his_self.updateStatus("acknowledge...");
                let action = $(this).attr("id");

                his_self.addMove("award_exploration_bonus\t"+faction+"\t"+explorer+"\t"+idx+"\t"+action);
		if (action == 'circumnavigation' && his_self.game.state.newworld['pacificstrait'].claimed != 1) {
                  his_self.addMove("award_exploration_bonus\t"+faction+"\t"+explorer+"\t"+idx+"\t"+'pacificstrait');
		}

                his_self.endTurn();
              });

	    }
	  
	    return 0;

	  }
	  return 1;
	}

	if (mv[0] === "conquer") {
	  let faction = mv[1];
    	  this.game.queue.splice(qe, 1);
	  this.game.state.conquests.push({
	    faction : faction,
	    resolved :  0 ,
	    round :   this.game.state.round,
	  });
	  let msg = this.returnFactionName(faction) + " launches a conquest";
	  this.updateLog(msg);
	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.game.queue.push("ACKNOWLEDGE\t"+msg);
	    this.game.queue.push("display_custom_overlay\tconquest\t"+msg);
	  } else {
	    this.displayHudPopup("conquest",msg); // true = as hud popup
	  }
          this.game.state.may_conquer[faction] = 0;
	  this.displayConquest();
	  return 1;
	}


	if (mv[0] === "give_captured_leader") {

    	  this.game.queue.splice(qe, 1);
	  let giving_faction = mv[1];
	  let receiving_faction = mv[2];
	  let captured_leader = mv[3];

	  let p1 = this.returnPlayerCommandingFaction(giving_faction);
	  let p2 = this.returnPlayerCommandingFaction(receiving_faction);

	  if (this.game.state.players_info.length >= p1 && this.game.state.players_info.length >= p2) {
	    if (p1 > 0 && p2 > 0) {

	      for (let i = this.game.state.players_info[p1-1].captured.length-1; i >= 0; i--) {

		let c = this.game.state.players_info[p1-1].captured[i];

		if (c.key == captured_leader) {

		  this.game.state.players_info[p1-1].captured.splice(i, 1);

		  //
		  // if the faction gets its leader back, place on board
		  //
		  if (c.owner == receiving_faction) {		  

		    c.spacekey = "";
		    c.space = "";

		    this.restoreMilitaryLeader(c, "", receiving_faction);

		  //
		  // otherwise place in captured array of recipient
		  //
		  } else {
		    c.capturing_faction = receiving_faction;
		    this.game.state.players_info[p2-1].captured.push(c);		    
		  }

		}
	      }

	    }
	  }

	  return 1;

	}


	if (mv[0] === "is_testing") {

    	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "is_1532") {

	  // SCHMALKALDIC LEAGUE
	  let deck = this.returnDeck(true);
	  deck['013'].onEvent(this, "protestant");

    	  this.game.queue.splice(qe, 1);
	  return 1;

	}


        
        if (mv[0] === "reshuffle_diplomacy_deck") {
          
          this.game.queue.splice(qe, 1);
          
          //
          // DECKRESTORE copies backed-up back into deck
          //
          this.game.queue.push("SHUFFLE\t2");
          this.game.queue.push("DECKRESTORE\t2");          

          for (let i = this.game.state.players_info.length; i > 0; i--) {
            this.game.queue.push("DECKENCRYPT\t2\t"+(i));
          } 
          for (let i = this.game.state.players_info.length; i > 0; i--) {
            this.game.queue.push("DECKXOR\t2\t"+(i));
          }
          
          //
          // re-add discards
          //  
          let discards = {};
          for (let i in this.game.deck[1].discards) {
            discards[i] = this.game.deck[1].cards[i];
            delete this.game.deck[1].cards[i];
          } 
          this.game.deck[1].discards = {};
        
          //  
          // our deck for re-shuffling
          //
          let reshuffle_cards = {};
          for (let key in discards) { reshuffle_cards[key] = discards[key]; }

console.log("----------------------------");
console.log("---SHUFFLING IN DISCARDS ---");
console.log("----------------------------");
          this.game.queue.push("DECK\t2\t"+JSON.stringify(reshuffle_cards));

          // backup any existing DECK #2
          this.game.queue.push("DECKBACKUP\t2");

        }



	if (mv[0] === "diplomacy_submit_proposal") {
	  let p = JSON.parse(mv[1]);
	  this.game.state.diplomacy.push(p);
	  this.game.queue.splice(qe, 1);
	  return 1;
	}


        if (mv[0] === "diplomacy_card_event") {

	  let faction = mv[1];
	  let card = mv[2];

	  this.updateStatus(this.returnFactionName(faction) + " plays " + this.popup(card));
          this.updateLog(this.returnFactionName(faction) + " plays " + this.popup(card));
          this.cardbox.hide();

	  this.game.queue.splice(qe, 1);

          let lqe = qe-1;
          if (lqe >= 0) {
            let lmv = this.game.queue[lqe].split("\t");
            if (lmv[0] == "diplomacy_card_event") {
	      this.game.queue.splice(lqe, 1);
	    }
	  }

	  if (!this.diplomatic_deck[card].onEvent(this, faction)) { return 0; }

	  return 1;

	}



        if (mv[0] === "event") {

	  let faction = mv[1];
	  let card = mv[2];
	  let deck = his_self.returnDeck(true);

	  this.game.queue.splice(qe, 1);
          this.game.state.cards_evented.push(card);
	  if (faction == "protestant") { this.game.state.protestant_cards_evented.push(card); }

          this.updateLog(this.returnFactionName(faction) + " triggers " + this.popup(card));

	  let c = deck[card];
          if (!c.onEvent(this, faction)) {
            return 0;
          }

	  return 1;
	}


        if (mv[0] === "card") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let card = mv[2];

	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player === p) {
	    this.playerPlayCard(card, p, faction);
	  }

	  return 0;

	}

        if (mv[0] === "ops") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let card = mv[2];
	  let opsnum = parseInt(mv[3]);
 
          this.updateLog(this.returnFactionName(faction) + " plays " + this.popup(card) + " for ops");

	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player === p) {
	    this.playerPlayOps(card, faction, opsnum);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " playing ops");
	  }

	  return 0;

	}

        if (mv[0] === "lock") {

	  let faction = mv[1];
	  let source = mv[2];

	  this.game.queue.splice(qe, 1);

	  for (let i = 0; i < this.game.spaces[source].units[faction].length; i++) {
	    this.game.spaces[source].units[faction][i].locked = 1;
	  }

          return 1;

        }


        if (mv[0] === "move") {

	  let faction = mv[1];
	  let movetype = mv[2];
	  let source = mv[3];
	  let destination = mv[4];
	  let unitidx = parseInt(mv[5]);
	  let skip_avoid_battle = 0;
	  if (mv[6]) { skip_avoid_battle = parseInt(mv[6]); }
	  let is_this_an_interception = 0;
	  if (parseInt(mv[7]) > 0) { is_this_an_interception = 1; }
	  let is_our_next_command_a_move = false;

	  if (qe > 0) {
	    let lmv = this.game.queue[qe-1].split("\t");
	    if (lmv[0] == "move") { is_our_next_command_a_move = true; } 	
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);

	  this.game.queue.splice(qe, 1);

	  if (this.game.state.active_player == this.returnPlayerCommandingFaction(faction)) {
	    this.game.state.attacker_comes_from_this_spacekey = mv[3];
	    this.game.state.player_last_move = "move";
	    this.game.state.player_last_spacekey = destination;
	  }

	  //
	  // winter retreat into port
	  //
	  if (movetype === "port") {

	    let units = this.game.navalspaces[source].units[faction];

	    for (let z = 0; z < units.length; z++) {
	      this.game.spaces[destination].units[faction].push(units[z]);
	    }

	    this.game.navalspaces[source].units[faction] = [];

	    if (!is_our_next_command_a_move) {
	      this.displaySpace(source);
	      this.displaySpace(destination);
	    }

	  }

	  //
	  // movement at sea
	  //
	  if (movetype === "sea") {

	    //
	    // source = land, destination = sea
	    //
	    if (this.game.spaces[source] && this.game.navalspaces[destination]) {
	      let unit_to_move = this.game.spaces[source].units[faction][unitidx];
 	      unit_to_move.already_moved = 1;
	      if (is_this_an_interception) { unit_to_move.locked = 1; }
              this.game.navalspaces[destination].units[faction].push(unit_to_move);
              this.game.spaces[source].units[faction].splice(unitidx, 1);
	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	      if (!is_our_next_command_a_move) {
	        this.displaySpace(source);
	        this.displayNavalSpace(destination);
	      }
	    }

	    //
	    // source = sea, destination = sea
	    //
	    if (this.game.navalspaces[source] && this.game.navalspaces[destination]) {
	      let actual_unitidx = 0;
	      for (let i = 0; i < this.game.navalspaces[source].units[faction].length; i++) {
		if (this.game.navalspaces[source].units[faction][i].idx === unitidx) {
		  actual_unitidx = i;
		  break; // it will always be the first match, since other ships may have moved
		  	 // into the space with the same IDX
		};
	      }

	      let unit_to_move = this.game.navalspaces[source].units[faction][actual_unitidx];

	      if (is_this_an_interception) { unit_to_move.locked = 1; }
 	      unit_to_move.already_moved = 1;
              this.game.navalspaces[destination].units[faction].push(unit_to_move);
              this.game.navalspaces[source].units[faction].splice(actual_unitidx, 1);

	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));

	      if (!is_our_next_command_a_move) {
	        this.displayNavalSpace(source);
	        this.displayNavalSpace(destination);
	      }
	    }

	    //
	    // source = sea, destination = land
	    //
	    if (this.game.navalspaces[source] && this.game.spaces[destination]) {

	      let actual_unitidx = 0;
	      for (let i = 0; i < this.game.navalspaces[source].units[faction].length; i++) {
		if (this.game.navalspaces[source].units[faction][i].idx === unitidx) {
		  actual_unitidx = i;
		};
	      }

	      let unit_to_move = this.game.navalspaces[source].units[faction][actual_unitidx];
 	      unit_to_move.already_moved = 1;
	      if (is_this_an_interception) { unit_to_move.locked = 1; }
              this.game.spaces[destination].units[faction].push(unit_to_move);
              this.game.navalspaces[source].units[faction].splice(actual_unitidx, 1);
	      this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	      if (!is_our_next_command_a_move) {
	        this.displayNavalSpace(source);
	        this.displaySpace(destination);
	      }
	    }

	    //
	    // do we have a jolly sea battle?
	    //
            let space;
	    if (this.game.spaces[destination]) {
	      space = this.game.spaces[destination];
	    }
	    if (this.game.navalspaces[destination]) {
	      space = this.game.navalspaces[destination];
	    }

            let anyone_else_here = 0;
            let who_wants_a_fight = [];

	    //
	    // a single move might trigger multiple combat attempts, so we need to loop backwards and 
	    // run this check for each destination.
	    //
	    let current_destination = destination;
	    let current_faction = faction;

            if (qe > 0 && is_this_an_interception != 1) {

              let lmv2 = this.game.queue[qe-1].split("\t");
              if (lmv2[0] == "naval_interception_check") {
	  
	        for (let lqe = qe-1; lqe >= 0; lqe--) {

                  let lmv = this.game.queue[lqe].split("\t");
                  if (lmv[0] == "naval_interception_check") {

		    current_faction = lmv[1];
		    current_destination = lmv[2];
		    current_source = lmv[3];

		    let cdest;
	            if (this.game.spaces[current_destination]) {
	              cdest = this.game.spaces[current_destination];
	            }
	            if (this.game.navalspaces[current_destination]) {
	              cdest = this.game.navalspaces[current_destination];
	            }

//console.log("CHECK");
//console.log("CHECK");
//console.log("CHECK");
//console.log("CHECK " + faction);
//console.log("CHECK " + current_faction);
//console.log("CHECK " + current_destination);

//
// if we have issues with sea battles, it is because current_faction was set as faction below everywhere except naval-retreat-check 
//
//

		    // refresh for each new destination
		    who_wants_a_fight = [];

// change faction to current faction

                    for (let f in cdest.units) {
                      if (cdest.units[f].length > 0 && f != current_faction) {
                        anyone_else_here = 1;
                      }
                      if (f !== current_faction && cdest.units[f].length > 0 && this.areEnemies(f, current_faction)) {
			let cp = this.returnControllingPower(f);
//console.log("FOUND " + cp + " " + f);
			if (!who_wants_a_fight.includes(cp)) {
			  who_wants_a_fight.push(cp);
                          if (lqe-1 >= 0) {
                            if (skip_avoid_battle != 1) {
                              this.game.queue.splice(lqe, 0, "naval_retreat_check\t"+current_faction+"\t"+current_destination+"\t"+current_source);
                            }
//alert("adding sea battle between: " + faction + " / " + cp);
                            this.game.queue.splice(lqe, 0, "naval_battle\t"+current_destination+"\t"+current_faction+"\t"+cp);
                          }
                        }
                      }
                    }
                  }
	        }
	      }

//console.log("AFTER LOOP: " + JSON.stringify(this.game.queue));

	    }
	  }

	  //
	  // movement on land
	  //
	  if (movetype === "land") {

	    let unit_to_move = this.game.spaces[source].units[faction][unitidx];

// if unit exists
	    if (unit_to_move) {

 	    unit_to_move.already_moved = 1;
            this.game.spaces[destination].units[faction].push(unit_to_move);
            this.game.spaces[source].units[faction].splice(unitidx, 1);
	    this.updateLog(this.returnFactionName(faction)+" moves "+unit_to_move.name+" from " + this.returnSpaceName(source) + " to " + this.returnSpaceName(destination));
	    this.displaySpace(source);
	    this.displaySpace(destination);

	    //
	    // if this space contains two non-allies, field-battle or siege must occur
	    //
	    let space = this.game.spaces[destination];
	    let anyone_else_here = 0;
	    let number_opposing_land_units = 0;

	    let lqe = qe-1;
	    if (lqe >= 0) {

	      let lmv = this.game.queue[lqe].split("\t");

	      //
	      // this space is not already besieged but it is possible that someone might
	      // intercept and trigger a field battle. This bit of code is confusing queue-management
	      // that screws around with the queue to ensure that commands are added only when 
	      // the last unit has moved into the space.
	      //

	      //
	      // we avoid the field battle and complicated nonsense if moving troops into a foreign war
	      //
	      if (space.key != "persia" && space.key != "egypt" && space.key != "ireland") {

		//
		// this is the last "move" that we will have to process, so this is the point
		// where we check to see if we have to have a field battle, etc. or whether 
		// we need to break the siege.
		//
	        if (lmv[0] == "interception_check" && space.besieged == 0) { // not already besieged

		  //
		  // do we need to break a siege in the place from which we are moving?
		  //
		  let source_space = this.game.spaces[source];
		  let hoiluis = this.returnHostileOrIndependentLandUnitsInSpace(faction, source_space);
		  let myluis = this.returnFactionLandUnitsInSpace(faction, source_space);
		  if (hoiluis > myluis && myluis > 0) {
		    let fac = this.returnFactionControllingSpace(source_space);
		    this.game.queue.push("ACKNOWLEDGE\t"+this.returnFactionName(faction) + " retreats after siege broken!");
	            this.game.queue.push("remove_siege\t"+source);
	            this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+faction+"\t"+fac+"\t"+source);
		    this.game.queue.push("player_evaluate_break_siege_retreat_opportunity\t"+faction+"\t"+source);
		  }

		  let field_battle_triggered = false;
		  let relevant_powers = [];
	          for (let f in space.units) {

		    //
		    // we check not only for NO units, but for NUM land units
		    //
	            if (space.units[f].length > 0 && f != faction) {
		      anyone_else_here = 1;
		      for (let z = 0; z < space.units[f].length; z++) {
		        let u = space.units[f][z];
		        if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") { number_opposing_land_units++; }
		      }
	            }

	            if (f !== faction && this.returnFactionLandUnitsInSpace(f, space) > 0 && !this.areAllies(f, faction)) {

		      let cp = this.returnControllingPower(f);
		      if (cp != f) { f = cp; }
		      if (!relevant_powers.includes(f)) {

		        relevant_powers.push(f);

		        if (lqe-1 >= 0) {

			  //
		          // added in reverse order
			  //
		          if (skip_avoid_battle != 1) {
			    //
		 	    // inactive faction indicates interception - neither retreat nor fortification
			    // should be offered because this movement invovles a player moving defensively
			    // into a space and this move is triggered by another active player, which means
			    // we need a field battle.
			    //
			    if (!is_this_an_interception) {
			      //
			      // active faction
			      //
	                      this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
			      if (space.besieged == 0) {
	                        this.game.queue.splice(lqe, 0, "fortification_check\t"+faction+"\t"+destination+"\t"+source);
			      }
			    } else {

			    }
		          }

		          //
		          // "move" is used by the intercept command, so we do not want intercepts to be changing the 
		          // software's concept of which faction is the attacker. for this reason, if the active player
		          // is present in the space, we treat them as the attacker.
		          //
		          if (field_battle_triggered != true) {
		            if (this.returnFactionLandUnitsInSpace(this.game.state.active_faction, space.key) > 0) {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+this.game.state.active_faction);
		  	      field_battle_triggered = true;
		            } else {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+faction);
		  	      field_battle_triggered = true;
	                    }
	                  }
	                }
	              }
	            }
	          }

		  if ((anyone_else_here == 0 || number_opposing_land_units == 0) && (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress")) {

		    let f = this.returnFactionControllingSpace(space.key);

		    if (!this.areAllies(f, faction) && f !== faction) {
		      if (space.besieged != 1) { // not if already besieged

		        //
		        // besiege the defenders, and lock the attackers (preventing further movement)
		        //
		        for (let z = 0; z < space.units[f].length; z++) {
			  if (!space.units[f][z].reformer) { space.units[f][z].besieged = true; }
		        }
		        for (let z = 0; z < space.units[faction].length; z++) {
			  if (!space.units[faction][z].reformer) { space.units[faction][z].locked = 1; }
		        }
	 	        space.besieged = 2;
		        this.displaySpace(space.key);
		      }
		    }

	          }

	        } else {

		  //
		  // no-one is around to intercept, but is this assaultable
		  //
		  if (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress") {
		    let f = this.returnFactionControllingSpace(space.key);
		    if (this.returnFactionLandUnitsInSpace(f, space.key, 1) == 0) {
 		      if (!this.areAllies(f, faction) && f !== faction) {
		        if (space.besieged != 1) { // not if already besieged
	 	          space.besieged = 2;
		          this.displaySpace(space.key);
		        }
		      }
		    }
	          }

		  //
		  // on the very last move we check to see if there are any enemy factions in the 
		  // space and trigger a field battle, deciding first whether the existing forces
		  // are capable of retreating or fortifying.
		  //
		  if (lmv[0] !== "move") {

		    //
		    // occupier is antequated
		    //
		    space.occupier = faction;

		    let field_battle_triggered = false;

		    //
		    // relief forces showing up
		    //
		    for (let f in space.units) {

 		      if (!this.areAllies(f, faction, 1) && f !== faction) {

		        if (this.returnFactionLandUnitsInSpace(f, space.key, 1) > 0 && field_battle_triggered == false) {


			  //
			  // if all the units are besieged we skip field battle because attacker needs to assault
			  //
			  let is_anyone_not_besieged = false;
			  let is_anyone_besieged = false;
			  let is_defender_the_one_who_is_besieged = false;
			  let unbesieged_faction = "";
			  let faction_controlling_space = this.returnFactionControllingSpace(space);
			  faction_controlling_space = this.returnControllingPower(faction_controlling_space);
			  let any_besieged_controlling_units = false;

			  //
			  // if the defender has any controlling units
			  //
			  if (space.besieged == 1) {
			    for (let k in space.units) {
			      if (this.returnControllingPower(k) == faction_controlling_space) {
			        for (let z = 0; z < space.units[f].length; z++) {
				  if (space.units[f][z].besieged > 0) {
				    any_besieged_controlling_units = true;
				  }
			        }
			      }
			    }
			  }


			  for (let z = 0; z < space.units[f].length; z++) {
			    if (!space.units[f][z].besieged) {
			      is_anyone_not_besieged = true;
			      unbesieged_faction = f;
			    } else {
			      is_anyone_besieged = true;
			      if (!this.areAllies(f, faction)) { 
				is_defender_the_one_who_is_besieged = true;
			      }
			    }
			  }

			  //
			  // we are also a relief siege if the defender is the one who is 
			  // controlling the space, and does not have any besieged controlling
			  // units.
			  //
			  if (this.returnControllingPower(faction) == faction_controlling_space) {

			    if (!any_besieged_controlling_units) {
          		      //                      
      			      // mark relief forces - anyone friendly who is still there
      			      //
			      if (space.besieged == 1) {
                      	        for (let fkey in space.units) {
   			          if (this.areAllies(fkey, faction)) {
         			    for (let z = 0; z < space.units[fkey].length; z++) { 
                		      space.units[fkey][z].relief_force = 1;
				      defender_is_the_one_who_is_besieged = false;
              			    }
            			  }
          		        }
			      }

			    }

			  }

			  if (is_anyone_not_besieged) {

			    field_battle_triggered = true;

			    //
			    // but maybe no-one is besieged, in which case we want to offer fortification option
			    // to the defender.
			    //
			    if (is_defender_the_one_who_is_besieged != true) {

			      //
			      // the defender is not besieged, but if the defender is besieging a third party
			      // then this is a relief expedition. so we check to see if there are any other
			      // forces that are not allied with the defender.
			      //
			      let is_this_a_relief_force = false;
			      for (let zf in space.units) {
				if (space.units[zf].length > 0) {
				  for (let zzz = 0; zzz < space.units[zf].length; zzz++) {
				    if (space.units[zf][zzz].besieged) {
				      if ((faction == zf || this.areAllies(faction, zf)) && zf != unbesieged_faction) {
					is_this_a_relief_force = true;
				      }
				    }
				  }
				} else {
				  // if this faction controls the space and is the defender
				  // then we have a defense force
				}
			      }

			      if (is_this_a_relief_force == true) {
	                        this.game.queue.splice(lqe, 0, "relief_forces\t"+faction+"\t"+destination);
	                        this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
			      } else {
	                        this.game.queue.splice(lqe, 0, "fortification_check\t"+faction+"\t"+destination+"\t"+source);
	                        this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
			      }

			    } else {

		              //
		              // someone else is here, so let's trigger a field battle
		              //
			      if (!is_this_an_interception) {
	                        this.game.queue.splice(lqe, 0, "relief_forces\t"+faction+"\t"+destination);
	                        this.game.queue.splice(lqe, 0, "retreat_check\t"+faction+"\t"+destination+"\t"+source);
		              }

			    }

			    //
		            // "move" is used by the intercept command, so we do not want intercepts to be changing the 
		            // software's concept of which faction is the attacker. for this reason, if the active player
		            // is present in the space, we treat them as the attacker.
		            //
		            if (this.returnFactionLandUnitsInSpace(this.game.state.active_faction, space.key) > 0) {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+this.game.state.active_faction);
		            } else {
	                      this.game.queue.splice(lqe, 0, "field_battle\t"+space.key+"\t"+faction);
	                    }
		          }
		        }
		      }
		    }
		  }
	        }
	      } // persia, egypt and irelance
	    } // if unit exists
	    }
	  
	    //
	    // did moving remove a siege? check
	    //
	    if (!this.isSpaceBesieged(source)) {
	      this.removeSiege(source);
	    }

	    if (!is_our_next_command_a_move) {
	      this.displaySpace(source);
	      this.displaySpace(destination);
	    }

	  }

          return 1;
	}




        if (mv[0] === "fortification_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = "";

	  //
	  // if this is a defensive interception, the attacker will be
	  // the active player.
	  //
	  if (this.returnControllingPower(attacker) != this.returnControllingPower(this.game.state.active_faction) && this.returnPlayerCommandingFaction(attacker) != this.returnPlayerCommandingFaction(this.game.state.active_faction)) {
	    defender = attacker;
	    attacker = this.game.state.active_faction;
	    attacker_comes_from_this_spacekey = this.game.state.attacker_comes_from_this_spacekey;
	  }

	  let space = this.game.spaces[spacekey];

	  if (space.type !== "electorate" && space.type !== "key" && space.type !== "fortress") {
	    return 1;
	  }

	  //
	  // no units, no fortification check
	  //
	  let fluis = 0;
	  if (defender != "") {
	    if (defender !== attacker && !this.areAllies(this.game.state.active_faction, defender, 1)) {
	      for (let f in this.game.spaces[spacekey].units) {
		if (this.returnControllingPower(f) == this.returnControllingPower(defender) || this.returnPlayerCommandingFaction(f) == this.returnPlayerCommandingFaction(defender)) {
	          fluis += this.returnFactionLandUnitsInSpace(defender, spacekey, 1);
	        }
	      }
            }
	  } else {
	    for (let f in this.game.spaces[spacekey].units) {
	      if (f !== attacker && !this.areAllies(attacker, f, 1)) {
	        fluis += this.returnFactionLandUnitsInSpace(f, spacekey, 1);
	      }
	    }
	  }

	  if (fluis == 0) { return 1; }

	  //
	  // whoever is being attacked can retreat into the fortification if they
	  // have 4 or less land units
	  //
	  let processed_factions = [];
	  for (let f in this.game.spaces[spacekey].units) {

	    //
	    // if from interception
	    //
	    if (defender != "") { f = defender; }

	    //
	    // if minor powers are here and a major power is as well, we treat the minor as a major power
	    //
	    f = this.returnControllingPower(f);
	    if (processed_factions.includes(f)) { continue; } else { processed_factions.push(f); }

	    if (f !== attacker && (this.areAllies(f, this.returnFactionControllingSpace(spacekey)) || this.isSpaceControlled(spacekey, f)) && !this.areAllies(this.game.state.active_faction, f, 1)) {

	      let fluis = this.returnFactionLandUnitsInSpace(f, spacekey, 1); // include minor allies

	      if (fluis == 0) {
		//
		// no troops - skip
		//
	      } else {

	        if (fluis > 4) {

		  // must land battle

	        } else {

		  if (this.isMinorPower(f)) {

		    if (this.isMinorUnactivatedPower(f)) {

		      //
		      // auto-handled -- we retreat for siege
		      //
		      this.game.queue.push("fortification\t"+attacker+"\t"+f+"\t"+spacekey);

		    } else {

		      //
 		      // major power decides
		      //
		      let cf = "";
		      let mp = f;

		      if (this.game.state.activated_powers['ottoman'].includes(f)) { cf = "ottoman"; }
		      if (this.game.state.activated_powers['hapsburg'].includes(f)) { cf = "hapsburg"; }
		      if (this.game.state.activated_powers['france'].includes(f)) { cf = "france"; }
		      if (this.game.state.activated_powers['england'].includes(f)) { cf = "england"; }
		      if (this.game.state.activated_powers['papacy'].includes(f)) { cf = "papacy"; }
		      if (this.game.state.activated_powers['protestant'].includes(f)) { cf = "protestant"; }

		      let cp = this.returnPlayerCommandingFaction(cf);
		      this.game.queue.push("player_evaluate_fortification"+"\t"+attacker+"\t"+cp+"\t"+mp+"\t"+spacekey);

		    }

	          } else {

		    //
		    // major or independent power - some player decides
		    //
		    let cp = this.returnPlayerCommandingFaction(f);

		    if (cp != 0) {
		      this.game.queue.push("player_evaluate_fortification"+"\t"+attacker+"\t"+cp+"\t"+f+"\t"+spacekey);


		    } else {

	              //
		      // independent key
	              //
	              // non-player controlled, minor power or independent, so auto-handle
	              //
	              // If there are 4 or fewer land units in a space, they will always withdraw into
	              // the fortifications and try to withstand a siege if their space is entered.
	              // if there are 5 or more land units,they will hold their ground and fight a field
	              // battle. If they lose that field battle, do not retreat their units from the
	              // space as usual. Instead, they retain up to 4 units which withdraw into the
	              // fortifications; all other land units in excess of 4 are eliminated.
	              //
	              // fortify everything
	              //
	              his_self.game.queue.push("NOTIFY\t" + his_self.returnFactionName(f) + " fortifies in " + his_self.returnSpaceName(spacekey));
	              for (let i = 0; i < space.units[f].length; i++) {
	                his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+f+"\t"+JSON.stringify(space.units[f][i]));
	              }
		    }
	          }
	        }
	      }

	    } else {

	      //
	      // no land units (skip)
	      //

	    }


	    //
	    // if from interception
	    //
	    if (defender != "") { break; }

	  }

          return 1;

	}

        if (mv[0] === "post_field_battle_player_evaluate_fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let spacekey = mv[4];
          let space = this.game.spaces[spacekey];
          let relief_siege = "";
          let tied_relief_siege = "";
	  if (mv[5]) { relief_siege = true; }
	  if (mv[5] === "relief_siege_tie") { tied_relief_siege = true; }

	  if (tied_relief_siege == true) {
	    this.game.state.field_battle_relief_battle = false;
	    relief_siege = false;
	  }

	  //
	  // if no-one is left to fortify
	  //
	  if (this.game.state.field_battle.defender_land_units_remaining <= 0 && this.game.state.field_battle_attacker_land_units_remaining > 0) {
	    //
	    // immediately besiege if a key
	    //
	    if (space.type === "fortress" || space.type === "electorate" || space.type === "key") {
	      if (space.besieged != 1) { // not if already besieged
                space.besieged = 2; // 2 = cannot attack this round
                space.besieged_factions.push(faction);
	      }
	    }
	    this.displaySpace(spacekey);
	    return 1;
	  }

	  //
	  // if this is not a fortified space, clear and continue
	  //
	  if (space.type !== "fortress" && space.type !== "electorate" && space.type !== "key") {
	    return 1;
	  }

	  //
	  // this was a relief battle, but no formerly-besieged units survived
	  //
	  let did_anyone_survive = false;
	  let did_anyone_allied_with_me_survive = false;
	  let did_anyone_allied_with_me_who_can_fortify_survive = false;
	  let is_relief_siege = 0;
	  if (this.game.state.field_battle_relief_battle || relief_siege == true) {
	    for (let key in space.units) {
	      for (let z = 0; z < space.units[key].length; z++) {
		let u = space.units[key][z];
		if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
		  if (this.areAllies(key, faction, 1)) { did_anyone_allied_with_me_survive = true; }
	          is_relief_siege = 1;
		  if (relief_siege == true) {
		    did_anyone_allied_with_me_who_can_fortify_survive = 1;
		  } else {
		    if (u.relief_forces == 0) { did_anyone_allied_with_me_who_can_fortify_survive = true; }	
		  }
		}

		//
		// the units that came out of the fortified space will have relief_force = 0 while
		// anyone who moved it will be the "relief force" and marked as relief_force = 1
		// this matters as the only units that can retreat are those which 
		//
		if (space.units[key][z].relief_force == 0) { did_anyone_survive = true; }
	      }
	    }

	    if (relief_siege == true) {
	      if (!did_anyone_allied_with_me_who_can_fortify_survive) {
		return 1;
	      }
	    }

	    if (!did_anyone_survive) {
	      return 1;
	    }
	    if (!did_anyone_allied_with_me_survive) {
	      return 1;
	    }
	  }

	  //
	  // otherwise, we have to evaluate fortifying
	  //
	  if (this.game.player == player) {
	    this.field_battle_overlay.renderFortification(this.game.state.field_battle);
	    this.playerEvaluateFortification(attacker, faction, spacekey, 1, is_relief_siege); // 1 = post battle , 1/0 = relief_siege
	  } else {
	    if (this.isPlayerControlledFaction(faction)) {
	      this.field_battle_overlay.renderFortification(this.game.state.field_battle);
	      this.field_battle_overlay.updateInstructions(faction + " considering fortification");
	      this.updateStatus(this.returnFactionName(faction) + " considering fortification");
	    } else {

	      //
	      // non-player controlled, minor power or independent, so auto-handle
	      //
	      // If there are 4 or fewer land units in a space, they will always withdraw into
	      // the fortifications and try to withstand a siege if their space is entered.
	      // if there are 5 or more land units,they will hold their ground and fight a field
	      // battle. If they lose that field battle, do not retreat their units from the
	      // space as usual. Instead, they retain up to 4 units which withdraw into the
	      // fortifications; all other land units in excess of 4 are eliminated.
      	      //
      	      // this only runs after we have had a battle, so we fortify everything if we still
	      // exist.
      	      //
	      //
	      // fortify up to four units, the rest retreats
	      //
	      let retreat_option = "";
	      for (let z = 0; z < space.neighbours.length; z++) {
		if (his_self.isSpaceFriendly(space, faction)) {
		  retreat_option = space.neighbours[z];
		}
	      }

	      let fortification_limit = 0;
	      for (let i = 0; i < space.units[faction].length; i++) {
		if (fortification_limit < 4) {
	          his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
		  fortification_limit++;
	        } else {
		  his_self.game.spaces[retreat_option].units[faction].push(space.units[faction][i]);
		  space.units[faction].splice(i, 1);
		  i--;
	        }
	      }
	      return 1;
	    }
	  }

          return 0;

	}


        if (mv[0] === "player_publish_treatise") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  if (faction == "england") {
	    if (this.game.players.length == 2) { faction = "protestant"; }
	    if (this.game.player === this.returnPlayerCommandingFaction(faction)) {
	      this.playerPublishTreatise(this, this.game.player, "england");
	    }
	  }
	
	  return 0;

	}

	

        if (mv[0] === "player_evaluate_fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let spacekey = mv[4];
	  let space = this.game.spaces[spacekey];

	  let any_unbesieged_units = false;
	  for (let f in this.game.spaces[spacekey].units) {
	    if (f == faction || this.areAllies(f, faction, true)) {
	      for (let z = 0; z < this.game.spaces[spacekey].units[f].length; z++) {
		let u = this.game.spaces[spacekey].units[f][z];
		if (u.reformer != true && u.besieged == false) {
		  any_unbesieged_units = true;
		}
	      }
	    }
	  }

	  let space_inside_fortifications = 4;
	  for (let f in this.game.spaces[spacekey].units) {
	    if (f == faction || this.areAllies(f, faction, true)) {
	      for (let z = 0; z < this.game.spaces[spacekey].units[f].length; z++) {
		let u = this.game.spaces[spacekey].units[f][z];
		if (u.army_leader != true && u.besieged == true) {
		  space_inside_fortifications = 0;
		}
	      }
	    }
	  }

	  //
	  // nothing to fortify
	  //
	  if (any_unbesieged_units == false) { return 1; }

	  //
	  // no space left anyway
	  //
	  if (space_inside_fortifications == 0) {
	    return 1;
	  }

	  let decider = this.returnPlayerCommandingFaction(faction);
	  if (decider > 0) {
	    if (this.game.player == decider) {
	      this.playerEvaluateFortification(attacker, faction, spacekey);
	    } else {
	      this.updateStatus(this.returnFactionName(faction) + " considering fortification");
	    }
	    return 0;
	  } else {
	    //
	    // non-player controlled, minor power or independent, so auto-handle
	    //
	    // If there are 4 or fewer land units in a space, they will always withdraw into
	    // the fortifications and try to withstand a siege if their space is entered.
	    // if there are 5 or more land units,they will hold their ground and fight a field
	    // battle. If they lose that field battle, do not retreat their units from the
	    // space as usual. Instead, they retain up to 4 units which withdraw into the
	    // fortifications; all other land units in excess of 4 are eliminated.
      	    //
      	    // this only runs after we have had a battle, so we fortify everything if we still
	    // exist.
      	    //
	    //
	    // fortify everything
	    //
	    for (let i = 0; i < space.units[faction].length; i++) {
	      his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
	    }
	    return 1;
	  }

	}


	if (mv[0] === "unfortify_unit_by_index") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let space = this.game.spaces[spacekey];

	  space.units[faction][unit_idx].relief_force = 0;
	  space.units[faction][unit_idx].besieged = 0;

	  this.displaySpace(spacekey);

	  return 1;

	}
	if (mv[0] === "fortify_unit_by_index") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let unit_idx = parseInt(mv[3]);
	  let space = this.game.spaces[spacekey];

	  if (space.besieged != 1) { // not if already besieged
            space.besieged = 2; // 2 = cannot attack this round
            space.besieged_factions.push(faction);
	  }
	  space.units[faction][unit_idx].besieged = 1;

	  this.displaySpace(spacekey);

	  return 1;

	}

	if (mv[0] === "fortify_unit") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];
	  let units = JSON.parse(mv[3]);
	  let space = this.game.spaces[spacekey];

	  if (space.besieged != 1) { // not if already besieged
            space.besieged = 2; // 2 = cannot attack this round
            space.besieged_factions.push(faction);
	  }
	  for (let i = 0; i < space.units[faction].length; i++) {
	    space.units[faction][i].besieged = 1;
	  }

	  this.displaySpace(spacekey);

	  return 1;

        }



        if (mv[0] === "relief_forces_join_battle") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[spacekey];

          this.game.state.field_battle_relief_battle = true;

	  //
	  // mark relief forces - anyone friendly who is still there
	  //
	  for (let key in space.units) {
	    if (key == faction || this.areAllies(key, faction)) {
	      for (let z = 0; z < space.units[key].length; z++) {
		space.units[key][z].relief_force = 1;
	      }
	    }
	  }

	  let player = this.returnPlayerCommandingFaction(faction);

	  if (this.game.player === player) {
	    this.playerReliefForcesJoinBattle(faction, spacekey);
	  } else {
	    this.updateLog(this.returnFactionName(faction) + " deciding whether besieged units join battle");
	    this.updateStatus(this.returnFactionName(faction) + " deciding whether besieged units join battle");
	  }

	  this.displaySpace(spacekey);

          return 0;

        }



        if (mv[0] === "fortification") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let faction = mv[2];
	  let spacekey = mv[3];
	  let post_battle = 0;
	  let relief_siege = 0;
	  if (mv[4]) { post_battle = parseInt(mv[4]); }
	  //
	  // if this is set only those with relief_siege = 0 can fortify
	  //
	  if (mv[5]) { relief_siege = parseInt(mv[5]); }
	  let space = this.game.spaces[spacekey];

	  let faction_map = this.returnFactionMap(space, attacker, faction);
	  let player = this.returnPlayerCommandingFaction(faction);

	  if (player > 0) {
	    if (this.game.player === player) {
	      this.playerFortifySpace(faction, attacker, spacekey, post_battle, relief_siege);
	    } else {
	      this.updateLog(this.returnFactionName(faction) + " fortifies in " + this.returnSpaceName(spacekey));
	      this.updateStatus(this.returnFactionName(faction) + " fortifying in " + this.returnSpaceName(spacekey));
	    }
	  } else {

	    //
	    // non-player controlled, minor power or independent, so auto-handle
	    //
	    // If there are 4 or fewer land units in a space, they will always withdraw into
	    // the fortifications and try to withstand a siege if their space is entered.
	    // if there are 5 or more land units,they will hold their ground and fight a field
	    // battle. If they lose that field battle, do not retreat their units from the
	    // space as usual. Instead, they retain up to 4 units which withdraw into the
	    // fortifications; all other land units in excess of 4 are eliminated.
      	    //
	    let luis = this.returnFactionLandUnitsInSpace(faction, space.key, 1);

	    if (luis <= 4) {
	      //
	      // fortify everything
	      //
	      for (let i = 0; i < space.units[faction].length; i++) {
	        his_self.game.queue.push("fortify_unit\t"+spacekey+"\t"+faction+"\t"+JSON.stringify(space.units[faction][i]));
	      }
	    } else {
		//
		// go into field battle or next step
		//
	    }
	    this.displaySpace(spacekey);
	    return 1;
	  }

	  this.displaySpace(spacekey);

          return 0;

	}

	if (mv[0] === "unbesiege_if_empty") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let faction = mv[2];

	  let space = this.game.spaces[spacekey];
	  let anyone_left = false;
	  let leaders_left = false;
	  let leaders_left_factions = [];
	  let cf = this.returnControllingPower(faction);
	  let faction_controlling_space = this.returnFactionControllingSpace(spacekey);
	  faction_controlling_space = this.returnControllingPower(faction_controlling_space);

	  for (let f in space.units) {
	    if (this.returnControllingPower(f) == cf) {
	      for (let i = 0; i< space.units[f].length; i++) {
		let t = space.units[f][i].type;
		if (t == "mercenary" || t == "cavalry" || t == "regular") {
		  anyone_left = true;
		} 
		if (space.units[f][i].army_leader) {
		  leaders_left = true;
		  leaders_left_factions.push(f);
		}
	      }
	    }
	  }

	  //
	  // we have stripped the defenders, so do not remove siege
	  //
	  if (faction_controlling_space == cf) {
	    if (anyone_left == false) {
 	      if (space.besieged != 0) {
	      } else {
	        if (leaders_left == true && anyone_left == false) {
	          for (let i = 0; i < leaders_left_factions.length; i++) {
	            this.game.queue.push("maybe_evacuate_or_capture_leaders\t"+leaders_left_factions[i]+"\t"+spacekey);
	          }
	        }
	      }
	    }
	  //
	  // or remove siege, evacuate or capture leaders
	  //
	  } else {
	    if (anyone_left == false) {
 	      if (space.besieged != 0) {
	        this.game.queue.push("remove_siege\t"+spacekey);
	      } else {
	        if (leaders_left == true) {
	          for (let i = 0; i < leaders_left_factions.length; i++) {
	            this.game.queue.push("maybe_evacuate_or_capture_leaders\t"+leaders_left_factions[i]+"\t"+spacekey);
	          }
	        }
	      }
	    }
	  }

	  return 1;

	}

	if (mv[0] === "remove_siege") {

	  this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];
	  let space = this.game.spaces[spacekey];

	  //
	  // remove siege record from units/space
	  //
	  space.besieged = 0;
	  for (let f in space.units) {
	    for (let i = 0; i < space.units[f].length; i++) {
	      space.units[f][i].relief_force = 0;
	      space.units[f][i].besieged = 0;
	    }
	  }
	  this.displaySpace(spacekey);

	  return 1;

	}

	if (mv[0] === "break_siege") {

	  this.game.queue.splice(qe, 1);

	  let faction_map;
	  let attacker_faction;
	  let defender_faction;
	  let spacekey;

	  if (his_self.game.state.assault) {
	    faction_map      = his_self.game.state.assault.faction_map;
	    attacker_faction = his_self.game.state.assault.attacker_faction;
	    defender_faction = his_self.game.state.assault.defender_faction;
	    spacekey         = his_self.game.state.assault.spacekey;
	  } else {
	    //
	    // relief sieges can trigger this, which is why attackers/defenders reversed here
	    //
	    faction_map      = his_self.game.state.field_battle.faction_map;
	    defender_faction = his_self.game.state.field_battle.attacker_faction;
	    attacker_faction = his_self.game.state.field_battle.defender_faction;
	    spacekey         = his_self.game.state.field_battle.spacekey;
	  }

	  let space 	       = his_self.game.spaces[spacekey];
	  let neighbours       = space.neighbours;

	  //
	  // remove siege record from units/space
	  //
	  space.besieged = 0;
	  for (let f in space.units) {
	    for (let i = 0; i < space.units[f].length; i++) {
	      space.units[f][i].relief_force = 0;
	      space.units[f][i].besieged = 0;
	    }
	  }
	  this.displaySpace(spacekey);

	  for (let f in faction_map) {
	    let cf = this.returnControllingPower(f);
	    if (cf == attacker_faction || faction_map[f] == attacker_faction) {
	      for (let zz = 0; zz < neighbours.length; zz++) {
                let fluis = this.canFactionRetreatToSpace(f, neighbours[zz]);
	        if (fluis) {
                  this.game.queue.push("player_evaluate_break_siege_retreat_opportunity\t"+f+"\t"+spacekey);
	          zz = neighbours.length+1;
	        }
	      }
            }
          }

	  return 1;

	}


	if (mv[0] === "relief_forces") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[spacekey];
	
	  let player = this.returnPlayerCommandingFaction(faction);

	  //
	  // if the player is the attacker, not the defender we want
	  // to skip this completely.
	  //
	  let anyone_besieged = 0;
	  for (let f in space.units) {
	    if (f == faction || this.areAllies(f, faction, 1)) {
	      for (let z = 0; z < space.units[f].length; z++) {
	        if (space.units[f][z].besieged > 0) { anyone_besieged = 1; }
	      }
	    }
	  }

	  //
	  // pass through if attacker (not besieged)
	  //
	  if (anyone_besieged == 0) {
	    return 1;
	  }

	  if (this.game.player == player) {
	    this.playerEvaluateReliefForce(faction, spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " handling besieged units");
	  }

	  return 0;
	}


        if (mv[0] === "retreat_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];

	  let attacker_comes_from_this_spacekey = mv[3];
	  // TODO remove if needed -- now set in move
	  //this.game.state.attacker_comes_from_this_spacekey = mv[3];


	  let space = this.game.spaces[spacekey];
	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0, 0); // 0 cannot intercept across passes or seas
	  let attacking_player = this.returnPlayerOfFaction(attacker);
	  let factions_with_units_in_space = [];

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_faction_retreat = 0;
	    let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	    if (player_of_faction != attacking_player && player_of_faction > 0) {
  	      if (io[i] !== attacker && (io[i] != this.game.state.active_faction && !this.areAllies(this.game.state.active_faction, io[i], 1))) {
	        let units_in_space = this.returnFactionLandUnitsInSpace(io[i], spacekey);
	        if (units_in_space > 0) {
	  	  factions_with_units_in_space.push(io[i]);
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToSpace(io[i], neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
	              let x = "player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i];
		      if (this.game.queue[this.game.queue.length-1] !== x) {
	                this.game.queue.push("player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i]);
		        zz = neighbours.length;
		      }
	            }
	          }
	        }
	      }
	    }

	    //
	    // let activated powers retreat, but only if their major power has not already been asked
	    //
	    for (let zz = 0; zz < this.game.state.activated_powers[io[i]].length; zz++) {
	      let ap = this.game.state.activated_powers[io[i]][zz];
	      let cp = this.returnControllingPower(ap);
	      if (!factions_with_units_in_space.includes(cp)) {
		factions_with_units_in_space.push(ap);
	        if (ap !== attacker && !io.includes(ap) && io[i] != attacker && !this.areAllies(this.game.state.active_faction, ap)) {
	          let units_in_space = this.returnFactionLandUnitsInSpace(ap, spacekey);
	          if (units_in_space > 0) {
	            for (let zz = 0; zz < neighbours.length; zz++) {
	              let fluis = this.canFactionRetreatToSpace(ap, neighbours[zz], attacker_comes_from_this_spacekey);
	              if (fluis > 0) {
		        let x = "player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap;
		        if (this.game.queue[this.game.queue.length-1] !== x) {
		          this.game.queue.push("player_evaluate_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap);
		          zz = neighbours.length;
	                }
	              }
	            }
	          }
	        }
	      }
	    }
	  }

          return 1;

	}

        if (mv[0] === "naval_retreat_check") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let space = "";
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }      
	  if (this.game.navalspaces[spacekey]) { space = this.game.spaces[spacekey]; }      

	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0); // 0 cannot intercept across passes
	  let attacking_player = this.returnPlayerOfFaction(attacker);

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_faction_retreat = 0;
	    let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	    if (player_of_faction != attacking_player && player_of_faction > 0) {
  	      if (io[i] !== attacker) {
	        let units_in_space = this.returnFactionSeaUnitsInSpace(io[i], spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToNavalSpace(io[i], neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
	              this.game.queue.push("player_pre_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+io[i]);
		      zz = neighbours.length;
	            }
	          }
	        }
	      }
	    }

	    for (let zz = 0; zz < this.game.state.activated_powers[io[i]].length; zz++) {
	      let ap = this.game.state.activated_powers[io[i]][zz];
	      if (ap != attacker && this.returnControllingPower(ap) != this.returnControllingPower(attacker)) {
	        let units_in_space = this.returnFactionSeaUnitsInSpace(ap, spacekey);
	        if (units_in_space > 0) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
	            let fluis = this.canFactionRetreatToNavalSpace(ap, neighbours[zz], attacker_comes_from_this_spacekey);
	            if (fluis > 0) {
		      this.game.queue.push("player_pre_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+ap);
		      zz = neighbours.length;
	            }
	          }
	        }
	      }
	    }
	  }

	  this.displaySpace(spacekey);
          return 1;

	}





        if (mv[0] === "player_evaluate_break_siege_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];

	  let player_factions = this.returnPlayerFactions(this.game.player)

	  // if no-one survived, let's skip the formalities
	  let survivors = this.returnHostileOrIndependentLandUnitsInSpace(attacker, spacekey);
	  if (survivors == 0) { return 1; }

	  if (player_factions.includes(attacker) || this.returnPlayerCommandingFaction(attacker) == this.game.player) {
	    this.playerEvaluateBreakSiegeRetreatOpportunity(attacker, spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(attacker) + " considering retreat");
	  }

	  return 0;

	}


        if (mv[0] === "player_evaluate_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = mv[4];
          let space = this.game.spaces[spacekey];
	  let all_have_lost_field_battle = true;

          //
          // you cannot retreat if besieged, so check if besieged, and one besieged unit 
          // means the whole stack is besieged
          //
          if (space.besieged > 0) {
            for (let x = 0; x < space.units[defender].length; x++) {
              if (space.units[defender][x].besieged == 1) { return 1; }
            }
          }

          for (let x = 0; x < space.units[defender].length; x++) {
	    if (space.units[defender][x].lost_field_battle == 0) { 
	      all_have_lost_field_battle = false;
	    }
	  }


          //
          // roll dice to see if avoid battle is an option
          //
	  if (!all_have_lost_field_battle) {
            let abr = this.rollDice(6) + this.rollDice(6);

            let highest_battle_rating = 0;
            if (space != null) {
              for (let i = 0; i > space.units[defender].length; i++) {
                let u = space.units[defender][i];
                if (parseInt(u.battle_rating) > highest_battle_rating) { highest_battle_rating = parseInt(u.battle_rating); }            
              }
              abr += parseInt(highest_battle_rating);
              if (abr >= 9) {
                this.updateLog(this.returnFactionName(defender) + " avoid battle roll succeeds: " + abr);
              } else {
                this.updateLog(this.returnFactionName(defender) + " avoid battle roll fails: " + abr);
                return 1;
              }
            }
          } else {
            this.updateLog(this.returnFactionName(defender) + " - routed troops may avoid battle...");
	  }

	  let player_factions = this.returnPlayerFactions(this.game.player)

	  if (player_factions.includes(defender) || this.returnPlayerCommandingFaction(defender) == this.game.player) {
	    this.playerEvaluateRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering retreat");
	  }

	  return 0;

	}

	//
	// this sticks itself into the naval_retreat process in order to allow 
	// Professional Rowers to modify values
	//
	if (mv[0] === "player_pre_evaluate_naval_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = mv[4];

	  if (defender == "" && mv[5] != "") { defender = mv[5]; }

	  this.game.state.naval_avoid_battle_bonus = 0;

	  //
	  // cannot proactively retreat from port
	  //
	  if (this.game.spaces[spacekey]) { return 1; }

	  //
	  // check if avoid battle successful - we do this so Professional Rowers can show if it matters
	  //
	  let x = this.game.dice;
	  let abr = this.rollDice(6) + this.rollDice(6);
	  this.game.dice = x;

	  if (this.game.state.events.intervention_naval_avoid_battle_possible == 1 && abr >= 7 && abr < 9) {
	    this.game.queue.push("player_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+defender);	   
            his_self.game.queue.push("counter_or_acknowledge\tPlayer Considering Professional Rowers\tnaval_avoid_battle\t"+spacekey);
            his_self.game.queue.push("RESETCONFIRMSNEEDED\tall");
	  } else {
	    this.game.queue.push("player_evaluate_naval_retreat_opportunity\t"+attacker+"\t"+spacekey+"\t"+attacker_comes_from_this_spacekey+"\t"+defender);	   
	  }

	  return 1;

	}

        if (mv[0] === "player_evaluate_naval_retreat_opportunity") {

	  this.game.queue.splice(qe, 1);


	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_comes_from_this_spacekey = mv[3];
	  let defender = mv[4];

	  //
	  // cannot proactively retreat from port
	  //
	  if (this.game.spaces[spacekey]) { return 1; }


	  // roll dice to see if avoid battle is an option -- only in sea zones
	  //
	  let abr = this.rollDice(6) + this.rollDice(6);
	  if (this.game.state.naval_avoid_battle_bonus > 0) { abr += parseInt(this.game.state.naval_avoid_battle_bonus); };
	  let highest_battle_rating = 0;
	  let space = null;

	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

	  if (space != null) {
	    for (let i = 0; i > space.units[defender].length; i++) {
	      let u = space.units[defender][i];
	      if (u.battle_rating > highest_battle_rating) { highest_battle_rating = parseInt(u.battle_rating); }	      
	    }
	    abr += highest_battle_rating;

	    if (abr >= 9) {
	      this.updateLog(this.returnFactionName(defender) + " avoid battle roll succeeds: " + abr);
	    } else {
	      this.updateLog(this.returnFactionName(defender) + " avoid battle roll fails: " + abr);
	      return 1;
	    }

	  }

	  if (this.returnPlayerCommandingFaction(defender) == this.game.player) {
	    this.playerEvaluateNavalRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering retreat");
	  }

	  return 0;

	}


	if (mv[0] === "naval_retreat") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source_spacekey = mv[2];
	  let destination_spacekey = mv[3];
	  let lockdown = 0; if (parseInt(mv[4]) > 0) { lockdown = 1; }

	  let source;
	  if (this.game.spaces[source_spacekey]) { source = this.game.spaces[source_spacekey]; }
	  if (this.game.navalspaces[source_spacekey]) { source = this.game.navalspaces[source_spacekey]; }

	  let destination;
	  if (this.game.spaces[destination_spacekey]) { destination = this.game.spaces[destination_spacekey]; }
	  if (this.game.navalspaces[destination_spacekey]) { destination = this.game.navalspaces[destination_spacekey]; }

	  for (let i = source.units[faction].length-1; i >= 0; i--) {
	    let u = source.units[faction][i];
	    if (u.land_or_sea == "sea" || u.land_or_sea == "both") {
	      if (lockdown) { u.locked = 1; }
	      destination.units[faction].push(u);
	      source.units[faction].splice(i, 1);
	    }
	  }

	  this.displaySpace(source_spacekey);
	  this.displayNavalSpace(source_spacekey);
	  this.displaySpace(destination_spacekey);
	  this.displayNavalSpace(destination_spacekey);

	  return 1;

	}



        if (mv[0] === "retreat") {

	  this.game.queue.splice(qe, 1);

	  let f = mv[1];
	  let from = mv[2];
	  let to = mv[3];

	  this.updateLog(this.returnFactionName(f) + " retreats from " + this.returnSpaceName(from) + " to " + this.returnSpaceName(to));

	  let source = this.game.spaces[from];
	  let destination = this.game.spaces[to];

	  for (let faction in source.units) {

	    if (this.returnControllingPower(faction) == f || f == faction) {

   	      for (let i = source.units[faction].length-1; i >= 0; i--) {
	        let u = source.units[faction][i];
	        if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.army_leader == true || u.navy_leader == true) {
	          source.units[faction][i].locked = 1;
	          source.units[faction][i].already_moved = true;
	          if (source.units[faction][i].besieged != 1) {
	            destination.units[faction].push(source.units[faction][i]);
	            source.units[faction].splice(i, 1);
	          }
	        }
	      }
	    }
	  }

	  this.displaySpace(from);
	  this.displaySpace(to);

          return 1;
	}


        if (mv[0] === "interception_check") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let includes_cavalry = parseInt(mv[3]);

	  let space = this.game.spaces[spacekey];
	  let neighbours = this.returnNeighboursAsArrayOfKeys(spacekey, 0); // 0 cannot intercept across passes
	  let attacking_player = this.returnPlayerCommandingFaction(faction);

	  let already_asked = [];

	  //
	  // faction is set to skip in move if no-one should be able to intercept
	  // such as if I am moving into a space in which I already have units.
	  //
	  if (faction == "skip") {
	    return 1;  
	  }

	  //
	  // players cannot be intercepted moving into friendly, fortified spaces
	  //
	  if (this.isSpaceFriendly(spacekey, faction) && this.isSpaceFortified(spacekey)) {
	    return 1;
	  }

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    let can_this_faction_enter = false;
	    if (this.areEnemies(io[i], faction)) {
	      let fac = this.returnFactionControllingSpace(spacekey);
	      if (fac != faction && fac != io[i]) {
	        if (this.areAllies(io[i], fac)) { can_this_faction_enter = true; }
	      } else {
		can_this_faction_enter = true;
	      }
	    }

	    if (this.areEnemies(io[i], faction)) {

	      let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	      if (player_of_faction != attacking_player && player_of_faction != 0) {
  	        if (io[i] !== faction) {

		  let player_needs_adding = 0;

	          for (let zz = 0; zz < neighbours.length; zz++) {
		    if (neighbours[zz] != spacekey) {
	              let fluis = this.returnFactionLandUnitsInSpace(io[i], neighbours[zz]);
	              if (fluis > 0) {
		        if (!already_asked.includes(his_self.returnPlayerCommandingFaction(io[i])) && !already_asked.includes(neighbours[zz])) {
	                  this.game.queue.push("player_evaluate_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+includes_cavalry+"\t"+io[i]+"\t"+neighbours[zz]);
	  	          already_asked.push(neighbours[zz]);
		          player_needs_adding = 1;
		        }
	              }
	            }
	          }
		  if (player_needs_adding) {
	  	    already_asked.push(his_self.returnPlayerCommandingFaction(io[i]));
	          }
	        }
	      }
	    }

	    for (let zzz = 0; zzz < this.game.state.activated_powers[io[i]].length; zzz++) {
	      let ap = this.game.state.activated_powers[io[i]][zzz];
	      if (this.areEnemies(ap, faction)) {
	        if (ap != faction && !already_asked.includes(ap)) {
	          for (let zz = 0; zz < neighbours.length; zz++) {
		    if (neighbours[zz] != spacekey) {
	              let fluis = this.returnFactionLandUnitsInSpace(ap, neighbours[zz]);
	              if (fluis > 0 && this.game.spaces[neighbours[zz]].unrest != 1) {
		        if (!already_asked.includes(his_self.returnPlayerCommandingFaction(ap)) && !already_asked.includes(neighbours[zz])) {
	                  this.game.queue.push("player_evaluate_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+"0"+"\t"+ap+"\t"+neighbours[zz]);
	  	          already_asked.push(neighbours[zz]);
	                }
	              }
	            }
	          }
	        }
	  	already_asked.push(ap);
	      }
	    }
	  }
          return 1;
	}


        if (mv[0] === "naval_interception_check") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];

	  let neighbours = this.returnNavalAndPortNeighbours(spacekey);
	  let attacking_player = this.returnPlayerCommandingFaction(faction);

	  //
	  // interception at port is not possible
	  //
	  if (this.game.spaces[spacekey]) { return 1; }

	  //
	  //
	  //
	  if (this.game.navalspaces[spacekey]) {

	    //
	    // you can't be intercepted moving into a space where you have units
	    // or where you have allies...
	    //
	    let are_my_allies_already_in_this_space = false;
	    let s = this.game.navalspaces[spacekey].units;

	    for (let f in s.units) {
	      if (this.areAllies(f, faction) && f != faction) {
		if (this.returnFactionNavalUnitsInSpace(f, spacekey, true) > 0) {  // true = include minor allies
		  are_my_allies_already_in_this_space = true;
		}
	      }
	    }

	    if (!are_my_allies_already_in_this_space) {
	      let io = this.returnImpulseOrder();
	      for (let i = io.length-1; i>= 0; i--) {
	        if (this.areEnemies(io[i], faction)) {
	          let player_of_faction = this.returnPlayerCommandingFaction(io[i]);
	          if (player_of_faction != attacking_player && player_of_faction != 0) {
  	            if (io[i] !== faction) {
	              for (let zz = 0; zz < neighbours.length; zz++) {
	                let fluis = this.returnFactionSeaUnitsInSpace(io[i], neighbours[zz], 1);
	                if (fluis > 0) {

			  //
			  // we've found neighbouring enemies, but they can't intercept if the 
			  // power moving (faction) also has units in their neighbouring space
			  //
	                  fluis = this.returnFactionSeaUnitsInSpace(faction, neighbours[zz], 1);

			  if (fluis == 0) {
	                    this.game.queue.push("player_evaluate_naval_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+io[i]+"\t"+neighbours[zz]);
	                  }

	                }
	              }
	            }
	          }
	        }
	        for (let z = 0; z < this.game.state.activated_powers[io[i]].length; z++) {
	          let ap = this.game.state.activated_powers[io[i]][z];
	          if (this.areEnemies(ap, faction)) {
	            if (ap != faction) {
	              for (let zz = 0; zz < neighbours.length; zz++) {
	                let fluis = this.returnFactionSeaUnitsInSpace(ap, neighbours[zz], 1);
	                if (fluis > 0) {
			  //
			  // we've found neighbouring enemies, but they can't intercept if the 
			  // power moving (faction) also has units in their neighbouring space
			  //
	                  fluis = this.returnFactionSeaUnitsInSpace(faction, neighbours[zz], 1);

			  if (fluis == 0) {
	                    this.game.queue.push("player_evaluate_naval_interception_opportunity\t"+faction+"\t"+spacekey+"\t"+ap+"\t"+neighbours[zz]);
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	    }

	  }

          return 1;
	}


        if (mv[0] === "player_evaluate_naval_interception_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = mv[3];
	  let defender_spacekey = mv[4];

          let controller_of_defender = this.returnPlayerCommandingFaction(defender);
          if (controller_of_defender == 0) { return 1; }
 
	  let invaded_space = this.game.spaces[spacekey];
	  if (this.game.navalspaces[spacekey]) { invaded_space = this.game.navalspaces[spacekey]; }

	  //
	  // you cannot intercept if the space contains hostile ships other than
	  // the faction/alliance you are trying to intercept
	  //
	  for (let f in invaded_space.units) {
	    let cf = this.returnControllingPower(f);
	    if (this.areEnemies(cf, defender)) {
	      if (this.returnFactionNavalUnitsInSpace(cf, spacekey, true) > 0) {
	        if (this.returnControllingPower(cf) != this.returnControllingPower(attacker)) {
		  return 1;
	        }
	      }
	    }
	  }

          if (this.game.player == controller_of_defender) {
	    this.playerEvaluateNavalInterceptionOpportunity(attacker, spacekey, defender, defender_spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering naval interception from " + this.returnSpaceName(defender_spacekey));
	  }

	  return 0;

	}


        if (mv[0] === "player_evaluate_interception_opportunity") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_includes_cavalry = mv[3];
	  let defender = mv[4];
	  let defender_spacekey = mv[5];
	  let controller_of_defender = this.returnPlayerCommandingFaction(defender);
	  let controller_of_attacker = this.returnPlayerCommandingFaction(attacker);
	  let invaded_space = this.game.spaces[spacekey];
	  let defender_space = this.game.spaces[defender_spacekey];

	  //
	  // you cannot intercept if besieged, so check if besieged, and one besieged unit
	  // means the whole stack is besieged
	  //
	  if (defender_space.besieged > 0) {
	    for (let x = 0; x < defender_space.units[defender].length; x++) {
	      if (defender_space.units[defender][x].besieged == 1) { return 1; }
	    }
	  }

	  //
	  // you cannot intercept if the space contains independent units
	  //
	  if (invaded_space.units["independent"].length > 0) { return 1; }

	  //
	  // you cannot intercept if the land units in the space belong to a power
	  // that is not allied to you. an example is Haps being at war with France
	  // and being invited to intercept if the French invade a space with 
	  // British regulars, but England and Haps are not allies.
	  //
	  for (let f in invaded_space.units) {
	    if (this.returnFactionLandUnitsInSpace(f, invaded_space.key) > 0) {
	      if (!this.areAllies(f, attacker) && f != attacker) {
		if (!this.areAllies(f, defender) && f != defender) { 
		  return 1;
		}
	      }
	    }
	  }

	  //
	  // you cannot intercept if the space is controlled by non-ally and non-enemy
	  //
	  let fcs = this.returnFactionControllingSpace(invaded_space.key);
	  if (!this.areAllies(fcs, defender, 1) &&  !this.areEnemies(fcs, defender, 1)) { return 1; }

	  //
	  // protestants can't intercept before the League forms
	  //
	  if (defender === "protestant" && this.game.state.events.schmalkaldic_league != 1) {
	    return 1;
	  }

	  if (controller_of_defender == 0) { return 1; }
	  if (controller_of_defender == controller_of_attacker) { return 1; }

	  if (this.game.player == controller_of_defender) {
	    this.playerEvaluateInterceptionOpportunity(attacker, spacekey, attacker_includes_cavalry, defender, defender_spacekey);
	  } else {
	    this.updateStatus(this.returnFactionName(defender) + " considering interception from " + this.returnSpaceName(defender_spacekey));
	  }

	  return 0;

	}


        if (mv[0] === "intercept") {

	  this.game.queue.splice(qe, 1);

	  //
	  // in case we had it open to intercept
	  //
	  this.movement_overlay.hide();

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let attacker_includes_cavalry = parseInt(mv[3]);
	  let defender = mv[4];
	  let defender_spacekey = mv[5];
	  let units_to_move_idx = JSON.parse(mv[6]); // is actually obj now
	  let units_to_move = [];

	  //
	  // load actual units to examine them for cavalry, leaders
	  //
	  let s = this.game.spaces[defender_spacekey];
          for (let i = 0; i < units_to_move_idx.length; i++) {
	    units_to_move.push(s.units[units_to_move_idx[i].faction][units_to_move_idx[i].idx]);
	  }

	  if (units_to_move.length == 0) {
	    this.updateLog("no units sent to intercept...");
	    return 1;
	  }

	  let hits_on = 9;
	  let defender_has_cavalry = 0;
	  let defender_highest_battle_rating = 0;

	  for (let i = 0; i < units_to_move.length; i++) {
	    if (units_to_move[i].type === "cavalry") { defender_has_cavalry = 1; }
	    if (units_to_move[i].battle_rating > defender_highest_battle_rating) {
	      defender_highest_battle_rating = units_to_move[i].battle_rating;
	    }
	  }

	  this.updateLog(this.returnFactionName(defender) + " moves to intercept from " + this.returnSpaceName(defender_spacekey));

	  if (attacker === "ottoman" && attacker_includes_cavalry) {
	    this.updateLog("Ottoman +1 cavalry bonus");
	    hits_on++;
	  }
	  if (defender === "ottoman" && defender_has_cavalry) {
	    this.updateLog("Ottoman -1 cavalry bonus");
	    hits_on--;
	  }
	  if (defender_highest_battle_rating > 0) {
	    this.updateLog(this.returnFactionName(defender) + " gains " + defender_highest_battle_rating + " bonus from formation leader");
	    hits_on -= defender_highest_battle_rating;
	  }

	  let d1 = this.rollDice(6);
	  let d2 = this.rollDice(6);
	  let dsum = d1+d2;

	  this.updateLog("Interception roll #1: " + d1);
	  this.updateLog("Interception roll #2: " + d2);

	  if (dsum >= hits_on) {

	    try { salert(`${this.returnFactionName(defender)} Interception Succeeds!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Interception Succeeds!`);

	    //
	    // insert at end of queue by default
	    //
	    let index_to_insert_moves = this.game.queue.length-1;

	    //
	    // BUT NO OTHER POWER CAN INTERCEPT, SO CLEAN OUT GAME QUEUE
	    //
	    for (let i = this.game.queue.length-1; i >= 0; i--) {
	      let lqe = this.game.queue[i];
	      let lmv = lqe.split("\t");
	      if (lmv[0] !== "player_evaluate_interception_opportunity") {
	        index_to_insert_moves = i;
		break;
	      } else {
	        if (lmv[4] !== defender) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		}
	      }
	    }

	    //
	    // SUCCESS - move and continue to evaluate interception opportunities
	    //
	    let factions = {};
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      factions[units_to_move_idx[i].faction] = [];
	      for (let z = 0; z < 100; z++) { factions[units_to_move_idx[i].faction].push(""); }
	    }
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      let m = "move\t"+units_to_move_idx[i].faction+"\tland\t"+defender_spacekey+"\t"+spacekey+"\t"+units_to_move_idx[i].idx+"\t1\t1"; // 1 = skip avoid battle, 1 = is interception
	      factions[units_to_move_idx[i].faction][units_to_move_idx[i].idx] = m;
	    }

	    for (let f in factions) {
	      for (let z = 99; z >= 0; z--) {
		if (factions[f][z] != "") {
	          his_self.game.queue.splice((index_to_insert_moves+1), 0, factions[f][z]);
		}
	      }
	    }

	    let m = "lock\t"+defender+"\t"+spacekey; // 1 = skip avoid battle
	    his_self.game.queue.splice((index_to_insert_moves+1), 0, m);
	    his_self.game.queue.splice((index_to_insert_moves+1), 0, ("field_battle\t"+spacekey+"\t"+attacker));

	  } else {
	    try { salert(`${this.returnFactionName(defender)} Interception Fails!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Interception Fails!`);
	  }

	  return 1;

	}




        if (mv[0] === "naval_intercept") {

	  this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let defender = mv[3];
	  let defender_spacekey = mv[4];
	  let units_to_move_idx = JSON.parse(mv[5]); // should be array of objs with idx /faction
	  let units_to_move = [];

	  //
	  // load actual units to examine them for squadrons, corsairs, navy leaders
	  //
	  let s;
	  if (this.game.spaces[defender_spacekey]) {
	    s = this.game.spaces[defender_spacekey];
	  }
	  if (this.game.navalspaces[defender_spacekey]) {
	    s = this.game.navalspaces[defender_spacekey];
	  }

          for (let i = 0; i < units_to_move_idx.length; i++) {
	    if (units_to_move_idx[i].faction) {
  	      units_to_move.push(s.units[units_to_move_idx[i].faction][units_to_move_idx[i].idx]);
	    } else {
  	      units_to_move.push(s.units[defender][units_to_move_idx[i]]);
	    }
	  }

	  if (units_to_move.length == 0) {
	    this.updateLog("no units sent to intercept...");
	    return 1;
	  }

	  let hits_on = 9;
	  let defender_highest_battle_rating = 0;

	  for (let i = 0; i < units_to_move.length; i++) {
	    if (units_to_move[i].battle_rating > defender_highest_battle_rating) {
	      defender_highest_battle_rating = units_to_move[i].battle_rating;
	    }
	  }

	  this.updateLog(this.returnFactionName(defender) + " navy moves to intercept from " + this.returnSpaceName(defender_spacekey));
	  if (defender_highest_battle_rating > 0) {
	    this.updateLog(this.returnFactionName(defender) + " gains " + defender_highest_battle_rating + " bonus from navy leader");
	  }



	  let d1 = this.rollDice(6);
	  let d2 = this.rollDice(6);
	  let dsum = d1+d2;
	  dsum += defender_highest_battle_rating;

	  this.updateLog("Interception roll #1: " + d1);
	  this.updateLog("Interception roll #2: " + d2);

	  if (this.game.state.naval_intercept_bonus > 0) {
	    this.updateLog("Naval Intercept Bonus: " + this.game.state.naval_intercept_bonus);
	    dsum += this.game.state.naval_intercept_bonus;
	  }
	  // and undo so as not to affect future intercepts
	  this.game.state.naval_intercept_bonus = 0;

	  //
	  // or move if successful !
	  //
	  if (dsum >= hits_on) {

	    try { salert(`${this.returnFactionName(defender)} Naval Interception Succeeds!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Naval Interception Succeeds!`);

	    //
	    // insert at end of queue by default
	    //
	    let index_to_insert_moves = this.game.queue.length-1;

	    //
	    // NO OTHER POWER CAN INTERCEPT, SO CLEAN OUT GAME QUEUE FOR THIS DESTINATION
	    //
	    for (let i = this.game.queue.length-1; i >= 0; i--) {
	      let lqe = this.game.queue[i];
	      let lmv = lqe.split("\t");
	      if (lmv[0] !== "player_evaluate_naval_interception_opportunity") {
	        index_to_insert_moves = i;
		break;
	      } else {
	        if (lmv[2] != spacekey) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		  i--; // queue is 1 shorter
	          index_to_insert_moves = i;
		  break;
		}
	        if (lmv[3] !== defender) {
		  this.game.queue.splice(i, 1); // remove 1 at i
		  i--; // queue is 1 shorter
	        }
	      }
	    }


	    //
	    // SUCCESS - move and continue to evaluate interception opportunities
	    //
	    let factions = {};
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      factions[units_to_move_idx[i].faction] = [];
	      for (let z = 0; z < 100; z++) {
	        factions[units_to_move_idx[i].faction].push("");
	      }
	    }
	    for (let i = 0; i < units_to_move_idx.length; i++) {
	      let m = "move\t"+units_to_move_idx[i].faction+"\t"+"sea"+"\t"+defender_spacekey+"\t"+spacekey+"\t"+units_to_move_idx[i].idx+"\t"+"1"+"\t"+"1"; // 1 = skip avoid battle, 1 = skip interceptions
	      factions[units_to_move_idx[i].faction][units_to_move_idx[i].idx] = m;
	    }

	    let nb_inserted = false;
	    for (let f in factions) {
	      for (let z = 100; z >= 0; z--) {
		if (factions[f][z] !== "" && factions[f][z] != undefined) {
	          his_self.game.queue.splice((index_to_insert_moves+1), 0, factions[f][z]);
		}
	      }
	    }

	    //
	    // we have just created a naval battle, so add to queue
	    //
	    if (nb_inserted == false) {
	      nb_inserted = true;
	      his_self.game.queue.splice((index_to_insert_moves+1), 0, "naval_battle\t"+spacekey+"\t"+attacker+"\t"+defender);
	    }

	  } else {
	    try { salert(`${this.returnFactionName(defender)} Naval Interception Fails!`); } catch (err) {}
	    this.updateLog(`${this.returnFactionName(defender)} Naval Interception Fails!`);
	    //
	    // lock ships to prevent trying again elsewhere
	    //
	    if (this.game.spaces[defender_spacekey]) {
	      for (let z = 0; z < units_to_move_idx.length; z++) {
	        this.game.spaces[defender_spacekey].units[units_to_move_idx[z].faction][units_to_move_idx[z].idx].locked = 1;  
	      }
	    }
	    if (this.game.navalspaces[defender_spacekey]) {
	      for (let z = 0; z < units_to_move_idx.length; z++) {
	        this.game.navalspaces[defender_spacekey].units[units_to_move_idx[z].faction][units_to_move_idx[z].idx].locked = 1;  
	      }
	    }

	  }

	  return 1;

	}

        if (mv[0] === "diet_of_worms_hapsburgs") {

	  this.factionbar.setActive("hapsburg");
	  this.game.queue.splice(qe, 1);

	  let game_self = this;
	  let x = [];
          let fhand_idx = 0;
          if (this.game.player == this.returnPlayerCommandingFaction("hapsburg")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "hapsburg");
	  } else {
            this.updateStatusAndListCards("Hapsburgs Selecting Card for the Diet of Worms", this.game.deck[0].fhand[0], () => {});
            return 0;
	  }

	  for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (this.game.deck[0].cards[this.game.deck[0].fhand[fhand_idx][i]].type === "mandatory") {
	    } else {
	      x.push(this.game.deck[0].fhand[fhand_idx][i]);
	    }
	  }

	  if (this.game.player === this.returnPlayerCommandingFaction("hapsburg")) {
            this.updateStatusAndListCards("Hapsburgs - Select Card to indicate your Commitment to Debate", x);
            this.attachCardboxEvents(async function(card) {
	      game_self.game_help.hide();
              game_self.updateStatus("You picked: " + game_self.deck[card].name);
              game_self.addMove("discard\thapsburg\t"+card);
              game_self.addMove("diet_of_worms_hapsburg_resolve\t"+card);
              game_self.endTurn();
            });
	  } else {
            this.updateStatusAndListCards("Hapsburgs Selecting Card for the Diet of Worms", x, () => {});
	  }

	  return 0;

	}

        if (mv[0] === "diet_of_worms_hapsburg_resolve") {

	  let card = mv[1];
	  this.game.state.sp.push(card);
	  this.game.queue.splice(qe, 1);
          return 1;

	}

        if (mv[0] === "diet_of_worms_faction_check") {

	  this.game.queue.splice(qe, 1);

	  let fa_idx = -1;
	  for (let i = this.game.queue.length-1; i >= 0; i--) {
	    let lmv  = this.game.queue[i].split("\t");
	    if (lmv[0] === "diet_of_worms_faction_array") {
	      fa_idx = i;
	    }
	  }
	  if (fa_idx >= 0) {
	    for (let i = this.game.queue.length-1; i > fa_idx && i >= 0; i--) {
	      if (this.game.queue[i].split("\t")[0] === "SIMULTANEOUS_PICK") {
	        let x = this.game.queue[i];
		this.game.queue.splice(i, 1);
		this.game.queue.splice(fa_idx, 0, x);
		fa_idx++;
	      }
	    }
	  }

	  return 1;

	}

        if (mv[0] === "diet_of_worms_faction_array") {

	  let remove_from_queue = 0;
	  if (parseInt(mv[1])) { remove_from_queue = 1; }

	  if (remove_from_queue) {
	    this.game.queue.splice(this.game.queue.length-1, 1);
	  }

	  this.factionbar.setActive(["protestant","papacy"]);

	  //
	  // skip if we have already confirmed!
	  //
          let have_i_resolved = false;
	  if (this.game.confirms_needed[this.game.player-1] == 0) {
	    have_i_resolved = true;
	  } else {
            if (this.game.tmp_confirm_sent == 1) {
              have_i_resolved = true;
            } else {
              if (await this.hasMyResolvePending()) {
                have_i_resolved = true;
              }
            }
	  }
	  if (have_i_resolved == true) { return 0; }

	  //
	  // if we haven't done this already...
	  //
	  if (this.moves.length == 0) {
	    this.addMove("RESOLVE\t"+this.publicKey);
	  }

	  let game_self = this;
	  let my_faction = "";

	  this.displayCardsLeft();

          //
          // remove mandatory events from both hands
	  //
	  let x = [];
          let fhand_idx = 0;
          if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "papacy");
	    my_faction = "Papacy";
	  }
          if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
	    fhand_idx = this.returnFactionHandIdx(this.game.player, "protestant");
	    my_faction = "Protestants";
	  }
	  for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	    if (this.game.deck[0].cards[this.game.deck[0].fhand[fhand_idx][i]].type === "mandatory") {
	    } else {
	      x.push(this.game.deck[0].fhand[fhand_idx][i]);
	    }
	  }

	  if (this.game.player != this.returnPlayerCommandingFaction("papacy") && this.game.player != this.returnPlayerCommandingFaction("protestant")) {

            this.updateStatusAndListCards("Protestants and Papacy assemble at the Diet of Worms", x, () => {});

            let hash1 = game_self.app.crypto.hash("");    // my card
            let hash2 = game_self.app.crypto.hash(Math.random().toString());  // my secret
            let hash3 = game_self.app.crypto.hash(hash2 + hash1);             // combined hash

	    let privateKey = await game_self.app.wallet.getPrivateKey();

            let card_sig = game_self.app.crypto.signMessage("", privateKey);
            let hash2_sig = game_self.app.crypto.signMessage(hash2, privateKey);
            let hash3_sig = game_self.app.crypto.signMessage(hash3, privateKey);

            game_self.game.spick_card = "";
            game_self.game.spick_hash = hash2;

            game_self.addMove("SIMULTANEOUS_PICK\t"+game_self.game.player+"\t"+hash3+"\t"+hash3_sig);
            game_self.addMove("diet_of_worms_faction_check");
            game_self.endTurn();

	  } else {

	    if (game_self.game.spick_card != "") {
	      for (let i = 0; i < x.length; i++) {
	        if (x[i] === game_self.game.spick_card) { 
		  x.splice(i, 1); 
		}
	      }
              this.updateStatusAndListCards("Waiting for Opponent(s) to Pick Cards", [], () => {});
	      return 0;
	    }

            this.updateStatusAndListCards(my_faction + " - Select Card to indicate your Commitment to Debate", x);
            this.attachCardboxEvents(async function(card) {

	      //for (let i = 0; i < x.length; i++) { if (x[i] == card) { x.splice(i, 1); } }
              //game_self.updateStatusAndListCards(my_faction + " - Card Selected", x);

  	      //
	      // hide triangular help if game start -- papacy and other factions
	      //
	      game_self.game_help.hide();

              game_self.updateStatus("You picked: " + game_self.deck[card].name);

              let hash1 = game_self.app.crypto.hash(card);    // my card
              let hash2 = game_self.app.crypto.hash(Math.random().toString());  // my secret
              let hash3 = game_self.app.crypto.hash(hash2 + hash1);             // combined hash

	      let privateKey = await game_self.app.wallet.getPrivateKey();

              let card_sig = game_self.app.crypto.signMessage(card, privateKey);
              let hash2_sig = game_self.app.crypto.signMessage(hash2, privateKey);
              let hash3_sig = game_self.app.crypto.signMessage(hash3, privateKey);

              game_self.game.spick_card = card;
              game_self.game.spick_hash = hash2;
 
              game_self.addMove("SIMULTANEOUS_PICK\t"+game_self.game.player+"\t"+hash3+"\t"+hash3_sig);
              game_self.addMove("diet_of_worms_faction_check");
              game_self.endTurn();

            });
	  }

          return 0;
        }


	if (mv[0] === "resolve_diet_of_worms") {

	  this.game.queue.splice(qe, 1);

	  let protestant = this.returnPlayerOfFaction("protestant");
	  let papacy = this.returnPlayerOfFaction("papacy");
	  let protestant_arolls = [];
	  let papacy_arolls = [];

	  let all_players_but_protestant = [];
	  let all_players_but_papacy = [];
          for (let i = 1; i <= this.game.players.length; i++) {
	    if (i != protestant) { all_players_but_protestant.push(i); }
	    if (i != papacy) { all_players_but_papacy.push(i); }
	  }

	  let protestant_card = this.game.deck[0].cards[this.game.state.sp[protestant-1]];
	  let papacy_card = this.game.deck[0].cards[this.game.state.sp[papacy-1]];
	  let hapsburg_card = "";
	  if (this.game.players.length == 2) {
	    hapsburg_card = this.game.pool[0].hand[0];
	  } else {
	    hapsburg_card = this.game.state.sp[this.game.state.sp.length-1]; // hapsburgs added to last slot
	  }

	  this.updateLog("*************************");
	  this.updateLog("*** The Diet of Worms ***");
	  this.updateLog("*************************");
	  this.updateLog("Protestants select: " + this.popup(this.game.state.sp[protestant-1]));
	  this.updateLog("Papacy selects: " + this.popup(this.game.state.sp[papacy-1]));
	  this.updateLog("Hapsburgs select: " + this.popup(hapsburg_card));

	  //
	  // show card in overlay
	  //
	  this.diet_of_worms_overlay.render();
	  this.diet_of_worms_overlay.addCardToCardfan(this.game.state.sp[protestant-1], "protestant");
	  this.diet_of_worms_overlay.addCardToCardfan(this.game.state.sp[papacy-1], "catholic");
	  this.diet_of_worms_overlay.addCardToCardfan(hapsburg_card, "catholic");

	  //
	  // discard the selected cards
	  //
	  this.game.queue.push("discard\tprotestant\t"+this.game.state.sp[protestant-1]);
	  this.game.queue.push("discard\tpapacy\t"+this.game.state.sp[papacy-1]);
	  this.game.queue.push("discard\tall\t"+hapsburg_card);


	  //
	  // 3. roll protestant dice: The Protestant player adds 4 to the CP value of his card.
	  // This total represents the number of dice he now rolls. Each roll of a â5â or a â6â
	  // is considered to be a hit.
	  //
	  // 4. roll papal and Hapsburg dice: The Papal player rolls a num- ber of dice equal to
	  // the CP value of his card. The Hapsburg player does the same. Each roll of a â5â or a
	  // â6â is considered to be a hit. These two powers combine their hits into a Catholic total.
	  //
	  // 5. protestant victory: If the number of Protestant hits exceeds the number of Catholic
	  // hits, the Protestant power flips a number of spaces equal to the number of extra hits he
	  // rolled to Protestant influence. All spaces flipped must be in the German language zone.
	  // Spaces flipped must be adjacent to another Protestant space; spaces that were just
	  // flipped in this step can be used as the required adjacent Protestant space.
	  //
	  // 6. Catholic Victory: If the number of Catholic hits exceeds the number of Protestant hits,
	  // the Papacy flips a number of spaces equal to the number of extra hits he rolled to Catholic
	  // influence. All spaces flipped must be in the German language zone. Spaces flipped must be
	  // adjacent to another Catholic space; spaces that were just flipped in this step can be used
	  // as the required adjacent Catholic space.
	  //

	  let protestant_rolls = protestant_card.ops + 4;
	  let protestant_hits = 0;

	  for (let i = 0; i < protestant_rolls; i++) {
	    let x = this.rollDice(6);
	    protestant_arolls.push(x);
	    if (x >= 5) { protestant_hits++; }
	  }

	  let papacy_rolls = papacy_card.ops;
	  let papacy_hits = 0;

	  for (let i = 0; i < papacy_rolls; i++) {
	    let x = this.rollDice(6);
	    papacy_arolls.push(x);
	    if (x >= 5) { papacy_hits++; }
	  }

 	  if (this.game.deck[0].cards[hapsburg_card].type != "mandatory") {
	    for (let i = 0; i < this.game.deck[0].cards[hapsburg_card].ops; i++) {
	      papacy_rolls++;
	      let x = this.rollDice(6);
	      papacy_arolls.push(x);
	      if (x >= 5) { papacy_hits++; }
	    }
	  } else {
	    for (let i = 0; i < 2; i++) {
	      papacy_rolls++;
	      let x = this.rollDice(6);
	      papacy_arolls.push(x);
	      if (x >= 5) { papacy_hits++; }
	    }
	  }

	  this.updateLog("Protestants ("+protestant_hits+") vs. Catholics ("+papacy_hits+")");

	  if (protestant_hits > papacy_hits) {
	    this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "protestant" , difference : (protestant_hits - papacy_hits) , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	    this.game.queue.push("hide_overlay\ttheses");
	    let total_conversion_attempts = protestant_hits - papacy_hits;
	    for (let i = 1; i <= total_conversion_attempts && i <= this.returnNumberOfCatholicSpacesInLanguageZone("", 1); i++) {
	      this.game.queue.push("select_for_protestant_conversion\tprotestant\tgerman");
	    }
  	    this.game.queue.push("STATUS\tProtestants selecting towns to convert...\t"+JSON.stringify(all_players_but_protestant));
  	    this.game.queue.push("show_overlay\ttheses");
  	    this.game.queue.push("ACKNOWLEDGE\tProtestants win Diet of Worms");
	  } else {
	    if (protestant_hits < papacy_hits) {
	      this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "papacy" , difference : (papacy_hits - protestant_hits) , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	      this.game.queue.push("hide_overlay\ttheses");
	      let total_conversion_attempts = papacy_hits - protestant_hits;
	      for (let i = 1; i <= total_conversion_attempts && i <= this.returnNumberOfProtestantSpacesInLanguageZone("", 1); i++) {
	        this.game.queue.push("select_for_catholic_conversion\tpapacy\tgerman");
	      }
  	      this.game.queue.push("STATUS\tPapacy selecting towns to convert...\t"+JSON.stringify(all_players_but_papacy));
  	      this.game.queue.push("show_overlay\ttheses");
  	      this.game.queue.push("ACKNOWLEDGE\tPapacy wins Diet of Worms");
	    } else {
  	      //
              // report results
              //
	      this.updateLog("Diet of Worms ends in tie.");
	      this.diet_of_worms_overlay.showResults({ protestant_hits : protestant_hits , papacy_hits : papacy_hits , winner : "none" , difference : 0 , protestant_rolls : protestant_arolls , papacy_rolls : papacy_arolls });
  	      this.game.queue.push("ACKNOWLEDGE\tDiet of Worms ends in a Stalemate");
	    }
	  }

          return 1;

	}

	if (mv[0] === "insert_before_counter_or_acknowledge") {

          this.game.queue.splice(qe, 1);

	  let insert = "";
	  for (let i = 1; i < mv.length; i++) {
	    if (i > 1) { insert += "\t"; }
	    insert += mv[i];
	  }

	  for (let i = this.game.queue.length-1; i >= 0; i--) {
	    let lqe = this.game.queue[i];
	    let lmv = lqe.split("\t");
	    // c_or_a can be swapped out for halted
	    if (lmv[0] === "HALTED" || lmv[0] === "counter_or_acknowledge") {
	      this.game.queue.splice(i, 0, insert);
	      i = 0;
	    }
	  }

	  return 1;

        }

	//
	// exists to be removed by counter_or_acknowledge -- TODO check if still needed
	//
	if (mv[0] === "halted") {
	  this.updateStatus("acknowledged...");
	  return 0;
	}

	if (mv[0] === "counter_or_acknowledge") {

          let my_specific_game_id = this.game.id;

	  //
	  //
	  //
	  this.unbindBackButtonFunction();

	  //
	  // hide any cardbox
	  //
	  this.cardbox.hide();

	  //
	  // if i have already confirmed, we only splice and pass-through if everyone else has confirmed
	  // otherwise we will set ack to 0 and return 0 which halts execution. so we should never clear 
	  // splice anything out except here...
	  //
	  let have_i_resolved = false;
	  if (this.game.confirms_needed[this.game.player-1] == 0) {
	    have_i_resolved = true;
	  } else {
	    if (this.game.tmp_confirm_sent == 1) { 
	      have_i_resolved = true;
	    } else {
	      if (await this.hasMyResolvePending()) {
	        have_i_resolved = true;
	      }
	    }
	  }

	  //
	  //
	  //
	  let unresolved_players = [];
	  if (have_i_resolved == true) {

	    let ack = 1;

	    for (let i = 0; i < this.game.confirms_needed.length; i++) {
	      if (this.game.confirms_needed[i] >= 1) { 
		unresolved_players.push(this.game.players[i]);
		ack = 0;
	      }
	    }

	    //
	    // if everyone has returned, splice out counter_or_acknowledge
 	    // and continue to the next move on the game queue
	    //
	    if (ack == 1) { 
	      this.game.queue.splice(qe, 1);
	    }

	    this.updateStatus("acknowledged");
	    return ack;
	  }


	  //
	  // if we get this far i have not confirmed and others may or may
	  // not have confirmed, but we want at least to check to see wheter
	  // i want to just click ACKNOWLEDGE or take an action that might
	  // affect future gameplay (such as playing a card)....
	  //
	  let msg = mv[1];
	  let stage = "";
	  if (mv[2]) { stage = mv[2]; }
	  let extra = "";
	  if (mv[3]) { extra = mv[3]; }

	  //
	  // this is run when players have the opportunity to counter
	  // or intercede in a move made by another player. we cannot
	  // automatically handle without leaking information about
	  // game state, so we let players determine themselves how to
	  // handle. if they are able to, they can respond. if not they
	  // click acknowledge and the msg counts as notification of an
	  // important game development.
	  //
	  let his_self = this;

	  let html = '<ul>';

	  let menu_index = [];
	  let menu_triggers = [];
	  let attach_menu_events = 0;

    	  html += '<li class="option" id="ok">acknowledge</li>';

          let z = this.returnEventObjects();
	  for (let i = 0; i < z.length; i++) {

	    //
	    // maybe event has been removed, will fail
	    //
	    try {

	      if (z[i].key !== this.game.state.active_card) {
                if (z[i].menuOptionTriggers(this, stage, this.game.player, extra) == 1) {
                  let x = z[i].menuOption(this, stage, this.game.player, extra);
		  if (x.html) {
                    html += x.html;
	            z[i].faction = x.faction;
	            menu_index.push(i);
	            menu_triggers.push(x.event);
	            attach_menu_events = 1;
	          }
	        }
	      }

	    } catch (err) {
	      console.log("caught error looking for event: " + JSON.stringify(err));
	    }

	  }
	  html += '</ul>';

	  //
	  // skipping, and no options for active player -- skip completely
	  //
	  if (this.game.state.skip_counter_or_acknowledge == 1) {
	    if (attach_menu_events == 0) {
	      his_self.game.tmp_confirm_sent = 1;
	      his_self.game.confirms_needed[his_self.game.player-1] = 1;
              his_self.addMove("RESOLVE\t"+his_self.publicKey);
              his_self.endTurn();
	      his_self.updateStatus("skipping acknowledge...");
	      return 0;
	    }
	  }

	  //
	  // in faster_play mode, we will switch to HALTED if there are 
	  // no other options. this halts OUR game but allows others to continue
	  // to play more rapidly, which helps speed-up games where network connections
	  // can be a little slow, at the cost of leaking a small amount of information
	  // about player hands from the speed of the response (i.e. a fast response 
	  // likely means an automatic response, which likely means no cards permitting
	  // intervention are in-hand.
	  //
	  if (this.faster_play == 1 && menu_index.length == 0 && attach_menu_events != 1 && this.isGameHalted() != 1) {

	    //
	    // we don't need to HALT the game because the game will not progress
	    // until all players have hit RESOLVE anyway. 
	    //
	    his_self.halted = 1;
            his_self.game.queue[his_self.game.queue.length-1] = "HALTED\tWaiting for Game to Continue\t"+his_self.publicKey;
            his_self.hud.back_button = false;

      	    let html = '<ul><li class="option" id="ok">acknowledge</li></ul>';
            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              $('.option').off();
              let action = $(this).attr("id");

              if (his_self.game.id != my_specific_game_id) {
                his_self.game = his_self.loadGame(my_specific_game_id);
              }

	      // tell game engine we can move
	      his_self.halted = 0;
	      his_self.gaming_active = 0;

              his_self.updateStatus('continuing...');

              //
              // our own move will have been ticked into the future queue, along with
	      // anyone else's so we skip restartQueue() which will freeze if it sees
	      // that we have moves still pending, but should clear if it now finds 
	      // UNHALT is the latest instruction and this resolve is coming from us!
              //
		//
		// debugging -- maybe my move has arrived 
		//
	      setTimeout(() => { his_self.processFutureMoves(); }, 5);

	    });

	    his_self.game.tmp_confirm_sent = 1;
            his_self.addMove("RESOLVE\t"+his_self.publicKey);
            his_self.endTurn();

            return 0;

	  }

	  this.updateStatusWithOptions(msg, html);
	  let deck = his_self.returnDeck(true);

	  //
	  // this removes other options like Foul Weather after N seconds, so that
	  // the game is not significantly slowed if a player refuses to take action. 
	  //

	  if (this.isGameHalted() != 1) {

	  //
	  // prevent double broadcast if we run a second time and reach here
	  //
	  clearTimeout(counter_or_acknowledge_inactivity_timeout);
	  true_if_counter_or_acknowledge_cleared = false;
	  counter_or_acknowledge_inactivity_timeout = setTimeout(() => {

	    if (true_if_counter_or_acknowledge_cleared) { 
	      //alert("in auto-sending timer, but true if counter or acknowledge cleared is true!");
	      clearTimeout(counter_or_acknowledge_inactivity_timeout);
	      return 0;
	    }

	    his_self.cardbox.hide();

            his_self.halted = 1;
            his_self.hud.back_button = false;
                  
            let html = '<ul><li class="option acknowledge" id="ok">acknowledge</li></ul>';
            his_self.updateStatusWithOptions(msg, html);
      
	    $('.option').off();
            $('.option').on('click', function () {

	            true_if_counter_or_acknowledge_cleared = true;

		    $('.option').off();

                    his_self.updateStatus("continuing...");

                    let action = $(this).attr("id");
                
  		    setTimeout(() => {

                	    if (his_self.game.id != my_specific_game_id) {
                	      his_self.game = his_self.loadGame(my_specific_game_id);
                	    }

                	    // tell game engine we can move
                	    his_self.halted = 0;
                	    his_self.gaming_active = 0;
            
                	    //
                	    // our own move will have been ticked into the future queue, along with
                	    // anyone else's so we skip restartQueue() which will freeze if it sees
                	    // that we have moves still pending, but should clear if it now finds
                	    // UNHALT is the latest instruction and this resolve is coming from us!
                	    //
                	    his_self.processFutureMoves();

		    }, 5);
	    });

	    his_self.game.tmp_confirm_sent = 1;
            his_self.addMove("RESOLVE\t"+his_self.publicKey);
            his_self.endTurn();
            return 0;

	  }, 7500);
	  }


	  $('.option').off();
	  $('.option').on('mouseover', function() {

	    //
	    // mark that we have interacted
	    //
	    true_if_counter_or_acknowledge_cleared = true;
	    clearTimeout(counter_or_acknowledge_inactivity_timeout);

	    document.querySelectorAll(".blink").forEach((el) => {
	      el.classList.remove("blink");
	    });
	
            let action2 = $(this).attr("id");
	    if (deck[action2]) {
	      his_self.cardbox.show(action2);
	      return;
	    }
	    if (his_self.debaters[action2]) {
	      his_self.cardbox.show(action2);
	      return;
	    }
	    if (his_self.game.deck[0].cards[action2]) {
	      his_self.cardbox.show(action2);
	      return;
	    }
          });
	  $('.option').on('mouseout', function() {

	    //
	    // mark that we have interacted
	    //
	    true_if_counter_or_acknowledge_cleared = true;
	    clearTimeout(counter_or_acknowledge_inactivity_timeout);

            let action2 = $(this).attr("id");
	    if (deck[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	    if (his_self.debaters[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	    if (his_self.game.deck[0].cards[action2]) {
	      his_self.cardbox.hide(action2);
	    }
	  });
          $('.option').on('click', async function () {

	    //
	    // mark that we have interacted
	    //
	    true_if_counter_or_acknowledge_cleared = true;
	    clearTimeout(counter_or_acknowledge_inactivity_timeout);

            let action2 = $(this).attr("id");

	    //
	    // prevent blocking
	    //
	    his_self.cardbox.hide();

            //
            // events in play
            //
            if (attach_menu_events == 1) {
              for (let i = 0; i < menu_triggers.length; i++) {
                if (action2 == menu_triggers[i]) {
                  $(this).remove();
		  his_self.updateStatus("acknowledged...");
	          if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
                    his_self.prependMove("RESOLVE\t"+his_self.publicKey);
		    z[menu_index[i]].menuOptionActivated(his_self, stage, his_self.game.player, z[menu_index[i]].faction);
                  }
                  return 0;
                }
              }
            }

            if (action2 == "ok") {

	      //
	      // make sure we are not halted
	      //
	      his_self.halted = 0;

	      //
	      // this ensures we clear regardless of choice
	      //
	      // manually add, to avoid re-processing
	      if (his_self.game.confirms_needed[his_self.game.player-1] == 1) {
                his_self.prependMove("RESOLVE\t"+his_self.publicKey);
	        his_self.updateStatus("acknowledged");
                his_self.endTurn();
              }
	      return 0;
            }

          });

	  return 0;

	}



	if (mv[0] === "naval_battle") {


	  //
	  // people are still moving stuff in
	  //
	  if (qe > 0) {
	    let lmv = "";
	    for (let i = qe-1; i > 0; i--) {
	      lmv = this.game.queue[i].split("\t");
	      if (lmv[0] === "naval_battle" && lmv[1] == mv[1]) {
		let id = "";
		if (mv[4]) { id = mv[4]; }
		//
		// only remove if the unit moving in is my controlled/minor power
		//
		if (lmv[4]) { 
		  if (this.returnControllingPower(lmv[4]) == this.returnControllingPower(mv[4])) {
          	    this.game.queue.splice(qe, 1);
		    return 1;
	          }
	        }
	      }
	    }
	  }
 
          this.game.queue.splice(qe, 1);

	  //
	  // we will create this object dynamically
	  //
	  this.game.state.naval_battle = {};

	  //
	  // calculate rolls
	  //
          let calculate_rolls = function(faction) {
	    let rolls = 0;
	    let units = [];
	    let owners = [];
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].personage == false) {
		if (space.units[faction][i].land_or_sea === "sea" || space.units[faction][i].land_or_sea === "both") {
	          rolls++;
		  if (space.units[faction][i].type === "squadron") {
	            rolls++;
		  }
		  if (space.units[faction][i].owner != faction) {
		    owners.push(space.units[faction][i].owner);
		  } else {
		    owners.push(faction);
		  }
	          units.push(space.units[faction][i].key);
	        }
	      }
	    }
	    return { rolls : rolls , units : units , owners : owners};
          }
	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      	if (space.units[faction][i].navy_leader == true && space.units[faction][i].battle_rating > 0) {
	        if (highest_battle_rating < space.units[faction][i].battle_rating) {
		  highest_battle_rating = space.units[faction][i].battle_rating;
		}
	      }
	    }
	    return highest_battle_rating;
          }
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }

	  //
	  // this is run when a naval battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a nearby sea or port if 
	  // possible. as such, the rest of this function simply handles
	  // the battle on the high-seas.
	  //
	  let his_self = this;
	  let space = "";
	  let spacekey = mv[1];
	  let is_battle_in_port = false;

	  //
	  // either in port
	  //
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; is_battle_in_port = true; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }
	  let attacker = mv[2];
	  let stage = "naval_battle";
	  let intended_defender = mv[3]; // if specified, this is the major power controlling the opponent

          //
          // stop naval battle if only attacker is left (retreat)
          //
          let fluis = 0;
          let attacker_fluis = this.returnFactionNavalUnitsInSpace(attacker, spacekey);
          for (let f in space.units) {
            if (!this.areAllies(attacker, f, 1)) {
              fluis += this.returnFactionNavalUnitsInSpace(f, spacekey);
            }
          }
          if (fluis == 0 || attacker_fluis == 0) {
            return 1;
          }

	  //
	  // who is here?
	  //
	  // in sea battles an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);
	  if (intended_defender != "") { defender_faction = intended_defender; }

 	  let attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerOfFaction(defender_faction);
	  let is_janissaries_possible = false;

	  // if card was played to attack, don't slow game by checking for intervention
	  if (his_self.game.state.active_card == "001") { is_janissaries_possible = false; }

	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnNavalFactionMap(space, attacker_faction, defender_faction);

	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {

	    //
	    // check for janissaries in this loop
	    //
	    if (f === "ottoman" && space.units["ottoman"].length > 0 && (attacker_faction == "ottoman" || defender_faction == "ottoman")) {
	      if (!his_self.game.deck[0].discards['001']) {
	        if (!this.game.queue.includes("discard\tottoman\t001")) { is_janissaries_possible = true; }
	      }
	    }

	    if (f !== attacker_faction && faction_map[f] === attacker_faction) {
try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p && ap) {
	        if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
} catch (err) {}
	    }

	    if (f !== defender_faction && faction_map[f] === attacker_faction) {
try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(defender_faction)-1];
	      let dp = his_self.game.state.players_info[defender_player-1];
	      if (p && dp) {
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
} catch (err) {}
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_rolls = 0;
	  let defender_rolls = 0;
	  let attacker_units = [];
	  let defender_units = [];
	  let attacker_units_faction = [];
	  let defender_units_faction = [];
	  let attacker_units_owners = [];
	  let defender_units_owners = [];
	  if (is_battle_in_port) { defender_rolls++; defender_units.push('port defense'); defender_units_faction.push(defender_faction); }
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;
	  let attacker_highest_battle_rating_figure = "";
	  let defender_highest_battle_rating_figure = "";

	  for (let f in faction_map) {
	    if (faction_map[f] === attacker_faction) {
	      let x = calculate_rolls(f);
	      attacker_rolls += x.rolls;
	      attacker_units_owners.push(...x.owners);
	      attacker_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { 
		attacker_units_faction.push(f);
	      }
	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	    let is_intended_defender = false;
	    if (intended_defender == "") {
	      if (faction_map[f] === defender_faction) { is_intended_defender = true; } 
	    } else {
	      if (this.returnControllingPower(f) == this.returnControllingPower(intended_defender)) { is_intended_defender = true; }
	    }
	    if (is_intended_defender) {

	      let x = calculate_rolls(f);
	      defender_rolls += x.rolls;
	      defender_units.push(...x.units);
	      defender_units_owners.push(...x.owners);
	      for (let i = 0; i < x.rolls; i++) { defender_units_faction.push(f); }

	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // add rolls for highest battle ranking
	  //
	  for (let z = 0; z < attacker_highest_battle_rating; z++) {
	    attacker_rolls++;
	  }
	  for (let z = 0; z < defender_highest_battle_rating; z++) {
	    defender_rolls++;
	  }

	  //
	  // add bonus rolls
	  //
	  if (attacker_player.tmp_roll_bonus) {
  	    attacker_rolls += parseInt(attacker_player.tmp_roll_bonus);
	  }
	  if (defender_player.tmp_roll_bonus) {
            defender_rolls += parseInt(defender_player.tmp_roll_bonus);
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  //
	  // modify rolls as needed
	  //
	  let attacker_modified_rolls = attacker_results;
	  let defender_modified_rolls = attacker_results;
  	  if (his_self.game.state.naval_battle.attacker_player > 0) {
	    attacker_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.naval_battle.attacker_player-1], attacker_results);
	  }
  	  if (his_self.game.state.naval_battle.defender_player > 0) {
 	    defender_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.naval_battle.defender_player-1], defender_results);
	  }

	  for (let i = 0; i < attacker_modified_rolls; i++) {
	    if (attacker_modified_rolls[i] >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_modified_rolls; i++) {
	    if (defender_modified_rolls[i] >= 5) { defender_hits++; }
	  }

	  //
	  // we have now rolled all of the dice that we need to roll at this stage
	  // and the results have been pushed into the naval_battle object. but there
	  // is still the possibility that someone might want to intervene...
	  //
	  // things get extra messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue via counter/acknowledge. those independent
	  // functions can then manipulate the naval_battle object directly before
	  // permitting it to fall-through..
	  //

	  //
	  // save battle state
	  //
          his_self.game.state.naval_battle.spacekey = mv[1];
          his_self.game.state.naval_battle.spacekey = mv[1];
	  his_self.game.state.naval_battle.attacker_units = attacker_units;
	  his_self.game.state.naval_battle.defender_units = defender_units;
	  his_self.game.state.naval_battle.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.naval_battle.defender_units_faction = defender_units_faction;
	  his_self.game.state.naval_battle.attacker_units_owners = attacker_units_owners;
	  his_self.game.state.naval_battle.defender_units_owners = defender_units_owners;
	  his_self.game.state.naval_battle.attacker_rolls = attacker_rolls;
	  his_self.game.state.naval_battle.defender_rolls = defender_rolls;
	  his_self.game.state.naval_battle.attacker_modified_rolls = attacker_modified_rolls;
	  his_self.game.state.naval_battle.defender_modified_rolls = defender_modified_rolls;
	  his_self.game.state.naval_battle.attacker_hits = attacker_hits;
	  his_self.game.state.naval_battle.defender_hits = defender_hits;
	  his_self.game.state.naval_battle.attacker_units_destroyed = [];
	  his_self.game.state.naval_battle.defender_units_destroyed = [];
	  his_self.game.state.naval_battle.attacker_results = attacker_results;
	  his_self.game.state.naval_battle.defender_results = defender_results;
	  his_self.game.state.naval_battle.attacker_faction = attacker_faction;
	  his_self.game.state.naval_battle.defender_faction = defender_faction;
	  his_self.game.state.naval_battle.attacker_player = his_self.returnPlayerCommandingFaction(attacker_faction);
	  his_self.game.state.naval_battle.defender_player = his_self.returnPlayerCommandingFaction(defender_faction);
	  his_self.game.state.naval_battle.attacker_highest_battle_rating = attacker_highest_battle_rating;
	  his_self.game.state.naval_battle.defender_highest_battle_rating = defender_highest_battle_rating;
	  his_self.game.state.naval_battle.defender_hits_first = 0;
	  his_self.game.state.naval_battle.attacker_hits_first = 0;
	  his_self.game.state.naval_battle.defender_hits_first = 0;
	  his_self.game.state.naval_battle.faction_map = faction_map;
	  his_self.game.state.naval_battle.is_battle_in_port = is_battle_in_port;

	  let ap = {};
	  let dp = {};

	  if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
	  if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

	  //
	  // ottomans may play Janissaries, and some players may attack before each other, so
	  // we take conditional action and move to COUNTER_OR_ACKNOWLEDGE based on the details
	  // of how the battle should execute. the most important division is if one player
	  // "goes first" in which case they knock away from potential hits from the other
	  // side.
	  //
	  his_self.game.queue.push(`naval_battle_continue\t${mv[1]}`);

	  if (defender_hits > 0) {
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.attacker_faction);
	  }
	  if (attacker_hits > 0) {
	    his_self.game.queue.push("naval_battle_assign_hits\t"+his_self.game.state.naval_battle.defender_faction);
	  }

	  let from_whom = his_self.returnArrayOfPlayersInNavalSpacekey(mv[1]);

	  //
	  // this should stop execution while we are looking at the pre-naval battle overlay
	  //
	  if (his_self.game.state.events.intervention_post_naval_battle_possible) {
            his_self.game.queue.push("counter_or_acknowledge\tProceed to Assign Hits in Sea Battle\tpost_naval_battle_rolls\t"+space.key);
            his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
	  } else {
	    if (attacker_hits == 0 && defender_hits == 0) {
	      his_self.game.queue.push("ACKNOWLEDGE\tEntirely Futile Sea Battle");
	    } else {
	      if (from_whom.includes(his_self.game.players[his_self.game.player-1])) {
	        his_self.game.queue.push("ACKNOWLEDGE\tProceed to Hits Assignment");
	      }
	    }
	  }

          if (is_janissaries_possible) {
	    his_self.game.queue.push("naval_battle_assign_hits_render");
            his_self.game.queue.push("counter_or_acknowledge\tOttomans considering playing Janissaries\tjanissaries_naval\t"+space.key); 
	    his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
          }

	  his_self.game.queue.push("naval_battle_assign_hits_render");
	  his_self.game.queue.push("counter_or_acknowledge\tNaval Battle commences in "+space.name + "\tpre_naval_battle_rolls\t"+space.key);
	  his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
          
          his_self.naval_battle_overlay.renderPreNavalBattle(his_self.game.state.naval_battle);
          his_self.naval_battle_overlay.pullHudOverOverlay();

	  return 1;

        }



	if (mv[0] === "field_battle") {

	  //
	  // people are still moving stuff in
	  //
	  if (qe > 0) {
	    let lmv = "";
	    for (let i = qe-1; i > 0; i--) {
	      lmv = this.game.queue[i].split("\t");
	      if (lmv[0] === "field_battle" && lmv[1] == mv[1]) {
          	this.game.queue.splice(qe, 1);
		return 1;
	      }
	    }
	  }

          this.game.queue.splice(qe, 1);

	  //
	  // we will create this object dynamically
	  //
	  this.game.state.field_battle = {};

	  //
	  // calculate rolls
	  //
          let calculate_rolls = function(faction) {
	    let rolls = 0;
	    let units = [];
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].navy_header != true && space.units[faction][i].army_leader != true && space.units[faction][i].personage == false && space.units[faction][i].besieged == 0) {
		if (space.units[faction][i].land_or_sea === "land" || space.units[faction][i].land_or_sea === "both") {
	          rolls++;
		  units.push(space.units[faction][i].key);
	        }
	      }
	    }

	    return { rolls : rolls , units : units };
          }
	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].battle_rating > 0 && space.units[faction][i].besieged == 0) {
	        if (highest_battle_rating < space.units[faction][i].battle_rating) {
		  highest_battle_rating = space.units[faction][i].battle_rating;
		}
	      }
	    }
	    return highest_battle_rating;
          }
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }

	  //
	  // this is run when a field battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a fortress if available. as
	  // such, the rest of this function moves to to handle the on-the-
	  // ground conflict.
	  //
	  let his_self = this;
	  let spacekey = mv[1];
	  let attacker = mv[2];
	  let space = this.game.spaces[spacekey];
	  let stage = "field_battle";


          //
          // if there is no-one here but the attacker, we want to stop the field battle 
	  // because it is pointless...
          //
	  if (this.game.state.events.sack_of_rome == 1) {

	    //
	    // 
	    //

	  } else {

            let fluis = 0;
            for (let f in this.game.spaces[spacekey].units) {
              if (f !== attacker && !this.areAllies(this.game.state.active_faction, f, 1)) {
                fluis += this.returnUnbesiegedFactionLandUnitsInSpace(f, spacekey);
              }
            }

            if (fluis == 0) { 

	      //
	      // if key or fortress or electorate, we may need to besiege first
	      //
	      if (this.game.spaces[spacekey].type == "fortress" || this.game.spaces[spacekey].type == "electorate" || this.game.spaces[spacekey].type == "key") {
	        let fac = this.returnFactionControllingSpace(spacekey);
	        if (fac != attacker) {
		  if (this.game.spaces[spacekey].besieged != 1) {
	    	    this.game.spaces[spacekey].besieged = 2;
                    this.game.spaces[spacekey].besieged_factions.push(fac);
		  }
	        }
	      }

	      this.displaySpace(spacekey);
	      return 1; 
	    }

	  }


	  //
	  // the first thing we check is whether the land units that control the space have
	  // withdrawn into fortifications, as if that is the case then land battle is avoided
	  // note that besieged 2 means it is the same turn that the place was put under siege
	  //
	  if (space.besieged == 2) {
	    //
	    // we can hit this point if there is an intercept from the player that controls the 
	    // space, moving into a space that was undefended and was put under siege when the 
	    // opponent moved in. in order to guard against this, we check to see if there are
	    // any units that have withdrawn into the space..
	    //
	    let anyone_home = false;
	    for (let f in this.game.spaces[spacekey].units) {
	      for (let z = 0; z < this.game.spaces[spacekey].units[f].length; z++) {
		if (this.game.spaces[spacekey].units[f][z].besieged != 0) { anyone_home = true; }
	      }
	    }

	    let anyone_not_besieged = false;
	    let anyone_besieged = false;
	    for (let f in this.game.spaces[spacekey].units) {
	      if (!this.areAllies(f, attacker)) {
	        for (let z = 0; z < this.game.spaces[spacekey].units[f].length; z++) {
		  if (this.game.spaces[spacekey].units[f][z].besieged == 0) { anyone_not_besieged = true; }
		  if (this.game.spaces[spacekey].units[f][z].besieged > 0) { anyone_besieged = true; }
	        }
	      }
	    }

	    if (anyone_home == true) {

	      if (anyone_not_besieged == false) {

	        this.updateLog("Field Battle avoided by defenders withdrawing into fortifications");

	        if (this.game.state.active_player == this.game.player) {
	          this.game.queue.push("ACKNOWLEDGE\tField Battle avoided by defenders retreating into fortification");
	        }

	        //
	        // and redraw
	        //
	        this.displaySpace(space.key);
	        return 1;

	      }

	    }

	  }

	  //
	  // otherwise -- who the hell is here?
	  //
	  // an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);
	  let is_janissaries_possible = false;

	  // if card was played to attack, don't slow game by checking for intervention
	  if (his_self.game.state.active_card == "001") { is_janissaries_possible = false; }

 	  let attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerOfFaction(defender_faction);

	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnFactionMap(space, attacker_faction, defender_faction);

	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {

	    //
	    // check for janissaries in this loop
	    //
	    if (f === "ottoman" && space.units["ottoman"].length > 0) {
	      if (!his_self.game.deck[0].discards['001']) {
	        is_janissaries_possible = true;
	      }
	    }

	    if (f !== attacker_faction && faction_map[f] === attacker_faction) {
	      let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p && ap) {
	        if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	    }
	    if (f !== defender_faction && faction_map[f] === attacker_faction) {
	      let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1];
	      let dp = his_self.game.state.players_info[defender_player-1];
	      if (p && dp) {
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	  	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //
	  // we can how start building the field_battle object, which will contain
	  // the information, die rolls, modified die rolls, needed to carry out the
	  // conflict.
	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_rolls = 0;
	  let defender_rolls = 1;
	  let attacker_units = [];
	  let attacker_units_relief_force = []; // set as 1 if index is previously fortified unit coming out for field battle
	  let defender_units = ['defender'];

	  //
	  // no defender bonus in foreign wars
	  //
	  if (space.key === "persia" || space.key === "egypt" || space.key === "ireland") {
	    defender_rolls = 0;
	    defender_units = [];
	  }

	  let attacker_units_faction = [];
	  let defender_units_faction = [defender_faction];
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;
	  let attacker_highest_battle_rating_figure = "";
	  let defender_highest_battle_rating_figure = "";

	  let unbesieged_defender_units = 0;

	  for (let f in faction_map) {

	    if (faction_map[f] === attacker_faction) {
	      let x = calculate_rolls(f);

	      attacker_rolls += x.rolls;
	      attacker_units.push(...x.units);

	      for (let i = 0; i < x.rolls; i++) { 
		attacker_units_faction.push(f);
	      }

              for (let i = 0; i < space.units[f].length; i++) {
	        if (space.units[f][i].navy_header != true && space.units[f][i].army_leader != true && space.units[f][i].personage == false && space.units[f][i].besieged == 0) {
	  	  if (space.units[f][i].land_or_sea === "land" || space.units[f][i].land_or_sea === "both") {
		   if (space.units[f][i].relief_force == 1) { attacker_units_relief_force.push(1); } else { attacker_units_relief_force.push(0); }
	          }
	        }
	      }

	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }

	    }
	    if (faction_map[f] === defender_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		let u = space.units[f][z];
		if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") {
		  if (u.besieged == 0) { unbesieged_defender_units++; }
		}
	      }
	      let x = calculate_rolls(f);
	      defender_rolls += x.rolls;
	      defender_units.push(...x.units);
	      for (let i = 0; i < x.rolls; i++) { defender_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // max formation limit affects attacker
	  //
	  let units_from_inside_siege = 0;
	  for (let i = 0; i < attacker_units.length; i++) {
	    if (attacker_units[i].relief_force != false) {
	      units_from_inside_siege++;
	    }
	  }
          let max_formation_size = his_self.returnMaxFormationSize(space.units[attacker_faction]);
	  max_formation_size += units_from_inside_siege;
	  for (let i = max_formation_size; i < attacker_units.length; i++) {
	    attacker_rolls[i] = 0; // no hits allowed -- troops over formation (roll 0)
	  }

	  //
	  // if the defender has no units in the space and this is a fortified space
	  // we don't want to go into hits assignment because we cannot actually have
	  // a field battle, so we just nope out and put the space immediately under 
	  // siege.
	  //
 	  // <= 1 because defenders get that bonus hit
	  //
	  let no_defender_units = false;
	  if (defender_units.length < 1) { no_defender_units = true; } else {
	    if (defender_units[0] == "defender") {
 	      if (defender_units.length == 1) { no_defender_units = true; }
	    }
	  }
	  if (!this.game.state.sack_of_rome != 1 && no_defender_units == true && (space.type == "electorate" || space.type == "key" || this.isSpaceFortified(space.key) || space.type == "fortress")) {
	    if (space.besieged != 1) { // not if already besieged
	      space.besieged = 2;
	      this.updateLog(space.name + " put under siege.");
	    }
	    this.displaySpace(space.key);
	    return 1;	    
	  }

	  //
	  // no unbesieged defender units
	  //
	  if (!this.game.state.sack_of_rome != 1 && unbesieged_defender_units == 0) {
	    this.displaySpace(space.key);
	    return 1;
	  }


	  //
	  // if the defender has no units (retreat?) then we just exit the field battle
	  // immediately since there is no battle at all. note that we have already handled
	  // edge-cases with siege/assault above.
	  //
	  if (!this.game.state.sack_of_rome != 1 && no_defender_units == true) {
	    this.displaySpace(space.key);
	    return 1;	    
	  }

	  //
	  // add rolls for highest battle ranking
	  //
	  for (let z = 0; z < attacker_highest_battle_rating; z++) {
	    attacker_rolls++;
	  }
	  for (let z = 0; z < defender_highest_battle_rating; z++) {
	    defender_rolls++;
	  }

	  //
	  // add bonus rolls
	  //
	  if (attacker_player.tmp_roll_bonus) {
  	    attacker_rolls += parseInt(attacker_player.tmp_roll_bonus);
	  }
	  if (defender_player.tmp_roll_bonus) {
            defender_rolls += parseInt(defender_player.tmp_roll_bonus);
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  //
	  // modify rolls as needed
	  //
	  let attacker_modified_rolls = attacker_results;
	  let defender_modified_rolls = defender_results;
  	  if (his_self.game.state.field_battle.attacker_player > 0) {
	    attacker_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.field_battle.attacker_player-1], attacker_results);
	  }

  	  if (his_self.game.state.field_battle.defender_player > 0) {
 	    defender_modified_rolls = modify_rolls(his_self.game.state.players_info[his_self.game.state.field_battle.defender_player-1], defender_results);
	  }

	  for (let i = 0; i < attacker_modified_rolls; i++) {
	    if (attacker_modified_rolls[i] >= 5 && attacker_results[i] < 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_modified_rolls; i++) {
	    if (defender_modified_rolls[i] >= 5 && defender_results[i] < 5) { defender_hits++; }
	  }


//
// TEST / HACK -- control hits / adjust hits here
//
//attacker_hits = 4;
//defender_hits = 4;

	  //
	  // we have now rolled all of the dice that we need to roll at this stage
	  // and the results have been pushed into the field_battle object. but there
	  // is still the possibility that someone might want to intervene...
	  //
	  // things get extra messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue via counter/acknowledge. those independent
	  // functions can then manipulate the field_battle object directly before
	  // permitting it to fall-through..
	  //
          his_self.game.state.field_battle.spacekey = mv[1];
	  his_self.game.state.field_battle.attacker_units = attacker_units;
	  his_self.game.state.field_battle.defender_units = defender_units;
	  his_self.game.state.field_battle.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.field_battle.attacker_units_relief_force = attacker_units_relief_force;
	  his_self.game.state.field_battle.defender_units_faction = defender_units_faction;
	  his_self.game.state.field_battle.attacker_rolls = attacker_rolls;
	  his_self.game.state.field_battle.defender_rolls = defender_rolls;
	  his_self.game.state.field_battle.attacker_modified_rolls = attacker_modified_rolls;
	  his_self.game.state.field_battle.defender_modified_rolls = defender_modified_rolls;
	  his_self.game.state.field_battle.attacker_hits = attacker_hits;
	  his_self.game.state.field_battle.defender_hits = defender_hits;
	  his_self.game.state.field_battle.attacker_units_destroyed = [];
	  his_self.game.state.field_battle.defender_units_destroyed = [];
	  his_self.game.state.field_battle.attacker_results = attacker_results;
	  his_self.game.state.field_battle.defender_results = defender_results;
	  his_self.game.state.field_battle.attacker_faction = attacker_faction;
	  his_self.game.state.field_battle.defender_faction = defender_faction;
	  his_self.game.state.field_battle.attacker_player = his_self.returnPlayerOfFaction(attacker_faction);
	  his_self.game.state.field_battle.defender_player = his_self.returnPlayerOfFaction(defender_faction);
	  his_self.game.state.field_battle.attacker_highest_battle_rating = attacker_highest_battle_rating;
	  his_self.game.state.field_battle.defender_highest_battle_rating = defender_highest_battle_rating;
	  his_self.game.state.field_battle.defender_hits_first = 0;
	  his_self.game.state.field_battle.attacker_hits_first = 0;
	  his_self.game.state.field_battle.defender_hits_first = 0;
	  his_self.game.state.field_battle.faction_map = faction_map;

	  let ap = {};
	  let dp = {};

	  if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
	  if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

	  //
	  // ottomans may play Janissaries, and some players may attack before each other, so
	  // we take conditional action and move to COUNTER_OR_ACKNOWLEDGE based on the details
	  // of how the battle should execute. the most important division is if one player
	  // "goes first" in which case they knock away from potential hits from the other
	  // side.
	  //
	  his_self.game.queue.push(`field_battle_continue\t${mv[1]}`);

	  if ((his_self.game.state.field_battle.attacker_hits_first == 1 || ap.tmp_roll_first == 1) && (dp.tmp_roll_first != 1 && his_self.game.state.field_battle.defender_hits_first != 1)) {
	    his_self.game.state.field_battle.attacker_hits_first = 1;
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	    his_self.game.queue.push("field_battle_remove_hits\t"+his_self.game.state.field_battle.attacker_hits);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	  } else if ((his_self.game.state.field_battle.attacker_hits_first != 1 && ap.tmp_roll_first != 1) && (dp.tmp_roll_first == 1 || his_self.game.state.field_battle.defender_hits_first == 1)) {
	    his_self.game.state.field_battle.defender_hits_first = 1;
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	    his_self.game.queue.push("field_battle_remove_hits\t"+his_self.game.state.field_battle.defender_hits);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	  } else {
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.attacker_faction);
	    his_self.game.queue.push("field_battle_assign_hits\t"+his_self.game.state.field_battle.defender_faction);
	  }
	  //
	  // this should stop execution while we are looking at the pre-field battle overlay
	  //
	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(space.key);
	  if (from_whom.includes(his_self.game.players[his_self.game.player-1])) {
	    his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
	  }
	  his_self.game.queue.push("field_battle_assign_hits_render");
	  if (is_janissaries_possible) {
	    his_self.game.queue.push("counter_or_acknowledge\tOttomans considering playing Janissaries\tjanissaries\t"+space.key);
            his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
	  }
	  his_self.game.queue.push("counter_or_acknowledge\tField Battle is about to begin in "+space.name + "\tpre_field_battle_rolls\t"+space.key);
          his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
          his_self.field_battle_overlay.renderPreFieldBattle(his_self.game.state.field_battle);
          his_self.field_battle_overlay.pullHudOverOverlay();

	  return 1;

        }

	if (mv[0] === "field_battle_remove_hits") {

	  let his_self = this;
	  let hits_to_remove = parseInt(mv[1]);

	  if (his_self.game.state.field_battle.attacker_hits_first == 1) {
	    for (let i = 0; i < hits_to_remove; i++) {
	      if (his_self.game.state.field_battle.defender_rolls > 0) { his_self.game.state.field_battle.defender_rolls--; }
	      if (his_self.game.state.field_battle.defender_modified_rolls.length > 0) {
		if (his_self.game.state.field_battle.defender_modified_rolls[his_self.game.state.field_battle.defender_modified_rolls.length-1] >= 5) {
		  his_self.updateLog("Field Battle - hit removed from defender...");
		  his_self.game.state.field_battle.defender_hits--;
		}
		his_self.game.state.field_battle.defender_modified_rolls.splice(his_self.game.state.field_battle.defender_modified_rolls.length, 1);
	      }
	      if (his_self.game.state.field_battle.defender_results.length > 0) { his_self.game.state.field_battle.defender_results.splice(his_self.game.state.field_battle.defender_results.length, 1); }
	    }
	  } else {
	    for (let i = 0; i < hits_to_remove; i++) {
	      if (his_self.game.state.field_battle.attacker_rolls > 0) { his_self.game.state.field_battle.attacker_rolls--; }
	      if (his_self.game.state.field_battle.attacker_modified_rolls.length > 0) {
		if (his_self.game.state.field_battle.attacker_modified_rolls[his_self.game.state.field_battle.attacker_modified_rolls.length-1] >= 5) {
		  his_self.updateLog("Field Battle - hit removed from attacker...");
		  his_self.game.state.field_battle.attacker_hits--;
		}
		his_self.game.state.field_battle.attacker_modified_rolls.splice(his_self.game.state.field_battle.attacker_modified_rolls.length, 1);
	      }
	      if (his_self.game.state.field_battle.attacker_results.length > 0) { his_self.game.state.field_battle.attacker_results.splice(his_self.game.state.field_battle.attacker_results.length, 1); }
	    }

	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



        if (mv[0] === "field_battle_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies, but they have
	  // to split hits, with a random roll used to determine who takes the extra
	  // hit ON DEFENSE. the active power assigns hits independently to any land
	  // units who attack.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.field_battle.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // we auto-assign the hits to independent, non-player controlled units
	  // this function handles that.
	  //
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;
	    let faction_map = his_self.game.state.field_battle.faction_map;

	    if (faction == "independent") {
	      max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(faction, space);
	    } else {
	      //
	      // max hits to assign are the faction land units
	      //
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
	      	  max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	        }
	      }
	    }

	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }

	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

	      let number_of_targets = 0;

	      //
	      // first we calculate starting faction targets
	      //
	      if (faction != "independent") {
	        for (let f in faction_map) {
	          if (faction_map[f] === faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      } else {
		number_of_targets = 1;
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] === faction || (f == "independent" && faction == "independent")) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "mercenary"; }
		        if (zzz == 1) { cannon_fodder = "regular"; }
		        if (zzz == 2) { cannon_fodder = "cavalry"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type === cannon_fodder && space.units[f][i].besieged == 0) {

			    //
			    // and remove from field battle unit
			    //
		            if (faction === his_self.game.state.field_battle_attacker_faction) {
			      for (let z = 0; z < his_self.game.state.field_battle.attacker_units.length; z++) {
			        let u = his_self.game.state.field_battle.attacker_units[z];
			        if (u.type === cannon_fodder) {
			          if (!his_self.game.state.field_battle.attacker_units_destroyed.includes(z)) {
			            his_self.game.state.field_battle.attacker_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }
		            if (faction === his_self.game.state.field_battle_defender_faction) {
			      for (let z = 0; z < his_self.game.state.field_battle.defender_units.length; z++) {
			        let u = his_self.game.state.field_battle.defender_units[z];
			        if (u.type === cannon_fodder) {
			          if (!his_self.game.state.field_battle.defender_units_destroyed.includes(z)) {
			            his_self.game.state.field_battle.defender_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }

		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] === faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "mercenary"; }
                    if (zzz == 1) { cannon_fodder = "regular"; }
                    if (zzz == 2) { cannon_fodder = "cavalry"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type === cannon_fodder && space.units[selected_faction][ii].besieged == 0) {

			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
	  		his_self.game.state.field_battle.attacker_units_destroyed = [];
	  		his_self.game.state.field_battle.defender_units_destroyed = [];

                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }


	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {
	    if (faction === this.game.state.field_battle.attacker_faction) {
	      assign_hits(faction, this.game.state.field_battle.defender_hits);
	    } else {
	      assign_hits(faction, this.game.state.field_battle.attacker_hits);
	    }
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.updateInstructions("Independent Hits Assigned");
	    return 1;
	  }


	  //
	  // no hits assignment if no hits
	  //
	  //
	  if (faction === this.game.state.field_battle.attacker_faction) {
	    if (this.game.state.field_battle.defender_hits == 0) { return 1; }
	  } else {
	    if (this.game.state.field_battle.attacker_hits == 0) { return 1; }
	  }


	  //
	  // if we hit this point we need manual intervention to assign the hits.
	  // the attacker can assign hits however they prefer if others join them
	  // in the attack, but if two major powers share defense then the hits
	  // are divided evenly among them.
	  //
          let hits_to_assign = this.game.state.field_battle.attacker_hits;
          let defending_factions = [];
          let defending_factions_count = 0;
          let defending_major_powers = 0;
          let defending_factions_hits = [];
	  let units_capable_of_taking_hits = 0;
	  for (let f in this.game.state.field_battle.faction_map) {
	    if (this.game.state.field_battle.faction_map[f] == faction || f == faction) {
	      units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.field_battle.spacekey);
	      if (this.isMajorPower(f)) {
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
	    }
          }
	  //
	  // this can happen if only minor powers, but controlled by major power
	  //
	  if (defending_factions_hits.length == 0) {
	    for (let f in this.game.state.field_battle.faction_map) {
	      if (this.game.state.field_battle.faction_map[f] == faction || f == faction) {
	        units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.field_battle.spacekey);
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
            }
          }

	  // this is needed, but we shouldn't hit it
	  //if (defending_faction_hits.length == 0) {
	  //  return 1;
	  //}

	  if (units_capable_of_taking_hits == 0) {
	    return 1;
	  }

	  //
	  // every gets shared hits
	  //
	  while (hits_to_assign > defending_factions_hits.length) {
	    for (let i = 0; i < defending_factions_hits.length; i++) { defending_factions_hits[i]++; }
	    hits_to_assign -= defending_factions_hits.length;
	  }

	  //
	  // randomly assign remainder
	  //
	  let already_punished = [];
	  for (let i = 0; i < hits_to_assign; i++) {
	    let unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	    while (already_punished.includes(unlucky_faction)) {
	      unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	    }
	    defending_factions_hits[unlucky_faction]++;
	    already_punished.push(unlucky_faction);
	  }

	  //
	  // defending major powers
	  //
	  if (defending_major_powers > 0 && this.game.state.field_battle.faction_map[faction] == this.game.state.field_battle.defender_faction) {
	    for (let i = 0; i < defending_factions_hits.length; i++) {
  	      this.game.queue.push(`field_battle_manually_assign_hits\t${defending_factions[i]}\t${defending_factions_hits[i]}`);
	    }
	    return 1;
	  }

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.assignHits(his_self.game.state.field_battle, faction);
	  } else {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
	    his_self.updateStatus(this.returnFactionName(faction) + " Assigning Hits");
            his_self.field_battle_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;

	}





        if (mv[0] === "naval_battle_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space;
	  let is_battle_in_port = false;
	  if (this.game.spaces[this.game.state.naval_battle.spacekey]) { is_battle_in_port = true; space = this.game.spaces[this.game.state.naval_battle.spacekey]; }
	  if (this.game.navalspaces[this.game.state.naval_battle.spacekey]) { is_battle_in_port = true; space = this.game.navalspaces[this.game.state.naval_battle.spacekey]; }

          this.game.queue.splice(qe, 1);

	  //
	  // this auto-assigns hits to squadrons...
	  //
	  let assign_hits = function(faction, hits) {
	    for (let z = space.units[faction].length-1; assign_hits >= 2 && z >= 0; z--) {
	      if (space.units[faction][z].type == "squadron") {
		space.units[faction].splice(z, 1);
		assign_hits-=2;
	      }
	    }
	  }

	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {
	    if (faction == this.game.state.naval_battle.attacker_faction) {
	      if (this.game.state.naval_battle.defender_hits > 0) {
	        assign_hits(faction, this.game.state.naval_battle.defender_hits);
	      }
	    } else {
	      if (this.game.state.naval_battle.attacker_hits > 0) {
	        assign_hits(faction, this.game.state.naval_battle.attacker_hits);
	      }
	    }

            his_self.naval_battle_overlay.renderNavalBattle(his_self.game.state.naval_battle);
            his_self.naval_battle_overlay.updateInstructions("Independent Hits Assigned");

	    return 1;

	  } else {

            his_self.naval_battle_overlay.renderNavalBattle(his_self.game.state.naval_battle);
	    if (his_self.game.player == this.returnPlayerCommandingFaction(faction)) {
	      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(his_self.game.state.naval_battle.attacker_faction)) {
	        if (this.game.state.naval_battle.defender_hits > 0) {
                  his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
	        } else {
		  his_self.endTurn();
		}
	      } else {
	        if (this.game.state.naval_battle.attacker_hits > 0) {
                  his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
	        } else {
		  his_self.endTurn();
		}
	      }
	    } else {
	      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(this.game.state.naval_battle.attacker_faction)) {
	        if (this.game.state.naval_battle.defender_hits > 0) {
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Assigning Hits");
	        } else {
		  his_self.updateStatus(his_self.returnFactionName(faction) + " - Fleet Survives Intact");
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Unscathed - click to continue");
		}
	      } else {
	        if (this.game.state.naval_battle.attacker_hits > 0) {
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Assigning Hits");
	        } else {
		  his_self.updateStatus(his_self.returnFactionName(faction) + " - Fleet Survives Intact");
                  his_self.naval_battle_overlay.updateInstructions(his_self.returnFactionName(faction) + " Unscathed - click to continue");
		}
	      }
	    }
	  }

	  return 0;

	}





        if (mv[0] === "assault_assign_hits") {

	  //
	  // major powers may assign hits completely to minor allies, but they have
	  // to split hits, with a random roll used to determine who takes the extra
	  // hit ON DEFENSE. the active power assigns hits independently to any land
	  // units who attack.
	  //
	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.assault.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // we auto-assign the hits to independent, non-player controlled units
	  // this function handles that.
	  //
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;
	    let faction_map = his_self.game.state.assault.faction_map;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	      }
	    }

	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }

	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "mercenary"; }
		        if (zzz == 1) { cannon_fodder = "regular"; }
		        if (zzz == 2) { cannon_fodder = "cavalry"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {

			    //
			    // and remove from field battle unit
			    //
		            if (faction == his_self.game.state.assault_attacker_faction) {
			      for (let z = 0; z < his_self.game.state.assault.attacker_units.length; z++) {
			        let u = his_self.game.state.assault.attacker_units[z];
			        if (u.type == cannon_fodder) {
			          if (!his_self.game.state.assault.attacker_units_destroyed.includes(z)) {
			            his_self.game.state.assault.attacker_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }
		            if (faction == his_self.game.state.assault_defender_faction) {
			      for (let z = 0; z < his_self.game.state.assault.defender_units.length; z++) {
			        let u = his_self.game.state.assault.defender_units[z];
			        if (u.type == cannon_fodder) {
			          if (!his_self.game.state.assault.defender_units_destroyed.includes(z)) {
			            his_self.game.state.assault.defender_units_destroyed.push(z);
				    z = 100000;
				  }
			        }
			      }
			    }

		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "mercenary"; }
                    if (zzz == 1) { cannon_fodder = "regular"; }
                    if (zzz == 2) { cannon_fodder = "cavalry"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {

			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
	  		his_self.game.state.assault.attacker_units_destroyed = [];
	  		his_self.game.state.assault.defender_units_destroyed = [];

                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }

	  //
	  // auto-assign hits to independent entities
	  //
	  if (player == 0) {

	    if (faction == this.game.state.assault.attacker_faction) {
	      assign_hits(faction, this.game.state.assault.defender_hits);
	    } else {
	      assign_hits(faction, this.game.state.assault.attacker_hits);
	    }

            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.updateInstructions("Independent Hits Assigned");
	    his_self.assault_overlay.pullHudOverOverlay();

	    return 1;
	  }

	  //
	  // no hits assignment if no hits
	  //
	  //
	  if (faction == this.game.state.assault.attacker_faction) {
	    if (this.game.state.assault.defender_hits == 0) { return 1; }
	  } else {
	    if (this.game.state.assault.attacker_hits == 0) { return 1; }
	  }

	  //
	  // if we hit this point we need manual intervention to assign the hits.
	  // the attacker can assign hits however they prefer if others join them
	  // in the attack, but if two major powers share defense then the hits
	  // are divided evenly among them.
	  //
          let hits_to_assign = this.game.state.assault.attacker_hits;
	  if (faction == this.game.state.assault.attacker_faction) {
            hits_to_assign = this.game.state.assault.defender_hits;
	  }

          let defending_factions = [];
          let defending_factions_count = 0;
          let defending_major_powers = 0;
          let defending_factions_hits = [];
	  let major_power = false;
	  let multiple_major_powers = false;
	  let defender_units_capable_of_taking_hits = 0;
	  for (let f in this.game.state.assault.faction_map) {
	    if (this.game.state.assault.faction_map[f] == faction) {
	      defender_units_capable_of_taking_hits += this.returnFactionLandUnitsInSpace(f, this.game.state.assault.spacekey);
	      if (this.isMajorPower(f)) {
		if (major_power) { multiple_major_powers = true; }
	        defending_factions.push(f);
                defending_factions_hits.push(0);
		major_power = true;
		defending_major_powers++;
	      } else {
	        defending_factions.push(f);
                defending_factions_hits.push(0);
	      }
	    }
	  }

	  //
	  // no-one to take hits
	  //
	  if (defender_units_capable_of_taking_hits == 0) { return 1; }

	  //
	  // every gets shared hits
	  //
	  if (multiple_major_powers) {
  	    if (defending_factions_hits.length > 0) {
	      while (major_power == true && hits_to_assign > defending_factions_hits.length) {
	        for (let i = 0; i < defending_factions_hits.length; i++) { defending_factions_hits[i]++; }
	        hits_to_assign -= defending_factions_hits.length;
	      }
	    }

	    //
	    // randomly assign remainder
	    //
	    let already_punished = [];
	    if (defending_factions_hits.length > 0 && hits_to_assign > 0) {
	      for (let i = 0; i < hits_to_assign; i++) {
	        let unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	        while (already_punished.includes(unlucky_faction)) {
	          unlucky_faction = this.rollDice(defending_factions_hits.length)-1;
	        }
	        defending_factions_hits[unlucky_faction]++;
	        already_punished.push(unlucky_faction);
	      }
	      hits_to_assign = 0;
	    }

	    //
	    // defending major powers
	    //
	    for (let i = 0; i < defending_factions_hits.length; i++) {
  	      this.game.queue.push(`assault_manually_assign_hits\t${defending_factions[i]}\t${defending_factions_hits[i]}`);
	    }
	    return 1;
	  }

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.assignHits(his_self.game.state.assault, faction);
	  } else {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
	    his_self.updateStatus(this.returnFactionName(faction) + " Assigning Hits");
            his_self.assault_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;

	}

        //
        // variant of above when major powers have to split hits assignments
        //
	if (mv[0] === "field_battle_manually_assign_hits") {

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.field_battle.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.assignHitsManually(his_self.game.state.field_battle, faction, hits);
	  } else {
            his_self.field_battle_overlay.renderFieldBattle(his_self.game.state.field_battle);
            his_self.field_battle_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;
        }

        //
        // variant of above when major powers have to split hits assignments
        //
	if (mv[0] === "assault_manually_assign_hits") {

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let player = this.returnPlayerCommandingFaction(faction);
	  let space = this.game.spaces[this.game.state.assault.spacekey];

          this.game.queue.splice(qe, 1);

	  //
	  // otherwise assign hits directly
	  //
	  if (player == this.game.player) {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.assignHitsManually(his_self.game.state.assault, faction, hits);
	  } else {
            his_self.assault_overlay.renderAssault(his_self.game.state.assault);
            his_self.assault_overlay.updateInstructions(this.returnFactionName(faction) + " Assigning Hits");
	  }

	  return 0;
        }

        if (mv[0] === "assault_show_hits_render") {
          this.game.queue.splice(qe, 1);
          this.assault_overlay.render(his_self.game.state.assault);
          this.assault_overlay.pullHudOverOverlay();
          return 1;
        }
          
	if (mv[0] === "assault_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.assault_overlay.render(his_self.game.state.assault);
          this.assault_overlay.pullHudOverOverlay();
	  return 1;
	}

	if (mv[0] === "naval_battle_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.naval_battle_overlay.render(his_self.game.state.naval_battle);
	  return 1;
	}

	if (mv[0] === "field_battle_assign_hits_render") {
          this.game.queue.splice(qe, 1);
          this.field_battle_overlay.render(his_self.game.state.field_battle);
          this.field_battle_overlay.pullHudOverOverlay();
	  return 1;
	}


	if (mv[0] === "destroy_faction_units_in_spacekey") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let space = null;

          this.game.queue.splice(qe, 1);

	  try { if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; } } catch (err) {}
	  try { if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; } } catch (err) {}

	  let is_processed = false;

	  if (this.game.state.field_battle) {
	    if (this.game.state.field_battle.spacekey == spacekey) {
	      for (let f in this.game.state.field_battle.faction_map) {
	        if (this.game.state.field_battle.faction_map[f] == faction) {
	          is_processed = true;
		  for (let z = 0; z < space.units[f].length; z++) {
		    let u = space.units[f][z];
		    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
		      space.units[f].splice(z, 1);
		      z--;
		    }
		  }
		}
	      }
	    }
	  }
	  if (is_processed == false && this.game.state.assault) {
	    if (this.game.state.assault.spacekey == spacekey) {
	      for (let f in this.game.state.assault.faction_map) {
	        if (this.game.state.assault.faction_map[f] == faction) {
		  is_processed = true;
		  for (let z = 0; z < space.units[f].length; z++) {
		    let u = space.units[f][z];
		    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
		      space.units[f].splice(z, 1);
		      z--;
		    }
		  }
	        }
	      }
	    }
	  }

	  if (is_processed == false) {
	    for (let z = space.units[faction].length-1; z >= 0; z--) {
	      let u = space.units[faction][z];
	      if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.type == "squadron" || u.type == "corsair") {
	        space.units[faction].splice(z, 1);
	      }
	    }
	  }

          this.refreshBoardUnits();
	  this.displaySpace(spacekey);

	  return 1;
	}




 	if (mv[0] === "siege_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

          this.game.queue.splice(qe, 1);

	  let space = this.game.spaces[spacekey];
	  let unit_destroyed = false;

	  for (let i = 0; i < space.units[faction].length && unit_destroyed == false; i++) {
	    if (space.units[faction][i].type == unit_type) {
	      if (this.game.state.assault.faction_map[faction] == this.game.state.assault.attacker_faction) {
		for (let z = 0; z < this.game.state.assault.attacker_units_units.length; z++) {
		  if (this.game.state.assault.attacker_units_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.assault.attacker_units_destroyed.includes(z)) {
		      this.game.state.assault.attacker_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      } else {
		for (let z = 0; z < this.game.state.assault.defender_units_units.length; z++) {
		  if (this.game.state.assault.defender_units_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.assault.defender_units_destroyed.includes(z)) {
		      this.game.state.assault.defender_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      }
	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	    }
	  }

	  return 1;

	}

 	if (mv[0] === "field_battle_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

          this.game.queue.splice(qe, 1);

	  let space = this.game.spaces[spacekey];
	  let unit_destroyed = false;

	  let is_loser_attacker = false;
	  let any_relief_force = false;

	  //
	  // we assign back to front as relief forces will always be at the start of our
	  // units-in-space
	  //
	  for (let i = space.units[faction].length-1; i >= 0 && unit_destroyed == false; i--) {
	    if (space.units[faction][i].type == unit_type) {
	      if (this.game.state.field_battle.faction_map[faction] == this.game.state.field_battle.attacker_faction) {
		for (let z = this.game.state.field_battle.attacker_units.length-1; z >= 0; z--) {
		  if (this.game.state.field_battle.attacker_units[z] == space.units[faction][i].type) {
		    if (!this.game.state.field_battle.attacker_units_destroyed.includes(z)) {
		      this.game.state.field_battle.attacker_units_destroyed.push(z);
		      z -= 100000;
		    }
		  }
		}
	      } else {
		for (let z = this.game.state.field_battle.defender_units.length-1; z >= 0; z--) {
		  if (this.game.state.field_battle.defender_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.field_battle.defender_units_destroyed.includes(z)) {
		      this.game.state.field_battle.defender_units_destroyed.push(z);
		      z -= 100000;
		    }
		  }
		}
	      }
	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	    }
	  }

	  return 1;

	}



 	if (mv[0] === "naval_battle_destroy_unit") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

	  //
	  // sanity check "france / scotland" etc.
	  //
	  if (faction.indexOf(" / ") > 0) {
	    faction = faction.split(" / ")[0];
	  }

	  //
	  // keep track that we have destroyed one -- cannot be rebuilt until next turn
	  //
	  if (!this.game.state.ships_destroyed[faction]) { this.game.state.ships_destroyed[faction] = 0; }
	  this.game.state.ships_destroyed[faction]++;

          this.game.queue.splice(qe, 1);

	  let space;
          if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
          if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }
	  let unit_destroyed = false;

	  for (let i = 0; i < space.units[faction].length && unit_destroyed == false; i++) {
	    if (space.units[faction][i].type == unit_type && (unit_type === "corsair" || unit_type === "squadron")) {
	      if (this.game.state.naval_battle.faction_map[faction] == this.game.state.naval_battle.attacker_faction) {
		for (let z = 0; z < this.game.state.naval_battle.attacker_units.length; z++) {
		  if (this.game.state.naval_battle.attacker_units[z] == space.units[faction][i].type) {
		    if (!this.game.state.naval_battle.attacker_units_destroyed.includes(z)) {
		      this.game.state.naval_battle.attacker_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      } else {
		for (let z = 0; z < this.game.state.naval_battle.defender_units.length; z++) {
		  if (this.game.state.naval_battle.defender_units[z].type == space.units[faction][i].type) {
		    if (!this.game.state.naval_battle.defender_units_destroyed.includes(z)) {
		      this.game.state.naval_battle.defender_units_destroyed.push(z);
		      z = 100000;
		    }
		  }
		}
	      }

	      space.units[faction].splice(i, 1);
	      unit_destroyed = true;
	      i = 10000;

	    }
	  }

	  return 1;

	}


	if (mv[0] === "foreign-war-cleanup") {

          this.game.queue.splice(qe, 1);
	  let faction = "ottoman";
	  let spacekey = mv[1];
	  if (spacekey == "ireland") { faction = "england"; }

          this.game.state.foreign_wars_fought_this_impulse.push(spacekey);

	  //
	  // no need for cleanup unless battle is over
	  //
	  if (!this.doesSpaceHaveNonFactionUnits(spacekey, faction)) {

	    if (spacekey == "ireland") { this.updateLog("Revolt in Ireland finishes, English forces return to London"); }
	    if (spacekey == "persia") { this.updateLog("War in Persia finishes, Turkish forces return to Istanbul"); }
	    if (spacekey == "egypt") { this.updateLog("Revolt in Egypt finishes, Turkish forces return to Istanbul"); }

	    //
	    // move all soldiers back to capital (if controlled)
	    //
	    let s = this.game.spaces[spacekey];
	    if (faction == "england") {
	      for (let i = 0; i < s.units[faction].length; i++) {
	        this.game.spaces["london"].units["england"].push(s.units[faction][i]);
	      }
	      s.units[faction] = [];
	    }

	    if (faction == "ottoman") {
	      for (let i = 0; i < s.units[faction].length; i++) {
	        this.game.spaces["istanbul"].units["ottoman"].push(s.units[faction][i]);
	      }
	      s.units[faction] = [];
	    }

	    //
	    // remove -1 war effect
	    //
	    if (spacekey == "ireland") {
	      this.game.state.england_war_winner_vp++;
              this.game.state.events.revolt_in_ireland = 0;
              this.hideIreland();
	    }
	    if (spacekey == "persia") {
	      this.game.state.ottoman_war_winner_vp++;
              this.game.state.events.war_in_persia = 0;
              this.hidePersia();
	    }
	    if (spacekey == "egypt") {
	      this.game.state.ottoman_war_winner_vp++;
              this.game.state.events.revolt_in_egypt = 0;
              this.hideEgypt();
	    }
	  }

	  return 1;

	}

	if (mv[0] === "field_battle_continue") {


          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space = this.game.spaces[mv[1]];

	  //
	  // foreign wars handle their own post-battle clean-up
	  //
	  if (mv[1] == "persia" || mv[1] == "ireland" || mv[1] == "egypt") {
	    his_self.game.queue.push("foreign-war-cleanup\t"+mv[1]);
	    return 1;
	  }

	  //
	  // hits assignment happens here
	  //
	  his_self.updateLog("Attacker Modified: " + JSON.stringify(his_self.game.state.field_battle.attacker_modified_rolls));
	  his_self.updateLog("Defender Modified: " + JSON.stringify(his_self.game.state.field_battle.defender_modified_rolls));
	  his_self.updateLog("Attacker Hits: " + his_self.game.state.field_battle.attacker_hits);
	  his_self.updateLog("Defender Hits: " + his_self.game.state.field_battle.defender_hits);

	  this.field_battle_overlay.renderFieldBattle(this.game.state.field_battle);

	  //
	  // who won ?
	  //
	  let winner = his_self.game.state.field_battle.defender_faction;
	  if (his_self.game.state.field_battle.attacker_hits > his_self.game.state.field_battle.defender_hits) {
	    winner = his_self.game.state.field_battle.attacker_faction;
	  }

	  //
	  // mark losers for avoid-battle purposes
	  //
	  for (let f in his_self.game.state.field_battle.faction_map) {
	    if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	      for (let z = 0; z < space.units[f].length; z++) {
		space.units[f][z].lost_field_battle = 1;
	      }
	    }
	  }

	  //
	  // calculate units remaining
	  //
          his_self.game.state.field_battle.attacker_land_units_remaining = his_self.game.state.field_battle.attacker_units.length - his_self.game.state.field_battle.defender_hits;
	  for (let i = 0; i < his_self.game.state.field_battle.attacker_units.length; i++) {
	    if (his_self.game.state.field_battle.attacker_units[i] == "bonus") { his_self.game.state.field_battle.attacker_land_units_remaining--; }
	  }
	  let du = 0;
	  for (let i = 0; i < his_self.game.state.field_battle.defender_units.length; i++) {
	    if (his_self.game.state.field_battle.defender_units[i] != "defender" && his_self.game.state.field_battle.defender_units[i] != "bonus") { du++; }
	  }
	  his_self.game.state.field_battle.defender_land_units_remaining = du - his_self.game.state.field_battle.attacker_hits;

	  if (his_self.game.state.field_battle.attacker_land_units_remaining == 0 && his_self.game.state.field_battle.defender_land_units_remaining == 0) {
	    if (his_self.game.state.field_battle.attacker_rolls > his_self.game.state.field_battle.defender_rolls) {
	      his_self.updateLog("Attacker adds 1 regular");
	      his_self.addRegular(his_self.game.state.field_battle.attacker_faction, space);
	    } else {
	      his_self.updateLog("Defender adds 1 regular");
	      his_self.addRegular(his_self.game.state.field_battle.defender_faction, space);
	    }
	  }


console.log("field battle: ");
console.log("attacker units remaining: " + his_self.game.state.field_battle.attacker_land_units_remaining);
console.log("defender units remaining: " + his_self.game.state.field_battle.defender_land_units_remaining);



	  //
	  // capture stranded leaders
	  //
	  if (his_self.game.state.field_battle.attacker_land_units_remaining == 0) {
	    let purge_attacking_leaders = true;
	    // unless relief siege and "defenders" are all destroyed...
	    if (his_self.game.state.field_battle.defender_land_units_remaining == 0) {
	      for (let key in space.units) {
		if (space.units[key].length > 0) {
	          if (his_self.returnPlayerCommandingFaction(his_self.returnFactionControllingSpace(his_self.game.state.field_battle.spacekey)) == his_self.returnPlayerCommandingFaction(key)) {
		    purge_attacking_leaders = false;
		  }
		}
	      }
	    }
	    if (purge_attacking_leaders == true) {
	      for (let f in his_self.game.state.field_battle.faction_map) {
	        if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	          for (let i = 0; i < space.units[f].length; i++) {
	            his_self.captureLeader(his_self.game.state.field_battle.defender_faction, his_self.game.state.field_battle.attacker_faction, mv[1], space.units[f][i]);
		    space.units[f].splice(i, 1);
		    i--;
		  }
	        }
	      }
	    }
	  }

	  if (his_self.game.state.field_battle.defender_land_units_remaining == 0) {
	    for (let f in his_self.game.state.field_battle.faction_map) {
	      if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(his_self.game.state.field_battle.attacker_faction, his_self.game.state.field_battle.defender_faction, mv[1], space.units[f][i]);

		  //
		  // do not strip ships if this is a space that needs to be besieged...
		  //
		  if ((space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair") && (space.fortified == 1 || space.fortified == true || space.type == "key" || space.type == "fortress")) {
		  } else {
		    space.units[f].splice(i, 1);
		    i--;
		  }

		}
	      }
	    }
	  }

	  //
	  // sack of rome exits
	  //
	  if (this.game.state.events.sack_of_rome == 1) {
	    return 1;
	  }

	  //
	  // unexpected war -- everyone retreats or gets destroyed
	  //
	  if (his_self.game.state.events.unexpected_war == 1) {
            for (let f in his_self.game.state.field_battle.faction_map) {
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	        this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
              }
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
              }
	    }
            this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
            this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	    this.displaySpace(space.key);
	    return 1;
	  }


          //
          // do any units remain
          //
	  let do_any_attacker_units_remain = false;
	  let do_any_defender_units_remain = false;
	  for (let f in his_self.game.state.field_battle.faction_map) {
	    if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	      if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) { do_any_attacker_units_remain = true; break; }
	    }
	  }
	  for (let f in his_self.game.state.field_battle.faction_map) {
	    if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	      if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) { do_any_attacker_units_remain = true; break; }
	    }
	  }

	  // 
	  // we are pushing things onto the queue in reverse order so that when the queue 
	  // is "unwound" in reverse the purging and capturing of leaders happens at the
	  // end. this is probably the most counterintuitive part of the code that follows
	  // -- to understand process in reverse.
	  //
	  let purge_instructions_added = 0;

	  //
	  // purge units and capture leaders
	  //
          if (winner === his_self.game.state.field_battle.defender_faction) {
	    this.game.queue.push("show_overlay\tfield_battle\tpost_field_battle_defenders_win");
            for (let f in his_self.game.state.field_battle.faction_map) {
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
	        purge_instructions_added++;
                this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	      }
	    }
	  }
          if (winner === his_self.game.state.field_battle.attacker_faction) {
	    this.game.queue.push("show_overlay\tfield_battle\tpost_field_battle_attackers_win");
            for (let f in his_self.game.state.field_battle.faction_map) {
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        purge_instructions_added++;
                this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
	      }
	    }
	  }

	  //
	  // depending on who wins, we handle retreats
	  //
          if (winner === his_self.game.state.field_battle.defender_faction) {

            //
            // if the space is besieged and the attacker controls it, this was a field battle triggered by the 
	    // defender putting it under siege earlier and the attacker relieving the siege, in which case we 
	    // want to permit the attacker to re-fortify IF there are any attacker units that survived AND the 
	    // attacker was not "out-hit" by the defender...
	    //
	    // attacker has more or equal hits, so they get to fortify everything without regard to wether it 
	    // was fortified before, submit to "post_field_battle_..." without "relief_siege" argument.
	    //
            if (this.isSpaceFriendly(space.key, his_self.game.state.field_battle.attacker_faction) && space.besieged > 0 && his_self.game.state.active_faction == his_self.game.state.field_battle.attacker_faction) {

	      //
	      // either way, relief force should disappear when all is done...
	      //
	      this.game.queue.push("remove_relief_forces\t"+space.key);

	      //	
	      // attackers win, defenders retreat
	      //
	      if (his_self.game.state.field_battle.attacker_hits > his_self.game.state.field_battle.defender_hits) {
                this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	      }

	      //
	      // tie, attackers can fortify before retreat
	      //
	      if (his_self.game.state.field_battle.attacker_hits == his_self.game.state.field_battle.defender_hits) {

		//
		// this condition makes it impossible to maintain the siege
		//
	        if (his_self.game.state.field_battle.defender_land_units_remaining <= his_self.game.state.field_battle.attacker_land_units_remaining) {
                  his_self.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+his_self.game.state.field_battle.defender_faction+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
                  his_self.game.queue.push("break_siege");
		}

	        if (do_any_attacker_units_remain) {
                  for (let f in his_self.game.state.field_battle.faction_map) {
                    if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
                      this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		    }
		  }
                  this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		  this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.defender_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.attacker_faction)+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key+"\trelief_siege_tie");
	        }
	      }

	      //
	      // attackers lose
	      //
	      if (his_self.game.state.field_battle.attacker_hits < his_self.game.state.field_battle.defender_hits) {
		//
		// if they murdered everyone else, no need to retreat...
		//
	  	if (do_any_defender_units_remain) {
                  this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+f+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
                  this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key);
		  this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.defender_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.attacker_faction)+"\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key+"\trelief_siege");
	        }
	      }

            } else {

	      //
	      // normal battle not relieve siege, defenders have won, so attacker must retreat to the same space from which 
	      // he came.
	      //
	      if (his_self.game.state.field_battle.defender_hits >= his_self.game.state.field_battle.attacker_hits) {
                for (let f in his_self.game.state.field_battle.faction_map) {
                  let can_faction_retreat = 0;
                  if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.attacker_faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) {
                      for (let z = 0; z < space.neighbours.length; z++) {
		        //
		        // attacker must retreat into space it entered from -- if controlled by ally
		        //
		        if (space.neighbours[z] == this.game.state.attacker_comes_from_this_spacekey) {
		          let fac = this.returnFactionControllingSpace(space.neighbours[z]);
		          if (this.returnControllingPower(fac) == this.returnControllingPower(f) || fac == f || this.areAllies(fac, f, 1)) { can_faction_retreat = 1; }
		        }
                      }
                      if (can_faction_retreat == 1) {
	  	        if (his_self.game.state.field_battle.attacker_land_units_remaining > 0) {
                          this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+f+"\t"+space.key);
                        }
                      }
	              if (can_faction_retreat == 0) {
	  	        if (his_self.game.state.field_battle.attacker_land_units_remaining > 0) {
		          this.updateLog(his_self.returnFactionName(f) + ": no retreat options, units captured");
	                }
	              }
		    }
                  }
	        }
	      }
	    }
          }

          if (winner === his_self.game.state.field_battle.attacker_faction) {

	    //
	    // if the attacker has fewer units than the defender has fortified at the end of the fortification 
	    // process then we want to force them to retreat or sacrifice their units as well.
	    //
	    let idx = this.game.queue.length-1;
	    idx -= purge_instructions_added;
	    let cmd = "post_field_battle_player_evaluate_continued_assault_or_retreat\t"+his_self.game.state.field_battle.attacker_faction+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key;
            this.game.queue.splice(idx, 0, cmd);

	    //
	    // normal battle, but the defenders can retreat to any space that is eligible, or fortify if they
	    // control the space and have any surviving units
	    //
            for (let f in his_self.game.state.field_battle.faction_map) {
              let can_faction_retreat = 0;
              if (his_self.game.state.field_battle.faction_map[f] == his_self.game.state.field_battle.defender_faction) {
	        if (his_self.returnFactionLandUnitsInSpace(f, space.key) > 0) {
                  for (let z = 0; z < space.neighbours.length; z++) {
                    let fluis = this.canFactionRetreatToSpace(f, space.neighbours[z], his_self.game.state.attacker_comes_from_this_spacekey);
                    if (fluis > 0) {
                      can_faction_retreat = 1;
                    }
                  }
                  if (can_faction_retreat == 1) {
		    if (his_self.game.state.field_battle.defender_land_units_remaining > 0) {
		      this.game.queue.push("post_field_battle_player_evaluate_retreat\t"+f+"\t"+space.key);
                    }
                  }
		  if (space.units[f].length > 0) {
		    if (his_self.isSpaceControlled(space.key, his_self.game.state.field_battle.defender_faction)) {
                      this.game.queue.push("post_field_battle_player_evaluate_fortification\t"+his_self.game.state.field_battle.attacker_faction+"\t"+his_self.returnPlayerOfFaction(his_self.game.state.field_battle.defender_faction)+"\t"+his_self.game.state.field_battle.defender_faction+"\t"+space.key);
	            }
	          }
	        } else {
	  	  if (his_self.game.state.field_battle.defender_land_units_remaining > 0) {
		    this.updateLog(this.returnFactionName(f) + ": no retreat options, units captured");
		  }
		}
              }
            }
        
	    //
            // if the space is besieged and is friendly to the attacker, un-besiege defenders
            // 
            if (this.isSpaceFriendly(his_self.game.state.field_battle.spacekey, his_self.game.state.field_battle.attacker_faction) && space.besieged > 0) {
              space.besieged = 0;
              for (let key in space.units) {
                for (let ii = 0; ii < space.units[key].length; ii++) {
                  space.units[key][ii].besieged = 0;
                }
              }
            }

	    //
	    // if the space does not belong to the attacker and is a key, we put it under siege
	    //
	    if (!this.isSpaceFriendly(his_self.game.state.field_battle.spacekey, his_self.game.state.field_battle.attacker_faction) && space.besieged == 0 && (space.type == "key" || space.type == "electorate" || space.type == "fortress")) {
	      this.game.queue.push("besiege_space\t"+his_self.game.state.field_battle.attacker_faction+"\t"+space.key+"\t1"); // 1 = do not force besiege units
	    }

	  }

          //
          // redisplay
          //
          his_self.displaySpace(space.key);

	  //
	  // show field battle overlay
	  //
          his_self.field_battle_overlay.renderPostFieldBattle(his_self.game.state.field_battle);
          his_self.field_battle_overlay.pullHudOverOverlay();

	  //
	  // reset
	  //
	  his_self.game.state.field_battle.relief_force = 0;

          return 1;

        }


	if (mv[0] === "besiege_space") {

	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let skip_besiege_units_inside = false;
	  if (parseInt(mv[3]) == 1) { skip_besiege_units_inside = true; }
	  let space = this.game.spaces[spacekey];

	  if (space) {
	    if (space.besieged == 0) {
              space.besieged = 2;
	      if (!skip_besiege_units_inside) {
                for (let key in space.units) {
	          if (!this.areAllies(key, attacker)) {
                    for (let ii = 0; ii < space.units[key].length; ii++) {
                      space.units[key][ii].besieged = 1;
                    }
                  }
                }
              }
            }
          }

          this.game.queue.splice(qe, 1);
	  return 1;
	}


 	if (mv[0] === "destroy_unit_by_type") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_type = mv[3];

	  if (this.game.spaces[spacekey]) {
	    for (let i = 0; i < this.game.spaces[spacekey].units[faction].length; i++) {
	      if (this.game.spaces[spacekey].units[faction][i].type == unit_type) {
	        this.game.spaces[spacekey].units[faction].splice(i, 1);
		i = this.game.spaces[spacekey].units[faction].length + 10;
		break;
	      }
	    }
	  }
	  if (this.game.navalspaces[spacekey]) {
	    for (let i = 0; i < this.game.navalspaces[spacekey].units[faction].length; i++) {
	      if (this.game.navalspaces[spacekey].units[faction][i].type == unit_type) {
	        this.game.navalspaces[spacekey].units[faction].splice(i, 1);
		i = this.game.navalspaces[spacekey].units[faction].length + 10;
		break;
	      }
	    }
	  }

	  this.updateLog(this.returnFactionName(faction) + " " + unit_type + " destroyed in " + this.returnSpaceName(spacekey));
	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);
          this.game.queue.splice(qe, 1);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();

	  return 1;

        }
 	if (mv[0] === "destroy_unit_by_index") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let unit_idx = parseInt(mv[3]);

	  if (this.game.spaces[spacekey]) {
	    this.game.spaces[spacekey].units[faction].splice(unit_idx, 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displaySpace(spacekey);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();


          this.game.queue.splice(qe, 1);
	  return 1;

	}

 	if (mv[0] === "destroy_units") {

          this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let units_to_destroy = JSON.parse(mv[3]);

	  let space;

	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }

	  units_to_destroy.sort();
	  if (units_to_destroy[0] < units_to_destroy[units_to_destroy.length-1]) {
	    units_to_destroy.reverse();
	  }

	  //
	  // remove from max to minimum to avoid index-out-of-array errors
	  //
	  for (let i = 0; i < units_to_destroy.length; i++) {
	    space.units[faction].splice(units_to_destroy[i], 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displayBoard();

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();


	  return 1;

	}



	if (mv[0] === "piracy") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;

	  let faction = mv[1];
	  let target_navalspace = mv[2];
	  let target_port = mv[3];
	  let target_faction = "";

	  let anti_piracy_rolls = [];
	  let anti_piracy_faction = [];
	  let anti_piracy_unittype = [];
	  let piracy_rolls = [];
	  let piracy_faction = [];
	  let piracy_unittype = [];

	  let dragut = false;
      	  let barbarossa = false;

          this.game.state.events.ottoman_piracy_attempts++;
          this.game.state.events.ottoman_piracy_seazones.push(target_navalspace);
	  this.showPiracyMarker(target_navalspace);

      	  let target_space = this.game.navalspaces[target_navalspace];
      	  let adjacent_spaces = [];
	  let ports = [];

 	  let io = this.returnImpulseOrder();
 	  let factions_at_war_with_ottoman = his_self.returnEnemies("ottoman", true); // true = include minor powers

    	  for (let i = 0; i < target_space.neighbours.length; i++) {
    	    adjacent_spaces.push(his_self.game.navalspaces[target_space.neighbours[i]]);
    	  } 
    	  for (let i = 0; i < target_space.ports.length; i++) {
    	    adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
    	  } 

          ports = target_space.ports;
    	  for (let i = 0; i < target_space.units[faction].length; i++) {
    	    if (target_space.units[faction][i].type == "dragut") { dragut = true; }
    	    if (target_space.units[faction][i].type == "barbarossa") { barbarossa = true; }
    	  } 
          
          target_faction = this.game.spaces[target_port].political;
          if (target_faction == "") { target_faction = this.game.spaces[target_port].home; }
          if (!factions_at_war_with_ottoman.includes(target_faction)) { factions_at_war_with_ottoman.push(target_faction); }
          let opponent_dice = 0;


	  let squadron_in_sea_zone = 0;				// 2 dice
	  let enemy_squadron_in_port_or_sea_zone = 0;		// 1 dice
	  let fortress_adjacent = 0;				// 1 dice

          //
          // targetted player dice
          // 2 dice per naval squadron in sea zone
          //
          for (let z = 0; z < target_space.units[target_faction].length; z++) {
            if (target_space.units[target_faction][z].type == "squadron") {
	      opponent_dice += 2;
	      squadron_in_sea_zone += 2;
	      anti_piracy_faction.push(target_faction);
	      anti_piracy_unittype.push("squadron");
	      anti_piracy_faction.push(target_faction);
	      anti_piracy_unittype.push("squadron");
	    }
          }

          //
          // 1 dice for their own or at-war-with-ottoman power (incl. minor) in port or adjacent sea-zone
          //
          for (let i = 0; i < adjacent_spaces.length; i++) {
            for (let k = 0; k < factions_at_war_with_ottoman.length; k++) {
              for (let z = 0; z < adjacent_spaces[i].units[factions_at_war_with_ottoman[k]].length; z++) {
                let u = adjacent_spaces[i].units[factions_at_war_with_ottoman[k]][z];
                if (u.type == "squadron") {
                  opponent_dice++;
	          enemy_squadron_in_port_or_sea_zone++;
	          anti_piracy_faction.push(factions_at_war_with_ottoman[k]);
	          anti_piracy_unittype.push("squadron");
                }
              }
            }
          }

          //
          // 1 dice for each fortres controlled by target, power at war, or St. John -- fortress adjacent
          //
          if (target_space.key == "atlantic" || target_space.key == "barbary") {
            let x = his_self.returnFactionControllingSpace("gibraltar");
            if (target_faction == x || factions_at_war_with_ottoman.includes(x)) { 
	      anti_piracy_faction.push("gibraltar");
	      anti_piracy_unittype.push("fortress");
	      fortress_adjacent++;
	      opponent_dice++;
	    }
          }
          if (target_space.key == "africa" || target_space.key == "ionian") {
            let x = his_self.returnFactionControllingSpace("malta");
            if (target_faction == x || factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("malta");
	      anti_piracy_unittype.push("fortress");
	      fortress_adjacent++;
	      opponent_dice++;
            }
          }
          if (target_space.key == "africa" || target_space.key == "aegean") {
            let x = his_self.returnFactionControllingSpace("corfu");
            if (target_faction == x || factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("corfu");
	      anti_piracy_unittype.push("fortress");
	      fortress_adjacent++;
	      opponent_dice++;
	    }
          }
          if (target_space.key == "adriatic" || target_space.key == "ionian") {
            let x = his_self.returnFactionControllingSpace("candia");
            if (target_faction == x || factions_at_war_with_ottoman.includes(x)) {
	      anti_piracy_faction.push("candia");
	      anti_piracy_unittype.push("fortress");
	      fortress_adjacent++;
	      opponent_dice++;
	    }
          }
	  // why? because some ports on multiple seas
	  let already_counted_knights = false;
          if (his_self.game.state.knights_of_st_john != "") {
            let indspace = his_self.game.spaces[his_self.game.state.knights_of_st_john];
            if (indspace.unrest != 1 && indspace.besieged <= 0) {
              for (let b = 0; b < indspace.ports.length; b++) {
                if (indspace.ports[b] == target_space.key && already_counted_knights == false) {
		  already_counted_knights = true;
	          anti_piracy_faction.push(indspace.ports[b]);
	          anti_piracy_unittype.push("fortress");
	          fortress_adjacent++;
                  opponent_dice++;
                }
              }
            }
          }

	  //
	  // look for any trace italliances
	  //
	  for (let z = 0; z < target_space.ports.length; z++) {
	    let ap = target_space.ports[z];
	    let already_counted = ["gibraltar","malta","corfu","candia"];
	    if (his_self.game.state.knights_of_st_john != "") { already_counted.push(his_self.game.state.knights_of_st_john); }
	    if (!already_counted.includes(ap)) {
	      if (his_self.game.spaces[ap]) {
	        let x = his_self.returnFactionControllingSpace(ap);
	        if (x == target_faction || factions_at_war_with_ottoman.includes(x)) {
		  if (his_self.isSpaceFortress(ap) && !his_self.isSpaceInUnrest(ap) && !his_self.isSpaceBesieged(ap)) {
		    already_counted.push(ap);
	            anti_piracy_faction.push(ap);
	            anti_piracy_unittype.push("fortress");
	            fortress_adjacent++;
	            opponent_dice++;
	          }
	        }
	      }
	    }
	  }

	  if (squadron_in_sea_zone > 0) {
	    his_self.updateLog(` ${squadron_in_sea_zone} dice from local squadrons`);
	  }
	  if (enemy_squadron_in_port_or_sea_zone > 0) {
	    his_self.updateLog(` ${enemy_squadron_in_port_or_sea_zone} dice from adjacent/port squadrons`);
	  }
	  if (fortress_adjacent > 0) {
	    his_self.updateLog(` ${fortress_adjacent} dice from fortresses`);
	  }

          //
          // eliminate 1 corsair for each hit of 5 or 6
          //
          let hits = 0;
          for (let i = 0; i < opponent_dice; i++) {
	    let x = his_self.rollDice(6);
	    anti_piracy_rolls.push(x);
	    if (x >= 5) { hits++; }
          }

	  his_self.updateLog("Anti-Piracy Dice: " + opponent_dice);
	  his_self.updateLog("Anti-Piracy Rolls: " + JSON.stringify(anti_piracy_rolls));

	  if (hits > 0) {
	    for (let z = 0; hits > 0 && z < target_space.units["ottoman"].length; z++) {
	      let u = target_space.units["ottoman"][z];
	      if (u.type == "corsair") {
		target_space.units["ottoman"].splice(z, 1);
	        hits--;
		z--;
	      }
	    }
	  }

	  //
	  // how many corsairs left
	  //
	  let corsairs_remaining = 0;
	  for (let z = 0; z < target_space.units["ottoman"].length; z++) {
	    if (target_space.units["ottoman"][z].type == "corsair") {
	      corsairs_remaining++;
	    }
	  }

	  //
	  // how many target ports
	  //
	  let targetted_ports = 0;
	  for (let z = 0; z < target_space.ports.length; z++) {
	    if (his_self.returnFactionControllingSpace(target_space.ports[z]) == target_faction) {
	      targetted_ports++;
	    }
	  }

	  let piracy_dice = 0;

	  if (corsairs_remaining > 0) {
	    if (targetted_ports == 1) {
	      piracy_dice = 1;
	      piracy_unittype.push("corsairs");
	      piracy_faction.push("targetting single port");
	    } else {
	      if (corsairs_remaining == 1) {
	 	piracy_dice = 1;
	        piracy_unittype.push("corsairs");
	        piracy_faction.push("targeting multiple ports");
	      } else {
	 	if (corsairs_remaining > 1) {
		  piracy_dice = 2;
	          piracy_unittype.push("corsairs");
	          piracy_unittype.push("corsairs");
	          piracy_faction.push("targetting multiple ports");
	          piracy_faction.push("targetting multiple ports");
		}
	      }
	    }
	  }

	  if (piracy_dice == 0) {
	    his_self.updateLog("No corsairs remaining - piracy cancelled");
	    if (his_self.game.player == his_self.returnPlayerCommandingFaction("ottoman")) {
	      his_self.displayCustomOverlay("all_corsairs_destroyed");
	    }
	    return 1;
	  }

	  if (barbarossa) {
	    piracy_dice += 1;
	    piracy_unittype.push("barbarossa");
	    piracy_faction.push("pirate leader");
	  }
	  if (dragut) {
	    piracy_dice += 2;
	    piracy_unittype.push("dragut");
	    piracy_faction.push("pirate leader");
	    piracy_unittype.push("dragut");
	    piracy_faction.push("pirate leader");
	  }

	  his_self.updateLog("Piracy dice: " + piracy_dice);

	  let piracy_hits = 0;
	  piracy_rolls = [];
	  for (let i = 0; i < piracy_dice; i++) {
	    let x = his_self.rollDice(6);
	    piracy_rolls.push(x);
	    if (x >= 5) { piracy_hits++; }
	  }

	  his_self.updateLog("Piracy rolls: " + JSON.stringify(piracy_rolls));

	  //
	  // create piracy object for overlay
	  //
	  let pobj = {
	    anti_piracy_rolls : anti_piracy_rolls,
	    anti_piracy_faction : anti_piracy_faction,
	    anti_piracy_unittype : anti_piracy_unittype,
	    piracy_rolls : piracy_rolls,
	    piracy_faction : piracy_faction,
	    piracy_unittype : piracy_unittype,
	  };

	  this.piracy_overlay.render(pobj);

//
// TEST / HACK piracy hits
//
//piracy_hits = 3;

	  if (piracy_hits > 0) {
            if (his_self.game.state.events.julia_gonzaga_activated == 1 && target_navalspace == "tyrrhenian") {
              his_self.game.queue.push("SETVAR\tstate\tevents\tottoman_julia_gonzaga_vp\t1");
	    }
	    his_self.game.queue.push("piracy_hits\t"+target_faction+"\t"+piracy_hits+"\t"+target_port+"\t"+target_navalspace);
	  }

	  return 1;

	}


	//
	// Machiavelli, Defeat of Hungary
	//
	// Three Event cards (Schmalkaldic League, Machiavelli: âThe Princeâ, and Six Wives of Henry VIII) create a state of war 
	// during the Action Phase. The Ottoman defeat of Hungary may trigger a state of war with the Hapsburg during the Action 
	// Phase (Section 22.5). Finally, the activation of a minor power can create a state of war between major powers 
	// (Section 22.2). Add an appropriate marker to the Diplomatic Status Display when any of these five events occurs.
	// If naval units of the two powers now at war occupy the same sea zone, fight an immediate naval battle between the 
	// two powers. If the number of hits is equal, both sides must retreat (an exception to the usual naval combat rule)
	//
	if (mv[0] === "unexpected_war") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction1 = mv[1];
	  let faction2 = mv[2];

          his_self.game.queue.push("SETVAR\tstate\tevents\tunexpected_war\t0");

	  for (let key in his_self.game.navalspaces) {
	    let faction1_present = 0;
	    let faction2_present = 0;
	    let space = his_self.game.navalspaces[key];
	    for (let f in space.units) {
	      if (space.units[f].length > 0) {
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction1)) {
		  faction1_present = 1;
	        }
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction2)) {
		  faction2_present = 1;
	        }
	      }
	    }
	    if (faction1_present == 1 && faction2_present == 1) {
              his_self.game.queue.push("naval_battle\t"+key+"\t"+faction1+"\t"+his_self.returnControllingPower(faction2));
	    }
	  }

	  for (let key in his_self.game.spaces) {
	    let faction1_present = 0;
	    let faction2_present = 0;
	    let space = his_self.game.spaces[key];
	    for (let f in space.units) {
	      if (space.units[f].length > 0) {
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction1)) {
		  faction1_present = 1;
	        }
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction2)) {
		  faction2_present = 1;
	        }
	      }
	    }
	    if (faction1_present == 1 && faction2_present == 1) {
	      if (!his_self.isSpaceBesieged(key)) {
		// attacker will be one that does not control the space
		let fac = his_self.returnFactionControllingSpace(key);
		if (his_self.areAllies(fac, faction1)) {
                  his_self.game.queue.push("field_battle\t"+key+"\t"+faction2);
		} else {
                  his_self.game.queue.push("field_battle\t"+key+"\t"+faction1);
		}
	      }
	    }
	  }

          his_self.game.queue.push("SETVAR\tstate\tevents\tunexpected_war\t1");
	  return 1;

	}


	if (mv[0] === "piracy_hits") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let hits = parseInt(mv[2]);
	  let target_port = mv[3];
	  let target_navalspace = mv[4];
	  let hits_given = 0;

//
// TEST / HACK - adjust piracy hits
//
//hits = 3;

	  //
	  // number available
	  //
          let squadrons_available = 0;
          let vp_available = 10 - this.game.state.events.ottoman_piracy_vp;
	  let cards_available = 0;

	  let squadrons_offered = 0;
	  let cards_offered = 0;
	  let vp_offered = 0;

	  let options = ["eliminate","card","vp"];
	  let issued = [];

	  //
	  // cannot choose an option with no benefits, and must choose all possible
	  // options before giving one a second time. in order to know how many times
	  // we can issue a card or sacrifice a squadron, we need to know how many
	  // of those exist.
	  //
	  // first count squadrons that can be removed
	  //
          let target_space = this.game.spaces[target_port];
          target_navalspace = this.game.navalspaces[target_navalspace];
          let adjacent_spaces = [];
          for (let i = 0; i < target_navalspace.ports.length; i++) {
            adjacent_spaces.push(target_navalspace.ports[i]);
          }
	  adjacent_spaces.push(mv[4]);
          for (let i = 0; i < target_navalspace.neighbours.length; i++) {
            adjacent_spaces.push(target_navalspace.neighbours[i]);
          }
          for (let p = 0; p < adjacent_spaces.length; p++) {
	    let ts = adjacent_spaces[p];
	    let s = null;
	    if (this.game.spaces[ts]) { s = this.game.spaces[ts]; }
	    if (this.game.navalspaces[ts]) { s = this.game.navalspaces[ts]; }

            for (let key in s.units) {
	      if (this.returnControllingPower(key) == faction) {
	        for (let i = 0; i < s.units[key].length; i++) {
		  if (s.units[key][i].type == "squadron") {
		    squadrons_available++;
		  }
		}
	      }
	    }
	  }


	  let vp_issuable = true;
	  let cards_issuable = true;
	  let squadrons_issuable = true;

//
// TEST HACK piracy hits
//
//cards_issuable = false;



	  let selectPiracyRewards = function(selectPiracyRewards) {

            let msg = `Offer the Ottoman Empire which Reward (${(hits_given+1)} of ${hits})? `;
            let html = '<ul>';
	    let numchoice = 0;

	    if (
		vp_issuable == true && vp_available > 0 && 
		(
			(vp_offered <= cards_offered && vp_offered <= squadrons_offered) ||
			(vp_offered <= cards_offered && squadrons_issuable == false) || 
			(vp_offered <= squadrons_offered && vp_offered <= cards_offered) ||
			(vp_offered <= squadrons_offered && cards_issuable == false)
		)
	    ) {
              html += `<li class="option" id="vp">give vp</li>`;
	      numchoice++;
	    }


	    if (
		cards_issuable == true && cards_available > 0 && 
		(
			(cards_offered <= vp_offered && cards_offered <= squadrons_offered) ||
			(cards_offered <= vp_offered && squadrons_issuable == false) || 
			(cards_offered <= squadrons_offered && cards_offered <= vp_offered) ||
			(cards_offered <= squadrons_offered && vp_issuable == false)
		)
	    ) {
              html += `<li class="option" id="card">give card draw</li>`;
	      numchoice++;
	    }


	    if (
		squadrons_issuable == true && squadrons_available > 0 &&
		(
			(squadrons_offered <= vp_offered && squadrons_offered <= cards_offered) ||
			(squadrons_offered <= vp_offered && cards_issuable == false) || 
			(squadrons_offered <= cards_offered && squadrons_offered <= vp_offered) ||
			(squadrons_offered <= cards_offered && vp_issuable == false)
		)
	    ) {
              html += `<li class="option" id="squadron">destroy squadron</li>`;
	      numchoice++;
	    }


	    if (numchoice == 0) {
              html += `<li class="option" id="none">none available</li>`;
	    }	

            html += '</ul>';

	    if (numchoice == 0) {
	      if (vp_issuable == true) {
                html += `<li class="option" id="vp">give vp</li>`;
	        numchoice++;
	      }
	      if (cards_issuable == true) {
                html += `<li class="option" id="card">give card draw</li>`;
	        numchoice++;
	      }	
	      if (squadrons_issuable == true) {
                html += `<li class="option" id="squadron">destroy squadron</li>`;
	        numchoice++;
	      }	
	    }

	    if (numchoice == 0) {
	      his_self.updateStatus("No piracy wards can be issued...");
	      his_self.endTurn();
	      return 0;
	    }	    

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
              $('.option').off();
	      hits_given++;

	      if (action == "vp") {
		vp_offered++;
		vp_available--;
		his_self.addMove("piracy_reward_vp");
		his_self.addMove("NOTIFY\t" + his_self.returnFactionName(faction) + " offers Ottomans 1 VP");
	      }
	      if (action == "card") {
		cards_offered++;
		cards_available--;
		his_self.addMove("piracy_reward_card\t"+faction);
		his_self.addMove("NOTIFY\t" + his_self.returnFactionName(faction) + " offers Ottomans card draw");
	      }
	      if (action == "squadron") {
		squadrons_offered++;
		squadrons_available--;
		his_self.addMove("piracy_reward_squadron\t"+faction+"\t"+mv[4]);
		his_self.addMove("NOTIFY\t" + his_self.returnFactionName(faction) + " destroys squadron");
	      }
	      if (action == "none") {
                his_self.updateStatus("acknowledge...");
	        his_self.endTurn();
	      }

	      if (hits_given < hits) {
	        selectPiracyRewards(selectPiracyRewards);
	      } else {
                his_self.updateStatus("acknowledge...");
	        his_self.endTurn();
	      }
	    });
          }

          if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {

            let fhand_idx = this.returnFactionHandIdx(his_self.game.player, faction);

	    cards_available = this.game.deck[0].fhand[fhand_idx].length;

	    if (faction == "hapsburg" && !this.game.deck[0].discards['002']) { cards_available--; }
	    if (faction == "england" && !this.game.deck[0].discards['003']) { cards_available--; }
	    if (faction == "france" && !this.game.deck[0].discards['004']) { cards_available--; }
	    if (faction == "papacy" && !this.game.deck[0].discards['005']) { cards_available--; }
	    if (faction == "papacy" && !this.game.deck[0].discards['006']) { cards_available--; }
	    if (faction == "protestant" && !this.game.deck[0].discards['007']) { cards_available--; }

	    if (vp_available == 0 || ((vp_available-vp_offered) == 0)) { vp_issuable = false; }
	    if (squadrons_available == 0) { squadrons_issuable = false; }
	    if (cards_available <= 0) { cards_issuable = false; }

            selectPiracyRewards(selectPiracyRewards);

          } else {
            his_self.updateStatus(his_self.returnFactionName(faction) + " issuing Piracy Rewards");
          }

	  return 0;

	}

	if (mv[0] === "piracy_reward_vp") {
          this.game.queue.splice(qe, 1);
	  this.game.state.events.ottoman_piracy_vp++;
	  his_self.updateLog("Ottoman Empire earns VP from Piracy");
	  return 1;
	}

	if (mv[0] === "piracy_reward_card") {
          this.game.queue.splice(qe, 1);

	  let turkish_cards_left = parseInt(this.game.state.cards_left["ottoman"]);
	  if (turkish_cards_left > 0) {
	    turkish_cards_left += 1;
	  } else {
	    turkish_cards_left = 1;
	  }

	  this.game.queue.push("cards_left\tottoman\t"+turkish_cards_left);
	  this.game.queue.push("pull_card\tottoman\t"+mv[1]);
	  his_self.updateLog("Ottoman Empire earns Bonus Card from Piracy");
	  return 1;
	}

	if (mv[0] === "piracy_reward_squadron") {
          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let target_navalspace = mv[2];
	  let squadron_rich_targets = [];
          let target_space = this.game.navalspaces[target_navalspace];
          let adjacent_spaces = [];
          for (let i = 0; i < target_space.ports.length; i++) {
            adjacent_spaces.push(target_space.ports[i]);
          }
	  adjacent_spaces.push(target_navalspace);
          for (let i = 0; i < target_space.neighbours.length; i++) {
            adjacent_spaces.push(target_space.neighbours[i]);
          }
          for (let p = 0; p < adjacent_spaces.length; p++) {
	    let ts = adjacent_spaces[p];
	    let s = null;
	    let is_naval_space = false;
	    try { if (this.game.spaces[ts]) { s = this.game.spaces[ts]; } } catch (err) {}
	    try { if (this.game.navalspaces[ts]) { is_naval_space = true; s = this.game.navalspaces[ts]; } } catch (err) {}
            for (let key in s.units) {
	      if (his_self.returnControllingPower(key) == his_self.returnControllingPower(faction)) {
	        if (is_naval_space == true) {
	          for (let i = 0; i < s.units[key].length; i++) {
		    if (s.units[key][i].type == "squadron") {
		      if (!squadron_rich_targets.includes(ts)) {
		        squadron_rich_targets.push(ts);
		      }
		    }
		  }
	        } else {
	          if (this.returnControllingPower(key) == faction) {
	            for (let i = 0; i < s.units[key].length; i++) {
		      if (s.units[key][i].type == "squadron") {
		        if (!squadron_rich_targets.includes(ts)) {
		          squadron_rich_targets.push(ts);
		        }
		      }
		    }
	          }
		}
	      }
	    }
	  }

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            let msg = "Destroy Squadron: ";
            let html = '<ul>';
	    for (let i = 0; i < squadron_rich_targets.length; i++) {
	      html += `<li class="option" id="${squadron_rich_targets[i]}">${his_self.returnSpaceName(squadron_rich_targets[i])}</li>`;
	    }
	    html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);
            $('.option').off();
            $('.option').on('click', function () {

	      his_self.updateStatus("destroying...");

              let action = $(this).attr("id");
              $('.option').off();

	      his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " destroys squadron in " + his_self.returnSpaceName(action));
	      his_self.addMove("destroy_unit_by_type\t"+faction+"\t"+action+"\t"+"squadron");
	      his_self.endTurn();

	    });
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " destroying squadron...");
	  }

	  return 0;

	}


 	if (mv[0] === "destroy_naval_units") {
          this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let spacekey = mv[2];
	  let units_to_destroy = JSON.parse(mv[3]);

	  let space;

	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

	  units_to_destroy.sort();
	  if (units_to_destroy[0] < units_to_destroy[units_to_destroy.length-1]) {
	    units_to_destroy.reverse();
	  }

	  //
	  // remove from max to minimum to avoid index-out-of-array errors
	  //
	  for (let i = 0; i < units_to_destroy.length; i++) {
	    space.units[faction].splice(i, 1);
	  }

	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
	  this.displayBoard();

	  return 1;

	}


	if (mv[0] === "naval_battle_continue") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space;
	  if (this.game.spaces[mv[1]]) {
	    space = this.game.spaces[mv[1]];
	  }
	  if (this.game.navalspaces[mv[1]]) {
	    space = this.game.navalspaces[mv[1]];
	  }

	  //
	  // calculate hits
	  //
          let modify_rolls = function(player, roll_array) {
	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                }
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                }
              }
            }
	    return modified_rolls;
          }
          let calculate_hits = function(player, roll_array) {
            let hits = 0;
            for (let i = 0; i < roll_array.length; i++) {
              if (roll_array[i] >= 5) {
                hits++;
              }
            }
            return hits;
          }
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionSeaUnitsInSpace(f, space);
	      }
	    }

	    //
	    //
	    //
	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }

	    while (are_hits_all_assigned == 0 && hits_to_assign > 1) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 1) {

		//
		// assign hits to allies
		//
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 2; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "corsair"; }
		        if (zzz == 1) { cannon_fodder = "squadron"; }

  	     	        for (let i = 0; i < space.units[f].length; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {
		  	    space.units[f].splice(i, 1);
			    hits_to_assign -= 2;
		            zzz = 1000000;
		            i   = 1000000;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionSeaUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 1) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 2; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "corsair"; }
                    if (zzz == 1) { cannon_fodder = "squadron"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {
			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " sunk");
                        space.units[selected_faction].splice(ii, 1);
                        hits_to_assign -= 2;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction sea units next
		  //
		  targets.splice(selected_target-1, 1);
		}
	      }

	      are_hits_all_assigned = 1;

	    }

	  }

	  let faction_map       = his_self.game.state.naval_battle.faction_map;
	  let attacker_faction  = his_self.game.state.naval_battle.attacker_faction;
	  let defender_faction  = his_self.game.state.naval_battle.defender_faction;
          let attacker_player   = his_self.returnPlayerOfFaction(attacker_faction);
          let defender_player   = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_results  = his_self.game.state.naval_battle.attacker_results;
	  let defender_results  = his_self.game.state.naval_battle.defender_results;
	  let attacker_rolls    = his_self.game.state.naval_battle.attacker_rolls;
	  let defender_rolls    = his_self.game.state.naval_battle.defender_rolls;
	  let attacker_units    = his_self.game.state.naval_battle.attacker_units;
	  let defender_units    = his_self.game.state.naval_battle.defender_units;
	  let is_battle_in_port = his_self.game.state.naval_battle.is_battle_in_port;

	  let winner	        = defender_faction;
	  let attacker_hits     = 0;
	  let defender_hits     = 0;

	  //
	  // assign hits simultaneously
	  //
	  if (attacker_player > 0) {
	    let ap = his_self.game.state.players_info[attacker_player-1];
	    his_self.game.state.naval_battle.attacker_modified_rolls = modify_rolls(ap, attacker_results);
	  }

	  if (defender_player > 0) {
	    let dp = his_self.game.state.players_info[defender_player-1];
	    his_self.game.state.naval_battle.defender_modified_rolls = modify_rolls(dp, defender_results);
	  }

	  attacker_hits = calculate_hits(attacker_player, attacker_results);
	  defender_hits = calculate_hits(defender_player, defender_results);

	  if (attacker_player == 0) {
	    assign_hits(attacker_faction, defender_hits);
          }
	  if (defender_player == 0) {
	    assign_hits(defender_faction, attacker_hits);
          }

	  his_self.game.state.naval_battle.attacker_hits = attacker_hits;
	  his_self.game.state.naval_battle.defender_hits = defender_hits;

	  //
	  // who won?
	  //
	  if (attacker_hits > defender_hits) {
	    winner = attacker_faction;
	  }

	  his_self.game.state.naval_battle.winner = winner;

	  his_self.updateLog("Winner: " + winner);
	  his_self.updateLog("Attacker Hits: " + attacker_hits);
	  his_self.updateLog("Defender Hits: " + defender_hits);
	  his_self.updateLog("Attacker Modified: " + JSON.stringify(his_self.game.state.naval_battle.attacker_modified_rolls));
	  his_self.updateLog("Defender Modified: " + JSON.stringify(his_self.game.state.naval_battle.defender_modified_rolls));


	  //
	  // calculate units remaining
	  //
	  let attacker_sea_units_remaining = 0;
	  let defender_sea_units_remaining = 0;
	  for (let f in space.units) {
	    if (this.returnControllingPower(f) == this.returnControllingPower(attacker_faction)) {
	      for (let z = 0; z < space.units[f].length; z++) {
	        let u = space.units[f][z];
   	        if (u.type == "squadron" || u.type == "corsair") {
	          attacker_sea_units_remaining++;
	        }
	      }
	    }
	    if (this.returnControllingPower(f) == this.returnControllingPower(defender_faction)) {	
	      for (let z = 0; z < space.units[f].length; z++) {
	        let u = space.units[f][z];
   	        if (u.type == "squadron" || u.type == "corsair") {
	          defender_sea_units_remaining++;
	        }
	      }
	    }
	  }

          his_self.game.state.naval_battle.attacker_sea_units_remaining = attacker_sea_units_remaining;
          his_self.game.state.naval_battle.defender_sea_units_remaining = defender_sea_units_remaining;

	  if (attacker_sea_units_remaining <= 0 && defender_sea_units_remaining <= 0) {
	    if (attacker_rolls > defender_rolls) {
	      his_self.updateLog("Attacker adds 1 squadron");
	      his_self.addNavalSquadron(attacker_faction, space);
	    } else {
	      his_self.updateLog("Defender adds 1 squadron");
	      his_self.addNavalSquadron(defender_faction, space);
	    }
	  }

	  //
	  // capture stranded leaders
	  //
	  if (attacker_sea_units_remaining <= 0) {
	    for (let f in space.units) {
	      if (his_self.returnControllingPower(f) == his_self.returnControllingPower(attacker_faction)) {
	        for (let i = space.units[f].length-1; i >= 0; i--) {
	          if (space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair" || space.units[f][i].navy_leader == true) {
	            his_self.captureLeader(defender_faction, f, mv[1], space.units[f][i]);
	            space.units[f].splice(i, 1);
	            i--;
	          }
	        }
	      }
	    }
	  }
	  if (defender_sea_units_remaining <= 0) {
	    for (let f in space.units) {
	      if (his_self.returnControllingPower(f) == his_self.returnControllingPower(defender_faction)) {
	        for (let i = space.units[f].length-1; i >= 0; i--) {
	          if (space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair" || space.units[f][i].navy_leader == true) {
	            his_self.captureLeader(f, attacker_faction, mv[1], space.units[f][i]);
	            space.units[f].splice(i, 1);
	            i--;
	          }
	        }
	      }
	    }
	  }

          //          
          // unexpected war -- everyone retreats or gets destroyed
          //   
          if (his_self.game.state.events.unexpected_war == 1) {
            for (let f in his_self.game.state.naval_battle.faction_map) {
              if (his_self.game.state.naval_battle.faction_map[f] == his_self.game.state.naval_battle.attacker_faction) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.naval_battle.defender_faction+"\t"+space.key);
              }     
              if (his_self.game.state.naval_battle.faction_map[f] == his_self.game.state.naval_battle.defender_faction) {
                this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+his_self.game.state.naval_battle.attacker_faction+"\t"+space.key);
              }       
            }
	    if (attacker_sea_units_remaining > 0) {
              this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+his_self.game.state.naval_battle.attacker_faction+"\t"+space.key);
	    }
	    if (defender_sea_units_remaining > 0) {
              this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+his_self.game.state.naval_battle.defender_faction+"\t"+space.key);
	    }

	    this.displaySpace(space.key);
	    this.displayNavalSpace(space.key);
            return 1;
          }           

	  this.displaySpace(space.key);
	  this.displayNavalSpace(space.key);

	  this.updateLog("Winner: "+this.returnFactionName(winner));
	  this.updateLog("Attacker Units Remaining: "+attacker_sea_units_remaining);
	  this.updateLog("Defender Units Remaining: "+defender_sea_units_remaining);


          //
          // conduct retreats
          //
	  if (this.game.spaces[space.key]) {

	    //
	    // attacker always retreats from ports
	    //
            this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+attacker_faction+"\t"+space.key);

	  } else {

	    //
	    // loser retreats on open seas
	    //
            if (winner == defender_faction) {
	      if (attacker_sea_units_remaining > 0) {
                for (let f in his_self.game.state.naval_battle.faction_map) {
		  if (his_self.returnControllingPower(f) == his_self.returnControllingPower(attacker_faction)) {
                    this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+defender_faction+"\t"+space.key);
                    this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+f+"\t"+space.key);
	          }
	        }
	      }
	    } else {
	      if (defender_sea_units_remaining > 0) {
                for (let f in his_self.game.state.naval_battle.faction_map) {
		  if (his_self.returnControllingPower(f) == his_self.returnControllingPower(defender_faction)) {
                    this.game.queue.push("purge_naval_units_and_capture_leaders\t"+f+"\t"+attacker_faction+"\t"+space.key);
                    this.game.queue.push("player_evaluate_post_naval_battle_retreat\t"+f+"\t"+space.key);
	          }
	        }
	      }
	    }

	  }

          //
          // redisplay
          //
	  if (this.game.spaces[space.key]) {
            his_self.displaySpace(space.key);
	  } else {
            his_self.displayNavalSpace(space.key);
	  }

          return 1;

        }


	if (mv[0] === "assault") {

          this.game.queue.splice(qe, 1);
	  this.game.state.assault = {};
          this.game.state.assaulted_this_impulse = 1;
	  this.game.state.events.roxelana = 0; // no more free assaults :)

	  //
	  // calculate rolls
	  //
          let calculate_units = function(faction, space) {
	    let num = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].army_leader != true && space.units[faction][i].navy_leader != true && space.units[faction][i].type != "cavalry" && space.units[faction][i].personage == false) { num++; }
	    }
	    return num;
          }

	  //
	  // calculate highest battle ranking
	  //
          let calculate_highest_battle_rating = function(faction) {
	    let highest_battle_rating = 0;
            for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].battle_rating > 0) {
	        if (space.units[faction][i].gout != true) {
	          if (highest_battle_rating < space.units[faction][i].battle_rating) {
		    highest_battle_rating = space.units[faction][i].battle_rating;
		  }
		}
	      }
	    }
	    return highest_battle_rating;
          }


	  //
	  // this is run when a field battle starts. players have by now
	  // interceded or played cards that allow them to respond to the
	  // movement, including retreat into a fortress if available. as
	  // such, this handles the conflict.
	  //
	  let his_self = this;
	  let attacker = mv[1];
	  let spacekey = mv[2];
	  let space = this.game.spaces[mv[2]];
	  let stage = "assault";

	  //
	  //
	  //
	  this.updateLog(this.returnFactionName(attacker) + " assaults " + this.returnSpaceName(spacekey));

	  //
	  // keep track of assaulted spaces
	  //
 	  this.game.state.spaces_assaulted_this_turn.push(spacekey);

	  //
	  // prevent from being assaulted again
	  //
          space.besieged == 2;

	  //
	  // otherwise -- who the hell is here?
	  //
	  // an ally of a major power can intercept and fight together, complicating
	  // how hits are assigned. so we need to know which factions are actually on
	  // which sides. additionally, formations can include units from allied minor
	  // powers.
	  //
	  let attacker_faction = attacker;
	  let defender_faction = his_self.returnDefenderFaction(attacker_faction, space);

	  //
	  // defender-identification can backfire if the attacker is the only faction
	  // in the space. so we want to safeguard against this and set the defender
	  // to whomever is controlling the space in the event that we cannot find
	  // anyone but the attacker here.
	  //
	  if (defender_faction == attacker_faction) {
	    defender_faction = his_self.returnFactionControllingSpace(space);
	  }

 	  let attacker_player = his_self.returnPlayerCommandingFaction(attacker_faction);
 	  let defender_player = his_self.returnPlayerCommandingFaction(defender_faction);

	  //
	  // map every faction in space to attacker or defender
	  //
	  let attacking_factions = 0;
	  let defending_factions = 0;
	  let faction_map = this.returnFactionMap(space, attacker_faction, defender_faction);


	  //
	  // migrate any bonuses to attacker or defender
	  //
          for (let f in space.units) {
	    if (f !== attacker_faction && faction_map[f] == attacker_faction) {
	      try {
	      let p = his_self.game.state.players_info[his_self.returnPlayerCommandingFaction(attacker)-1];
	      let ap = his_self.game.state.players_info[attacker_player-1];
	      if (p.tmp_roll_first == 1) { ap.tmp_roll_first = 1; }
	      if (p.tmp_roll_bonus != 0) { ap.tmp_roll_bonus += p.tmp_roll_bonus; }
	      if (p.tmp_roll_modifiers.length > 0) {
		for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	          ap.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	        }
	      }
	      } catch (err) {}
	    }
	    if (f !== defender_faction && faction_map[f] == defender_faction) {
	      try {
	      if (defender_player > 0) {
	        let p = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1];
	        let dp = his_self.game.state.players_info[defender_player-1];
	        if (p.tmp_roll_first == 1) { dp.tmp_roll_first = 1; }
	        if (p.tmp_roll_bonus != 0) { dp.tmp_roll_bonus += p.tmp_roll_bonus; }
	        if (p.tmp_roll_modifiers.length > 0) {
	   	  for (let i = 0; i < p.tmp_roll_modifiers.length; i++) {
	            dp.tmp_roll_modifiers.push(p.tmp_roll_modifiers[i]);
	          }
	        }
	      }
	      } catch (err) {}
	    }
          }

	  //
	  // we now have a mapping of all factions to the two main factions that
	  // will make any strategic decisions for hits assignment, etc. and any
	  // bonuses that affect combat will have been copied over to those players
	  //

	  //
	  // calculate the total rolls each faction gets to make. the defender starts
	  // with +1 roll bonus because they have control over the space.
	  //
	  let attacker_units = 0;
	  let defender_units = 0;
	  let attacker_rolls = 0;
	  let defender_rolls = 1;
          let attacker_units_units = [];
          let defender_units_units = [];
          let attacker_units_faction = [];
          let defender_units_faction = [defender_faction];
	  let attacker_highest_battle_rating = 0;
	  let defender_highest_battle_rating = 0;

	  for (let f in faction_map) {
	    if (faction_map[f] == attacker_faction) {
	      let x = his_self.returnFactionLandUnitsInSpace(f, space);
	      attacker_units += x;
	      for (let i = 0; i < space.units[f].length; i++) {
		if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary") { // no cavalry
		  attacker_units_units.push(space.units[f][i]);
	        }
	      }
	      for (let i = 0; i < x; i++) { attacker_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > attacker_highest_battle_rating) {
		attacker_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	    if (faction_map[f] == defender_faction) {
	      let x = his_self.returnFactionLandUnitsInSpace(f, space);
	      defender_units += x;
	      for (let i = 0; i < space.units[f].length; i++) {
		if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary") { // no cavalry
		  defender_units_units.push(space.units[f][i]);
	        }
	      }
	      for (let i = 0; i < x; i++) { defender_units_faction.push(f); }
	      if (calculate_highest_battle_rating(f) > defender_highest_battle_rating) {
		defender_highest_battle_rating = calculate_highest_battle_rating(f);
	      }
	    }
	  }

	  //
	  // number of assaulting units are limited by formation size
	  //
	  let max_formation_size = his_self.returnMaxFormationSize(space.units[attacker_faction]);
	  let num_over_formation = 0;

	  //
	  // calculate how many rolls attacker and defender get in this situation
	  //
	  if (defender_units == 0) {
	    if (attacker_units > max_formation_size) { num_over_formation = attacker_units - max_formation_size; }
	    attacker_rolls = attacker_units;
	    attacker_rolls += attacker_highest_battle_rating;
	    defender_rolls = 1 + defender_highest_battle_rating;
	  } else {
	    if (attacker_units > max_formation_size) { num_over_formation = max_formation_size - attacker_units; }
	    for (let i = 0; i < attacker_units && i < max_formation_size; i++) {
	      if (i%2 === 0) { attacker_rolls++; }
	    }
	    attacker_rolls += attacker_highest_battle_rating;
	    defender_rolls = 1 + defender_units + defender_highest_battle_rating;
	  }

	  if (attacker_player > 0) {
	    if (his_self.game.state.players_info[attacker_player-1].tmp_roll_bonus) {
	      attacker_rolls += parseInt(his_self.game.state.players_info[attacker_player-1].tmp_roll_bonus);
	    }
	  }
	  if (defender_player > 0) {
	    if (his_self.game.state.players_info[defender_player-1].tmp_roll_bonus) {
	      defender_rolls += parseInt(his_self.game.state.players_info[defender_player-1].tmp_roll_bonus);
	    }
	  }

	  //
	  // logic forks depending on if any of the players can "go first". in order to
	  // simplify our implementation we are going to roll the dice now and then apply
	  // the hits either simultaneously or in sequence so that we don't need to re-
	  // implement the above.
	  //
	  let attacker_results = [];
	  let defender_results = [];
	  let attacker_hits = 0;
	  let defender_hits = 0;

	  for (let i = 0; i < attacker_rolls; i++) {
	    let res = this.rollDice(6);
	    attacker_results.push(res);
	    if (res >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let res = this.rollDice(6);
	    defender_results.push(res);
	    if (res >= 5) { defender_hits++; }
	  }

	  if (num_over_formation > 0) {
	    for (let z = 0; z < num_over_formation; z++) {
	      attacker_results[z] = 0;
	    }
	  }

	  //
	  // LOG RESULTS
	  //
	  this.updateLog("Attacker: " + attacker_hits + " / " + attacker_rolls);
	  this.updateLog("Defender: " + defender_hits + " / " + defender_rolls);

	  this.updateLog("************************");
	  this.updateLog("******** Assault *******");
	  this.updateLog("************************");


	  //
	  // things get messy and conditional now, because Ottomans may play
	  // Janissaries and Suprise Attack may change the order in which players
	  // remove units (and hits!) in the resolution of the battle.
	  //
	  // we handle this by saving the "state" of the battle and pushing
	  // execution back to the game queue.
	  //

	  //
	  // save battle state
	  //
	  his_self.game.state.assault.attacker_units = attacker_units;
	  his_self.game.state.assault.defender_units = defender_units;
	  his_self.game.state.assault.attacker_units_units = attacker_units_units;
	  his_self.game.state.assault.defender_units_units = defender_units_units;
	  his_self.game.state.assault.attacker_units_faction = attacker_units_faction;
	  his_self.game.state.assault.defender_units_faction = defender_units_faction;
	  his_self.game.state.assault.attacker_rolls = attacker_rolls;
	  his_self.game.state.assault.defender_rolls = defender_rolls;
	  his_self.game.state.assault.attacker_results = attacker_results;
	  his_self.game.state.assault.defender_results = defender_results;
	  his_self.game.state.assault.attacker_faction = attacker_faction;
	  his_self.game.state.assault.defender_faction = defender_faction;
	  his_self.game.state.assault.faction_map = faction_map;
	  his_self.game.state.assault.spacekey = spacekey;
	  his_self.game.state.assault.attacker_player = attacker_player;
	  his_self.game.state.assault.defender_player = defender_player;
	  his_self.game.state.assault.attacker_modified_rolls = attacker_rolls;
	  his_self.game.state.assault.defender_modified_rolls = defender_rolls;
          his_self.game.state.assault.attacker_hits = attacker_hits;
          his_self.game.state.assault.defender_hits = defender_hits;
          his_self.game.state.assault.attacker_units_destroyed = [];
          his_self.game.state.assault.defender_units_destroyed = [];
          his_self.game.state.assault.attacker_hits_first = 0;
          his_self.game.state.assault.defender_hits_first = 0;
          
	  his_self.game.queue.push(`assault_continue\t${mv[1]}\t${mv[2]}`);

          let ap = {};
          let dp = {};

          if (attacker_player > 0) { ap = this.game.state.players_info[attacker_player-1]; }
          if (defender_player > 0) { dp = this.game.state.players_info[defender_player-1]; }

	  let post_assault_intervention_possible = this.game.state.events.intervention_post_assault_possible;

	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(space.key);

          //
          // we stop here for intercession by cards that need to execute before the die rolls
	  // are assigned but after they have been rolled.
          //
          if (ap.tmp_roll_first == 1 && dp.tmp_roll_first != 1) {
	    if (attacker_hits > 0 || defender_hits > 0) {
              his_self.game.state.assault.attacker_hits_first = 1;
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
	      if (0 == post_assault_intervention_possible) {
	        if (from_whom.includes(this.game.players[this.game.player-1])) {
	          his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
	        }
	      }
	    }
          } else if (ap.tmp_roll_first != 1 && dp.tmp_roll_first == 1) {
	    if (attacker_hits > 0 || defender_hits > 0) {
              his_self.game.state.field_battle.defender_hits_first = 1;
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
	      if (0 == post_assault_intervention_possible) {
	        if (from_whom.includes(this.game.players[this.game.player-1])) {
	          his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
                }
              }
            }
          } else {
	    if (attacker_hits > 0 || defender_hits > 0) {
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.attacker_faction);
              his_self.game.queue.push("assault_assign_hits\t"+his_self.game.state.assault.defender_faction);
	      if (0 == post_assault_intervention_possible) {
	        if (from_whom.includes(this.game.players[this.game.player-1])) {
	          his_self.game.queue.push("ACKNOWLEDGE\tProceed to Assign Hits");
                }
              }
            }
          }

          //
          // this should stop execution while we are looking at the pre-field battle overlay
          //
	  if (attacker_hits == 0 && defender_hits == 0) {
	    his_self.game.queue.push("ACKNOWLEDGE\tEntirely Futile Assault");
	  }
	  if (his_self.game.state.events.intervention_post_assault_possible) {
            his_self.game.queue.push("counter_or_acknowledge\tProceed to Assign Hits in "+space.name + "\tpost_assault_rolls\t"+spacekey);
            his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));
	  }
          his_self.game.queue.push("assault_assign_hits_render");
          his_self.game.queue.push("assault_show_hits_render");
          his_self.game.queue.push("counter_or_acknowledge\tAssault is about to begin in "+space.name + "\tpre_assault_rolls\t"+spacekey);
          his_self.game.queue.push("RESETCONFIRMSNEEDED\t"+JSON.stringify(from_whom));

          his_self.assault_overlay.renderPreAssault(his_self.game.state.assault);
          his_self.assault_overlay.pullHudOverOverlay();

          return 1;

        }


	if (mv[0] === "assault_continue") {

          this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let space = this.game.spaces[mv[2]];

	  //
	  // calculate hits
	  //
          let modify_rolls = function(player, roll_array) {

	    if (!player.tmp_roll_modifiers) {
	      return roll_array;
	    }

	    let modified_rolls = [];
            for (let i = 0; i < roll_array.length; i++) {
              if (player.tmp_roll_modifiers.length > i) {
                let modded_roll = roll_array[i] + player.tmp_roll_modifiers[i];
                if (modded_roll >= 5) {
                  modified_rolls.push(modded_roll);
                } else {
                  modified_rolls.push(modded_roll);
		}
              } else {
                if (roll_array[i] >= 5) {
                  modified_rolls.push(roll_array[i]);
                } else {
                  modified_rolls.push(roll_array[i]);
	        }
              }
            }
	    return modified_rolls;
          }
          let calculate_hits = function(player, roll_array) {
            let hits = 0;
            for (let i = 0; i < roll_array.length; i++) {
              if (roll_array[i] >= 5) {
                hits++;
              }
            }
            return hits;
          }
	  let assign_hits = function(faction, hits) {

	    //
	    // hits are spread out over units
	    //
	    let are_hits_all_assigned = 0;
	    let hits_to_assign = hits;
	    let max_possible_hits_assignable = 0;

	    //
	    // max hits to assign are the faction land units
	    //
	    for (let f in faction_map) {
	      if (faction_map[f] == faction) {
	    	max_possible_hits_assignable += his_self.returnFactionLandUnitsInSpace(f, space);
	      }
	    }

	    //
	    //
	    //
	    if (max_possible_hits_assignable < hits_to_assign) {
	      hits_to_assign = max_possible_hits_assignable;
	    }


	    while (are_hits_all_assigned == 0 && hits_to_assign > 0) {

	      //
	      // first we calculate starting faction targets
	      //
	      let number_of_targets = 0;
	      for (let f in faction_map) {
	        if (faction_map[f] == faction) {
		  if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		    number_of_targets++;
		  }
		}
	      }

	      while (hits_to_assign >= number_of_targets && hits_to_assign > 0 && number_of_targets > 0) {

	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
	 	      for (let zzz = 0; zzz < 3; zzz++) {

		        let cannon_fodder = "";
		        if (zzz == 0) { cannon_fodder = "cavalry"; }
		        if (zzz == 1) { cannon_fodder = "mercenary"; }
		        if (zzz == 2) { cannon_fodder = "regular"; }

			let units_len = space.units[f].length;

  	     	        for (let i = 0; i < units_len; i++) {
	   	          if (space.units[f][i].type == cannon_fodder) {
		  	    space.units[f].splice(i, 1);
			    hits_to_assign--;
		            zzz = 1000000;
		            i   = units_len + 1;
			  }
			}
		      }
		    }
		  }
		}

	        //
	        // recalculate num targets
	        //
	        number_of_targets = 0;
	        for (let f in faction_map) {
	          if (faction_map[f] == faction) {
		    if (his_self.returnFactionLandUnitsInSpace(f, space) > 0) {
		      number_of_targets++;
		    }
		  }
	        }
	      }

	      //
	      // we now have fewer hits to assign than there are factions available
	      // to share the damage, so we pick randomly by rolling a dice.
	      //
	      while (hits_to_assign > 0) {

		let targets = [];
	        for (let f in faction_map) { targets.push(f); }
		targets.sort();

		for (let i = hits_to_assign; i > 0; i--) {
		  let selected_target = his_self.rollDice(targets.length);
		  let selected_faction = targets[selected_target-1];
		  his_self.updateLog("Random Target: " + selected_faction);

		  //
		  // again, survival of the fittest
		  //
		  for (let zzz = 0; zzz < 3; zzz++) {

                    let cannon_fodder = "";
                    if (zzz == 0) { cannon_fodder = "cavalry"; }
                    if (zzz == 1) { cannon_fodder = "mercenary"; }
                    if (zzz == 2) { cannon_fodder = "regular"; }

                    for (let ii = 0; ii < space.units[selected_faction].length; ii++) {
                      if (space.units[selected_faction][ii].type == cannon_fodder) {
			his_self.updateLog(this.returnFactionName(f) + " " + space.units[selected_faction][ii].name + " killed");
                        space.units[selected_faction].splice(ii, 1);
                        hits_to_assign--;
                        zzz = 1000000;
                        ii  = 1000000;
                      }
                    }
                  }

		  //
		  // remove other faction land unit next
		  //
		  targets.splice(selected_target-1, 0);
		}
	      }

	      are_hits_all_assigned = 1;

	    }
	  }

	  let faction_map      = his_self.game.state.assault.faction_map;
	  let attacker_faction = his_self.game.state.assault.attacker_faction;
	  let defender_faction = his_self.game.state.assault.defender_faction;
	  let ap = his_self.returnPlayerOfFaction(attacker_faction);
	  let dp = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_player = {};
	  let defender_player = {};
	  if (ap > 0) { attacker_player  = his_self.game.state.players_info[ap-1]; }
          if (dp > 0) { defender_player  = his_self.game.state.players_info[dp-1]; }
	  let attacker_results = his_self.game.state.assault.attacker_results;
	  let defender_results = his_self.game.state.assault.defender_results;
	  let attacker_rolls   = his_self.game.state.assault.attacker_rolls;
	  let defender_rolls   = his_self.game.state.assault.defender_rolls;
	  let attacker_units   = his_self.game.state.assault.attacker_units;
	  let defender_units   = his_self.game.state.assault.defender_units;


	  let winner	       = defender_faction;
	  let attacker_hits    = 0;
	  let defender_hits    = 0;

	  //
	  // attacker goes first
	  //
          if (attacker_player.tmp_rolls_first == 1 && defender_player.tmp_rolls_first != 1) {

	    //
 	    // assign attacker hits
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    attacker_hits = calculate_hits(attacker_player, his_self.game.state.assault.attacker_modified_rolls);
	    assign_hits(defender_player, attacker_hits);

	    for (let i = 0; i < attacker_hits; i++) {
	      if (defender_results.length > 0) {
		defender_rolls.splice(defender_rolls.length-1, 1);
		defender_results.splice(defender_rolls.length-1, 1);
	      }
	    }

	    //
	    // assign defender hits
	    //
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    defender_hits = calculate_hits(defender_player, his_self.game.state.assault.defender_modified_rolls);
	    assign_hits(attacker_player, defender_hits);

	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          //
          // defender goes first
          //
          } else if (attacker_player.tmp_rolls_first != 1 && defender_player.tmp_rolls_first == 1) {

	    //
 	    // assign defender hits
	    //
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    defender_hits = calculate_hits(defender_player, his_self.game.state.assault.defender_modified_rolls);
	    assign_hits(attacker_player, defender_hits);

	    for (let i = 0; i < defender_hits; i++) {
	      if (attacker_results.length > 0) {
		attacker_rolls.splice(attacker_rolls.length-1, 1);
		attacker_results.splice(attacker_rolls.length-1, 1);
	      }
	    }

	    //
	    // check if we can continue
	    //

	    //
	    // assign attacker hits
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    attacker_hits = calculate_hits(attacker_player, his_self.game.state.assault.attacker_modified_rolls);
	    assign_hits(defender_player, attacker_hits);

	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          } else {

	    //
	    // assign hits simultaneously
	    //
	    his_self.game.state.assault.attacker_modified_rolls = modify_rolls(attacker_player, attacker_results);
	    his_self.game.state.assault.defender_modified_rolls = modify_rolls(defender_player, defender_results);
	    attacker_hits = calculate_hits(attacker_player, attacker_results);
	    defender_hits = calculate_hits(defender_player, defender_results);
	    assign_hits(defender_player, attacker_hits);
	    assign_hits(attacker_player, defender_hits);
	    his_self.game.state.assault.attacker_hits = attacker_hits;
	    his_self.game.state.assault.defender_hits = defender_hits;

          }

	  //
	  // who won?
	  //
	  if (attacker_hits > defender_hits) {
	    winner = attacker_faction;
	  }

	  //
	  // calculate units remaining
	  //
	  let attacker_land_units_remaining = attacker_units - defender_hits;
	  let defender_land_units_remaining = defender_units - attacker_hits;

          his_self.game.state.assault.attacker_land_units_remaining = attacker_land_units_remaining;
          his_self.game.state.assault.defender_land_units_remaining = defender_land_units_remaining;

	  //
	  // attacker and defender both wiped out
	  //
	  if (attacker_land_units_remaining <= 0 && defender_land_units_remaining >= 0) {

	    space.besieged = 0;
	    space.unrest = 0;

	    //
	    // remove besieged
	    //
	    for (let key in space.units) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        space.units[key][i].besieged = 0;
	      }
	    }
	    //
	    // update log
	    //
	    this.updateLog("Winner: "+this.returnFactionName(defender_faction));
	  }

	  //
	  // mutually assured destruction
	  //
	  if (attacker_land_units_remaining <= 0 && defender_land_units_remaining <= 0) {

	    //
	    // no-one survived, so just end siege
	    //
	    this.removeSiege(space.key);
	    space.unrest = false;
	    this.updateLog("Siege in " + this.returnSpaceName(space.key) + " ends");

	  }

	  //
	  // capture stranded leaders
	  //
	  if (attacker_land_units_remaining <= 0) {
	    for (let f in faction_map) {
	      if (faction_map[f] == attacker_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
	          his_self.captureLeader(defender_faction, attacker_faction, mv[1], space.units[f][i]);
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }

	  if (defender_land_units_remaining <= 0 && attacker_hits > 0) {
	    for (let f in faction_map) {
	      let cf = this.returnControllingPower(f);
	      if (cf == defender_faction || f == defender_faction || faction_map[f] == defender_faction) {
	        for (let i = 0; i < space.units[f].length; i++) {
		  if (space.units[f][i].reformer != true) {
	            his_self.captureLeader(attacker_faction, defender_faction, mv[1], space.units[f][i]);
	  	    space.units[f].splice(i, 1);
		    i--;
		  }
		}
	      }
	    }
	  }

          //
          // conduct retreats
          //
          if (defender_land_units_remaining < attacker_land_units_remaining) {

	    //
	    // no land units remain
	    //
	    if (defender_land_units_remaining <= 0 && attacker_land_units_remaining > 0 && attacker_hits > 0) {
	      this.removeSiege(space.key);
	      space.unrest = 0;
	      this.controlSpace(attacker_faction, space.key);
	      this.updateLog(this.returnFactionName(attacker_faction) + " wins siege, controls " + this.returnSpaceName(space.key));
	      for (let f in space.units) {
		if (!this.areAllies(f, attacker_faction, 1) && f != attacker_faction) {
		  for (let i = 0; i < space.units[f].length; i++) {
		    if (space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair") { 
		      space.units[f].splice(i, 1); i--;
		    }
		  }
		}
	      }
	    }

          } else {

            if (attacker_land_units_remaining == 0) {
	      this.removeSiege(space.key);
	      space.unrest = 0;
	      this.updateLog(this.returnFactionName(defender_faction) + " breaks siege, controls " + this.returnSpaceName(space.key));
	    } else {
	      his_self.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+attacker_faction+"\t"+defender_faction+"\t"+space.key);
              his_self.game.queue.push("break_siege");
              his_self.game.queue.push("hide_overlay\tassault");
	    }
	  }

          //
          // redisplay
          //
	  his_self.refreshBoardUnits();
          his_self.displaySpace(space.key);

	  //
	  // check if triggers defeat of Hungary Bohemia
	  //
          this.triggerDefeatOfHungaryBohemia();

          return 1;

        }


	if (mv[0] === "remove_relief_forces") {

          this.game.queue.splice(qe, 1);

	  let spacekey = mv[1];

	  if (this.game.spaces[spacekey]) {
	    for (let f in this.game.spaces[spacekey].units) {
	      for (let i = 0; i < this.game.spaces[spacekey].units[f].length; i++) {
		this.game.spaces[spacekey].units[f][i].relief_force = 0;		
	      }
	    }
	  }

	  return 1;
	}


	if (mv[0] === "purge_units_and_capture_leaders_if_unbesieged") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];
	  let anyone_but_loser_here = false;
	  let any_winners_survive = false;

	  let space = this.game.spaces[spacekey];

	  for (let f in space.units) {
	    if (this.returnPlayerCommandingFaction(f) != this.returnPlayerCommandingFaction(loser)) {
	      if (space.units[f].type == "regular" || space.units[f].type == "cavalry" || space.units[f].type == "mercenary") {
		anyone_but_loser_here = true;
	      }
	    }
	  }

	  //	
	  // skip the purge if no-one else is here...	
	  //	
	  if (anyone_but_loser_here == false) {
		return 1;
	  }


	  if (space.units[loser].length > 0) {
	    for (let z = 0; z < space.units[loser].length; z++) {

	      if (space.units[loser][z].army_leader || space.units[loser][z].navy_leader) {
	        if (space.units[loser][z].besieged == 0) { this.captureLeader(winner, loser, spacekey, space.units[loser][z]); }
	      }
	      if (space.units[loser][z].besieged == 0) { 

                //
                // do not strip ships if this is a space that needs to be besieged...
                //
                if ((space.units[loser][z].type == "squadron" || space.units[loser][z].type == "corsair") && (space.fortified == 1 || space.fortified == true || space.type == "key" || space.type == "fortress")) {		  
		  if ((space.key == "oran" && space.pirate_haven == 1) || (space.key == "tripoli" && space.pirate_haven == 1)) {  space.units[loser].splice(z, 1); z--; }
                } else {
		  space.units[loser].splice(z, 1); z--;
                }

	      }
	    }
	  }

	  this.displaySpace(spacekey);

	  return 1;

	}


	if (mv[0] === "purge_units_and_capture_leaders") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];

	  let space = this.game.spaces[spacekey];

	  if (space.units[loser].length > 0) {
	    this.updateLog(this.returnFactionName(loser) + " eliminated in " + this.returnSpaceName(spacekey));
	  }

	  for (let f in space.units) {
	    let cf = this.returnControllingPower(f);
	    if (f == loser || cf == loser) {
	      for (let i = 0; i < space.units[f].length; i++) {
	        this.captureLeader(winner, f, spacekey, space.units[f][i]);
	      }
	      for (let i = 0; i < space.units[f].length; i++) {
		if (space.units[f][i].reformer != true) {
		  space.units[f].splice(i, 1);
		  i--;
		}
	      }
	    }
	  }

	  return 1;

	}


	if (mv[0] === "purge_naval_units_and_capture_leaders") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let winner = mv[2];
          let spacekey = mv[3];

	  let space;
	  if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
	  if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

	  for (let f in space.units) {
	    let cf = this.returnControllingPower(f);
	    if (f == loser || cf == loser) {
	      if (space.units[f].length > 0) {
	        this.updateLog(this.returnFactionName(f) + " eliminated in " + this.returnSpaceName(spacekey));
	      }
	      for (let i = 0; i < space.units[f].length; i++) {
	        this.captureNavalLeader(f, winner, spacekey, space.units[f][i]);
	      }
	      space.units[f] = [];
	    }
	  }

	  this.displaySpace(space.key);
	  this.displayNavalSpace(space.key);

	  return 1;

	}


        if (mv[0] === "player_evaluate_post_naval_battle_retreat") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let spacekey = mv[2];

	  let commanding_player = this.returnPlayerCommandingFaction(loser);
	  if (commanding_player == 0) { return 1; }

          if (this.returnFactionNavalUnitsInSpace(loser, spacekey) < 1) {
	    return 1;
	  }


          if (this.game.player == commanding_player) {
            this.playerEvaluateNavalRetreatOpportunity(loser, spacekey, "", loser, true);
          } else {
            this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat at sea");
          }

          return 0;

        }



        if (mv[0] === "post_field_battle_player_evaluate_continued_assault_or_retreat") {

          this.game.queue.splice(qe, 1);

	  let attacker = mv[1];
	  let defender = mv[2];
	  let spacekey = mv[3];

	  let his_self = this;

	  let attacker_units = 0;
	  let fortified_defender_units = 0;

	  for (let f in his_self.game.spaces[spacekey].units) {
	    if (his_self.returnPlayerCommandingFaction(f) == his_self.returnPlayerCommandingFaction(attacker)) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		let u = his_self.game.spaces[spacekey].units[f][z];
		if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { attacker_units++; }
	      }
	    }
	    if (his_self.returnPlayerCommandingFaction(f) == his_self.returnPlayerCommandingFaction(defender)) {
	      for (let z = 0; z < his_self.game.spaces[spacekey].units[f].length; z++) {
		let u = his_self.game.spaces[spacekey].units[f][z];
		if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { fortified_defender_units++; }
	      }
	    }
	  }

	  if (attacker_units <= fortified_defender_units) {
	    his_self.game.state.field_battle_relief_battle = false; // no longer relevant
	    his_self.game.queue.push("post_field_battle_player_evaluate_retreat"+"\t"+attacker+"\t"+spacekey);
	  }

	  return 1;

	}


        if (mv[0] === "post_field_battle_player_evaluate_retreat") {

          this.game.queue.splice(qe, 1);

          let loser = mv[1];
          let spacekey = mv[2];
	  let unfortified_units = 0;
	  let fortified_units = 0;

try {
	  //
	  // auto-skip if there are < 4 loser units and they are fortified
	  //
	  for (let i = 0; i < this.game.spaces[spacekey].units[loser].length; i++) {
	    let u = this.game.spaces[spacekey].units[loser][i];
	    if (u.besieged == 0 && (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary")) {
	      unfortified_units++;
	    }
	  }
} catch (err) {
  // exit if loser or spacekey "unidentified"
  console.log("#");
  console.log("#");
  console.log("# PLEASE REPORT");
  console.log("#");
  console.log("#");
  console.log("edge case in post_field_battle_player_evaluate_retreat hit...");
  return 1;
}

	  if (unfortified_units == 0) {
	    return 1;
	  }

	  //
	  // auto-skip if loser cannot retreat because they have no land units
	  //
	  let loser_can_retreat = false;
	  for (let i = 0; i < this.game.spaces[spacekey].units[loser].length; i++) {
	    if (["regular", "mercenary", "calvary"].includes(this.game.spaces[spacekey].units[loser][i].type)) { loser_can_retreat = true; }
	  }
	  if (loser_can_retreat == false) { return 1; }

          let faction_map = his_self.game.state.field_battle.faction_map;
          let attacker_faction = his_self.game.state.field_battle.attacker_faction;
          let defender_faction = his_self.game.state.field_battle.defender_faction;
          let ap = his_self.returnPlayerOfFaction(attacker_faction);
          let dp = his_self.returnPlayerOfFaction(defender_faction);
	  let attacker_player = {};
	  let defender_player = {};
          if (ap > 0) { attacker_player  = his_self.game.state.players_info[his_self.returnPlayerOfFaction(attacker_faction)-1]; }
	  if (dp > 0) { defender_player  = his_self.game.state.players_info[his_self.returnPlayerOfFaction(defender_faction)-1]; }
          let attacker_results = his_self.game.state.field_battle.attacker_results;
          let defender_results = his_self.game.state.field_battle.defender_results;
          let attacker_rolls   = his_self.game.state.field_battle.attacker_rolls;
          let defender_rolls   = his_self.game.state.field_battle.defender_rolls;
          let attacker_units   = his_self.game.state.field_battle.attacker_units;
          let defender_units   = his_self.game.state.field_battle.defender_units;
          let attacker_land_units_remaining = his_self.game.state.field_battle.attacker_land_units_remaining;
          let defender_land_units_remaining = his_self.game.state.field_battle.defender_land_units_remaining;
          let attacker_comes_from_this_spacekey = his_self.game.state.attacker_comes_from_this_spacekey; // from state

          //
          // fortification has already happened. if the loser is the attacker, they have to retreat
          //
          if (loser === attacker_faction) {
	    let winning_faction = defender_faction;
	    if (this.game.player == this.returnPlayerCommandingFaction(loser)) {
	      if (this.game.state.field_battle_relief_battle) {
		this.playerEvaluateBreakSiegeRetreatOpportunity(loser, spacekey);
	      } else {
	        this.playerEvaluatePostBattleRetreatOpportunity(loser, winning_faction, attacker_faction, spacekey, this.game.state.attacker_comes_from_this_spacekey);
	      }
            } else {
              this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat");
            }
          } else {
	    let winning_faction = attacker_faction;
	    if (this.game.player == this.returnPlayerCommandingFaction(loser)) {
	      if (this.game.state.field_battle_relief_battle) {
		this.playerEvaluateBreakSiegeRetreatOpportunity(loser, spacekey);
	      } else {
	        this.playerEvaluatePostBattleRetreatOpportunity(loser, winning_faction, attacker_faction, spacekey, this.game.state.attacker_comes_from_this_spacekey);
	      }
            } else {
              this.updateStatus(this.returnFactionName(loser) + " considering post-battle retreat");
            }
          }

          return 0;

        }



        if (mv[0] === "found_jesuit_university") {

	  let spacekey = mv[1];

	  this.game.queue.splice(qe, 1);

	  this.updateLog("Jesuit University founded in " + this.game.spaces[spacekey].name);
	  this.game.spaces[spacekey].university = 1;
	  this.displaySpace(spacekey);

	  return 1;

	}



	if (mv[0] === "pick_second_round_debaters") {

	  let attacker = this.game.state.theological_debate.attacker;
	  let defender = this.game.state.theological_debate.defender;
	  let committed = this.game.state.theological_debate.committed;
	  // 2nd round defaults to uncommitted
	  let language_zone = this.game.state.theological_debate.language_zone;
	  this.game.state.theological_debate.round++;
	  let prohibited_protestant_debater = this.game.state.theological_debate.prohibited_protestant_debater;

          this.game.state.theological_debate.attacker_debater = ""; // resetting
          this.game.state.theological_debate.defender_debater = "";

	  let x = 0;

	  let attacker_enters_uncommitted = 1;

          let ad = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (this.game.state.debaters[i].owner == attacker) {
              if (this.game.state.debaters[i].committed == 0) {
                if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                  ad++;
                }
              }
            }
          }
          if (ad == 0) {
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker) {
                if (this.game.state.debaters[i].committed == 1) {
                  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                    ad++;
                    attacker_enters_uncommitted = 0;
                  }
                }
              }
            }
          }

	  x = this.rollDice(ad) - 1;
          ad = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (this.game.state.debaters[i].owner == attacker) {
              if ((attacker_enters_uncommitted == 1 && this.game.state.debaters[i].committed == 0) || (attacker_enters_uncommitted == 0 && this.game.state.debaters[i].committed == 1)) {
                if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                  if (x == ad) {
                    this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.attacker_debater_entered_uncommitted = attacker_enters_uncommitted;
                  }
                  ad++;
                }
              }
            }
          }


          //
          // defender chosen randomly from uncommitted if available
          //
	  let uncommitted_defender = 1;
          let dd = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
              if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
                dd++;
              }
            }
          }
	  if (dd == 0) {
	    uncommitted_defender = 0;
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
                  dd++;
                }
              }
            }
	  }

          x = this.rollDice(dd) - 1;
          dd = 0;
          for (let i = 0; i < this.game.state.debaters.length; i++) {
            if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
              if (uncommitted_defender == 0) {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
                  if (x === dd) {
                    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
                  }
                  dd++;
                }
              } else {
                if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
                  if (x === dd) {
                    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
                    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
                    this.game.state.theological_debate.defender_debater_entered_uncommitted = 1;
                    this.game.state.theological_debate.defender_debater_bonus++;
                  }
                  dd++;
                }
              }
            }
          }

	  //
	  // it is possible that we fall through because there are no eligible debaters. in this case
	  // we simply grab a committed debater in a follow-up random sweep.
	  //
	  if (this.game.state.theological_debate.defender_debater === "") {
	    dd = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	          dd++;
	        }
	      }
	    }
	    x = this.rollDice(dd) - 1;
	    for (let i = 0, j = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	          if (x === j) {
		    this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		    this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	            this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	          }
		  j++;
	        }
	      }
	    }
	  }
          if (this.game.state.theological_debate.attacker_debater === "") {
            dd = 0;
            for (let i = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker && this.game.state.debaters[i].committed == 1) {
                dd++;
              }
            }
            x = this.rollDice(dd) - 1;
            for (let i = 0, j = 0; i < this.game.state.debaters.length; i++) {
              if (this.game.state.debaters[i].owner == attacker && this.game.state.debaters[i].committed == 1) {
                if (x === j) {
                  this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
                  this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
                  this.game.state.theological_debate.attacker_debater_entered_uncommitted = 0;
                }
                j++;
              }
            }
          }

          this.game.state.theological_debate.round2_attacker_debater = this.game.state.theological_debate.attacker_debater;
          this.game.state.theological_debate.round2_defender_debater = this.game.state.theological_debate.defender_debater;

	  this.updateLog(this.game.state.theological_debate.attacker_debater + " vs. " + this.game.state.theological_debate.defender_debater);

	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "pick_first_round_debaters") {

	  let attacker = mv[1];
	  let defender = mv[2];
	  let language_zone = mv[3];
	  let committed = mv[4];
	  if (parseInt(mv[4]) === 1) { committed = "committed"; };
	  if (parseInt(mv[4]) === 0) { committed = "uncommitted"; };
	  let selected_papal_debater = "";
	  if (mv[5]) { selected_papal_debater = mv[5]; }
	  let prohibited_protestant_debater = "";
	  if (mv[6]) { prohibited_protestant_debater = mv[6]; }

	  this.updateLog(this.returnFactionName(attacker) + " targets " + committed + " debater");

	  this.game.state.theological_debate = {};
	  this.game.state.theological_debate.attacker_rolls = 0;
	  this.game.state.theological_debate.defender_rolls = 0;
	  this.game.state.theological_debate.adice = [];
	  this.game.state.theological_debate.ddice = [];
	  this.game.state.theological_debate.attacker = mv[1];
	  this.game.state.theological_debate.defender = mv[2];
	  this.game.state.theological_debate.language_zone = mv[3];
	  this.game.state.theological_debate.committed = committed;
	  this.game.state.theological_debate.round = 1;
	  this.game.state.theological_debate.round1_attacker_debater = "";
	  this.game.state.theological_debate.round1_defender_debater = "";
	  this.game.state.theological_debate.round2_attacker_debater = "";
	  this.game.state.theological_debate.round2_defender_debater = "";
	  this.game.state.theological_debate.attacker_debater = "";
	  this.game.state.theological_debate.defender_debater = "";
	  this.game.state.theological_debate.attacker_debater_entered_uncommitted = 0;
	  this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	  this.game.state.theological_debate.attacker_debater_power = 0;
	  this.game.state.theological_debate.defender_debater_power = 0;
	  this.game.state.theological_debate.attacker_debater_bonus = 3;
	  this.game.state.theological_debate.defender_debater_bonus = 1;
	  this.game.state.theological_debate.selected_papal_debater = "";
	  this.game.state.theological_debate.prohibited_protestant_debater = "";
	  this.game.state.theological_debate.attacker_faction = attacker;
	  this.game.state.theological_debate.defender_faction = defender;

	  let x = 0;

	  let attacker_enters_uncommitted = 1;

	  //
	  // Henry Petitions for Divorce pre-selects 
	  //
	  if (this.game.state.events.henry_petitions_for_divorce_grant == 1) {
	    selected_papal_debater = "campeggio-debater";
	  }

	  //
	  // papacy can select their attacker, or attacker picks debater at random from uncommitted
	  //
	  if (selected_papal_debater != "") {
	    this.game.state.theological_debate.attacker_debater = selected_papal_debater;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (selected_papal_debater == this.game.state.debaters[i].type) {
  	        this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
		if (!this.game.state.debaters[i].committed) {
	          this.game.state.theological_debate.attacker_debater_entered_uncommitted = 1;
		}
	      }
	    }
	  } else {
            let ad = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].owner == attacker) {
	        if (this.game.state.debaters[i].committed == 0) {
		  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	            ad++;
	          }
	        }
	      }
	    }

	    if (ad == 0) {
	      for (let i = 0; i < this.game.state.debaters.length; i++) {
	        if (this.game.state.debaters[i].owner == attacker) {
	          if (this.game.state.debaters[i].committed == 1) {
		    if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	              ad++;
	  	      attacker_enters_uncommitted = 0;
	            }
	          }
	        }
	      }
	    }

	    x = this.rollDice(ad) - 1;
	    ad = 0;
	    for (let i = 0; i < this.game.state.debaters.length; i++) {
	      if (this.game.state.debaters[i].owner == attacker) {
		if ((attacker_enters_uncommitted == 1 && this.game.state.debaters[i].committed == 0) || (attacker_enters_uncommitted == 0 && this.game.state.debaters[i].committed == 1)) {
		  if (attacker == "papacy" || (attacker == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	            if (x == ad) {
	  	      this.game.state.theological_debate.attacker_debater = this.game.state.debaters[i].type;
		      this.game.state.theological_debate.attacker_debater_power = this.game.state.debaters[i].power;
	              this.game.state.theological_debate.attacker_debater_entered_uncommitted = attacker_enters_uncommitted;
	            }
	            ad++;
	          }
	        }
	      }
	    }
	  }

	  //
	  // defender chosen randomly from type committed / uncommitted
	  //
	  let dd = 0;
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.theological_debate.committed == "committed") {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	            dd++;
	          }
	        } else {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed != 1) {
	            dd++;
	          }
	        }
	      }
	    }
	  }

	  x = this.rollDice(dd) - 1;

	  dd = 0;
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (defender == "papacy" || (defender == "protestant" && this.game.state.theological_debate.language_zone == this.game.state.debaters[i].language_zone)) {
	      if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	        if (this.game.state.theological_debate.committed == "committed") {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 1) {
	            if (x === dd) {
		      this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		      this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	              this.game.state.theological_debate.defender_debater_entered_uncommitted = 0;
	            }
	            dd++;
	          }
	        } else {
	          if (this.game.state.debaters[i].owner == defender && this.game.state.debaters[i].committed == 0) {
	            if (this.game.state.debaters[i].type !== prohibited_protestant_debater) {
	              if (x === dd) {
		        this.game.state.theological_debate.defender_debater = this.game.state.debaters[i].type;
		        this.game.state.theological_debate.defender_debater_power = this.game.state.debaters[i].power;
	                this.game.state.theological_debate.defender_debater_entered_uncommitted = 1;
	                this.game.state.theological_debate.defender_debater_bonus++;
		      }
	              dd++;
		    }
	          }
	        }
	      }
	    }
	  }


	  this.updateLog(this.game.state.theological_debate.attacker_debater + " vs. " + this.game.state.theological_debate.defender_debater);

          this.game.state.theological_debate.round1_attacker_debater = this.game.state.theological_debate.attacker_debater;
          this.game.state.theological_debate.round1_defender_debater = this.game.state.theological_debate.defender_debater;

	  //
	  // and show it...
	  //
	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  this.game.queue.splice(qe, 1);

	  return 1;

	}

        if (mv[0] === "destroy_all_mercenaries") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];

	  for (let key in this.game.spaces) {
	    let space = this.game.spaces[key];
	    for (let i = 0; i < space.units[faction].length; i++) {
	      if (space.units[faction][i].type == "mercenary") {
		space.units[faction].splice(i, 1);
		i--;
	      }
	    }
	  }

	  this.updateLog(this.returnFactionName(faction) + " loses all mercenaries.");

	  return 1;

        }

        if (mv[0] === "commit") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let debater = mv[2];
	  let activate_it = 0;

	  this.updateLog(this.returnFactionName(faction) + " commits " + this.popup(debater));

	  if (parseInt(mv[3]) > 0) { activate_it = parseInt(mv[3]); }
	  this.commitDebater(faction, debater, activate_it);

	  return 1;

        }

	if (mv[0] === "player_call_theological_debate_in_region") {
	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let language_zone = mv[2];
	  let player = this.returnPlayerCommandingFaction(faction);
	  if (this.game.player == player) {
	    this.playerCallTheologicalDebateInRegion(this, player, faction, language_zone);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " calling theological debate");
	  }
	  return 0;
	}

	if (mv[0] === "player_call_theological_debate") {
	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
	  if (this.game.player == player) {
	    this.playerCallTheologicalDebate(this, player, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " calling theological debate");
	  }
	  return 0;
	}

        if (mv[0] === "theological_debate") {

	  let attacker = this.game.state.theological_debate.attacker;
	  let defender = this.game.state.theological_debate.defender;
	  let language_zone = this.game.state.theological_debate.language_zone;
	  let committed = this.game.state.theological_debate.committed;
	  let attacker_idx = 0;
	  let defender_idx = 0;
	  let was_defender_uncommitted = 0;
	  let debate_results_discarded = false;

	  this.game.queue.splice(qe, 1);

	  //
	  // commit attacker if uncommitted
	  //
	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.attacker_debater) {
	      attacker_idx = i;
	      if (!this.isCommitted(this.game.state.theological_debate.attacker_debater)) {
		this.commitDebater(this.game.state.theological_debate.attacker, this.game.state.theological_debate.attacker_debater, 0);
	      }
	    }
	  }

	  //
	  // defender power and bonus check is complicated because of Here I Stand
	  //
	  let defender_debater_power = 1;
	  let defender_debater_bonus = 0;

	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.defender_debater) {
	      defender_idx = i;
	      defender_debater_power = this.game.state.debaters[defender_idx].power;
	      if (!this.isCommitted(this.game.state.theological_debate.defender_debater)) {
	        was_defender_uncommitted = 1;
		this.commitDebater(this.game.state.theological_debate.defender, this.game.state.theological_debate.defender_debater, 0);
	      }
	    }
	  }
	  for (let i = 0; i < this.game.state.excommunicated.length; i++) {
	    if (this.game.state.excommunicated[i].debater) {
	      if (this.game.state.excommunicated[i].debater.type === this.game.state.theological_debate.defender_debater) {
	        defender_debater_power = this.game.state.excommunicated[i].debater.power;
	        if (this.game.state.excommunicated[i].debater.committed == 0) {
	          was_defender_uncommitted = 1;
	  	  this.game.state.excommunicated[i].debater.committed = 1;
	        }
	      }
	    }
	  }

	  let attacker_debater_power = 1;
	  let attacker_debater_bonus = 3;

	  for (let i = 0; i < this.game.state.debaters.length; i++) {
	    if (this.game.state.debaters[i].type === this.game.state.theological_debate.attacker_debater) {
	      attacker_idx = i;
	      attacker_debater_power = this.game.state.debaters[attacker_idx].power;
	      if (this.game.state.debaters[i].committed == 0) {
		this.commitDebater(this.game.state.theological_debate.attacker, this.game.state.theological_debate.attacker_debater, 0);
	      }
	    }
	  }
	  for (let i = 0; i < this.game.state.excommunicated.length; i++) {
	    if (this.game.state.excommunicated[i].debater) {
	      if (this.game.state.excommunicated[i].debater.type === this.game.state.theological_debate.attacker_debater) {
	        attacker_debater_power = this.game.state.excommunicated[i].debater.power;
	        if (this.game.state.excommunicated[i].debater.committed == 0) {
	  	  this.game.state.excommunicated[i].debater.committed = 1;
	        }
	      }
	    }
	  }

	  //
	  // even Luther gets 3 if invoked w/ Here I Stand as attacker
	  //
	  let attacker_rolls = attacker_debater_power + 3;
	  //
	  // defender_debater_power handled above - Luther because may be excommunicated
	  //
	  defender_debater_bonus = 1 + was_defender_uncommitted;
	  let defender_rolls = defender_debater_power + 1 + was_defender_uncommitted;

	  //
	  // papal inquisition
	  //
	  if (attacker === "papacy" && this.game.state.events.papal_inquisition_debate_bonus == 1) {
	    attacker_rolls += 2;
	  }

	  //
	  // thomas more
	  //
	  if (this.game.state.events.more_bonus == 1) {
	    attacker_rolls += 1;
	    if (language_zone == "english") {
	      attacker_rolls += 2;
	    }
	  }

	  //
	  // eck-debator bonus
	  //
	  if (attacker === "papacy" && this.game.state.theological_debate.attacker_debater === "eck-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) {
	    attacker_rolls++;
	  }

	  //
	  // gardiner-debater bonus
	  //
	  if (attacker === "papacy" && this.game.state.theological_debate.attacker_debater === "gardiner-debater" && this.game.state.theological_debate.language_zone === "english" && this.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
	    attacker_rolls++;
	  }

	  //
	  // augsburg confession
	  //
	  if (attacker === "papacy" && this.game.state.events.augsburg_confession == 1) {
	    attacker_rolls--;
	  }

	  let attacker_hits = 0;
	  let defender_hits = 0;
	  let adice = [];
	  let ddice = [];

	  for (let i = 0; i < attacker_rolls; i++) {
	    let x = this.rollDice(6);
	    adice.push(x);
	    if (x >= 5) { attacker_hits++; }
	  }
	  for (let i = 0; i < defender_rolls; i++) {
	    let x = this.rollDice(6);
	    ddice.push(x);
	    if (x >= 5) { defender_hits++; }
	  }

	  this.updateLog(this.popup(this.game.state.theological_debate.attacker_debater) + " vs " + this.popup(this.game.state.theological_debate.defender_debater) + ` [${attacker_hits}/${defender_hits}]`);

	  //
	  // set theological debate object
	  //
	  this.game.state.theological_debate.attacker_rolls = attacker_rolls;
	  this.game.state.theological_debate.defender_rolls = defender_rolls;
	  this.game.state.theological_debate.adice = adice;
	  this.game.state.theological_debate.ddice = ddice;
	  this.game.state.theological_debate.attacker_debater_power = attacker_debater_power;
	  this.game.state.theological_debate.defender_debater_power = defender_debater_power;
	  this.game.state.theological_debate.attacker_debater_bonus = attacker_debater_bonus;
	  this.game.state.theological_debate.defender_debater_bonus = defender_debater_bonus;

	  if (attacker_hits == defender_hits) {
	    this.game.state.theological_debate.status = "Inconclusive - Second Round";
	  } else {
	    if (attacker_hits > defender_hits) {
	      this.game.state.theological_debate.status = this.returnFactionName(this.game.state.theological_debate.attacker_faction) + " Wins";
	    } else {
	      this.game.state.theological_debate.status = this.returnFactionName(this.game.state.theological_debate.defender_faction) + " Wins";
	    }
	  }

	  //
	  // open theological debate UI
	  //
	  this.displayTheologicalDebate(this.game.state.theological_debate);
	  this.displayTheologicalDebater(this.game.state.theological_debate.attacker_debater, true);
	  this.displayTheologicalDebater(this.game.state.theological_debate.defender_debater, false);

	  if (attacker_hits == defender_hits) {

	    //
	    // first round of debate moves into second
	    //
	    this.game.state.theological_debate.round++;
	    if (this.game.state.theological_debate.round > 2) {

	      this.game.queue.push("counter_or_acknowledge\tTie - Debate Ends Inconclusively");
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    } else {

	      this.game.queue.push("theological_debate");
	      this.game.queue.push("counter_or_acknowledge\tTheological Debate: 2nd Round\tdebate\t" + language_zone);
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate_and_debaters");
	      this.game.queue.push("pick_second_round_debaters");
	      this.game.queue.push("counter_or_acknowledge\tThe Debate is Tied - Progress to 2nd Round");
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    }

	  } else {

	    let bonus_conversions = 0;

	    //
	    // if aleander is in play, flip extra space
	    //
	    if ((this.game.state.theological_debate.attacker_debater === "aleander-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) || (this.game.state.theological_debate.defender_debater === "aleander-debater")) {
	      this.updateLog(this.popup("aleander-debater") + " bonus: +1 conversion");
	      bonus_conversions = 1;
	    }

	    if (attacker_hits > defender_hits) {

	      let total_spaces_to_convert = attacker_hits - defender_hits;
	      let unaltered_total_spaces_to_convert = total_spaces_to_convert;
	      let total_spaces_overall = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      if (total_spaces_to_convert > total_spaces_overall) { total_spaces_to_convert = total_spaces_overall; }
	      let total_spaces_in_zone = this.returnNumberOfProtestantSpacesInLanguageZone(language_zone, 1);
	      if (defender === "papacy") { total_spaces_in_zone = this.returnNumberOfCatholicSpacesInLanguageZone(language_zone, 1); }

	      //
	      // if campeggio is the debater, we have 1/3 chance of ignoring result
	      //
	      if (this.game.state.theological_debate.defender_debater === "campeggio-debater" && this.game.state.theological_debate.defender_debater_entered_uncommitted == 1) {
		let roll = this.rollDice(6);
	        if (roll >= 5) {
	          this.updateLog(this.popup("campeggio-debater") + " rolls: " + roll + " debate loss discarded");
		  total_spaces_to_convert = 0;
		  bonus_conversions = 0;
	          debate_results_discarded = true;
	        } else {
	          this.updateLog(this.popup("campeggio-debater") + " rolls: " + roll + " debate loss sustained");
	 	}
	      }

	      if ((bonus_conversions+total_spaces_to_convert) == 1) {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
	      }


	      //
	      // reduce number of convertible spaces to total available to convert
	      //
	      let flip_this_number = total_spaces_to_convert + bonus_conversions;
	      if (this.game.state.theological_debate.attacker_faction == "papacy" && this.returnNumberOfProtestantSpacesInLanguageZone("", 1) < flip_this_number) {
	        this.updateLog("Protestants only have " + this.returnNumberOfProtestantSpacesInLanguageZone("", 1) + " spaces to flip");
	        flip_this_number = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      }


	      //
	      // attacker has more hits, is defender burned?
	      //
	      if (debate_results_discarded == false && unaltered_total_spaces_to_convert > this.game.state.theological_debate.defender_debater_power) {
		if (this.game.state.theological_debate.attacker_faction === "papacy") {
		  this.burnDebater(this.game.state.theological_debate.defender_debater);
		} else {
		  this.disgraceDebater(this.game.state.theological_debate.defender_debater);
		}
	      }

	      this.game.queue.push("hide_overlay\tzoom\t"+language_zone);


	      for (let i = flip_this_number; i >= 1; i--) {
	        if (i > (total_spaces_in_zone+bonus_conversions)) {
		  if (attacker === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy");
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant");
		  }
		} else {
		  if (attacker === "papacy") {
  		    this.game.queue.push("select_for_catholic_conversion\tpapacy\t"+language_zone);
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant\t"+language_zone);
		  }
		}
	      }
	      //
	      this.game.queue.push("show_overlay\tzoom\t"+language_zone);
	      this.game.queue.push("hide_overlay\ttheological_debate");
	      if ((total_spaces_to_convert+bonus_conversions) == 1) {
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${(total_spaces_to_convert+bonus_conversions)} Space`);
	      } else { 
	        this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.attacker_faction) + ` Wins - Convert ${(total_spaces_to_convert+bonus_conversions)} Spaces`);
              }
	      this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");

	    //
	    // defender has more hits than attacker
	    //
	    } else {

	      let total_spaces_to_convert = defender_hits - attacker_hits;
	      let unaltered_total_spaces_to_convert = total_spaces_to_convert;
defender_hits - attacker_hits;
	      let total_spaces_overall = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      if (total_spaces_to_convert > total_spaces_overall) { total_spaces_to_convert = total_spaces_overall; }
	      let total_spaces_in_zone = this.returnNumberOfProtestantSpacesInLanguageZone(language_zone, 1);
	      if (attacker === "papacy") { total_spaces_in_zone = this.returnNumberOfCatholicSpacesInLanguageZone(language_zone, 1); }

	      //
	      // if campeggio is the debater, we have 1/3 chance of ignoring result
	      //
	      if (this.game.state.theological_debate.attacker_debater === "campeggio-debater" && this.game.state.theological_debate.attacker_debater_entered_uncommitted == 1) {
		let roll = this.rollDice(6);
	        if (roll >= 5) {
	          this.updateLog("Campeggio rolls: " + roll + " debate loss discarded");
		  total_spaces_to_convert = 0;
		  bonus_conversions = 0;
		  debate_results_discarded = true;
	        } else {
	          this.updateLog("Campeggio rolls: " + roll + " debate loss sustained");
	 	}
	      }


	      if ((total_spaces_to_convert+bonus_conversions) == 1) {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
	        this.updateLog(this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
	      }

	      //
	      // reduce number of convertible spaces to total available to convert
	      //
	      let flip_this_number = total_spaces_to_convert + bonus_conversions;

	      if (this.game.state.theological_debate.defender_faction == "papacy" && this.returnNumberOfProtestantSpacesInLanguageZone("", 1) < flip_this_number) {
	        this.updateLog("Protestants only have " + this.returnNumberOfProtestantSpacesInLanguageZone("", 1) + " spaces to flip");
	        flip_this_number = this.returnNumberOfProtestantSpacesInLanguageZone("", 1);
	      }

	      //
	      // defender has more hits, is attacker burned?
	      //
	      if (debate_results_discarded == false && unaltered_total_spaces_to_convert > this.game.state.theological_debate.attacker_debater_power) {
	        if (this.game.state.theological_debate.attacker_faction === "protestant") {
		  this.burnDebater(this.game.state.theological_debate.attacker_debater);
	 	} else {
		  this.disgraceDebater(this.game.state.theological_debate.attacker_debater);
		}
	      }

	      this.game.queue.push("hide_overlay\tzoom\t"+language_zone);

	      for (let i = flip_this_number; i >= 1; i--) {
	        if (i > total_spaces_in_zone) {
		  if (defender === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy");
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant");
		  }
		} else {
		  if (defender === "papacy") {
		    this.game.queue.push("select_for_catholic_conversion\tpapacy\t"+language_zone);
		  } else {
		    this.game.queue.push("select_for_protestant_conversion\tprotestant\t"+language_zone);
		  }
		}
	      }
	      this.game.queue.push("show_overlay\tzoom\t"+language_zone);
	      this.game.queue.push("hide_overlay\ttheological_debate");
	      if ((total_spaces_to_convert+bonus_conversions) == 1) { 
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Space`);
	      } else {
		this.game.queue.push("counter_or_acknowledge\t"+this.returnFactionName(this.game.state.theological_debate.defender_faction) + ` Wins - Convert ${total_spaces_to_convert+bonus_conversions} Spaces`);
              }
	      this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	      this.game.queue.push("show_overlay\ttheological_debate");
	    }
	  }

	  return 1;

	}



        if (mv[0] === "translation") {

	  let zone = mv[1];
	  let ops = 1;
	  if (mv[2]) { if (parseInt(mv[2]) > ops) { ops = parseInt(mv[2]); } }
          let player = this.returnPlayerOfFaction("protestant");

	  this.game.queue.splice(qe, 1);

	  for (let z = 0; z < ops; z++) {
	    if (zone === "german") {
	      if (this.game.state.translations['new']['german'] >= 6) {
	        this.updateLog("Protestants translate Old Testament (german)");
	        this.game.state.translations['full']['german']++;
		if (this.game.state.translations['full']['german'] == 10) {
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.state.german_bible_translation_bonus = 1;
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing German Bible");
		}
	        if (this.game.state.translations['full']['german'] > 10) { this.game.state.translations['full']['german'] = 10; }
  	      } else {
	        this.updateLog("Protestants translate New Testament (german)");
	        this.game.state.translations['new']['german']++;
		if (this.game.state.translations['new']['german'] == 6) {
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tgerman\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	    if (zone === "french") {
	      if (this.game.state.translations['new']['french'] >= 6) {
	        this.updateLog("Protestants translate Old Testament (french)");
	        this.game.state.translations['full']['french']++;
		if (this.game.state.translations['full']['french'] == 10) {
		  // protestant gets 1 roll bonus at start
	          his_self.game.state.french_bible_translation_bonus = 1;
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing French Bible");
		}
	        if (this.game.state.translations['full']['french'] > 10) { this.game.state.translations['full']['french'] = 10; }
	      } else {
	        this.updateLog("Protestants translate New Testament (french)");
	        this.game.state.translations['new']['french']++;
		if (this.game.state.translations['new']['french'] == 6) {
		  // protestant gets 1 roll bonus at start
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tfrench\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	    if (zone === "english") {
	      if (this.game.state.translations['new']['english'] >= 6) { 
	        this.updateLog("Protestants translate Old Testament (english)");
	        this.game.state.translations['full']['english']++;
		if (this.game.state.translations['full']['english'] == 10) {
		  // protestant gets 1 roll bonus at start
	          his_self.game.state.english_bible_translation_bonus = 1;
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	          his_self.updateLog("Protestants +1 VP for completing English Bible");
		}
	        if (this.game.state.translations['full']['english'] > 10) { this.game.state.translations['full']['english'] = 10; }
	      } else {
	        this.updateLog("Protestants translate New Testament (english)");
	        this.game.state.translations['new']['english']++;
		if (this.game.state.translations['new']['english'] == 6) {
		  // protestant gets 1 roll bonus at start
        	  his_self.game.queue.push("hide_overlay\ttheses");
	          his_self.game.queue.push("remove_translation_bonus");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("protestant_reformation\t"+player+"\tenglish\t1");
        	  his_self.game.queue.push("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
		}
	      }
	    }
	  }

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("protestant")) {
	    his_self.faction_overlay.render("protestant");
	    his_self.faction_overlay.updateNotice("Protestants advance in Bible Translation");
	  } else {
	    this.displayHudPopup("translate","Bible Translation"); // true = as hud popup
	  }

	  return 1;
        }


	if (mv[0] === "build_saint_peters_with_cp") {

	  let ops = parseInt(mv[1]);

	  this.game.queue.splice(qe, 1);

          for (let i = 0; i < ops; i++) {
            his_self.game.queue.push("build_saint_peters");
          }

	  return 1;

	}

        if (mv[0] === "build_saint_peters") {

	  this.game.queue.splice(qe, 1);

	  if (this.game.state.saint_peters_cathedral['vp'] < 5) {
	    this.updateLog("Papacy builds St. Peter's Basilica");
	    this.game.state.saint_peters_cathedral['state'] += 1;
	    if (this.game.state.saint_peters_cathedral['state'] >= 5) {
	      this.game.state.saint_peters_cathedral['state'] = 0;
	      this.updateLog(this.returnFactionName("papacy") + " +1 VP from St. Peter's Basilica");
	      this.game.state.saint_peters_cathedral['vp'] += 1;
	    }
	  }

	  if (his_self.game.player == his_self.returnPlayerCommandingFaction("papacy")) {
	    his_self.faction_overlay.render("papacy");
	    his_self.faction_overlay.updateNotice("Papacy progresses with Saint Peter's Construction");
	  } else {
	    this.displayHudPopup("st_peters","Saint Peter's Basilica");
	  }

	  return 1;

	}

	//
	// runs later in the game to avoid New World phase if the game is already over and 
	// the New World phase cannot change the outcome. this prevents handling winter 
	// retreat.
	//
        if (mv[0] === "advance_victory_determination_phase") {

	  this.game.queue.splice(qe, 1);

	  let max_new_world_points = 0;
	  if (this.game.state.newworld['greatlakes'].claimed != 1) { max_new_world_points += 1; }
	  if (this.game.state.newworld['stlawrence'].claimed != 1) { max_new_world_points += 1; }
	  if (this.game.state.newworld['mississippi'].claimed != 1) { max_new_world_points += 1; }
	  if (this.game.state.newworld['pacificstrait'].claimed != 1) { max_new_world_points += 1; }
	  if (this.game.state.newworld['amazon'].claimed != 1) { max_new_world_points += 2; }
	  if (this.game.state.newworld['circumnavigation'].claimed != 1) { max_new_world_points += 3; }
	  if (this.game.state.newworld['maya'].claimed != 1) { max_new_world_points += 1; }
	  if (this.game.state.newworld['aztec'].claimed != 1) { max_new_world_points += 2; }
	  if (this.game.state.newworld['inca'].claimed != 1) { max_new_world_points += 2; }

	  let f = this.calculateVictoryPoints();

	  for (let faction in f) {
	    if (f[faction].victory == 1) {

	      let winning_vp = f[faction].vp;
	      let contention = winning_vp - max_new_world_points;
	      let have_they_really_won = true;
	
	      for (let of in f) {
		if (of != faction) {
		  if (f[of].vp >= contention) {
		    have_they_really_won = false;
		  }
	        }
	      }

	      //
	      // show scoring points - situation
	      //
	      if (have_they_really_won) {
	        this.vp_overlay.render();
	        this.updateLog(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	        this.updateStatus(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	        return 0;
	      }
	    }
	  }

          return 1;
        }


	if (mv[0] === "victory_determination_phase") {

	  this.game.queue.splice(qe, 1);

	  let f = this.calculateVictoryPoints();

	  for (let faction in f) {
	    if (f[faction].victory == 1) {
	      //
	      // show scoring points - situation
	      //
	      this.vp_overlay.render();

	      this.updateLog(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	      this.updateStatus(this.returnFactionName(faction) + " wins: " + f[faction].reason);
	      return 0;
	    }
	  }

          return 1;

        }




        if (mv[0] === "new_world_phase") {

	  this.game.queue.splice(qe, 1);


	  //
	  // new world phase only in > 2P games
	  //
	  if (this.game.players.length > 2) {
	    this.game.queue.push("resolve_new_world_riches_rolls");
	    this.game.queue.push("resolve_new_world_colonies");
	    this.game.queue.push("resolve_new_world_conquests");
	    this.game.queue.push("resolve_new_world_explorations");
	  }

	  //
	  // phase otherwise removed entirely for 2P
	  //
          return 1;

        }
        if (mv[0] === "winter_phase") {

	  this.factionbar.setActive();

	  // show the winter overlay to let people know WTF is happening
	  this.winter_overlay.render("stage2");

	  // unset any sieges
	  this.removeSieges();

	  // Remove loaned naval squadron markers
	  this.returnLoanedUnits();

	  // Flip all debaters to their uncommitted (white) side, and
	  this.restoreDebaters();

	  // unset alliances
	  let powers = ["hapsburg","ottoman","england","france","papacy","protestant"];
	  for (let i = 0; i < powers.length; i++) {
	    for (let z = 0; z < powers.length; z++) {	    
	      if (i != z) {
		this.unsetAllies(powers[i], powers[z]);
	      }
	    }
	  }

	  // remove Renegade Leader if in play
	  let rl_f = "";
	  let rl_s = "";
	  rl_s = his_self.returnSpaceOfPersonage("hapsburg", "renegade");
          if (rl_s) { rl_f = "hapsburg"; }
	  rl_s = his_self.returnSpaceOfPersonage("papacy", "renegade");
          if (rl_s) { rl_f = "papacy"; }
	  rl_s = his_self.returnSpaceOfPersonage("england", "renegade");
          if (rl_s) { rl_f = "england"; }
	  rl_s = his_self.returnSpaceOfPersonage("france", "renegade");
          if (rl_s) { rl_f = "france"; }
	  rl_s = his_self.returnSpaceOfPersonage("ottoman", "renegade");
          if (rl_s) { rl_f = "ottoman"; }
	  rl_s = his_self.returnSpaceOfPersonage("protestant", "renegade");
          if (rl_s) { rl_f = "protestant"; }
	  if (rl_f != "") {
	    for (let key in his_self.game.spaces) {
	      for (let z = 0; z < his_self.game.spaces[key].units[rl_f].length; z++) {
		if (his_self.game.spaces[key].units[rl_f][z].type == "renegade") {
		  his_self.game.spaces[key].units[rl_f].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }

	  // Remove major power alliance markers
	  this.unsetAllies("hapsburg", "papacy");
	  this.unsetAllies("hapsburg", "england");
	  this.unsetAllies("hapsburg", "france");
	  this.unsetAllies("hapsburg", "ottoman");
	  this.unsetAllies("hapsburg", "protestant");
	  this.unsetAllies("papacy", "england");
	  this.unsetAllies("papacy", "france");
	  this.unsetAllies("papacy", "ottoman");
	  this.unsetAllies("papacy", "protestant");
	  this.unsetAllies("england", "france");
	  this.unsetAllies("england", "ottoman");
	  this.unsetAllies("england", "protestant");
	  this.unsetAllies("france", "ottoman");
	  this.unsetAllies("france", "protestant");
	  this.unsetAllies("ottoman", "protestant");

	  // Add 1 regular to each friendly-controlled capital
	  if (this.isSpaceControlled("rome", "papacy") && this.game.spaces["rome"].unrest != 1) { this.game.queue.push("build\tland\tpapacy\tregular\trome\t0"); }
	  // only to non-papacy if > 2P game
	  if (this.game.players.length > 2) {
	    if (this.isSpaceControlled("london", "england") && this.game.spaces["london"].unrest != 1) { this.game.queue.push("build\tland\tengland\tregular\tlondon\t0"); }
	    if (this.isSpaceControlled("paris", "france") && this.game.spaces["paris"].unrest != 1) { this.game.queue.push("build\tland\tfrance\tregular\tparis\t0"); }
	    if (this.isSpaceControlled("valladolid", "hapsburg") && this.game.spaces["valladolid"].unrest != 1) { this.game.queue.push("build\tland\thapsburg\tregular\tvalladolid\t0"); }
	    if (this.isSpaceControlled("vienna", "hapsburg") && this.game.spaces["vienna"].unrest != 1) { this.game.queue.push("build\tland\thapsburg\tregular\tvienna\t0"); }
	    if (this.isSpaceControlled("istanbul", "ottoman") && this.game.spaces["istanbul"].unrest != 1) { this.game.queue.push("build\tland\tottoman\tregular\tistanbul\t0"); }
	  }

	  // Remove all piracy markers
	  // ResolvespecificMandatoryEventsiftheyhavenotoccurred by their âdue dateâ.

	  //
	  // Clement VII takes the Papacy by the end of round two
	  //
	  if (this.game.state.round == 2 && this.game.state.events.clement_vii != 1) {
	    this.game.queue.push("display_custom_overlay\t010");
	    this.game.queue.push("remove\tpapacy\t010");
	    this.game.queue.push("event\tpapacy\t010");
	    this.removeCardFromGame("010");
	  }
	  //
	  // Paul III takes the Papacy by the end of round 4
	  //
	  if (this.game.state.round == 4 && this.game.state.events.paul_iii != 1) {
	    this.game.queue.push("display_custom_overlay\t014");
	    this.game.queue.push("remove\tpapacy\t014");
	    this.game.queue.push("event\tpapacy\t014");
	    this.removeCardFromGame("014");
	  }
	  //
	  // Barbary Pirates form by end of round 3 (not in 2P game)
	  //
	  if (this.game.players.length > 2 && this.game.state.round == 3 && this.game.state.events.barbary_pirates != 1) {
	    this.game.queue.push("display_custom_overlay\t009");
	    this.game.queue.push("remove\tottoman\t009");
	    this.game.queue.push("event\tottoman\t009");
	    this.removeCardFromGame("009");
	  }
	  //
	  // Society of Jesus forms by end of round 6
	  //
	  if (this.game.state.round == 6 && this.game.state.events.society_of_jesus != 1) {
	    this.game.queue.push("display_custom_overlay\t015");
	    this.game.queue.push("remove\tprotestant\t015");
	    this.game.queue.push("event\tprotestant\t015");
	    this.removeCardFromGame("015");
	  }
	  //
	  // form Schmalkaldic League if unformed by end of round 4
	  //
	  if (this.game.state.round == 4 && this.game.state.events.schmalkaldic_league != 1) {
	    this.game.queue.push("ACKNOWLEDGE\tTurn 4: Schmalkaldic League Forms");
	    this.game.queue.push("remove\tprotestant\t013");
	    // custom overlay is shown here
	    this.game.queue.push("event\tprotestant\t013");
	    this.removeCardFromGame("013");
	  }

	  // Return leaders and units to fortified spaces (suffering attrition if there is no clear path to such a space)
	  this.game.queue.push("retreat_to_winter_spaces");




	  // Return naval units to the nearest port - do this before retreat_to_winter_spaces so that we don't move
	  // naval leaders to Algiers etc. before their ships have the option of retreating to a specific port with
	  // them.
	  this.game.queue.push("retreat_to_winter_ports");

	  this.game.queue.splice(qe, 1);
          return 1;
        }


	//
	// this is called by War cards, after troop removal. It is possible that 
	// removing troops from the board reduces the number who are besieging a 
	// space below the amount that are needed to sustain the siege. in this 
	// case, we terminate the siege and trigger a withdrawal.
	//
	if (mv[0] === "check_for_broken_sieges") {

	  this.game.queue.splice(qe, 1);

	  for (let key in this.game.spaces) {
	    if (this.game.spaces[key].besieged > 0 && key != "persia" && key != "ireland" && key != "egypt") {

	      let forces_outside = 0;
	      let forces_inside = 0;
	      let assaulting_faction = "";
	      let cf = this.returnFactionControllingSpace(key);

	      let space = this.game.spaces[key];
	      for (let f in space.units) {
		for (let z = 0; z < space.units[f].length; z++) {
		  let u = space.units[f][z];
		  if (u.type == "cavalry" || u.type == "regular" || u.type == "mercenary") {
		    if (u.besieged) { forces_inside++; } else { forces_outside++; }
		  };
		  if (!u.besieged && assaulting_faction == "") { assaulting_faction = f; };
		}
	      }

	      if (forces_outside < forces_inside) {
                this.game.queue.push("ACKNOWLEDGE\t"+this.returnFactionName(assaulting_faction) + " retreats after siege broken!");
                this.game.queue.push("remove_siege\t"+key);
                this.game.queue.push("purge_units_and_capture_leaders_if_unbesieged\t"+assaulting_faction+"\t"+cf+"\t"+key);
                this.game.queue.push("player_evaluate_break_siege_retreat_opportunity\t"+assaulting_faction+"\t"+key);
	      }
	    }
	  }

          return 1;

	}


	// must be removed by RESOLVES -- but handled automatically
	if (mv[0] === "check_interventions" || mv[0] === "check_intervention") {

	  //
	  // if a single faction is dealt cards, we can call "check_intervention\tfaction"
	  // to ask it to update us with any interventions that are newly enabled for that
	  // specific faction and that specific card.
	  //
	  let faction = "";
	  let resolve_required = false;
	  let no_need_for_resolve = false;

	  if (mv[1] && (mv[0] === "check_interventions" || mv[0] === "check_intervention")) { 
	    this.game.queue.splice(qe, 1);
	    faction = mv[1];
	    no_need_for_resolve = true;
	  }

	  this.unbindBackButtonFunction();
	  this.updateStatus("preparing for Action Phase...");

	  let should_i_check = false;
	  if (faction != "" && this.game.player == this.returnPlayerCommandingFaction(faction)) { should_i_check = true; resolve_required = true; }
	  if (this.game.confirms_needed[this.game.player-1] == 1) { resolve_required = true; }
	  if (should_i_check == false && this.game.confirms_needed[this.game.player-1] == 1) { should_i_check = true; }

	  if (should_i_check) {

	    //
	    // we do not want to run this command multiple times, sending 
	    // extra RESOLVES because we receive another RESOLVE before 
	    // ours, so we swap out this for a HALTED command.
	    //
	    if ((resolve_required == true && no_need_for_resolve != true) || faction == "") {
	      this.game.queue[his_self.game.queue.length-1] = "halted";
	      this.addMove("RESOLVE\t"+this.publicKey);
	    }

	    for (let z = 0; z < this.game.deck[0].fhand.length; z++) {
	      for (let i = 0; i < this.game.deck[0].fhand[z].length; i++) {

		//
		// venetian informant
		//
	        if (this.game.deck[0].fhand[z][i] == "109") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_venetian_informant_possible\t1");
		}

	        //
	        // Professional Rowers permits naval_intercept and naval_avoid_battle and post-naval-battle
	        //
	        if (this.game.deck[0].fhand[z][i] == "034") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t1");
                  this.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t1");
                  this.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t1");
	        };
		//
		// Gout and Foul Weather block moves
		//
	        if (this.game.deck[0].fhand[z][i] == "032" || this.game.deck[0].fhand[z][i] == "031") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_movement_possible\t1");
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_assault_possible\t1");
	        };
		//
		// Siege Artillery
		//
	        if (this.game.deck[0].fhand[z][i] == "035") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_post_assault_possible\t1");
	        }
	      }
	    }

	    //
	    // Wartburg permits intervention in events
	    //
	    if (this.game.player == this.returnPlayerOfFaction("protestant")) {
              let fhand_idx = this.returnFactionHandIdx(this.game.player, "protestant");
	      for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	        if (this.game.deck[0].fhand[fhand_idx][i] == "037") {
                  this.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t1");
		  i = this.game.deck[0].fhand[fhand_idx].length+1;
	        };
	      }
	    }

	    this.endTurn();

	  }

          return 0;

	}



        if (mv[0] === "action_phase") {

	  this.winter_overlay.hide();

	  this.game.state.impulse++;

	  //
	  // check if we are really ready for a new round, or just need another loop
	  // until all of the players have passed. note that players who have passed 
	  // and have more than their admin_rating (saved cards) are forced to eventually
	  // stop passing and play....
	  //
	  let factions_in_play = [];
	  let factions_force_pass = [];

	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	      let faction = this.game.state.players_info[i].factions[z];
	      if (this.game.state.players_info[i].factions_passed[z] == false) {
		if (!this.game.state.skip_next_impulse.includes(this.game.state.players_info[i].factions[z])) {
		  factions_in_play.push(this.game.state.players_info[i].factions[z]);
		} else {
		  for (let ii = 0; ii < this.game.state.skip_next_impulse.length; ii++) {
		    if (this.game.state.skip_next_impulse[ii] === this.game.state.players_info[i].factions[z]) {
		      this.game.state.skip_next_impulse.splice(ii, 1);
		      factions_force_pass.push(this.game.state.players_info[i].factions[z]);
		    }
		  }
		}
	      } else {
		// they passed but maybe they have more cards left than their admin rating?
		let far = this.factions[faction].returnAdminRating(this);
	        if (far < this.game.state.cards_left[faction]) {
		  factions_in_play.push(this.game.state.players_info[i].factions[z]);
	        }
	      }
	    }
	  }

	  //
	  // if anyone is left to play, everyone with cards left needs to pass again
	  //
          if (factions_in_play.length > 0) {
	    for (let i = 0; i < this.game.state.players_info.length; i++) {
	      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	        let f = this.game.state.players_info[i].factions[z];
	        if (!factions_in_play.includes(f) && !factions_force_pass.includes(f)) {

		  let is_activated_power = false;
	          let io = this.returnImpulseOrder();
		  for (let y = 0; y < io.length; y++) {
		    if (this.game.state.activated_powers[io[y]].includes(f)) { is_activated_power = true; }
		  }
		  if (!is_activated_power) {
	    	    factions_in_play.push(f);
		  }
	        }
	      }
	    }
	  }

	  //
	  // players still to go...
	  //
	  if (factions_in_play.length > 0) {

	    //
	    // add save instruction!
	    //
	    this.game.queue.push("SAVE");

	    let io = this.returnImpulseOrder();
	    for (let i = io.length-1; i >= 0; i--) {
	      for (let k = 0; k < factions_in_play.length; k++) {
	        if (factions_in_play[k] === io[i]) {
	          this.game.queue.push("play\t"+io[i]);
		  k = factions_in_play.length+2;
	        }
	      }
	      for (let k = 0; k < factions_force_pass.length; k++) {
	        if (factions_force_pass[k] === io[i]) {
	          this.game.queue.push("skipturn\t"+io[i]);
		  k = factions_force_pass.length+2;
	        }
	      }
	    }
	    return 1;
	  }

	  //
	  // move past action phase if no-one left to play
	  //
	  this.game.queue.splice(qe, 1);
          return 1;
        }

	if (mv[0] === "spring_deployment_faction_array") {

	  let factions = JSON.parse(mv[1]);
	  let do_i_get_to_move = false;

	  //
	  // skip if we have already confirmed!
	  //
	  if (this.game.confirms_needed[this.game.player-1] == 0) {
	    this.diplomacy_overlay.hide();
	    return 0;
	  }

	  //
	  // exit if diplomacy-overlay open and visible
	  //
	  if (this.spring_deployment_overlay.visible) { return 0; }
	  if (this.moves.length > 0) { return 0; }

	  this.addMove("RESOLVE\t"+this.publicKey);

	  for (let i = 0; i < factions.length; i++) {
	    let p = this.returnPlayerCommandingFaction(factions[i]);
	    if (this.game.player == p && factions[i] != "protestant") {
              this.playerPlaySpringDeployment(factions[i], this.game.player, ""); // we have not removed, just avoid resolve
	      do_i_get_to_move = true;
            }
          }

	  // hey, it's me, protestants
	  if (do_i_get_to_move == false) {
	     this.endTurn();
	  }

	  return 0;

	}

        if (mv[0] === "vinformant_spring_deployment") {

	  this.game.queue.splice(qe, 1);

	  if (this.game.state.events.intervention_venetian_informant_possible == 1) {
	    this.game.state.events.intervention_venetian_informant_possible = 0;
	  } else {
	    return 1;
	  }

	  //
	  //
	  //
	  let do_i_have_it = false;
	  let which_faction = "";

	  for (let z = 0; z < this.game.deck[0].fhand.length; z++) {
	    for (let i = 0; i < this.game.deck[0].fhand[z].length; i++) {
	      if (this.game.deck[0].fhand[z][i] == "109") {
	        do_i_have_it = true;
	        which_faction = this.game.state.players_info[this.game.player-1].factions[z];
	      }
	    }
	  }

	  if (do_i_have_it) {

            let html  = `<ul>`;
                html += `<li class="card" id="109">yes</li>`;
                html += `<li class="card" id="skip">no</li>`;
                html += `</ul>`;

            this.updateStatusWithOptions(`${his_self.returnFactionName(which_faction)}: do you wish to play ${his_self.popup("109")}`, html);
            this.attachCardboxEvents(async (user_choice) => {

	      this.updateStatus("selected...");

	      if (user_choice == "skip") {
		his_self.endTurn();
	      } else {
                his_self.addMove("discard\t"+which_faction+"\t109");
                his_self.addMove("venetian_informant\t"+which_faction);
                his_self.addMove("NOTIFY\t"+his_self.returnFactionName(which_faction)+" plays " + his_self.popup("109"));
                his_self.endTurn();
	      };

	    });
	  }

	  return 0;

	}


        if (mv[0] === "spring_deployment_phase") {

	  if (this.game.state.events.intervention_venetian_informant_possible == 1) {
	    this.game.queue.push("vinformant_spring_deployment");
	    return 1;

	  }

	  this.game.queue.splice(qe, 1);

	  //
	  // hide winter overlay
	  //
	  this.game_help.hide();
	  this.winter_overlay.hide();

//
//
//
if (this.game.player == this.returnPlayerCommandingFaction("papacy") && this.round == 1) {
  this.game_help.render(TutorialTemplate, {
    help : `Spring Deployment` ,
    content : `
	Spring Deployment takes place at the start of every round. It allows players
 	to move units from their capital to any space connected to it via a line of 
	uninterrupted control.
	<p></p>
	The Papacy normally skips Spring Deployment in the first round. Later in the game
	it often uses Spring Deployment to move troops north into Europe to assist with
	Counter-Reformation attempts.
    `,
    line1 : "spring" ,
    line2 : "deployment" ,
    fontsize : "2.1rem" ,
    img : `/his/img/backgrounds/tutorials/spring_deployment.jpeg`,
  });
}

	  if (this.game.players.length === 2) {
	    // only papacy moves units
	    let pp = this.returnPlayerOfFaction("papacy");
            this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["papacy"]));
            this.game.queue.push("RESETCONFIRMSNEEDED\t"+pp);
	  } else {

	    if (this.game.players.length == 3) {
              this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["france","papacy","protestant"]));
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england"]));
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              return 1;
            }
          
            if (this.game.players.length == 4) {
              this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["papacy","protestant"]));
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france"]));
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              return 1;
            }
          
            if (this.game.players.length >= 5) {
              this.game.queue.push("spring_deployment_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france","papacy","protestant"]));
              this.game.queue.push("RESETCONFIRMSNEEDED\tall");
              return 1;
            } 
	  }

          return 1;

        }

        if (mv[0] === "spring_deployment") {

	  let instruction = this.game.queue[this.game.queue.length-1];;
	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  if (faction === "protestant") { return 1; }
	  if (player == 0) { return 1; }

	  if (this.game.player == player) {
this.game_help.renderCustomOverlay("spring_deployment", {
  line1 : "spring",
  line2 : "deployment?",
  fontsize : "2.1rem" ,
});
	    this.playerPlaySpringDeployment(faction, player, instruction);
	  } else {
	    this.game_help.hide();
	    this.updateStatus(this.returnFactionName(faction) + " Spring Deployment");
	  }

	  return 0;

	}

	//
	// this is a 3P++ game
	//
        if (mv[0] === "diplomacy_reject") {
	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];

	  let idx = parseInt(mv[2]);
	  let proposal = this.game.state.diplomacy[idx];
	  let terms = this.convertTermsToText(idx);
	  for (let i = terms.length-1; i >= 0; i--) { this.updateLog("  "+terms[i]); }
	  this.updateLog(this.returnFactionName(faction) + " rejects " + this.returnFactionName(proposal.proposer) + " offer:");
	  this.game.state.diplomacy.splice(idx, 1);
	  return 1;

	}
        if (mv[0] === "diplomacy_accept") {

	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let idx = parseInt(mv[2]);

	  let proposal = this.game.state.diplomacy[idx];
	  let terms = this.convertTermsToText(proposal);
	  for (let i = terms.length-1; i >= 0; i--) { this.updateLog("  "+terms[i]); }
	  this.updateLog(this.returnFactionName(faction) + " accepts " + this.returnFactionName(proposal.proposer) + " offer:");

	  for (let i = 0; i < proposal.parties.length; i++) { 
	    if (!proposal.confirms) { proposal.confirms = []; }
	    if (proposal.confirms.length < (i+1)) { proposal.confirms.push(0); }
	    if (proposal.parties[i] === faction || proposal.parties[i] === proposal.proposer) {
	      proposal.confirms[i] = 1;
	    }
	  }

	  let all_confirmed = true;
	  for (let i = 0; i < proposal.confirms.length; i++) { 
	    if (proposal.confirms[i] != 1) {
	     all_confirmed = false;
	    }
	  }

	  if (all_confirmed == true) {
	    this.updateLog(this.returnFactionName(proposal.proposer) + " offer takes effect.");
	    for (let i = proposal.terms.length-1; i >= 0; i--) {
	      this.game.queue.push(proposal.terms[i]);
	    }
	    this.game.state.diplomacy.splice(idx, 1);
	    this.diplomacy_overlay.purgeProposals();
	    //this.diplomacy_propose_overlay.purgeProposals();
	  }

	  return 1;

	}
        if (mv[0] === "diplomacy_phase") {

	  this.game.queue.splice(qe, 1);

if (this.game.state.round == 1) {
this.game_help.render(TutorialTemplate, {
  help : `What is the Diplomacy Phase?` ,
    content : `       
        
In the Diplomacy Phase, factions propose and accept binding agreements in Impulse Order, starting with the Ottoman Empire, Hapsburg Empire, England, France, Papacy and finishing with the Protestants. Proposals cannot be offered by a later faction to an earlier faction, so if a later faction desires an agreement with the Ottomans they must propose it.

	<p></p>

Players are allowed to communicate in secret during this phase. The most commonly negotiated terms are Alliances, which permit factions to move through spaces controlled by their allies, join forces to fight common enemies and retreat into allied spaces if defeated in battle. Factions can also "spring deploy" through allied territory as if it is their own. Factions can also agree to terminate a war, offer bonus cards, or yield strategic keys.

	<p></p>

If this is your first game, it is usually fine to skip the diplomacy phase until you have a better sense of how the game plays.

    `,              
    img : "/his/img/backgrounds/tutorials/diplomacy.jpg",
    line1 : "what is", 
    line2 : "diplomacy?",
    fontsize : "2.1rem" ,
});  
}
	  this.game.state.diplomacy = [];

	  if (this.game.players.length == 2) {
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\tprotestant");
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\tpapacy");
	    return 1;
	  }

	  let io = this.returnImpulseOrder();
	  for (let i = io.length-1; i>= 0; i--) {
	    this.game.queue.push("confirm_diplomatic_proposals\t"+io[i]);
	  }

	  if (this.game.players.length == 3) {
	    this.game.queue.push("propose_diplomatic_proposals_faction_array\t"+JSON.stringify(["france","papacy","protestant"]));
	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	    this.game.queue.push("propose_diplomatic_proposals_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england"]));
  	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	    return 1;
	  }

	  if (this.game.players.length == 4) {
	    this.game.queue.push("propose_diplomatic_proposals_faction_array\t"+JSON.stringify(["papacy","protestant"]));
  	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	    this.game.queue.push("propose_diplomatic_proposals_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france"]));
	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	    return 1;
	  }

	  if (this.game.players.length >= 5) {
	    this.game.queue.push("propose_diplomatic_proposals_faction_array\t"+JSON.stringify(["ottoman","hapsburg","england","france","papacy","protestant"]));
  	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
	    return 1;
	  }

	  //
	  // deprecated function, but works for marriage
	  //
	  if (this.game.state.henry_viii_marital_status == 1) {
	    this.game.queue.push("confirm_and_propose_diplomatic_proposals\tmarriage");
	  }
	  return 1;

	}

	if (mv[0] === "confirm_diplomatic_proposals") {

	  let faction = mv[1];

          //
          // first, if there are any outstanding proposals that
          // involve this faction, we need to ask them one-by-one
          // if they agree or disagree. if they agree and are the
          // last to agree, it will immediately execute.
          //
          let anything_to_review = false;
          for (let i = 0; i < this.game.state.diplomacy.length; i++) {
            if (this.game.state.diplomacy[i].parties.includes(faction)) {
              for (let z = 0; z < this.game.state.diplomacy[i].parties.length; z++) {
                if (!this.game.state.diplomacy[i].confirms) { this.game.state.diplomacy[i].confirms = []; }
                while (this.game.state.diplomacy[i].confirms.length < this.game.state.diplomacy[i].parties.length) { this.game.state.diplomacy[i].confirms.push(0); }
                for (let zz = 0; zz < this.game.state.diplomacy[i].parties.length; zz++) {
                  if (this.game.state.diplomacy[i].parties[zz] == this.game.state.diplomacy[i].proposer) {
                    this.game.state.diplomacy[i].confirms[zz] = 1;
                  }
                }
                if (this.game.state.diplomacy[i].parties[z] == faction && this.game.state.diplomacy[i].confirms[z] != 1) {
                  this.game.queue.push("confirm_diplomatic_proposal\t"+faction+"\t"+i);
                  anything_to_review = true;
                }
              }
            }
          }

          if (anything_to_review) {
            // we have pushed to the queue, so will return and pass-
            // through when all proposals are fine.
            return 1;
          }

	  //
	  // nothing to review? remove instruction
	  //
	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "confirm_diplomatic_proposal") {

	  let faction = mv[1];
	  let proposal_idx = parseInt(mv[2]);
	  let proposal = this.game.state.diplomacy[proposal_idx];
	  let player = this.returnPlayerOfFaction(faction);

	  if (this.game.player == player) {
	    this.diplomacy_confirm_overlay.render(faction, proposal_idx);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " reviewing offers...");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}

	if (mv[0] === "propose_diplomatic_proposals_faction_array") {

	  let factions = JSON.parse(mv[1]);
	  let do_i_get_to_move = false;

	  //
	  // exit if diplomacy-overlay open and visible
	  //
	  if (this.diplomacy_overlay.is_visible) { return 0; }
	  if (this.moves.length > 0) { return 0; }

	  //
	  // skip if we have already confirmed!
	  //
	  if (this.game.confirms_needed[this.game.player-1] == 0) {
	    this.diplomacy_overlay.hide();
	    this.winter_overlay.render("stage6");
	    return 0;
	  }

	  this.addMove("RESOLVE\t"+this.publicKey);

	  for (let i = 0; i < factions.length; i++) {
	    let p = this.returnPlayerCommandingFaction(factions[i]);
	    if (this.game.player == p && factions[i] != "protestant") {
	      this.diplomacy_overlay.render(factions[i]);
	      do_i_get_to_move = true;
	    }
          }

	  if (do_i_get_to_move == false) {
	     this.endTurn();
	  }

	  return 0;

	}


	if (mv[0] === "confirm_and_propose_diplomatic_proposals") {

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  this.winter_overlay.render("stage6");

	  //
	  // papacy asked for Henry VIII marriage
	  //
	  if (faction == "marriage") {
	    if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
	      this.marriage_overlay.renderApproveDivorce();
	    }
	    this.game.queue.splice(qe, 1);
	    return 0;
	  }

	  //
	  // first, if there are any outstanding proposals that
	  // involve this faction, we need to ask them one-by-one
	  // if they agree or disagree. if they agree and are the
	  // last to agree, it will immediately execute.
	  //
	  let anything_to_review = false;
	  for (let i = 0; i < this.game.state.diplomacy.length; i++) {
	    if (this.game.state.diplomacy[i].parties.includes(faction)) {
	      for (let z = 0; z < this.game.state.diplomacy[i].parties.length; z++) {

	        if (!this.game.state.diplomacy[i].confirms) { this.game.state.diplomacy[i].confirms = []; }
		while (this.game.state.diplomacy[i].confirms.length < this.game.state.diplomacy[i].parties.length) { this.game.state.diplomacy[i].confirms.push(0); }
		for (let zz = 0; zz < this.game.state.diplomacy[i].parties.length; zz++) {
		  if (this.game.state.diplomacy[i].parties[zz] == this.game.state.diplomacy[i].proposer) {
		    this.game.state.diplomacy[i].confirms[zz] = 1;
		  }
		}
		if (this.game.state.diplomacy[i].parties[z] == faction && this.game.state.diplomacy[i].confirms[z] != 1) {
	          this.game.queue.push("confirm_diplomatic_proposal\t"+faction+"\t"+i);
	          anything_to_review = true;
	        }
	      }
	    }
	  }
	  if (anything_to_review) { 
	    // we have pushed to the queue, so will return and pass-
	    // through when all proposals are fine.
	    return 1;
	  }

	  //
	  // protestants cannot make new proposals....
	  //
	  if (faction === "protestant") {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // there are no proposals left
	  //
	  if (player === this.game.player) {
	    // makes sure old data purged from last faction we did
	    //this.diplomacy_propose_overlay.purgeProposals();
	    //this.diplomacy_propose_overlay.render(faction);
	    this.diplomacy_overlay.purgeProposals();
	    this.diplomacy_overlay.render(faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " conducting diplomacy...");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}



	if (mv[0] === "remove_excommunication") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];

          if (this.game.state.excommunicated_factions[faction] != 1) { return 1; }

	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.playerManuallyRemoveExcommunication(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " conducting diplomacy...");
	  }

	  return 0;

	}




	if (mv[0] === "sue_for_peace") {

	  this.game.queue.splice(qe, 1);

	  this.winter_overlay.render("stage7");

	  let faction = mv[1];
	  let can_faction_sue_for_peace = this.canFactionSueForPeace(faction);

	  if (can_faction_sue_for_peace.length == 0) { return 1; }

	  if (this.game.player == this.returnPlayerCommandingFaction(faction)) {
	    this.playerSueForPeace(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering Suing for Peace");
	  }

	  return 0;

	}



	if (mv[0] === "make_declarations_of_war") {

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  this.winter_overlay.render("stage8");

	  if (this.game.player == player) {
	    this.playerMakeDeclarationsOfWar(this, faction);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " considering Declarations of War");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}



        if (mv[0] === "diplomacy_phase_2P") {

	  //
	  // hide winter overlay
	  //
	  this.winter_overlay.hide();

	  // removed besieged spaces
	  this.removeBesiegedSpaces();

	  //
	  // remove french, hapsburg and ottoman army leaders
	  //
	  let rf = ["hapsburg", "france", "ottoman"];
	  for (let key in this.game.spaces) {
	    for (let z = 0; z < rf.length; z++) {
	      let f = rf[z];
	      for (let i = 0; i < this.game.spaces[key].units[f].length; i++) {
		let u = this.game.spaces[key].units[f][i];
		if (u.army_leader || u.navy_leader) {
		  this.game.spaces[key].units[f].splice(i, 1);
		  i--;
		  this.displaySpace(key);
		}
	      }
	    }
	  }

//
// Papacy 
//
//
//if (this.game.state.round == 2) {
//  this.game_help.render(TutorialTemplate, {
//    help : `Diplomacy Phase` ,
//    content : `
//	In the two-player version of Here I Stand, the Diplomatic Stage starts with the Papacy having the option
//	to end any wars it is in with third powers such as France or the Ottomans. Terminating any war will give 
//	the Protestants a "War Winner" VP.
//	</p></p>
//	Both players are then dealt two cards from a special Diplomatic Deck and must choose one to event. These
//	cards trigger actions affecting the other factions on the board.
//	<p></p>
//	If diplomatic events put a player at war with either the Papacy or the Protestants, that faction can be 
//	controlled by the opposing faction during their turn. Once the Schmalkaldic League has formed, for instance,
//	the Papacy also controls the Hapsburgs.
//    `,
//    line1 : "learn" ,
//    line2 : "diplomacy" ,
//    fontsize : "2.1rem" ,
//    img : `/his/img/backgrounds/tutorials/the_ambassadors_depart.png`,
//  });
//}


	  //
	  // multiplayer has diplomacy phase
	  //
	  if (this.game.players.length > 2) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // no diplomacy phase round 1
	  //
	  if (this.game.state.round == 1 || (this.game.state.round <= this.game.state.starting_round)) {

            this.game.queue.push("SHUFFLE\t2");
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKENCRYPT\t2\t"+(i));
	    }
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKXOR\t2\t"+(i));
	    }

	    let new_cards = this.returnNewDiplomacyCardsForThisTurn(this.game.state.round);
    	    this.game.queue.push("DECK\t2\t"+JSON.stringify(new_cards));

	    this.game.queue.splice(qe, 1);
	    return 1;

	  }

	  //
	  // 2-player game? both players play a diplomacy card
	  // AFTER they have been dealt on every turn after T1
	  //
	  if (this.game.state.round > 1) {
    	    this.game.queue.push("play_diplomacy_card\tprotestant");
    	    this.game.queue.push("play_diplomacy_card\tpapacy");
	  }

	  //
	  // 2-player game? Diplomacy Deck
	  //
	  if (this.game.players.length == 2) {

	    let cards_to_deal = 2;
	    if (this.game.state.round > 2) { cards_to_deal = 1; }

	    for (let i = this.game.state.players_info.length-1; i >= 0; i--) {
	      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
    	        this.game.queue.push("DEAL\t2\t"+(i+1)+"\t"+cards_to_deal);
	      }
	    }
            this.game.queue.push("SHUFFLE\t2");
            this.game.queue.push("DECKRESTORE\t2");
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKENCRYPT\t2\t"+(i));
	    }
	    for (let i = this.game.state.players_info.length; i > 0; i--) {
    	      this.game.queue.push("DECKXOR\t2\t"+(i));
	    }
	    let new_cards = this.returnNewDiplomacyCardsForThisTurn(this.game.state.round);
    	    this.game.queue.push("DECK\t2\t"+JSON.stringify(new_cards));
            this.game.queue.push("DECKBACKUP\t2");
	  }

	  //
	  // The Papacy may end a war they are fighting by playing Papal Bull or by suing for peace. -- start of diplomacy phase
	  //
          let is_papacy_at_war = false;
          let factions = ["genoa","venice","scotland","ottoman","france","england","hungary","hapsburg"];
          for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { is_papacy_at_war = true; } }
          if (is_papacy_at_war == true) {
            this.game.queue.push("papacy_diplomacy_phase_special_turn");
            this.game.queue.push("counter_or_acknowledge\tPapacy Special Diplomacy Phase");
  	    this.game.queue.push("RESETCONFIRMSNEEDED\tall");
          }

	  this.game.queue.splice(qe, 1);
          return 1;

        }


	if (mv[0] === "war_loser_regain_leaders_for_vp_or_cards") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];
	
	  if (winner == "skip") { return 1; }

	  let p2 = this.returnPlayerCommandingFaction(winner);
          let target_leaders = 0;

          for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
            if (his_self.game.state.players_info[p2-1].captured[z].faction == loser) {
              target_leaders++;
            }
          }

	  if (target_leaders == 0) { return 1; }
	
	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainLeadersForVPOrCards(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Leaders");
	  }

          return 0;

        }


	if (mv[0] === "war_loser_regain_spaces_for_vp_or_cards") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];

	  if (winner == "skip") { return 1; }

          let target_spaces = his_self.countSpacesWithFilter(
            function(space) {
              if (space.home == loser && space.political == winner) { return 1; }
	      return 0;
	    }
          );

	  if (target_spaces < 2) { return 1; }
 
	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainSpacesForVPOrCards(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Home Keys");
	  }

          return 0;

        }

	if (mv[0] === "war_loser_regain_keys_for_vp") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let loser = mv[1];
	  let winner = mv[2];

	  if (winner == "skip") { return 1; }

	  if (this.game.player == this.returnPlayerOfFaction(loser)) {
	    this.playerRegainKeysForVP(loser, winner);
	  } else {
	    this.updateStatus(this.returnFactionName(loser) + " Considering Regaining Home Keys");
	  }

          return 0;

        }

	if (mv[0] === "player_play_papacy_regain_spaces_for_vp") {

	  this.game.queue.splice(qe, 1);

          let enemies = [];
	  let factions = ["genoa","venice","scotland","ottoman","france","england","hungary","hapsburg"];
	  for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { enemies.push(factions[i]); } }

	  if (this.game.player == this.returnPlayerOfFaction("papacy")) {
	    this.playerPlayPapacyRegainSpacesForVP();
	  } else {
	    this.updateStatus("Papacy Considering Regaining Spaces");
	  }

          return 0;

	}


	if (mv[0] === "papacy_diplomacy_phase_special_turn") {

	  this.game.queue.splice(qe, 1);

	  let is_papacy_at_war = false;
          let enemies = [];
	  let factions = ["ottoman","france","england","hapsburg"];
	  for (let i = 0; i < factions.length; i++) { if (this.areEnemies(factions[i], "papacy")) { enemies.push(factions[i]); is_papacy_at_war = true; } }

	  if (is_papacy_at_war == false) {
	    this.updateLog("Papacy is not at War, skipping special pre-diplomacy stage...");
	    return 1;
	  }

	  if (this.game.player == this.returnPlayerOfFaction("papacy")) {
	    this.playerPlayPapacyDiplomacyPhaseSpecialTurn(enemies);
	  } else {
	    this.updateStatus("Papacy Considering Diplomatic Options to End War");
	  }

          return 0;

        }

	if (mv[0] === "unset_enemies") {

	  let f1 = mv[1];
	  let f2 = mv[2];

	  this.game.queue.splice(qe, 1);

  	  this.unsetEnemies(f1, f2);

	  // also unset any minor allied powers
	  if (this.returnControllingPower("venice") == f1) { this.unsetEnemies("venice", f2); }
	  if (this.returnControllingPower("venice") == f2) { this.unsetEnemies("venice", f1); }
	  if (this.returnControllingPower("hungary") == f1) { this.unsetEnemies("hungary", f2); }
	  if (this.returnControllingPower("hungary") == f2) { this.unsetEnemies("hungary", f1); }
	  if (this.returnControllingPower("genoa") == f1) { this.unsetEnemies("genoa", f2); }
	  if (this.returnControllingPower("genoa") == f2) { this.unsetEnemies("genoa", f1); }
	  if (this.returnControllingPower("scotland") == f1) { this.unsetEnemies("scotland", f2); }
	  if (this.returnControllingPower("scotland") == f2) { this.unsetEnemies("scotland", f1); }

	  this.displayWarBox();

	  return 1;
	  
	}
        if (mv[0] === "unset_allies") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetAllies(f1, f2);

	  // also unset any minor allied powers
	  if (this.returnControllingPower("venice") == f1) { this.unsetAllies("venice", f2); }
	  if (this.returnControllingPower("venice") == f2) { this.unsetAllies("venice", f1); }
	  if (this.returnControllingPower("hungary") == f1) { this.unsetAllies("hungary", f2); }
	  if (this.returnControllingPower("hungary") == f2) { this.unsetAllies("hungary", f1); }
	  if (this.returnControllingPower("genoa") == f1) { this.unsetAllies("genoa", f2); }
	  if (this.returnControllingPower("genoa") == f2) { this.unsetAllies("genoa", f1); }
	  if (this.returnControllingPower("scotland") == f1) { this.unsetAllies("scotland", f2); }
	  if (this.returnControllingPower("scotland") == f2) { this.unsetAllies("scotland", f1); }

	  this.game.queue.splice(qe, 1);

	  this.displayWarBox();

	  return 1;
	  
	}

	if (mv[0] === "display_vp_track") {
	
	  this.displayVictoryTrack();
	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "display_new_world") {
	  this.game.queue.splice(qe, 1);
	  this.displayNewWorld();
	  return 1;
	}


	if (mv[0] === "war") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let locale = mv[2];

	  this.updateLog(this.returnFactionName(faction) + " fights in " + this.returnSpaceName(locale));
	  this.game.queue.push("field_battle\t"+locale+"\t"+faction);

	  return 1;

	}

	if (mv[0] === "natural_ally_intervention") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let natural_ally = mv[2];
	  let enemy = mv[3];
	  let cost = parseInt(mv[4]);
	  let reason = mv[5];
	  let his_self = this;

	  //
	  // factions cannot intervene against themselves
	  //
	  if (faction == enemy) { return 1; }

	  let p = this.returnPlayerOfFaction(faction);
	  if (p == 0) { return 1; }

	  if (this.game.player == p) {

	    if (!this.canPlayerSelectOps(faction, cost)) {
	      his_self.endTurn();
	      return 0;
	    }

	    if (p === this.game.player) {

              let msg = "Intervene for " + this.returnFactionName(natural_ally) + " against " + this.returnFactionName(enemy);
	      if (cost > 0) { msg += " (cost: "+cost+")"; }
              let html = '<ul>';
              html += `<li class="option" id="yes">declare war</li>`;

	      //
	      // Auld Alliance is 
	      //
	      if (faction == "france") {
                let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    		for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      		  if (this.game.deck[0].fhand[faction_hand_idx][i] == "069") {
            	    html += `<li class="option showcard" id="069">Auld Alliance</li>`;
		  }
		}
	      }

              html += `<li class="option" id="no">do not intervene</li>`;

              html += '</ul>';

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

		his_self.cardbox.hide();

                $('.option').off();
                his_self.updateStatus("acknowledge...");
                let action = $(this).attr("id");

	        if (action === "069") {

                  //
                  // add up to 3 new French regulars in any Scottish home space under French control that isnot under siege.
                  //
                  his_self.playerSelectSpaceWithFilter(

                    "Select Unbesieged Scottish Home Space Under French Control",

                    function(space) {
                      if (space.home == "scotland") {
                        if (his_self.isSpaceControlled(space.key, "france") || his_self.isSpaceControlled(space.key, "scotland")) {
                          if (!space.besieged) {
                            return 1;
                          }
                        }
                      }
                    },

                    function(spacekey) {
		      his_self.updateStatus("fortifying...");
		      his_self.addMove("discard\t"+faction+"\t"+"069");
	              his_self.addMove("unexpected_war\t"+faction+"\t"+enemy);
		      his_self.addMove("set_allies\t"+faction+"\t"+natural_ally);
		      his_self.addMove("declare_war\t"+faction+"\t"+enemy);
                      his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
                      his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
                      his_self.addMove("build\tland\tfrance\t"+"regular"+"\t"+spacekey);
                      his_self.endTurn();
                    }
                  );

		  return;
	        }

		if (action === "yes") {
	  	  if (cost > 0) {
		    his_self.playerSelectOps(faction, cost, (card) => {
		      his_self.addMove("discard\t"+faction+"\t"+card);
	              his_self.addMove("unexpected_war\t"+faction+"\t"+enemy);
		      his_self.addMove("set_allies\t"+faction+"\t"+natural_ally);
		      his_self.addMove("declare_war\t"+faction+"\t"+enemy);
		      his_self.endTurn();
		    });
		  } else {
	            his_self.addMove("unexpected_war\t"+faction+"\t"+enemy);
		    his_self.addMove("set_allies\t"+faction+"\t"+natural_ally);
		    his_self.addMove("declare_war\t"+faction+"\t"+enemy);
		    his_self.endTurn();
		  }
	        }

	        if (action === "no") {
		  his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" defers to intervene");
		  his_self.endTurn();
	        }

	      });	
	    }	
	  } else {
            this.updateStatus(this.returnFactionName(faction) + " considering intervening for " + this.returnFactionName(natural_ally) + " against " + this.returnFactionName(enemy));
	  }

	  return 0;

	}


	//
	// if a faction is at war with a minor power, and that power becomes allied / controlled by
	// another major power, the power at war with the minor power has the option of a free 
	// declaration of war on the major power
	//
	// this can happen if someone is already at war with Venice (French) and Ottomans declare war
	// on it triggering Papal intervention. France must declare war on the Papacy in order to 
	// remain at war with Venice.
	//
	if (mv[0] === "natural_enemy_intervention") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let minor_power = mv[2];
	  let minor_power_ally = mv[3];
	  let his_self = this;

	  let p = this.returnPlayerCommandingFaction(faction);
	  if (p == 0) { return 1; }

	  if (this.game.player == p) {

            let msg = this.returnFactionName(minor_power_ally) + " allies with " + this.returnFactionName(minor_power) + ". Declare War?";
            let html = '<ul>';
            html += `<li class="option" id="yes">declare war</li>`;
            html += `<li class="option" id="no">end war</li>`;
            html += '</ul>';

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              $('.option').off();
              his_self.updateStatus("acknowledge...");
              let action = $(this).attr("id");

	      if (action === "yes") {
	        his_self.addMove("unexpected_war\t"+faction+"\t"+minor_power_ally);
	        his_self.addMove("declare_war\t"+faction+"\t"+minor_power_ally);
		his_self.endTurn();
	      } else {
		his_self.addMove("end_war\t"+faction+"\t"+minor_power);
		his_self.endTurn();
	      }

	    });	
	  }

	  return 0;

	}


	if (mv[0] === "declare_peace" || mv[0] === "set_peace" || mv[0] === "end_war") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetEnemies(f1, f2);
	  this.game.queue.splice(qe, 1);

	  this.displayWarBox();

	  return 1;

	}

	if (mv[0] === "declare_war" || mv[0] === "set_enemies") {

	  this.game.queue.splice(qe, 1);

	  let f1 = mv[1];
	  let f2 = mv[2];
	  let skip_natural_ally_intervention = 0;
	  if (parseInt(mv[3])) { skip_natural_ally_intervention = 1; }

	  this.updateLog(this.returnFactionName(f1) + " declares war on " + this.returnFactionName(f2));

  	  this.setEnemies(f1, f2);

	  if (!skip_natural_ally_intervention) {
	    if (f2 == "scotland") {
	      his_self.game.queue.push(`natural_ally_intervention\tfrance\tscotland\t${f1}\t2\t${this.returnFactionName(f1)} declares war on Scotland`);
	    }
	    if (f2 == "venice") {
	      his_self.game.queue.push(`natural_ally_intervention\tpapacy\tvenice\t${f1}\t2\t${this.returnFactionName(f1)} declares war on Venice`);
	    }
	  }


	  if (this.returnPlayerCommandingFaction(f1) == this.game.player || this.returnPlayerCommandingFaction(f2) == this.game.player) {
    	    this.displayHudPopup("war", `${this.returnFactionName(f1)} declares war on ${this.returnFactionName(f2)}`);
	  }

	  // also set any minor allied powers
	  if (this.returnControllingPower("venice") == f1) { this.setEnemies("venice", f2); }
	  if (this.returnControllingPower("venice") == f2) { this.setEnemies("venice", f1); }
	  if (this.returnControllingPower("hungary") == f1) { this.setEnemies("hungary", f2); }
	  if (this.returnControllingPower("hungary") == f2) { this.setEnemies("hungary", f1); }
	  if (this.returnControllingPower("genoa") == f1) { this.setEnemies("genoa", f2); }
	  if (this.returnControllingPower("genoa") == f2) { this.setEnemies("genoa", f1); }
	  if (this.returnControllingPower("scotland") == f1) { this.setEnemies("scotland", f2); }
	  if (this.returnControllingPower("scotland") == f2) { this.setEnemies("scotland", f1); }

	  this.displayWarBox();

	  return 1;

	}

	if (mv[0] === "declare_alliance" || mv[0] === "set_allies") {

	  this.game.queue.splice(qe, 1);

	  let f1 = mv[1];
	  let f2 = mv[2];

	  if ((f1 == "papacy" && f2 == "hapsburg") || (f1 == "hapsburg" && f2 == "papacy") && this.game.state.round == this.game.state.henry_viii_pope_approves_divorce_round == this.game.state.round) { return 1; }

  	  this.setAllies(f1, f2);

	  // also set any minor allied powers
	  // setting allies with minor powers de-activates them from othres....
	  //if (this.returnControllingPower("venice") == f1) { this.setAllies("venice", f2); }
	  //if (this.returnControllingPower("venice") == f2) { this.setAllies("venice", f1); }
	  //if (this.returnControllingPower("hungary") == f1) { this.setAllies("hungary", f2); }
	  //if (this.returnControllingPower("hungary") == f2) { this.setAllies("hungary", f1); }
	  //if (this.returnControllingPower("genoa") == f1) { this.setAllies("genoa", f2); }
	  //if (this.returnControllingPower("genoa") == f2) { this.setAllies("genoa", f1); }
	  //if (this.returnControllingPower("scotland") == f1) { this.setAllies("scotland", f2); }
	  //if (this.returnControllingPower("scotland") == f2) { this.setAllies("scotland", f1); }

	  return 1;

	}

	if (mv[0] === "unset_activated_power") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.unsetActivatedPower(f1, f2);
	  this.game.queue.splice(qe, 1);

	  return 1;

	}

	if (mv[0] === "set_activated_power" || mv[0] === "set_activated_powers") {

	  let f1 = mv[1];
	  let f2 = mv[2];

  	  this.setActivatedPower(f1, f2);
	  this.game.queue.splice(qe, 1);

	  return 1;

	}



	//
	// this checks we have not been dealt a removed card (can happen if Clement VII is floating 
	// around the undealt cards and removed. and asks for a new one if this is the case.
	//
	if (mv[0] === "check_replacement_cards") {

	  this.game.queue.splice(qe, 1);
	  faction = mv[1];

	  let num = 0;
	  let p = this.returnPlayerOfFaction(faction);

	  if (this.game.player == p) {

	    this.updateStatus("checking "+this.returnFactionName(faction)+" has no removed cards...");

            let fhand_idx = this.returnFactionHandIdx(p, faction);
	
	    if (fhand_idx == -1) {

	      //
	      // TESTING can trigger but we are good - continue!
	      //
	      this.endTurn();
	      return 0;

	    }

  	    while (this.game.deck[0].fhand.length < (fhand_idx+1)) { this.game.deck[0].fhand.push([]); }
	    for (let zz = 0; zz < this.game.deck[0].fhand[fhand_idx].length; zz++) {
	      let c = this.game.deck[0].fhand[fhand_idx][zz];
	      if (this.game.state.removed.includes(c)) {
	        this.game.deck[0].fhand[fhand_idx].splice(zz, 1);
		num++;
		zz--;
	      }
	    }

	    //
	    // we need a new/replacement card
	    //
	    if (num > 0) {

	      //
	      // not good - deal another!
	      //
	      this.addMove("check_replacement_cards\t"+faction);
    	      this.addMove("hand_to_fhand\t1\t"+p+"\t"+faction);
    	      this.addMove("DEAL\t1\t"+p+"\t"+(num));
	      this.endTurn();

	    } else {

	      //
	      // we are good - continue!
	      //
	      this.endTurn();
	    }

	  } else {
	    this.updateStatus("checking "+this.returnFactionName(faction)+" has no removed cards...");
	  }

	  return 0;

	}

        if (mv[0] === "card_draw_phase") {

	  this.updateStatus("dealing cards...");

	  if (this.game.state.round > 1) {
	    this.winter_overlay.render("stage5");
	  }


	  //
	  // check cards
	  //
	  if (this.game.players.length == 2) {
    	    this.game.queue.push("check_replacement_cards\tpapacy");
    	    this.game.queue.push("check_replacement_cards\tprotestant");
	  } else {
    	    this.game.queue.push("check_replacement_cards\tottoman");
    	    this.game.queue.push("check_replacement_cards\thapsburg");
    	    this.game.queue.push("check_replacement_cards\tfrance");
    	    this.game.queue.push("check_replacement_cards\tengland");
    	    this.game.queue.push("check_replacement_cards\tpapacy");
    	    this.game.queue.push("check_replacement_cards\tprotestant");
	  }

	  //
	  // deal cards and add home card
	  //
	  for (let i = this.game.state.players_info.length-1; i >= 0; i--) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {

	      //
	      // sanity check we are major power
	      //
	      let f = this.game.state.players_info[i].factions[z];

	      if (f === "protestant" || f === "hapsburg" || f === "papacy" || f === "england" || f === "ottoman" || f === "france") {

                let cardnum = this.factions[f].returnCardsDealt(this);

		//
		// is_testing
		//
		if (this.game.options.scenario == "is_testing") { 
		  cardnum = 5;
            	  this.game.queue.push("remove\tprotestant\t013");
            	  this.game.queue.push("event\tprotestant\t013");
		}


	        //
	        // fuggers card -1
	        //
                if (this.game.state.events.fuggers === this.game.state.players_info[i].factions[z]) {
		  cardnum--;
	  	  this.game.state.events.fuggers = "";
	        }

	        //
	        // war in persia
	        //
                if (this.game.state.events.war_in_persia == 1 && f === "ottoman") {
		  this.updateLog("Ottomans penalized -1 card for War in Persia");
		  cardnum--;
	        }

	        //
	        // war in egypt
	        //
                if (this.game.state.events.revolt_in_egypt == 1 && f === "ottoman") {
		  this.updateLog("Ottomans penalized -1 card for Revolt in Egypt");
		  cardnum--;
	        }

	        //
	        // war in egypt
	        //
                if (this.game.state.events.revolt_in_ireland == 1 && f === "england") {
		  this.updateLog("England penalized -1 card for Revolt in Ireland");
		  cardnum--;
	        }

		//
		// new world card bonus
		//
	  	if (f == "england" && this.game.state.new_world_bonus['england'] > 0) { cardnum += this.game.state.new_world_bonus['england']; }
	  	if (f == "france" && this.game.state.new_world_bonus['france'] > 0) { cardnum += this.game.state.new_world_bonus['france']; }
	  	if (f == "hapsburg" && this.game.state.new_world_bonus['hapsburg'] > 0) { cardnum += this.game.state.new_world_bonus['hapsburg']; }
	  	if (f == "ottoman" && this.game.state.new_world_bonus['ottoman'] > 0) { cardnum += this.game.state.new_world_bonus['ottoman']; }
	  	if (f == "papacy" && this.game.state.new_world_bonus['papacy'] > 0) { cardnum += this.game.state.new_world_bonus['papacy']; }
	  	if (f == "protestant" && this.game.state.new_world_bonus['protestant'] > 0) { cardnum += this.game.state.new_world_bonus['protestant']; }

		//
		// sanity check
		//
		if (cardnum < 0) { cardnum = 0; }

    	        this.game.queue.push("hand_to_fhand\t1\t"+(i+1)+"\t"+this.game.state.players_info[i].factions[z]);

//cardnum = 1;
//if (this.game.options.scenario == "is_testing") {
// if (f == "france") { cardnum = 0; }
// if (f == "papacy") { cardnum = 0; }
 //if (f == "hapsburg") { cardnum = 1; }
// if (f == "protestant") { cardnum = 0; }
// if (f == "england") { cardnum = 0; }
 //if (f == "ottoman") { cardnum = 0; }
//} else {
    		this.game.queue.push("add_home_card\t"+(i+1)+"\t"+this.game.state.players_info[i].factions[z]);
//}

    	        this.game.queue.push("DEAL\t1\t"+(i+1)+"\t"+(cardnum));

		//
	        // try to update cards_left
		//
	        if (!this.game.state.cards_left[this.game.state.players_info[i].factions[z]]) {
	          this.game.state.cards_left[this.game.state.players_info[i].factions[z]] = 0;
	        }
	        this.game.state.cards_left[this.game.state.players_info[i].factions[z]] += cardnum;

		//
		// and display cards left
		//
		this.displayCardsLeft();

	      }
	    }
	  }

	  //
	  // DECKRESTORE copies backed-up back into deck
	  //
          this.game.queue.push("SHUFFLE\t1");
          this.game.queue.push("DECKRESTORE\t1");

	  for (let i = this.game.state.players_info.length; i > 0; i--) {
    	    this.game.queue.push("DECKENCRYPT\t1\t"+(i));
	  }
	  for (let i = this.game.state.players_info.length; i > 0; i--) {
    	    this.game.queue.push("DECKXOR\t1\t"+(i));
	  }

	  //
	  // re-add discards
	  //
	  let discards = {};
	  for (let i in this.game.deck[0].discards) {
      	    discards[i] = this.game.deck[0].cards[i];
      	    delete this.game.deck[0].cards[i];
    	  }
	  for (let i in this.game.deck[0].removed) {
      	    delete this.game.deck[0].cards[i];
      	    delete discards[i];
    	  }
	  //
	  // remove any removed cards again for sanity sake (i.e. Clement VII)
	  //
	  for (let z = 0; z < this.game.state.removed.length; z++) {
      	    delete this.game.deck[0].cards[this.game.state.removed[z]];
      	    delete discards[this.game.state.removed[z]];
	  }
    	  this.game.deck[0].discards = {};

	  //
	  // our deck for re-shuffling
	  //
	  let reshuffle_cards = {};
	  for (let key in discards) {
	    if (key !== "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
	      reshuffle_cards[key] = discards[key];
	    }
	  }


	  //
	  // remove home cards 
	  //
	  if (this.game.deck[0].cards['001']) { delete this.game.deck[0].cards['001']; }
	  if (this.game.deck[0].cards['002']) { delete this.game.deck[0].cards['002']; }
	  if (this.game.deck[0].cards['003']) { delete this.game.deck[0].cards['003']; }
	  if (this.game.deck[0].cards['004']) { delete this.game.deck[0].cards['004']; }
	  if (this.game.deck[0].cards['005']) { delete this.game.deck[0].cards['005']; }
	  if (this.game.deck[0].cards['006']) { delete this.game.deck[0].cards['006']; }
	  if (this.game.deck[0].cards['007']) { delete this.game.deck[0].cards['007']; }
	  if (this.game.deck[0].cards['008']) { delete this.game.deck[0].cards['008']; }


	  //
	  // new cards this turn
	  //
	  if (this.game.state.starting_round >= this.game.state.round && this.game.state.starting_round > 1) {
	    this.game.state.round = 0;
	    for (let i = this.game.state.round; i < this.game.state.starting_round; i++) {
	      this.game.state.round++;
	      let deck_to_deal = this.returnNewCardsForThisTurn(this.game.state.round);

	      for (let key in deck_to_deal) { 
	        if (key !== "001" && key !== "002" && key !== "003" && key !== "004" && key !== "005" && key !== "006" && key !== "007" && key !== "008") {
	          reshuffle_cards[key] = deck_to_deal[key]; 
	        }
	      }
	    }
	  } else {
	    let deck_to_deal = this.returnNewCardsForThisTurn(this.game.state.round);
	    for (let key in deck_to_deal) { 
	      if (key !== "001" && key != "002" && key != "003" && key != "004" && key != "005" && key != "006" && key != "007" && key != "008") {
	        reshuffle_cards[key] = deck_to_deal[key]; 
	      }
	    }
	  }

console.log("----------------------------");
console.log("---SHUFFLING IN DISCARDS ---");
console.log("----------------------------");

    	  this.game.queue.push("restore_home_cards_to_deck");
    	  this.game.queue.push("DECK\t1\t"+JSON.stringify(reshuffle_cards));

	  // backup any existing DECK #1
          this.game.queue.push("DECKBACKUP\t1");


	  //
	  // remove any card bonuses
	  //
  	  this.game.state.papacy_card_bonus = 0;
  	  this.game.state.protestant_card_bonus = 0;
  	  this.game.state.ottoman_card_bonus = 0;
  	  this.game.state.france_card_bonus = 0;
  	  this.game.state.england_card_bonus = 0;
  	  this.game.state.hapsburg_card_bonus = 0;

	  this.game.queue.splice(qe, 1);
          return 1;

        }

        if (mv[0] === "restore_home_cards_to_deck") {

	  let d = this.returnDeck();
	  this.deck['008'] = d['008'];
	  this.game.deck[0].cards['001'] = d['001'];
	  this.game.deck[0].cards['002'] = d['002'];
	  this.game.deck[0].cards['003'] = d['003'];
	  this.game.deck[0].cards['004'] = d['004'];
	  this.game.deck[0].cards['005'] = d['005'];
	  this.game.deck[0].cards['006'] = d['006'];
	  this.game.deck[0].cards['007'] = d['007'];
	  this.game.deck[0].cards['008'] = d['008'];
	  this.game.queue.splice(qe, 1);
          return 1;
	}

	// removes from game
	if (mv[0] === "remove") {

	  let faction = mv[1];
	  let card = mv[2];

	  this.game.queue.splice(qe, 1);

	  if (!this.game.state.removed.includes(card)) { 
	    this.updateLog(this.popup(card) + " removed from deck");
	  }
	  this.removeCardFromGame(card);

	  return 1;

	}


	// pull card
	if (mv[0] === "pull_card") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let home_card_permitted = 0;
	  if (parseInt(mv[3]) > 0) { home_card_permitted = 1; }

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p2) {
            let fhand_idx = this.returnFactionHandIdx(p2, faction_giving);
	    let roll = this.rollDice(this.game.deck[0].fhand[fhand_idx].length) - 1;

            let is_this_home_card = 0;
            let pulled = this.game.deck[0].fhand[fhand_idx][roll];
            if (pulled == "001" || pulled == "002" || pulled == "003" || pulled == "004" || pulled == "005" || pulled == "006" || pulled == "007") {
              is_this_home_card = 1;
            }

	    let looped_once = false;
            if (home_card_permitted == 0 && is_this_home_card == 1) {
              while (roll >= 0 && is_this_home_card == 1) {
                is_this_home_card = 0;
                roll--;
                if (roll < 0) {
		  if (looped_once == false) { 
		    looped_once = true;
		    roll = this.game.deck[0].fhand[fhand_idx].length-1;
		  } else {
	  	    this.game.queue.splice(qe, 1);
                    this.addMove("NOTIFY\t"+this.returnFactionName(faction_giving)+ " has no non-home cards to pull");
                    this.endTurn();
                    return 0;
	          }
                }
                let pulled = this.game.deck[0].fhand[fhand_idx][roll];
                if (pulled == "001" || pulled == "002" || pulled == "003" || pulled == "004" || pulled == "005" || pulled == "006" || pulled == "007") {
                  is_this_home_card = 1;
                }
              }
            }

	    let card = this.game.deck[0].fhand[fhand_idx][roll];
	    this.addMove("give_card\t"+faction_taking+"\t"+faction_giving+"\t"+card);
	    this.endTurn();
	  } else {
	    this.rollDice();
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

        }

	// requestreveal hand
	if (mv[0] === "request_reveal_hand") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p2) {
            let fhand_idx = this.returnFactionHandIdx(p2, faction_giving);
	    this.addMove("reveal_hand\t"+faction_taking+"\t"+faction_giving+"\t"+JSON.stringify(his_self.game.deck[0].fhand[fhand_idx]));
	    this.endTurn();
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

        }

	// reveal hand
	if (mv[0] === "reveal_hand") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let cards = JSON.parse(mv[3]);

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);

	  if (this.game.player == p1) {
	    for (let i = 0; i < cards.length; i++) {
	      this.updateLog(" * " + this.popup(cards[i]));
	      //
	      // does this show our cards
	      //
	      this.deck_overlay.render("hand", cards);
	    }
	    this.updateLog(this.returnFactionName(faction_giving) + " Hand: ");
	  }


	  this.game.queue.splice(qe, 1);
	  return 1;

        }



	// give card
	if (mv[0] === "give_card") {

	  let faction_taking = mv[1];
	  let faction_giving = mv[2];
	  let card = mv[3];

	  if (card == "undefined") { 
	    this.game.queue.splice(qe, 1);
	    this.game.state.last_pulled_card = "";
	    return 1;
	  }

	  this.updateLog(this.returnFactionName(faction_taking) + " pulls " + this.popup(card));

	  let p1 = this.returnPlayerOfFaction(faction_taking);
	  let p2 = this.returnPlayerOfFaction(faction_giving);
	  this.game.state.last_pulled_card = card;


	  //
	  // update cards left
	  //
	  this.game.state.cards_left[faction_taking] += 1;
	  this.game.state.cards_left[faction_giving] -= 1;
	  if (this.game.state.cards_left[faction_giving] < 0) { 
	    this.game.state.cards_left[faction_taking] -= 1;
	    this.game.state.cards_left[faction_giving] = 0;
	  }
	  this.displayCardsLeft();


	  if (this.game.player == p2) {
	    for (let i = 0; i < this.game.deck[0].fhand.length; i++) {
	      for (let z = 0; z < this.game.deck[0].fhand[i].length; z++) {
		if (this.game.deck[0].fhand[i][z] === card) {
		  this.game.deck[0].fhand[i].splice(z, 1);
		  z--;
		}
	      }
	    }
	  }

	  if (this.game.player == p1) {
            let fhand_idx = this.returnFactionHandIdx(p1, faction_taking);
	    this.game.deck[0].fhand[fhand_idx].push(card);
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

        }

	// fortify a spacekey
	if (mv[0] === "fortify") {

	  let spacekey = mv[1];
	  this.game.spaces[spacekey].fortified = 1;
	  if (this.game.spaces[spacekey].type != "electorate" && this.game.spaces[spacekey].type != "key") { this.game.spaces[spacekey].type = "fortress"; }
	  this.game.queue.splice(qe, 1);

	  this.displaySpace(spacekey);

	  return 1;

	}



	if (mv[0] === "discard_diplomacy_card") {

	  let faction = mv[1];
	  let card = mv[2];
	  let player_of_faction = this.returnPlayerOfFaction(faction);

	  //
	  // move into discards
	  //
	  this.game.deck[1].discards[card] = this.game.deck[1].cards[card];

	  //
	  // and remove from hand
	  //
	  if (this.game.player === player_of_faction) {
	    for (let i = 0; i < this.game.deck[1].hand.length; i++) {
	      if (this.game.deck[1].hand[i] === card) {
		this.game.deck[1].hand.splice(i, 1);
	      }
	    }
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

	if (mv[0] === "select_and_discard") {

	  let his_self = this;
	  let faction = mv[1];
	  let player = this.returnPlayerCommandingFaction(faction);
          let fhand_idx = this.returnFactionHandIdx(player, faction);
	  let cards = [];

	  if (player == this.game.player) {

	    cards = this.game.deck[0].fhand[fhand_idx];
	    if (mv[2]) { cards = JSON.parse(mv[2]); }

            let msg = "Select Card to Discard:";
            let html = '<ul>';
	    let any_choice = false;
	    let lowest_op = 6;
	    for (let i = 0; i < cards.length; i++) {
	      // avoids removed cards crashing game if they sneak through
	      try {
                if (his_self.game.deck[0].cards[cards[i]].type != "mandatory" && parseInt(cards[i]) > 7) {
	  	  any_choice = true;
		  if (his_self.game.deck[0].cards[cards[i]].ops < lowest_op) {
		    lowest_op = parseInt(his_self.game.deck[0].cards[cards[i]].ops);
		  }
                  html += `<li class="option showcard" id="${cards[i]}">${his_self.game.deck[0].cards[cards[i]].name}</li>`;
                }
	      } catch (err) {}
            }
            html += '</ul>';

	    if (any_choice == false) { his_self.endTurn(); return 0; }

            his_self.updateStatusWithOptions(msg, html);

            $('.option').off();
            $('.option').on('click', function () {

              let action = $(this).attr("id");
	      let ops_discarded = parseInt(his_self.game.deck[0].cards[action].ops);
	      if (ops_discarded >= lowest_op+2) {
		let c = confirm("This appears to be a high-value card. Confirm discard?");
		if (!c) { return; }
	      }

              $('.option').off();
              his_self.updateStatus("acknowledge...");
              his_self.addMove("discard\t"+faction+"\t"+action);
              his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction)+" discards "+his_self.popup(action));
              his_self.endTurn();
            });
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " selecting discard");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}

        //
        // use "discard" when the card being discarded is known 
        //
	if (mv[0] === "discard") {

	  let faction = mv[1];
	  let card = mv[2];
	  let player_of_faction = this.returnPlayerCommandingFaction(faction);
	  let already_discarded = false;


          if (card === "034") {
            this.game.state.events.intervention_naval_avoid_battle_possible = 0;
            this.game.state.events.intervention_naval_intercept_possible = 0;
            this.game.state.events.intervention_post_naval_battle_possible = 0;
          }

          if (card === "037") {
            this.game.state.events.intervention_on_events_possible = 0;
          }

	  if (this.game.deck[0].discards[card]) { already_discarded = true; }
	  //
	  // move into discards
	  //
	  this.game.deck[0].discards[card] = this.game.deck[0].cards[card];

	  //
	  // and remove from hand
	  //
	  // song and dance here is because cards played as minor powers may try
	  // to discard from those faction hands, which is especially an issue 
	  // in the 2P game.
	  //
	  if (this.game.player === player_of_faction) {
            let fhand_idx = this.returnFactionHandIdx(player_of_faction, faction);
	    if (!this.game.deck[0].fhand[fhand_idx]) {
	      for (let i = 0; i < this.game.deck[0].fhand.length; i++) {	
		if (this.game.deck[0].fhand[i].includes(card)) {
		  fhand_idx = i;
		  i = this.game.deck[0].fhand.length+2;
		}
	      }
	    }
	    if (this.game.deck[0].fhand[fhand_idx]) {
	      for (let i = 0; i < this.game.deck[0].fhand[fhand_idx].length; i++) {
	        if (this.game.deck[0].fhand[fhand_idx][i] === card) {
		  this.game.deck[0].fhand[fhand_idx].splice(i, 1);
	        }
	      }
	    }
	  }

	  //
	  // and update cards left
	  //
          if (already_discarded == false && this.game.state.cards_left[faction]) {
            if (this.game.state.cards_left[faction] > 0) {
	      this.game.state.cards_left[faction]--;
	      this.displayCardsLeft();
	    }
	  }

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	// skip next impulse
	if (mv[0] === "skip_next_impulse") {
	  this.game.state.skip_next_impulse.push(mv[1]);
	  this.game.queue.splice(qe, 1);
          return 1;
        }


	if (mv[0] === "unexcommunicate_faction") {

	  let faction = mv[1];
	  this.unexcommunicateFaction(faction);
	  this.game.queue.splice(qe, 1);

          return 1;

	}

	// discards N cards from faction hand
	if (mv[0] === "excommunicate_faction") {

	  let faction = mv[1];
	  this.game.queue.splice(qe, 1);
	  this.excommunicateFaction(faction);
	  this.updateLog(this.returnFactionName(faction) + " excommunicated");
	  this.game.queue.push("ACKNOWLEDGE\t"+this.returnFactionName(faction) + " is excommunicated");
	  this.game.queue.push("display_custom_overlay\texcommunication\t"+faction);

          return 1;

	}

	// discards N cards from faction hand
	if (mv[0] === "excommunicate_reformer") {

	  let reformer = mv[1];

	  this.game.queue.splice(qe, 1);

	  this.updateLog(this.returnReformerName(reformer) + " excommunicated");
	  this.excommunicateReformer(reformer);
	  this.displayBoard();

          return 1;
        }


	//
	// discards N cards from faction hand
	//
	// this cannot pick the home card
	//
	if (mv[0] === "discard_random") {

	  let faction = mv[1];
	  let home_card_permitted = 0;
	  if (parseInt(mv[2]) > 0) { home_card_permitted = parseInt(mv[2]); }
	  let num = 1;

	  let player_of_faction = this.returnPlayerOfFaction(faction);

	  this.game.queue.splice(qe, 1);

	    if (this.game.player == player_of_faction) {

              let fhand_idx = this.returnFactionHandIdx(player_of_faction, faction);
	      let num_cards = this.game.deck[0].fhand[fhand_idx].length;
	      if (num_cards == 0) {
		this.rollDice(6);
		this.addMove("NOTIFY\t"+this.returnFactionName(faction)+ " has no cards to discard");
		this.endTurn();
		return 0;
	      }

	      let discards = [];
	      if (num_cards < num) { num = num_cards; }
	      let roll = this.rollDice(num_cards) - 1;
	      let is_this_home_card = 0;
	      let pulled = this.game.deck[0].fhand[fhand_idx][roll];
	      if (pulled === "001" || pulled === "002" || pulled === "003" || pulled === "004" || pulled === "005" || pulled === "006" || pulled === "007") {
		is_this_home_card = 1;
	      }

	      if (home_card_permitted == 0 && is_this_home_card == 1) {
		let is_looped = false;
	        while (roll >= 0 && is_this_home_card == 1) {
		  is_this_home_card = 0;
		  roll--;
		  if (roll == -1) {
		    if (is_looped == true) {
	  	      this.game.queue.splice(qe, 1);
		      this.addMove("NOTIFY\t"+this.returnFactionName(faction)+ " has no non-home cards to discard");
		      this.endTurn();
		      return 0;
		    } else {
		      is_looped = true;
		      roll = this.game.deck[0].fhand[fhand_idx].length-1;
		    }
		  }
	      	  let pulled = this.game.deck[0].fhand[fhand_idx][roll];
	      	  if (pulled === "001" || pulled === "002" || pulled === "003" || pulled === "004" || pulled === "005" || pulled === "006" || pulled === "007") {
		    is_this_home_card = 1;
		  }
		}
	      }

	      discards.push(roll);
	      discards.sort();
	      for (let zz = 0; zz < discards.length; zz++) {
	        this.addMove("discard\t"+faction+"\t"+this.game.deck[0].fhand[fhand_idx][discards[zz]]);
	        this.addMove("NOTIFY\t"+this.returnFactionName(faction)+" discards "+this.popup(this.game.deck[0].fhand[fhand_idx][discards[zz]]));
	      }
	      this.endTurn();

	    } else {
	      this.rollDice(6);
	    }


	  return 0;

	}

	if (mv[0] === "skipturn") {

	    this.game.queue.splice(qe, 1);
	    return 1;
	}

        if (mv[0] === "play") {

	  let faction = mv[1];

	  //
	  // check this first if it is the Haps turn - perhaps Ottoman field battle requires!
	  //
	  if (this.game.state.events.defeat_of_hungary_bohemia != 1) { this.triggerDefeatOfHungaryBohemia(); }

	  this.factionbar.setActive(faction);

	  this.unbindBackButtonFunction();

	  let player = this.returnPlayerOfFaction(faction);

	  // update board display
	  this.game.state.board[faction] = this.returnOnBoardUnits(faction);
          this.displayBoard();
	  this.displayCardsLeft();

	  //
	  // if everyone has passed, we can avoid this
	  //
	  let everyone_has_passed = true;
	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	      if (this.game.state.players_info[i].factions_passed[z] != true) { everyone_has_passed = false; }
	    }
	  }
	  if (everyone_has_passed == true) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // new impulse
	  //
          this.resetBesiegedSpaces();
          this.onNewImpulse();

	  //
	  // hide unneeded overlays
	  //
	  this.debate_overlay.hide();
	  this.theses_overlay.hide();

	  this.game.state.active_card = "";
	  this.game.state.active_player = player;
	  this.game.state.active_faction = faction;

	  //
	  // skip factions not-in-play
	  //
	  if (player == -1) {
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // skip turn if required
	  //
	  if (this.game.state.skip_next_impulse.includes(faction)) {
	    for (let i = 0; i < this.game.state.skip_next_impulse.length; i++) {
	      if (this.game.state.skip_next_impulse[i] == faction) {
		this.game.state.skip_next_impulse.splice(i, 1);
	    	this.game.queue.splice(qe, 1);
	    	return 1;
	      }
	    }

	    // safety check
	    this.game.state.skip_next_impulse = [];
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // reset player/state vars and set as active player
	  //
	  this.resetPlayerTurn(player);

	  if (this.game.player == player) {
	    this.playerTurn(faction);
	  } else {
	    let f = this.game.state.players_info[this.game.player-1].factions[0];
	    let fhand_idx = 0;
	    try {
	      f = this.game.state.players_info[this.game.player-1].active_faction;
	      fhand_idx = this.game.state.players_info[this.game.player-1].active_faction_idx;
	    } catch (err) {
	    }
	    this.updateStatusAndListCards(`${this.returnFactionName(f)} - Opponent Turn: `, this.game.deck[0].fhand[fhand_idx], () => {});
            this.attachCardboxEvents(async function(card) {});
	  }

	  this.game.queue.splice(qe, 1);
          return 0;
        }
	if (mv[0] === "continue") {

	  let player = mv[1];
	  let faction = mv[2];
	  let card = mv[3];
	  let ops = parseInt(mv[4]);
	  let limit = "";
	  if (mv[5]) { limit = mv[5]; }

	  //
	  // no ops, just continue
	  //
	  if (ops == 0) { 
	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  //
	  // cache our last move, as we will sometimes show a sub-menu if
	  // there is another obvious move and we want to allow the player
	  // to avoid wandering through the menu to make progress on their
	  // turn.
	  //
	  let player_last_move = this.game.state.player_last_move;
	  let player_last_spacekey = this.game.state.player_last_spacekey;

	  //
	  // now reset them so we have a "clean slate" for our next move
	  //
	  this.game.state.player_last_move = "";
	  this.game.state.player_last_spacekey = "";

	  this.game.queue.splice(qe, 1);

	  let player_turn = -1;

	  for (let i = 0; i < this.game.state.players_info.length; i++) {
	    if (this.game.state.players_info[i].factions.includes(faction)) {
	      player_turn = i+1;
	    }
	  }

	  //
	  // hide unneeded overlays
	  //
	  this.debate_overlay.hide();
	  this.theses_overlay.hide();

          this.displayBoard();

	  // no-one controls this faction, so skip
	  if (player_turn === -1) {
	    return 1;
	  }

	  // let the player who controls play turn
	  if (this.game.player === player_turn) {

	    let mycallback = [];

	    if (player_last_move == "move" && (card != "002" && ops != 5 && this.game.state.events.foul_weather != 1)) { // HRE moves as event, so disable on first ops played
	      if (player_last_spacekey != "") {
		if (this.game.spaces[player_last_spacekey]) {
		  if (!this.isSpaceBesieged(this.game.spaces[player_last_spacekey])) {
		    //
		    // we need units in this space
		    //
		    if (this.returnFactionLandUnitsInSpace(faction, player_last_spacekey) > 0) {

		      his_self.unbindBackButtonFunction();
 	              mycallback.push({ text : "continue move" , mycallback : () => { this.playerContinueToMoveFormationInClear(his_self, this.game.player, faction, player_last_spacekey, 1, (ops)); }});
	              if (!this.isSpaceControlled(faction, player_last_spacekey) && this.game.spaces[player_last_spacekey].type == "town" && !this.areAllies(faction, this.returnFactionControllingSpace(player_last_spacekey))) {
 	                mycallback.push({ text : "control town" , mycallback : () => {
		          if (ops > 1) {
                            his_self.addMove(`continue\t${mv[1]}\t${mv[2]}\t${mv[3]}\t${ops-1}\t${mv[5]}`);
                            his_self.addMove("SETVAR\tstate\tplayer_last_move\tmove");
                            his_self.addMove("SETVAR\tstate\tplayer_last_spacekey\t"+player_last_spacekey);
		          }
                          his_self.addMove("pacify\t"+faction+"\t"+player_last_spacekey);
                          his_self.endTurn();
	 	        }});
	              }
	            }
	          }
	        }
	      }
	    }
 	    mycallback.push({ text : "back to menu" , mycallback : () => { this.playerPlayOps(card, faction, ops, limit); }});
	    this.unbindBackButtonFunction();
	    this.playerAcknowledgeNotice(`You have ${ops} OPS remaining...`, mycallback);

	  } else {
	    this.hideOverlays();
	    let fhand_idx = 0;

	    //
	    // just moved? players update to upcoming faction
	    //
	    if (this.game.players == 3) {
	      if (faction == "ottoman") {
		if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "england";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "england");
		}
	      }
	      if (faction == "hapsburg") {
		if (this.game.player == this.returnPlayerCommandingFaction("france")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "france";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "france");
		}
	      }
	      if (faction == "england") {
		if (this.game.player == this.returnPlayerCommandingFaction("hapsburg")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "papacy";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "papacy");
		}
	      }
	      if (faction == "france") {
		if (this.game.player == this.returnPlayerCommandingFaction("england")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "protestant";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "protestant");
		}
	      }
	      if (faction == "papacy") {
		if (this.game.player == this.returnPlayerCommandingFaction("france")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "ottoman";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "ottoman");
		}
	      }
	      if (faction == "protestant") {
		if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "hapsburg";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "hapsburg");
		}
	      }
	    }
	    if (this.game.players == 4) {
	      if (faction == "ottoman") {
		if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "england";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "england");
		}
	      }
	      if (faction == "england") {
		if (this.game.player == this.returnPlayerCommandingFaction("hapsburg")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "papacy";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "papacy");
		}
	      }
	      if (faction == "france") {
		if (this.game.player == this.returnPlayerCommandingFaction("england")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "protestant";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "protestant");
		}
	      }
	      if (faction == "protestant") {
		if (this.game.player == this.returnPlayerCommandingFaction("papacy")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "hapsburg";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "hapsburg");
		}
	      }
	    }
	    if (this.game.players == 5) {
	      if (faction == "ottoman") {
		if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "england";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "england");
		}
	      }
	      if (faction == "france") {
		if (this.game.player == this.returnPlayerCommandingFaction("england")) {
                  this.game.state.players_info[this.game.player-1].active_faction = "protestant";
                  this.game.state.players_info[this.game.player-1].active_faction_idx = this.returnFactionHandIdx(this.game.player, "protestant");
		}
	      }
	    }

	    fhand_idx = this.game.state.players_info[this.game.player-1].active_faction_idx;
	    this.updateStatusAndListCards("Opponent Turn", his_self.game.deck[0].fhand[fhand_idx], () => {});

	  }

          return 0;
        }


	if (mv[0] === "place_protestant_debater") {

	  this.game.queue.splice(qe, 1);

	  let name = mv[3];
	  let location = mv[4];

	  this.updateLog(unitname + " enters at " + location);
	  this.addDebater("protestant", location, name);
	  if (this.game.spaces[space].religion != "protestant") {
	    this.game.spaces[space].religion = "protestant";
	    this.updateLog(this.returnSpaceName(location) + " converts Protestant");
	  }
	  this.displaySpace(location);

	  return 1;

	}

	if (mv[0] === "select_for_catholic_conversion") {

	  let faction = mv[1];
	  let zone = "";
	  let force_in_zone = false;
	  if (mv[2]) { zone = mv[2]; }
	  if (mv[3]) { force_in_zone = true; }

	  this.game.queue.splice(qe, 1);

	  let available_spaces = this.returnNumberOfProtestantSpacesInLanguageZone(zone, 1);
	  if (available_spaces == 0) {
	    if (force_in_zone) { 
	      return 1; 
	    } else { 
	      zone = ""; 
	    }
	  }
	  if (1 > this.returnNumberOfProtestantSpacesInLanguageZone(zone, 1)) {
	    return 1;
	  }

	  if (this.theses_overlay.visible) { this.theses_overlay.pushHudUnderOverlay(); }

	  let player = this.returnPlayerOfFaction(faction);
	  if (this.game.player == player) {

	    this.playerSelectSpaceWithFilter(
              "Select Town to Convert Catholic",

              //
              // catholic spaces adjacent to protestant
              //
              function(space) {
                if (
                  space.religion === "protestant" &&
		  (
                    his_self.isSpaceAdjacentToReligion(space, "catholic")
                    ||
                    his_self.isSpaceAPortInTheSameSeaZoneAsACatholicPort(space)
		  )
                ) {
		  if (space.language == zone || zone == "" || zone == "all") {
                    return 1;
                  }
                }
                return 0;
              },

              function(spacekey) {
    	        his_self.updateStatusWithOptions(`Converting ${his_self.returnSpaceName(spacekey)}`);
                his_self.addMove("convert\t"+spacekey+"\tcatholic");
                his_self.endTurn();
              },

              null,

	      true

            );

          } else {
	    this.updateStatus("Player selecting town for Catholicism");
	  }
	  this.displayVictoryTrack();
	  return 0;

        }

	if (mv[0] === "select_for_protestant_conversion") {

	  let faction = mv[1];
	  let zone = "";
	  let force_in_zone = false;
	  if (mv[2]) { zone = mv[2]; }
	  if (mv[3]) { force_in_zone = true; }

	  this.game.queue.splice(qe, 1);

	  let available_spaces = this.returnNumberOfCatholicSpacesInLanguageZone(zone, 1);
	  if (available_spaces == 0) {
	    if (force_in_zone) { 
	      return 1; 
	    } else { 
	      zone = ""; 
	    }
	  }
	  if (1 > this.returnNumberOfCatholicSpacesInLanguageZone(zone, 1)) {
	    return 1;
	  }

	  if (this.theses_overlay.visible) { this.theses_overlay.pushHudUnderOverlay(); }

	  let player = this.returnPlayerOfFaction(faction);
	  if (this.game.player == player) {
	    this.playerSelectSpaceWithFilter(
              "Select Town to Convert Protestant",

              //
              // catholic spaces adjacent to protestant
              //
              function(space) {
                if (
                  space.religion === "catholic" &&
		  (
                        his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
                        ||
                        his_self.isSpaceAdjacentToReligion(space, "protestant")
                        ||
                        his_self.doesSpaceContainProtestantReformer(space)
                        ||
                        his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
		  )
                ) {
		  if (space.language == zone || zone == "" || zone == "all") {
                    return 1;
                  }
                }
                return 0;
              },

              function(spacekey) {
    	        his_self.updateStatusWithOptions(`Reforming ${his_self.returnSpaceName(spacekey)}`);
                his_self.addMove("convert\t"+spacekey+"\tprotestant");
                his_self.endTurn();
              },

              null,

	      true

            );
          } else {
	    this.updateStatus("Protestants chosing space to reform");
	  }

	  this.displayVictoryTrack();
	  return 0;

        }



 	if (mv[0] === "unrest") {

	  let spacekey = mv[1];
	  this.game.spaces[spacekey].unrest = 1;
	  this.updateLog(this.returnSpaceName(spacekey) + " enters unrest");
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}

 	if (mv[0] === "remove_unrest") {

	  let faction = mv[1];
	  let spacekey = mv[2];
	  this.game.spaces[spacekey].unrest = 0;
	  this.updateLog(this.returnSpaceName(spacekey) + " out of unrest");
	  this.displaySpace(spacekey);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


 	if (mv[0] === "player_add_unrest") {

	  let faction = mv[1];
	  let zone = mv[2];
	  let religion = mv[3];
	  let player = this.returnPlayerOfFaction(faction);


	  if (this.game.player == player) {
	    this.playerAddUnrest(this, faction, zone, religion);
	  } else {
	    this.updateStatus(this.returnFactionName(faction) + " stirring unrest");
	  }

	  this.game.queue.splice(qe, 1);
	  return 0;

	}

	//
	// similar to evacuate below
	//
	// the difference is that units will be sent en mass to the nearest fortified space
	// even if that requires transiting water, so we can have the Hapsburgs positioned
	// in Malta if they withdraw from Istanbul for instance. This makes the choice less
	// optimal for some cases.
	//
	// overflow is sent to the capital at the end.
	//
	if (mv[0] === "withdraw_to_nearest_fortified_space") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let source_spacekey = mv[2];
	  let source_space = this.game.spaces[source_spacekey];

	  //
	  // move the units here
	  //
          let land_units = [];
          let naval_units = [];

	  for (let i = 0; i < source_space.units[faction].length; i++) {
	    let u = source_space.units[faction][i];
	    if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry" || u.army_leader == true) {
	      land_units.push(u);
	      source_space.units[faction].splice(i, 1);
	      i--;
	    } else {
	      // navy leaders that are army leaders treated as army leaders primarily
	      if (u.type == "squadron" || u.type == "corsair" || u.navy_leader == true) {
	        naval_units.push(u);
	        source_space.units[faction].splice(i, 1);
	        i--;
	      }
	    }
	  }

	  //
	  // find nearest fortified unit
	  //
	  let not_these_land_spaces = [];
	  let not_these_naval_spaces = [];
	  let all_land_units_repositioned = false;
	  let all_naval_units_repositioned = false;

	  //
	  // land units
	  //
	  while (all_land_units_repositioned == false) {
            let found_space = his_self.returnNearestSpaceWithFilter(
	      source_spacekey ,
              function(spacekey) {
                if ( !not_these_land_spaces.includes(spacekey) && his_self.game.spaces[spacekey].home == faction && (his_self.isSpaceFortified(spacekey) || his_self.game.spaces[spacekey].type == "key" || his_self.game.spaces[spacekey].type == "electorate" || his_self.game.spaces[spacekey].type == "fortress")) {
		  if (his_self.returnFactionLandUnitsInSpace(faction, spacekey) < 4) { return 1; }
		}
                return 0;
              },
              function(propagation_filter) {
                return 1;
              },
              0,
              1,
            );

	    try {
		let x = found_space[0].key;
	    } catch (err) {
		let capitals = his_self.returnCapitals(faction);
		if (capitals.length > 0) {
		  for (let z = 0; z < capitals.length; z++) {
	 	    if (his_self.isSpaceControlled(capitals[z], faction)) {
		      found_space = [{ key : capitals[0] }];
		    }
		  }
	        }
		
	    }

try {
	    let loop_limit = land_units.length;
	    for (let i = 0; i < loop_limit; i++) {
	      if (his_self.returnFactionLandUnitsInSpace(faction, found_space[0].key) < 4) {
		his_self.game.spaces[found_space[0].key].units[faction].push(land_units[i]);
		land_units.splice(i, 1);
		i--;
	        loop_limit = land_units.length;
	      } else {
		let capitals = his_self.returnCapitals(faction);
		if (capitals.length > 0) {
		  his_self.game.spaces[capitals[0]].units[faction].push(land_units[i]);
		  land_units.splice(i, 1);
		  i--;
	          loop_limit = land_units.length;
	        }
	      }
	      his_self.displaySpace(found_space[0].key);
	    }
	    if (land_units.length == 0) { all_land_units_repositioned = true; }
} catch (err) {}
	  }

	  //
	  // naval units
	  //
	  while (all_naval_units_repositioned == false) {
            let found_space = his_self.returnNearestSpaceWithFilter(
	      source_spacekey ,
              function(spacekey) {
                if (his_self.game.spaces[spacekey].ports.length > 0 && his_self.game.spaces[spacekey].home == faction && (his_self.isSpaceFortified(spacekey) || his_self.game.spaces[spacekey].type == "key" || his_self.game.spaces[spacekey].type == "electorate" || his_self.game.spaces[spacekey].type == "fortress")) {
		  return 1;
		}
                return 0;
              },
              function(propagation_filter) {
                return 1;
              },
              0,
              1,
            );

try {
	    if (found_space.length > 0) {
	      for (let z = 0; z < naval_units.length; z++) {
	        his_self.game.spaces[found_space[0].key].units[faction].push(naval_units[z]);
	      }
	      naval_units = [];
	      his_self.displaySpace(found_space[0].key);
	    }
} catch (err) {}
	    all_naval_units_repositioned = true;
	  }


	  //
	  // finally, return any overstacked units to capital
	  //
          this.returnOverstackedUnitsToCapitals();

	  return 1;

	}



	if (mv[0] === "check_for_stranded_leaders") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];

	  for (let key in his_self.game.spaces) {
	    let s = his_self.game.spaces[key];
	    if (s.units[faction].length > 0) {
	      let leader_exists = false;
	      let anyone_else = false;
	      for (let z = 0; z < s.units[faction].length; z++) {
		let u = s.units[faction][z];
		if (u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
		  anyone_else = true;
		}
		if (s.units[faction][z].army_leader == true) {
		  leader_exists = true;
		}
	      }
	      if (leader_exists && !anyone_else) {
	        this.game.queue.push("maybe_evacuate_or_capture_leaders\t"+faction+"\t"+key);
	      }
	    }
	  }

	  return 1;

	}

	
	//
	// examines the space to see if there are leaders with no supporting units in 
	// which case the leaders are either captured by the faction that controls
	// the space or moved to the nearest fortified space if it is an independent-
	// controlled space.
	//
	if (mv[0] === "maybe_evacuate_or_capture_leaders") {

	  this.game.queue.splice(qe, 1);

	  let his_self = this;
	  let faction = mv[1];
	  let spacekey = mv[2];
 	  let space = this.game.spaces[spacekey];
	  let faction_controlling_space = this.returnFactionControllingSpace(space);
	  faction_controlling_space = his_self.returnControllingPower(faction_controlling_space);

	  //
	  // avoid edge cases where it is my own guys
	  //
	  if (faction_controlling_space == his_self.returnControllingPower(faction)) { return 1; }

	  let fluis = this.returnFactionLandUnitsInSpace(faction, spacekey, 1);

	  if (fluis == 0) {
	    for (let f in space.units) {
	      let cf = his_self.returnControllingPower(f);
	      if (cf == faction) {
		for (let z = 0; z < space.units[f].length; z++) {
		  if (space.units[f][z].army_leader == true) {
		    this.captureLeader(faction_controlling_space, f, space, space.units[f][z]);
		    space.units[f].splice(z, 1);
		    z--;
		  }
		}
	      }
	    }
	  }

	  return 1;

	}


	//
	// similar to withdraw to nearest fortify space above
	//
	// the difference is that units will be split out the nearest fortified spaces
	// with the 4-unit limit affecting where they can go in this version, and any 
	// surplus being randomly distributed to the various capitals.
	//
	if (mv[0] === "evacuate") {

	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let spacekey = mv[2];
 	  let space = this.game.spaces[spacekey];

	  for (let f in space.units) {

	    if (this.areAllies(faction, f)) {

	      //
	      // move naval units if possible
	      //
	      let does_space_contain_naval_vessels = false;
	      for (let i = 0; i < space.units[f].length; i++) {
	        if (space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair") {
	   	  does_space_contain_naval_vessels = true;
	        }
	      }
	      if (does_space_contain_naval_vessels) {
	        let spacekey_for_relocation = "";
	        for (let key in this.game.spaces) {
		  if (this.game.spaces[key].home == f && spacekey_for_relocation == "") {
		    if (this.game.spaces[key].ports.length > 0) {
		      if (this.isSpaceControlled(key, f)) {
		        spacekey_for_relocation = key;
		      }
		    }
	 	  }
	        }
	        for (let i = space.units[f].length-1; i >= 0; i--) {
	          if (space.units[f][i].type == "squadron" || space.units[f][i].type == "corsair") {
		    if (spacekey_for_relocation != "") {
		      this.game.spaces[spacekey_for_relocation].units[f].push(space.units[f][i]);
		    }
		    space.units[f].splice(i, 1);
	          }
	        }
	      }
	

	      let fluis = this.returnFactionLandUnitsInSpace(f, space.key, 1);
	      for (let fluis_idx = 0; fluis_idx < fluis; fluis_idx++) {

	        let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(f, spacekey, 4, 0); // 0 => do not include source

	        //
	        // split the units between capitals
	        //
	        if (res.length == 0) {
	          let capitals = this.returnCapitals(faction);
                  for (let z = 0, y = 0; z < space.units[f].length; z++) {
                    if (capitals[y]) {
                      if (space.units[f][z].reformer != true) {
                        this.game.spaces[capitals[y]].units[f].push(space.units[f][z]);
                        this.game.spaces[spacekey].units[faction].splice(z, 1);
                        z--;
                      }
                    }
                    y++;
                    if (!capitals[y]) { y = 0; }
                  }

	        //
	        // otherwise move to nearest spaces
	        //
	        } else {

                  let options = [];
	          let faction = f;
                  for (let b = 0; b < res.length; b++) {
                    let unit_limit = 4;
                    if (res[b].key == "paris" || res[b].key == "valladolid" || res[b].key == "london" || res[b].key == "vienna" || res[b].key == "istanbul" || res[b].key == "rome") { unit_limit = 1000; } else {
                      unit_limit = 4;
                    }
                    options.push(unit_limit - this.returnFactionLandUnitsInSpace(faction, res[b].key));
                  }

                  //
                  // fill those spaces
                  //
                  for (let b = 0; b < res.length; b++) {
                    for (let zz = 0; zz < options[b]; zz++) {
                      let unitlen = space.units[f].length;
                      for (let zzz = 0, zzy = 0; zzz < unitlen; zzz++, zzy++) {
                        if (this.game.spaces[spacekey].units[faction][zzy].reformer != true) {
                          this.game.spaces[res[b].key].units[faction].push(this.game.spaces[spacekey].units[faction][zzy]);
                          this.game.spaces[spacekey].units[faction].splice(zzy, 1);
                          zzy--;
                          fluis--; fluis_idx--;
			  unitlen--;
                          this.displaySpace(res[b].key);
                        }
                      }
                    }
                  }
	        }
	      }
	    }
	  }

	  this.displaySpace(spacekey);

	  return 1;

	}



	if (mv[0] === "pacify" || mv[0] === "control") {

	  this.game.queue.splice(qe, 1);
	  let faction = mv[1];
	  let space = mv[2];
	  let religion = this.game.spaces[space].religion;

	  this.game.spaces[space].unrest = 0;

	  //
	  // 2P restriction on which keys can 
	  //
	  if (this.game.players.length == 2) {
	    if (space != "metz" && space != "liege" && this.game.spaces[space].language != "german" && this.game.spaces[space].language != "italian") { 
	      this.updateLog("NOTE: only Metz, Liege and German and Italian spaces may change control in the 2P game");
	    } else {
	      this.updateLog(this.returnFactionName(this.returnControllingPower(faction)) + " controls " + this.returnSpaceName(space));
	      this.game.spaces[space].political = this.returnControllingPower(faction);
	    }
	  } else {
	    this.updateLog(this.returnFactionName(this.returnControllingPower(faction)) + " controls " + this.returnSpaceName(space));
	    this.game.spaces[space].political = this.returnControllingPower(faction);
	  }


	  //
	  // capture any leaders, remove any squadron
	  //
	  for (let f in this.game.spaces[space].units) {
	    if (!this.areAllies(f, faction)) {
	      for (let z = 0; z < this.game.spaces[space].units[f].length; z++) {
	        his_self.captureLeader(faction, f, space, this.game.spaces[space].units[f][z]);
		let u = his_self.game.spaces[space].units[f][z];
		if (u.type == "squadron" || u.type == "corsair" || u.army_leader == true || u.navy_leader == true) {
		  his_self.game.spaces[space].units[f].splice(z, 1); z--;
		}
	      };
	    }
	  }


	  //
	  // post schmalkaldic_league
	  //
	  if (faction === "protestant") {
	    if (space.home === "" && space.language == "german") { space.home = "protestant"; }
            if (space === "augsburg" && religion === "protestant" && this.game.state.augsburg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['augsburg'].units['protestant'].push();
              this.addRegular("protestant", "augsburg", 2);
              this.game.state.augsburg_electoral_bonus = 1;
            }
            if (space === "mainz" && religion === "protestant" && this.game.state.mainz_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['mainz'].units['protestant'].push();
              this.addRegular("protestant", "mainz", 1);
              this.game.state.mainz_electoral_bonus = 1;
            }
            if (space === "trier" && religion === "protestant" && this.game.state.trier_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['trier'].units['protestant'].push();
              this.addRegular("protestant", "trier", 1);
              this.game.state.trier_electoral_bonus = 1;
            }
            if (space === "cologne" && religion === "protestant" && this.game.state.cologne_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['cologne'].units['protestant'].push();
              this.addRegular("protestant", "cologne", 1);
              this.game.state.cologne_electoral_bonus = 1;
            }
            if (space === "wittenberg" && religion === "protestant" && this.game.state.wittenberg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['wittenberg'].units['protestant'].push();
              this.addRegular("protestant", "wittenberg", 2);
              this.game.state.wittenberg_electoral_bonus = 1;
            }
            if (space === "brandenburg" && religion === "protestant" && this.game.state.brandenburg_electoral_bonus == 0 && this.game.state.events.schmalkaldic_league == 1) {
              this.game.spaces['brandenburg'].units['protestant'].push();
              this.addRegular("protestant", "brandenburg", 1);
              this.game.state.brandenburg_electoral_bonus = 1;
            }
          }


          if (space.besieged != 0) {
            space.besieged = 0;
          }


	  this.displaySpace(space);
	  this.displayVictoryTrack();


          //
          // military victory
          //
	  let keys = this.returnNumberOfKeysControlledByFaction(faction);
	  if (faction === "hapsburg" && keys >= this.game.state.autowin_hapsburg_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "ottoman" && keys >= this.game.state.autowin_ottoman_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "france" && keys >= this.game.state.autowin_france_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "england" && keys >= this.game.state.autowin_england_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }
	  if (faction === "papacy" && keys >= this.game.state.autowin_papacy_keys_controlled) {
	    let player = this.returnPlayerOfFaction(faction);
	    this.sendGameOverTransaction([this.game.players[player-1]], "Military Victory");
	    return 0;
	  }

	  return 1;

	}




	if (mv[0] === "convert") {

	  this.game.queue.splice(qe, 1);

	  let space = mv[1];
	  let religion = mv[2];

	  if (religion == "protestant") {
	    this.updateLog(this.returnSpaceName(space) + " converts Protestant");
	    this.updateStatus(this.returnSpaceName(space) + " converts Protestant");
	  } else {
	    this.updateLog(this.returnSpaceName(space) + " converts Catholic");
	    this.updateStatus(this.returnSpaceName(space) + " converts Catholic");
	  }

	  if (space === "augsburg" && religion === "protestant" && this.game.state.augsburg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "augsburg", 2);
	    this.game.state.augsburg_electoral_bonus = 1;
	  }
	  if (space === "mainz" && religion === "protestant" && this.game.state.mainz_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "mainz", 1);
	    this.game.state.mainz_electoral_bonus = 1;
	  }
	  if (space === "trier" && religion === "protestant" && this.game.state.trier_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "trier", 1);
	    this.game.state.trier_electoral_bonus = 1;
	  }
	  if (space === "cologne" && religion === "protestant" && this.game.state.cologne_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "cologne", 1);
	    this.game.state.cologne_electoral_bonus = 1;
	  }
	  if (space === "wittenberg" && religion === "protestant" && this.game.state.wittenberg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "wittenberg", 2);
	    this.game.state.wittenberg_electoral_bonus = 1;
	  }
	  if (space === "brandenburg" && religion === "protestant" && this.game.state.brandenburg_electoral_bonus == 0 && (this.game.state.events.schmalkaldic_league == 0 || this.isSpaceControlled(space, "protestant"))) {
    	    this.addRegular("protestant", "brandenburg", 1);
	    this.game.state.brandenburg_electoral_bonus = 1;
	  }

	  this.game.spaces[space].religion = religion;
	  this.displaySpace(space);
	  this.displayElectorateDisplay();
	  this.displayVictoryTrack();

	  //
	  // check for victory condition
	  //
          if (this.returnNumberOfProtestantSpacesInLanguageZone() >= 50) {
	    let player = this.returnPlayerOfFaction("protestant");
	    this.sendGameOverTransaction([this.game.players[player-1]], "Religious Victory");
	    return 0;
	  }

	  return 1;

	}

	if (mv[0] === "add_home_card") {

	  let player = parseInt(mv[1]);
 	  let faction = mv[2];
 	  let hc = this.returnDeck();

	  for (let key in hc) {
	    if (hc[key].faction === faction) {
	      if (!this.game.state.cards_left[faction]) { this.game.state.cards_left[faction] = 0; }
	      this.game.state.cards_left[faction]++;
	      if (this.game.player === player) {
                let fhand_idx = this.returnFactionHandIdx(player, faction);
                if (!this.game.deck[0].fhand) { this.game.deck[0].fhand = []; }
                while (this.game.deck[0].fhand.length <= fhand_idx) { this.game.deck[0].fhand.push([]); }
	        this.game.deck[0].fhand[fhand_idx].push(key);
	      }
	    }
	  }

	  this.displayCardsLeft();
	  this.game.queue.splice(qe, 1);

	  return 1;

	}


        if (mv[0] === "play_diplomacy_card") {

	  this.game.queue.splice(qe, 1);

	  let faction = mv[1];
	  let player = this.returnPlayerOfFaction(faction);

	  if (this.game.player == player) {
	    this.playerPlayDiplomacyCard(faction);
	  } else {
	    if (faction == "papacy") {
  	      this.updateStatusAndListCards("Papacy playing their Diplomacy Card", this.game.deck[1].hand, () => {});
	    } else {
  	      this.updateStatusAndListCards("Protestants playing their Diplomacy Card", this.game.deck[1].hand, () => {});
	    }
	  }

	  return 0;

	}


	if (mv[0] === "faction_assigns_hits_first_field_battle") {

	  this.game.queue.splice(qe, 1);

	  if (mv[1] === "attacker") {
	    this.game.state.field_battle.attacker_hits_first = 1;
	    let reversed = false;
	    for (let z = this.game.queue.length-1; reversed == false && z >= 1; z--) {
	      let mt = this.game.queue[z].split("\t");
	      let mb = this.game.queue[z-1].split("\t");
	      if (mt[0] === "field_battle_assign_hits" && mb[0] === "field_battle_assign_hits") {
		this.game.queue.splice(z, 0, `field_battle_remove_hits\t${this.game.state.field_battle.attacker_hits}`);
		reversed = true;
	      }
	    }
	  }

	  if (mv[1] === "defender") {

	    this.game.state.field_battle.defender_hits_first = 1;
	    let reversed = false;

	    for (let z = this.game.queue.length-1; reversed == false && z >= 1; z--) {

	      let mt = this.game.queue[z].split("\t");
	      let mb = this.game.queue[z-1].split("\t");

	      if (mt[0] === "field_battle_assign_hits" && mb[0] === "field_battle_assign_hits") {

		let x = this.game.queue[z];
		let y = this.game.queue[z-1];
		this.game.queue[z] = y;
		this.game.queue[z-1] = x;
		this.game.queue.splice(z, 0, `field_battle_remove_hits\t${this.game.state.field_battle.defender_hits}`);
	        reversed = true;

	      }
	    }
	  }

	  return 1;
	}
	if (mv[0] === "faction_assigns_hits_first_naval_battle") {

	  this.game.queue.splice(qe, 1);

	  if (mv[1] === "attacker") {
	    this.game.state.naval_battle.attacker_hits_first = 1;
	  }

	  if (mv[1] === "defender") {

	    let reversed = false;
	    this.game.state.naval_battle.defender_hits_first = 1;

	    for (let z = this.game.queue.length-1; reversed == false && z >= 1; z--) {

	      let mt = this.game.queue[z].split("\t");
	      let mb = this.game.queue[z-1].split("\t");

	      if (mt[0] === "naval_battle_assign_hits" && mb[0] === "naval_battle_assign_hits") {
		let x = this.game.queue[z];
		let y = this.game.queue[z-1];
		this.game.queue[z] = y;
		this.game.queue[z-1] = x;
	        reversed = true;
	      }
	    }
	  }

	  return 1;
	}


	// swiss mercenaries and landsnechts
	if (mv[0] === "add_units_before_field_battle") {

	  let his_self = this;
	  let faction = mv[1];
	  let unittype = mv[2];
	  let num = parseInt(mv[3]);
	  let spacekey = "";
	  if (mv[4]) { spacekey = mv[4]; }

	  if (spacekey != "") {

	    for (let i = 0; i < num; i++) {
	      let u = this.newUnit(faction, unittype);
	      if (this.game.spaces[spacekey]) {
	        if (this.game.spaces[spacekey].units[faction]) {
	  	  this.game.spaces[spacekey].units[faction].push(u);

		  if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(his_self.game.state.field_battle.attacker_faction)) {
          	    his_self.game.state.field_battle.attacker_units.push(unittype);
          	    his_self.game.state.field_battle.attacker_units_faction.push(faction);
          	    his_self.game.state.field_battle.attacker_rolls++;
          	    his_self.game.state.field_battle.attacker_modified_rolls++;
		    let r = his_self.rollDice(6);
          	    his_self.game.state.field_battle.attacker_results.push(r);
		    if (r > 4) { his_self.game.state.field_battle.attacker_hits++; }
		  }
		  if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(his_self.game.state.field_battle.defender_faction)) {
          	    his_self.game.state.field_battle.defender_units.push(unittype);
          	    his_self.game.state.field_battle.defender_units_faction.push(faction);
          	    his_self.game.state.field_battle.defender_rolls++;
          	    his_self.game.state.field_battle.defender_modified_rolls++;
		    let r = his_self.rollDice(6);
          	    his_self.game.state.field_battle.defender_results.push(r);
		    if (r > 4) { his_self.game.state.field_battle.defender_hits++; }
		  }

	        }
	      }
	    }

	    his_self.field_battle_overlay.renderPreFieldBattle(his_self.game.state.field_battle);

	    this.game.queue.splice(qe, 1);
	    return 1;
	  }

	  if (his_self.game.player === his_self.returnPlayerCommandingFaction(faction)) {
            his_self.playerPlaceUnitsInSpaceWithFilter(unittype, num, faction,
              function(space) {
                if (his_self.isSpaceUnderSiege(space.key)) { return 0; }
                if (!his_self.isSpaceFriendly(space.key, faction)) { return 0; }
                if (his_self.returnFriendlyLandUnitsInSpace(faction, space.key)) { return 1; }
                return 0;
              },
              function(spacekey) {
		if (his_self.game.state.field_battle.spacekey == spacekey) {
		  his_self.addMove("add_field_battle_bonus_rolls\t"+faction+"\t"+1+"\t"+unittype);
		}
	      } ,
              null ,
              true
            );
	  } else {
	    his_self.updateStatus(his_self.returnFactionName(faction) + " placing units...");
	  }

	  this.game.queue.splice(qe, 1);

	  return 0;

	}

	if (mv[0] === "add_field_battle_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.game.state.field_battle.faction_map[faction] === his_self.game.state.field_battle.defender_faction) { is_attacker = false; }

          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.field_battle.attacker_hits++; }
              if (his_self.game.state.field_battle.tercios == 1) { if (x == 4) { his_self.game.state.field_battle.attacker_hits++; } }
              his_self.game.state.field_battle.attacker_results.push(x);
	      // TODO - remove if safe
              //his_self.game.state.field_battle.attacker_modified_rolls.push(x);
              his_self.game.state.field_battle.attacker_units.push(comment);
              his_self.game.state.field_battle.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.field_battle.defender_hits++; }
              if (his_self.game.state.field_battle.tercios == 1) { if (x == 4) { his_self.game.state.field_battle.defender_hits++; } }
              his_self.game.state.field_battle.defender_results.push(x);
	      // TODO - remove if safe
              //his_self.game.state.field_battle.defender_modified_rolls.push(x);
              his_self.game.state.field_battle.defender_units.push(comment);
              his_self.game.state.field_battle.defender_units_faction.push(faction);
            }
	  }

          his_self.field_battle_overlay.render(his_self.game.state.field_battle, 1);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



	if (mv[0] === "add_assault_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.game.state.assault.faction_map[faction] == his_self.game.state.assault.defender_faction) { is_attacker = false; }
	  if (his_self.game.state.assault.faction_map[faction] != his_self.game.state.assault.attacker_faction) { is_attacker = false; }


          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.assault.attacker_hits++; }
              if (his_self.game.state.assault.siege_artillery == 1) { if (x >= 3 && x < 5) { his_self.game.state.assault.attacker_hits++; } }
              his_self.game.state.assault.attacker_results.push(x);
              //his_self.game.state.assault.attacker_modified_rolls.push(x);
              his_self.game.state.assault.attacker_units_units.push(comment);
              his_self.game.state.assault.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.assault.defender_hits++; }
              if (his_self.game.state.assault.siege_artillery == 1) { if (x >= 3 && x < 5) { his_self.game.state.assault.attacker_hits++; } }
              his_self.game.state.assault.defender_results.push(x);
              //his_self.game.state.assault.defender_modified_rolls.push(x);
              his_self.game.state.assault.defender_units_units.push(comment);
              his_self.game.state.assault.defender_units_faction.push(faction);
            }
	  }

          his_self.assault_overlay.render(his_self.game.state.assault);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}


	if (mv[0] === "add_naval_battle_bonus_rolls") {

	  let his_self = this;
	  let faction = mv[1];
	  let bonus = parseInt(mv[2]);
	  let comment = "bonus";
 	  if (mv[3]) { comment = mv[3]; }

	  let is_attacker = true;
	  if (his_self.areAllies(faction, his_self.game.state.naval_battle.defender_faction)) { is_attacker = false; }

          //
          // add five bonus rolls
          //
	  if (is_attacker) {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.naval_battle.attacker_hits++; }
              his_self.game.state.naval_battle.attacker_results.push(x);
              //his_self.game.state.naval_battle.attacker_modified_rolls.push(x);
              his_self.game.state.naval_battle.attacker_units.push(comment);
              his_self.game.state.naval_battle.attacker_units_faction.push(faction);
            }
          } else {
            for (let i = 0; i < bonus; i++) {
              let x = his_self.rollDice(6);
              if (x >= 5) { his_self.game.state.naval_battle.defender_hits++; }
              his_self.game.state.naval_battle.defender_results.push(x);
              //his_self.game.state.naval_battle.defender_modified_rolls.push(x);
              his_self.game.state.naval_battle.defender_units.push(comment);
              his_self.game.state.naval_battle.defender_units_faction.push(faction);
            }
	  }

          his_self.naval_battle_overlay.render(his_self.game.state.naval_battle);

	  this.game.queue.splice(qe, 1);
	  return 1;

	}



	if (mv[0] === "hand_to_fhand") {

	  this.game.queue.splice(qe, 1);

	  let deckidx = parseInt(mv[1])-1;
	  let player = parseInt(mv[2]);
	  let faction = mv[3];
	  let show_overlay = false;
	  if (mv[4]) { show_overlay = true; }
	  let fhand_idx = this.returnFactionHandIdx(player, faction);
	  let cards = [];

	  if (this.game.player == player) {
	    if (!this.game.deck[deckidx].fhand) { this.game.deck[deckidx].fhand = []; }
	    while (this.game.deck[deckidx].fhand.length < (fhand_idx+1)) { this.game.deck[deckidx].fhand.push([]); }

	    for (let i = 0; i < this.game.deck[deckidx].hand.length; i++) {
	      this.game.deck[deckidx].fhand[fhand_idx].push(this.game.deck[deckidx].hand[i]);
	      cards.push(this.game.deck[deckidx].hand[i]);
	    }

	    // and clear the hand we have dealt
	    this.game.deck[deckidx].hand = [];

	    if (show_overlay) {
	      this.deck_overlay.render('hand', cards);
	    }

	  }

	  //
	  // we only need to check manually if we have pulled a card in the 
	  // action phase, in which case state.impulse will have been 
	  // incremented above 0
	  //
	  if (this.game.state.impulse > 0 && faction != "") {
	    this.game.queue.push("check_intervention\t"+faction);
	  }

	  return 1;

	}

	if (mv[0] === "remove_translation_bonus") {
	  this.game.queue.splice(qe, 1);
	  this.game.state.tmp_protestant_translation_bonus = 0;
	  this.game.state.english_bible_translation_bonus = 0;
	  this.game.state.french_bible_translation_bonus = 0;
	  this.game.state.german_bible_translation_bonus = 0;
	  this.game.state.tmp_protestant_translation_bonus = 0;
	  return 1;
	}









        if (mv[0] == "protestant_reformation") {

          let his_self = this;

          his_self.updateStatus("Protestant Reformation...");

          let player = parseInt(mv[1]);
          if (his_self.returnPlayerOfFaction(mv[1])) { player = his_self.returnPlayerOfFaction(mv[1]); }
          let language_zone = "german";
          if (mv[2]) { language_zone = mv[2]; }
          let spillover = 0;
          if (mv[3]) { spillover = parseInt(mv[3]); } // allow reformation outside target area

          his_self.game.queue.splice(qe, 1);

          let target_spaces = his_self.countSpacesWithFilter(
            function(space) {
              if (
                space.religion == "catholic" &&
                !his_self.game.state.tmp_reformations_this_turn.includes(space.key) &&
                ((spillover == 1 || space.language == language_zone) || language_zone == "all") &&
                (
                        his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
                        ||
                        his_self.isSpaceAdjacentToReligion(space, "protestant")
                        ||
                        his_self.doesSpaceContainProtestantReformer(space)
                        ||
                        his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
                )
              ) {
                return 1;
              }
              return 0;
            }
          );

          if (target_spaces == 0) {
            his_self.updateStatus("No valid reformation targets");
            his_self.updateLog("No valid reformation targets");
            return 1;
          }

          if (his_self.game.player == player) {
            if (target_spaces > 0) {

              if (language_zone != "all" && language_zone != "") {
                his_self.theses_overlay.render(language_zone);
              } else {
                his_self.theses_overlay.render();
              }

              his_self.playerSelectSpaceWithFilter(

                "Select Reformation Target",

                //
                // catholic spaces adjacent to protestant
                //
                function(space) {
                  if (
                    space.religion === "catholic" &&
                    !his_self.game.state.tmp_reformations_this_turn.includes(space.key) &&
                    ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
                    (
                        his_self.isSpaceAdjacentToProtestantReformer(space, "protestant")
                        ||
                        his_self.isSpaceAdjacentToReligion(space, "protestant")
                        ||
                        his_self.doesSpaceContainProtestantReformer(space)
                        ||
                        his_self.isSpaceAPortInTheSameSeaZoneAsAProtestantPort(space)
                    )
                  ) {
                    return 1;
                  }
                  return 0;
                },

                //
                // launch reformation
                //
                function(spacekey) {
                  his_self.addMove("reformation\t"+spacekey+"\t"+language_zone);
                  his_self.addMove("counter_or_acknowledge\tProtestant Reformation Attempt in "+his_self.returnSpaceName(spacekey)+"\tprotestant_reformation\t"+spacekey);
                  his_self.addMove("RESETCONFIRMSNEEDED\tall");
                  his_self.updateStatus("Reformation attempt in "+his_self.returnSpaceName(spacekey));
                  his_self.endTurn();
                },
                null ,
                1     // permit board clicks
              );
            } else {
              his_self.addMove("counter_or_acknowledge\tProtestant Reformation - no valid targets");
              his_self.addMove("RESETCONFIRMSNEEDED\tall");
              his_self.updateStatus("No Valid Targets");
              his_self.endTurn();
            }
          } else {
            his_self.updateStatus("Protestant Reformation...");
          }
          return 0;
        }



        if (mv[0] == "catholic_counter_reformation") {

          let his_self = this;

          his_self.updateStatus("Catholic Counter-Reformation...");

          let player = parseInt(mv[1]);
          if (his_self.returnPlayerOfFaction(mv[1])) { player = his_self.returnPlayerOfFaction(mv[1]); }
          let language_zone = "german";
          if (mv[2]) { language_zone = mv[2]; }
          let spillover = 0;
          if (mv[3]) { spillover = parseInt(mv[3]); } // allow reformation outside target area

          his_self.game.queue.splice(qe, 1);

          let target_spaces = his_self.countSpacesWithFilter(
            function(space) {
              if (
                space.religion === "protestant" &&
                ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
                !his_self.game.state.tmp_counter_reformations_this_turn.includes(space.key) &&
                (
                  his_self.isSpaceAdjacentToReligion(space, "catholic")
                  ||
                  space.university == 1
                )
              ) {
                return 1;
              }
              return 0;
            }
          );

          //
          // no valid reformation targets
          //
          if (target_spaces == 0) {
            his_self.updateStatus("No valid counter-reformation targets");
            his_self.updateLog("No valid counter-reformation targets");
            his_self.game.queue.splice(qe, 1);
            return 1;
          }


          if (his_self.game.player == player) {
            if (target_spaces > 0) {

            if (language_zone != "all" && language_zone != "") {
              his_self.theses_overlay.render(language_zone);
            } else {
              his_self.theses_overlay.render();
            }

            his_self.playerSelectSpaceWithFilter(

              "Select Counter-Reformation Attempt",

              //
              // protestant spaces adjacent to catholic
              //
              function(space) {
                if (
                  space.religion === "protestant" &&
                  ((spillover == 1 || space.language === language_zone) || language_zone == "all") &&
                  !his_self.game.state.tmp_counter_reformations_this_turn.includes(space.key) &&
                  his_self.isSpaceAdjacentToReligion(space, "catholic")
                ) {
                  return 1;
                }
                return 0;
              },

              //
              // launch counter_reformation
              //
              function(spacekey) {
                his_self.updateStatus("Counter-Reformation attempt: "+his_self.returnSpaceName(spacekey));
                his_self.addMove("counter_reformation\t"+spacekey+"\t"+language_zone);
                let name = his_self.game.spaces[spacekey].name;
                his_self.addMove("counter_or_acknowledge\tCounter-Reformation Attempt: "+his_self.returnSpaceName(spacekey)+"\tcatholic_counter_reformation\t"+name);
                his_self.addMove("RESETCONFIRMSNEEDED\tall");
                his_self.endTurn();
              },

              null, // cancel func

              1     // permit board clicks

            );
            } else {
              his_self.addMove("counter_or_acknowledge\tCatholic Counter-Reformation - no valid targets");
              his_self.addMove("RESETCONFIRMSNEEDED\tall");
              his_self.endTurn();
            }
          } else {
            his_self.updateStatus("Catholic Counter-Reformation in Process");
          }


          return 0;

        }






	if (mv[0] === "reformation") {

	  //
	  // hide triangular help if game start
	  //
	  if (this.game.player == this.returnPlayerCommandingFaction("protestant")) {
	    this.game_help.hide();
	  }

	  this.game.queue.splice(qe, 1);


	  let space = mv[1];
	  let target_language_zone = mv[2] || "german";
	  this.game.state.tmp_reformations_this_turn.push(space);

	  let p_rolls = 0;
	  let c_rolls = 0;

	  let p_neighbours = 0;
	  let c_neighbours = 0;

	  let p_bonus = 0;
	  let c_bonus = 0;

	  let p_high = 0;
	  let c_high = 0;

	  let p_roll_desc = [];
	  let c_roll_desc = [];

	  let protestants_win = 0;
	  let catholics_win = 1;

	  let ties_resolve = "protestant";

	  //
	  // neighbours
	  //
	  for (let i = 0; i < this.game.spaces[space].neighbours.length; i++) {

	    if (!this.game.spaces[space].pass.includes(this.game.spaces[space].neighbours[i]) && !this.game.spaces[this.game.spaces[space].neighbours[i]].unrest) {
	      if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "catholic") {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
	        c_neighbours++;
	      }
	      if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "protestant") {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
	        p_neighbours++;
	      }
	      if (this.hasProtestantLandUnits(this.game.spaces[space].neighbours[i])) {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
	        p_rolls++;
	      }
	      if (this.hasCatholicLandUnits(this.game.spaces[space].neighbours[i])) {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
	        c_rolls++;
	      }
	      if (this.hasProtestantReformer(this.game.spaces[space].neighbours[i])) {
	        p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "reformer"});
	        p_rolls++;
	      }
	      if (this.game.spaces[this.game.spaces[space].neighbours[i]].university) {
	        c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "jesuit university"});
	        c_rolls++;
	      }
	    }
	  }

	  //
	  // ourselves
	  //
	  if (this.hasProtestantLandUnits(space)) {
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    p_rolls++;
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    p_rolls++;
	  }
	  if (this.hasCatholicLandUnits(space)) {
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    c_rolls++;
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
	    c_rolls++;
	  }
	  if (this.hasProtestantReformer(space)) {
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
	    p_rolls++;
	    p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
	    p_rolls++;
	  }
	  if (this.game.spaces[space].university) {
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
	    c_rolls++;
	    c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
	    c_rolls++;
	  }

	  //
	  // language zone
	  //
	  if (this.game.spaces[space].language !== target_language_zone && target_language_zone != "all") {
	    ties_resolve = "catholic";
 	  }

	  //
	  // everyone gets a minimum of one roll
	  //
	  if (p_rolls == 0 && p_neighbours == 0) {
	    p_roll_desc.push({ name : "basic roll" , desc : "no adjacency or influence"});
	    p_rolls++;
	  }
	  if (c_rolls == 0 && c_neighbours == 0) {
	    c_roll_desc.push({ name : "basic roll" , desc : "no adjacency or influence"});
	    c_rolls++;
	  }

	  //
	  // temporary bonuses
	  //
	  if (this.game.state.printing_press_active) {
	    p_rolls++;
	    p_roll_desc.push({ name : "Bonus" , desc : "printing press"});
	  }
	  if (this.game.state.tmp_protestant_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_protestant_reformation_bonus_spaces.includes(space)) {
	      p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
	      this.game.state.tmp_protestant_reformation_bonus--;
	      if (this.game.state.tmp_protestant_reformation_bonus < 0) { this.game.state.tmp_protestant_reformation_bonus = 0; }
	    }
	  }
	  if (this.game.state.tmp_catholic_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_catholic_reformation_bonus_spaces.includes(space)) {
	      c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
	      this.game.state.tmp_catholic_reformation_bonus--;
	      if (this.game.state.tmp_catholic_reformation_bonus < 0) { this.game.state.tmp_catholic_reformation_bonus = 0; }
	    }
	  }

	  for (let i = 0; i < this.game.state.tmp_protestant_reformation_bonus; i++) {
	    p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
	  }
	  for (let i = 0; i < this.game.state.tmp_catholic_reformation_bonus; i++) {
	    c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
	  }
	  p_bonus += this.game.state.tmp_protestant_reformation_bonus;
	  c_bonus += this.game.state.tmp_catholic_reformation_bonus;


	  //
	  // calculate total rolls
	  //
	  p_rolls += p_neighbours;
	  p_rolls += p_bonus;
	  c_rolls += c_neighbours;
	  c_rolls += c_bonus;

          //
          // everyone rolls at least 1 dice
          //
          if (c_rolls == 0) {
	    c_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    c_rolls = 1;
	  }
          if (p_rolls == 0) {
	    p_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    p_rolls = 1;
	  }

	  let pdice = [];
	  let cdice = [];

	  for (let i = 0; i < p_rolls; i++) {
	    let x = this.rollDice(6);
	    if (this.game.state.events.calvins_institutes == 1 && this.game.spaces[space].language === "french") {
	      if (i == 0) { this.updateLog("Calvin's Institutes modifies Protestant rolls by +1"); }
	      x++;
	    }
	    if (this.game.state.english_bible_translation_bonus == 1 || this.game.state.french_bible_translation_bonus == 1 || this.game.state.german_bible_translation_bonus == 1) { x++; }
	    if (x > p_high) { p_high = x; }
	    pdice.push(x);
	  }

	  for (let i = 0; i < c_rolls; i++) {
	    let x = this.rollDice(6);
	    if (x > c_high) { c_high = x; }
	    cdice.push(x);
	  }

	  //
	  // do protestants win?
	  //
	  if (p_high > c_high) { protestants_win = 1; catholics_win = 0; }
	  if (p_high == c_high && ties_resolve === "protestant") { protestants_win = 1; catholics_win = 0; }

	  //
	  //
	  //
	  let obj = {};
	  obj.key = mv[1];
          obj.name = this.spaces[space].name;
	  obj.pdice = pdice;
	  obj.cdice = cdice;
	  obj.p_roll_desc = p_roll_desc;
	  obj.c_roll_desc = c_roll_desc;
	  obj.p_high = p_high;
	  obj.c_high = c_high;
	  obj.ties_resolve = ties_resolve;
	  obj.reformation = true;
	  obj.counter_reformation = false;
          obj.protestants_win = protestants_win;
          obj.catholics_win = catholics_win;
	  this.reformation_overlay.render(obj);

	  //
	  // handle victory
	  //
	  if (protestants_win == 1) {
	    this.game.queue.push("convert\t"+space+"\tprotestant");
	  } else {
	    if (parseInt(this.game.state.events.carlstadt_debater) == 1) {
	      // unrest
	      this.game.queue.push("unrest\t"+space);
	    }
	    this.updateLog(this.returnSpaceName(space) + " remains Catholic");
	  }

	  return 1;

	}


	if (mv[0] === "counter_reformation") {

	  this.game.queue.splice(qe, 1);

	  let space = mv[1];
	  let target_language_zone = mv[2] || "german";
	  this.game.state.tmp_counter_reformations_this_turn.push(space);

	  let p_rolls = 0;
	  let c_rolls = 0;

	  let p_neighbours = 0;
	  let c_neighbours = 0;

	  let p_bonus = 0;
	  let c_bonus = 0;

	  let p_high = 0;
	  let c_high = 0;

	  let p_roll_desc = [];
	  let c_roll_desc = [];

	  let catholics_win = 0;
	  let protestants_win = 1;

	  let ties_resolve = "protestant";

	  //
	  // language zone
	  //
	  //if (this.game.spaces[space].language === target_language_zone) {
	  //
	  // catholics win ties if Paul III or Julius III are Pope
	  //
	  if (this.game.state.leaders.paul_iii == 1 || this.game.state.leaders.julius_iii == 1) {
	    ties_resolve = "catholic";
	  }
 	  //}

          //
          // neighbours
          //
          for (let i = 0; i < this.game.spaces[space].neighbours.length; i++) {
	    if (!this.game.spaces[space].pass.includes(this.game.spaces[space].neighbours[i]) && !this.game.spaces[this.game.spaces[space].neighbours[i]].unrest) {
            if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "catholic") {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
              c_neighbours++;
            }
            if (this.game.spaces[ this.game.spaces[space].neighbours[i] ].religion === "protestant") {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "adjacency"});
              p_neighbours++;
            }
            if (this.hasProtestantLandUnits(this.game.spaces[space].neighbours[i])) {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
              p_rolls++;
            }
            if (this.hasCatholicLandUnits(this.game.spaces[space].neighbours[i])) {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "land units"});
              c_rolls++;
            }
            if (this.hasProtestantReformer(this.game.spaces[space].neighbours[i])) {
              p_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "reformer"});
              p_rolls++;
            }
            if (this.game.spaces[this.game.spaces[space].neighbours[i]].university) {
              c_roll_desc.push({ name : this.game.spaces[this.game.spaces[space].neighbours[i]].name , desc : "jesuit university"});
              c_rolls++;
            }
            }
          }

          //
          // ourselves
          //
          if (this.hasProtestantLandUnits(space)) {
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            p_rolls++;
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            p_rolls++;
          }
          if (this.hasCatholicLandUnits(space)) {
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            c_rolls++;
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "land units"});
            c_rolls++;
          }
          if (this.hasProtestantReformer(space)) {
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
            p_rolls++;
            p_roll_desc.push({ name : this.game.spaces[space].name , desc : "reformer"});
            p_rolls++;
          }
          if (this.game.spaces[space].university) {
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
            c_rolls++;
            c_roll_desc.push({ name : this.game.spaces[space].name , desc : "jesuit university"});
            c_rolls++;
          }

	  //
	  // temporary bonuses
	  //
	  if (this.game.state.tmp_protestant_counter_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_protestant_counter_reformation_bonus_spaces.includes(space)) {
	      this.game.state.tmp_protestant_counter_reformation_bonus--;
	      if (this.game.state.tmp_protestant_counter_reformation_bonus < 0) { this.game.state.tmp_protestant_counter_reformation_bonus = 0; }
	    }
	  }
	  if (this.game.state.tmp_catholic_counter_reformation_bonus_spaces.length > 0) {
	    if (!this.game.state.tmp_catholic_counter_reformation_bonus_spaces.includes(space)) {
	      this.game.state.tmp_catholic_counter_reformation_bonus--;
	      if (this.game.state.tmp_catholic_counter_reformation_bonus < 0) { this.game.state.tmp_catholic_counter_reformation_bonus = 0; }
	    }
	  }

          for (let i = 0; i < this.game.state.tmp_protestant_counter_reformation_bonus; i++) {
            p_roll_desc.push({ name : "Bonus" , desc : "protestant bonus roll"});
          }
          for (let i = 0; i < this.game.state.tmp_catholic_counter_reformation_bonus; i++) {
            c_roll_desc.push({ name : "Bonus" , desc : "catholic bonus roll"});
          }
          p_bonus += this.game.state.tmp_protestant_counter_reformation_bonus;
          c_bonus += this.game.state.tmp_catholic_counter_reformation_bonus;

	  //
	  // calculate total rolls
	  //
	  p_rolls += p_neighbours;
	  p_rolls += p_bonus;
	  c_rolls += c_neighbours;
	  c_rolls += c_bonus;

	  //
	  // everyone rolls at least 1 dice
	  //
          if (c_rolls == 0) {
	    c_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    c_rolls = 1;
	  }
          if (p_rolls == 0) {
	    p_roll_desc.push({ name : "Default Roll" , desc : "base minimum"});
	    p_rolls = 1;
	  }

	  let pdice = [];
	  let cdice = [];

	  for (let i = 0; i < p_rolls; i++) {
	    let x = this.rollDice(6);
	    pdice.push(x);
	    if (x > p_high) { p_high = x; }
	  }

	  for (let i = 0; i < c_rolls; i++) {
	    let x = this.rollDice(6);
	    if (his_self.game.state.events.augsburg_confession == 1) { x--; }
	    cdice.push(x);
	    if (x > c_high) { c_high = x; }
	  }

	  //
	  // do catholics win?
	  //
	  if (p_high < c_high) { catholics_win = 1; protestants_win = 0; }
	  if (p_high == c_high && ties_resolve === "catholic") { catholics_win = 1; protestants_win = 0; }

          //
          // render results
          //
          let obj = {};
          obj.key = mv[1];
          obj.name = this.spaces[space].name;
          obj.pdice = pdice;
          obj.cdice = cdice;
          obj.pdice = pdice;
          obj.cdice = cdice;
          obj.p_roll_desc = p_roll_desc;
          obj.c_roll_desc = c_roll_desc;
          obj.p_high = p_high;
          obj.c_high = c_high;
          obj.ties_resolve = ties_resolve;
	  obj.reformation = false;
	  obj.counter_reformation = true;
          obj.catholics_win = catholics_win;
	  obj.protestants_win = protestants_win;
          this.reformation_overlay.render(obj);

	  //
	  // handle victory
	  //
	  if (catholics_win == 1) {
	    this.game.queue.push("convert\t"+space+"\tcatholic");
	  } else {
	    this.updateLog(this.returnSpaceName(space) + " remains Protestant");
	  }

	  return 1;

	}

	//
	// objects and cards can add commands
	//
        for (let i in z) {
	  //
	  // an action may have removed a card / event
	  //
	  if (z[i]) {
            if (!z[i].handleGameLoop(this, qe, mv)) { return 0; }
	  }
        }


        //
        // avoid infinite loops
        //
        if (shd_continue == 0) {
          console.log("NOT CONTINUING");
          return 0;
        }

    } // if cards in queue

    return 1;

  }



  cancelBackButtonFunction() {
    this.hud.back_button = false;
    this.hud.back_button_callback = null;
  }       
  unbindBackButtonFunction() {
    this.cancelBackButtonFunction();
  } 
  bindBackButtonFunction(mycallback) {
    // we bind before we update UI, so this should remove any outstanding options
    this.removeSelectable();
    this.hud.back_button = true;
    this.hud.back_button_callback = mycallback;
  }   

  returnArrayOfPlayersInFieldBattle() {
    if (this.game.state.field_battle.spacekey) {
      return this.returnArrayOfPlayersInSpacekey(this.game.state.field_battle.spacekey);
    }
    return this.game.players;
  }

  returnArrayOfPlayersInAssault() {
    if (this.game.state.assault.spacekey) {
      return this.returnArrayOfPlayersInSpacekey(this.game.state.assault.spacekey);
    }
    return this.game.players;
  }

  returnUsername(publickey) {
    let f = this.returnFactionOfPublickey(publickey);
    if (f != "") { return this.returnFactionName(f); }
    return this.app.keychain.returnUsername(publickey);
  }

  returnFactionOfPublickey(publickey) {
    for (let i = 0; i < this.game.players.length; i++) {
      if (this.game.players[i] == publickey) {
	if (!this.game.state) { return ""; }
	if (!this.game.state.players_info) { return ""; }
	if (!this.game.state.players_info[i]) { return ""; }
	if (!this.game.state.players_info[i].factions) { return ""; }
 	return this.game.state.players_info[i].factions[0];
      }
    }
    return "";
  }

  returnPublicKeyOfFaction(faction="") {
    let p = this.returnPlayerCommandingFaction(faction);
    if (p <= 0) { return ""; }
    return this.game.players[p-1];
  }


  returnArrayOfPlayersInSpacekey(spacekey="") {
    let res = [];
    let s = this.game.spaces[spacekey];
    if (s) {
      for (let key in s.units) {
        if (s.units[key].length > 0) {
          let p = this.returnPlayerCommandingFaction(key);
          if (p > 0 && !res.includes(this.game.players[p-1])) {
            res.push(this.game.players[p-1]);
          }
        }
      }
    }
    if (res.length > 0) { return res; }
    return this.game.players;
  }

  returnArrayOfPlayersInNavalSpacekey(spacekey="") {
    let res = [];
    let s = this.game.navalspaces[spacekey];
    if (s) {
      for (let key in s.units) {
        if (s.units[key].length > 0) {
          let p = this.returnPlayerCommandingFaction(key);
          if (p > 0 && !res.includes(this.game.players[p-1])) {
            res.push(this.game.players[p-1]);
          }
        }
      }
    }
    if (res.length > 0) { return res; }
    return this.game.players;
  }

  returnPlayers(num = 0) {

    var players = [];
    let factions  = JSON.parse(JSON.stringify(this.factions));
    let factions2 = JSON.parse(JSON.stringify(this.factions));

    // < 6 player games
    if (num == 2) {
      for (let key in factions) {
        if (key !== "protestant" && key !== "papacy") {
          delete factions[key];
        }
      }
    }

    if (num == 3) {
      for (let key in factions) {
	if (key !== "protestant" && key !== "france" && key !== "papacy") {
	  delete factions[key];
	}
      }
    }

    if (num == 4) {
      for (let key in factions) {
	if (key !== "protestant" && key !== "france" && key !== "ottoman" && key !== "papacy") {
	  delete factions[key];
	}
      }
    }


    let f = [];
    if (factions["protestant"]) { f.push("protestant"); }
    if (factions["papacy"]) { f.push("papacy"); }
    if (factions["hapsburg"]) { f.push("hapsburg"); }
    if (factions["ottoman"]) { f.push("ottoman"); }
    if (factions["france"]) { f.push("france"); }
    if (factions["england"]) { f.push("england"); }

    for (let i = 0; i < num; i++) {

      let rf = "";
      
      if (i == 0) {
        if (this.game.options.player1 != undefined) {
          if (this.game.options.player1 != "random") {
            rf = this.game.options.player1;
          }
        }
      }
      if (i == 1) {
        if (this.game.options.player2 != undefined) {
          if (this.game.options.player2 != "random") {
            rf = this.game.options.player2;
          }
        }
      }
      if (i == 2) {
        if (this.game.options.player3 != undefined) {
          if (this.game.options.player3 != "random") {
            rf = this.game.options.player3;
          }
        }
      }
      if (i == 3) {
        if (this.game.options.player4 != undefined) {
          if (this.game.options.player4 != "random") {
            rf = this.game.options.player4;
          }
        }
      }
      if (i == 4) {
        if (this.game.options.player5 != undefined) {
          if (this.game.options.player5 != "random") {
            rf = this.game.options.player5;
          }
        }
      }
      if (i == 5) {
        if (this.game.options.player6 != undefined) {
          if (this.game.options.player6 != "random") {
            rf = this.game.options.player6;
          }
        }
      }

      if (rf === "" || rf === "undefined") {
        let dr = this.rollDice(f.length) - 1;
	rf = f[dr];
      }

      for (let z = 0; z < f.length; z++) {
	if (f[z] === rf) {
	  f.splice(z, 1);
	}
      }

      delete factions[rf];

      players[i] = {};
      players[i].tmp_debaters_committed_reformation = 0;
      players[i].tmp_debaters_committed_translation = 0;
      players[i].tmp_debaters_committed_counter_reformation = 0;
      players[i].tmp_roll_bonus = 0;
      players[i].tmp_roll_first = 0;
      players[i].tmp_roll_modifiers = [];
      players[i].factions = [];
      players[i].factions.push(rf);
      players[i].factions_passed = [];
      players[i].factions_passed.push(false); // faction not passed
      players[i].captured = [];
      players[i].num = i;

      //
      // Each power's VP total is derived from base, special, and bonus VP. 
      // The base VP total is shown in the lower-left of the power card.
      //
      players[i].vp_base = 0;
      players[i].vp_special = 0;
      players[i].vp_bonus = 0;

      players[i].active_faction = players[i].factions[0];
      players[i].active_faction_idx = 0;

    }


    if (num == 3) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "papacy") {
	  players[i].factions.push("hapsburg");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "france") {
	  players[i].factions.push("ottoman");
	  players[i].factions_passed.push(false);
	}
      }
    }

    if (num == 4) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
	if (players[i].factions[0] == "papacy") {
	  players[i].factions.push("hapsburg");
	  players[i].factions_passed.push(false);
	}
      }
    }

    if (num == 5) {
      for (let i = 0; i < players.length; i++) {
	if (players[i].factions[0] == "protestant") {
	  players[i].factions.push("england");
	  players[i].factions_passed.push(false);
	}
      }
    }

    return players;

  }

  //
  // runs each new round
  //
  resetPlayerRound(player_num) {

    this.game.state.tmp_bonus_protestant_translation_german_zone = 0;
    this.game.state.tmp_bonus_protestant_translation_french_zone = 0;
    this.game.state.tmp_bonus_protestant_translation_english_zone = 0;
    this.game.state.tmp_bonus_papacy_burn_books = 0;

    for (let i = 0; i < this.game.state.players_info[player_num-1].factions.length; i++) {
      this.game.state.players_info[player_num-1].factions_passed[i] = false;
    }

  }

  returnPlayerInfoFaction(faction) {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	if (this.game.state.players_info[i].factions[z].key == faction) {
	  return this.game.state.players_info[i].factions[z];
	}
      }
    }

    return null;
  }

  //
  // runs each new turn
  //
  resetPlayerTurn(player_num) {

    this.game.state.tmp_reformations_this_turn = [];
    this.game.state.tmp_counter_reformations_this_turn = [];
    this.game.state.tmp_protestant_reformation_bonus = 0;
    this.game.state.tmp_catholic_reformation_bonus = 0;
    this.game.state.tmp_protestant_counter_reformation_bonus = 0;
    this.game.state.tmp_catholic_counter_reformation_bonus = 0;
    this.game.state.tmp_papacy_may_specify_debater = 0;
    this.game.state.tmp_papacy_may_specify_protestant_debater_unavailable = 0;

    this.deactivateDebaters();

    for (let s in this.game.spaces) {
      if (this.game.spaces[s].besieged == 2) {
	this.game.spaces[s].besieged = 1;
      }
      for (let f in this.game.spaces[s].units) {
	for (let z = 0; z < this.game.spaces[s].units[f].length; z++) {
	  this.game.spaces[s].units[f][z].already_moved = 0;
	}
      }
    }

    let p = this.game.state.players_info[(player_num-1)];
    p.tmp_debaters_committed_reformation = 0;
    p.tmp_debaters_committed_translation = 0;
    p.tmp_debaters_committed_counter_reformation = 0;
    p.tmp_roll_bonus = 0;
    p.tmp_roll_first = 0;
    p.tmp_roll_modifiers = [];

    this.game.state.field_battle = {};

    this.game.state.active_player = player_num;

  }

  isFactionInPlay(faction) {
    for (let i = 0; i < this.game.players.length; i++) {
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	if (this.game.state.players_info[i].factions[z] === faction) { return 1; }
      }
    }
    return 0;
  }

  returnPlayerOfFaction(faction) {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      if (this.game.state.players_info[i].factions.includes(faction)) {
	return i+1;
      }
      for (let z = 0; z < this.game.state.players_info[i].factions.length; z++) {
	let f = this.game.state.players_info[i].factions[z];
        if (this.game.state.activated_powers) {
	  if (this.game.state.activated_powers[f]) {
            if (this.game.state.activated_powers[f].includes(faction)) {
	      return (i+1);
            }
          }
        }
      }
    }
    let z = this.returnPlayerCommandingFaction(faction);
    if (z) { return this.game.state.players_info[z-1]; }
    return 0;
  }


  //
  // 1 hits to destroy everything, opt-in for naval units
  //
  playerAssignHits(faction, spacekey, hits_to_assign, naval_hits_acceptable=0) {

    let his_self = this;
    let space = spacekey;
    try { if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; } } catch (err) {}

    units_to_destroy = [];
    units_available = [];

    for (let f in space.units) {
      if (f == faction || this.isAlliedMinorPower(f, faction)) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].type === "regular")   { units_available.push(space.units[f][i]); }
          if (space.units[f][i].type === "mercenary") { units_available.push(space.units[f][i]); }
          if (space.units[f][i].type === "cavalry")   { units_available.push(space.units[f][i]); }
        }
      }
    } 

    let selectUnitsInterface = function(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface) {

      let msg = "Hits Remaining: " + hits_to_assign;
      let html = "<ul>";
      let targets = 0;

      for (let i = 0; i < space.units[faction].length; i++) {
        if (!units_to_destroy.includes(parseInt(i))) {

	  let is_fodder = true;
          if (space.units[faction][i].land_or_sea === "sea" && naval_hits_acceptable == 0) { is_fodder = false; }
          if (space.units[faction][i].personage == true) { is_fodder = false; }

	  if (is_fodder == true) {
	    targets++;
            html += `<li class="option" id="${i}">${space.units[faction][i].name}</li>`;
          }
	}
      }
      html += "</ul>";

      if (targets <= 0 || hits_to_assign <= 0) {
	his_self.addMove("destroy_units\t"+faction+"\t"+spacekey+"\t"+JSON.stringify(units_to_destroy));
	his_self.endTurn();
	return;
      }

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        $('.option').off();
        let id = $(this).attr("id");

	his_self.updateStatus("assign hit...");

        if (!units_to_destroy.includes(id)) {
          units_to_destroy.push(parseInt(id));
        }

	if (space.units[faction][id].type == "regular") { hits_to_assign -= 1; }
	if (space.units[faction][id].type == "mercenary") { hits_to_assign -= 1; }
	if (space.units[faction][id].type == "squadron") { hits_to_assign -= 1; }
	if (space.units[faction][id].type == "corsair") { hits_to_assign -= 1; }
	if (space.units[faction][id].type == "cavalry") { hits_to_assign -= 1; }

        selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

      });
    }

    selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

    return 0;

  }

  //
  // 2 hits to destroy a squadron, 1 for a corsair
  //
  playerAssignNavalHits(faction, hits_to_assign, spacekey) {

    let his_self = this;
    let space;

    if (this.game.spaces[spacekey]) { space = this.game.spaces[spacekey]; }
    if (this.game.navalspaces[spacekey]) { space = this.game.navalspaces[spacekey]; }

    let units_available = space.units[faction];
    let units_to_destroy = [];

    let selectUnitsInterface = function(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface) {

      let msg = "Hits Remaining: " + hits_to_assign;
      let html = "<ul>";
      let targets = 0;
      let one_hit_targets = false;
      for (let i = 0; i < space.units[faction].length; i++) {
        if (space.units[faction][i].land_or_sea === "sea" || space.units[faction][i].land_or_sea === "both") {
	  if (space.units[faction][i].personage == false) {
            if (!units_to_destroy.includes(parseInt(i))) {
  	      targets++;
	      if (space.units[faction][i].type === "squadron") {
                html += `<li class="option" id="${i}">${space.units[faction][i].name} (2 hits)</li>`;
              } else {
                html += `<li class="option" id="${i}">${space.units[faction][i].name} (1 hit)</li>`;
		one_hit_targets = true;
	      }
            }
            html += "</ul>";
          }
        }
      }

      if (targets <= 0 || hits_to_assign <= 0 || (hits_to_assign == 1 && one_hit_targets == false)) {
	his_self.addMove("destroy_naval_units\t"+faction+"\t"+spacekey+"\t"+JSON.stringify(units_to_destroy));
	his_self.endTurn();
	return;
      }

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

	his_self.updateStatus("assigning hits");

        let id = $(this).attr("id");

        if (!units_to_destroy.includes(id)) {
          units_to_destroy.push(parseInt(id));
        }

        if (space.units[faction][id].type == "squadron") { hits_to_assign -= 2; }
        if (space.units[faction][id].type == "corsair") { hits_to_assign -= 1; }

        selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

      });
    }

    his_self.naval_battle_overlay.assignHits(his_self.game.state.naval_battle, faction);
    selectUnitsInterface(his_self, units_to_destroy, hits_to_assign, selectUnitsInterface);

    return 0;

  }


  playerResolveNavalWinterRetreat(faction, spacekey) {

    let his_self = this;
    let space = null;
    if (his_self.game.spaces[spacekey]) { space = his_self.game.spaces[spacekey]; }
    if (his_self.game.navalspaces[spacekey]) { space = his_self.game.navalspaces[spacekey]; }

    let res = this.returnNearestFactionControlledPorts(faction, spacekey);

    let msg = this.returnFactionName(faction) + " - Select Winter Port for Naval Units in "+space.name;
    let opt = "<ul>";
    for (let i = 0; i < res.length; i++) {
      opt += `<li class="option" id="${res[i].key}">${res[i].key}</li>`;
    }
    opt += "</ul>";

    if (res.length == 0) {
      this.endTurn();
      return 0;
    }

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let id = $(this).attr('id');
      $(".option").off();
      his_self.updateStatus("wintering ships");

      his_self.addMove("retreat_to_winter_ports_resolve\t"+faction+"\t"+spacekey+"\t"+id);
      his_self.endTurn();

    });

  }

  //
  // 2P variant needs automatic determination of where to retreat
  //
  autoResolveWinterRetreat(faction, spacekey) {
    let his_self = this;
    let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(faction, spacekey);
    if (res.length > 0) {
      let space = this.game.spaces[spacekey];
      let roll = this.rollDice(res.length);
      if (res[roll-1].hops > 0) {
        let retreat_destination = res[roll-1].key;
        his_self.game.queue.push("retreat_to_winter_spaces_resolve\t"+faction+"\t"+spacekey+"\t"+retreat_destination);
      }
    }
  }

  playerResolveWinterRetreat(faction, spacekey) {

    let his_self = this;
    let res = this.returnNearestFriendlyFortifiedSpaces(faction, spacekey);
    let space = this.game.spaces[spacekey];

    let msg = this.returnFactionName(faction) + " - Select Winter Location for Units in "+space.name;
    let opt = "<ul>";
    for (let i = 0; i < res.length; i++) {
      opt += `<li class="option" id="${res[i].key}">${res[i].key}</li>`;
    }
    opt += "</ul>";

    if (res.length == 0) {
      this.endTurn();
      return 0;
    }

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let id = $(this).attr('id');
      $(".option").off();

      his_self.updateStatus("handling retreat...");
      his_self.addMove("retreat_to_winter_spaces_resolve\t"+faction+"\t"+spacekey+"\t"+id);
      his_self.endTurn();

    });

  }

  playerRetainUnitsWithFilter(faction, filter_func, num_to_retain) {

    let his_self = this;
    let units_available = [];
    let units_to_retain = [];

    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units[faction]) {
	for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
	  if (filter_func(key, i)) {
	    units_available.push({spacekey : key, idx : i});
	  }
	}
      }
    }

    let selectUnitsInterface = function(his_self, units_to_retain, units_available, selectUnitsInterface) {

      let msg = "Select Units to Retain: ";
      let html = "<ul>";
      for (let i = 0; i < units_available.length; i++) {
	let spacekey = units_available[i].spacekey;
	let unit = his_self.game.spaces[spacekey].units[faction][units_available[i].idx];
        if (units_to_retain.includes(parseInt(i))) {
          html += `<li class="option" style="font-weight:bold" id="${i}">* ${unit.type} - ${units_available[i].spacekey} *</li>`;
        } else {
          html += `<li class="option" id="${i}">${unit.type} - ${units_available[i].spacekey}</li>`;
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");

        if (id === "end") {

	  //
	  // moves prepended to last removed first
	  //
	  for (let i = units_available.length-1; i >= 0; i--) {
	    if (!units_to_retain.includes(i)) {
	      his_self.prependMove("destroy_unit_by_index\t"+faction+"\t"+units_available[i].spacekey+"\t"+units_available[i].idx);
	    }
	  }
	  his_self.endTurn();
	  return;

	}

	id = parseInt(id);

	//
	// add unit to units available
	//
        if (units_to_retain.includes(id)) {
          let idx = units_to_retain.indexOf(id);
          if (idx > -1) {
            units_to_retain.splice(idx, 1);
          }
        } else {
	  units_to_retain.push(id);
	}

	//
	// if this is max to retain, we end as well
	//
	if (units_to_retain.length === num_to_retain) {

	  his_self.updateStatus("submitting...");

	  //
	  // moves prepended to last removed first
	  //
	  for (let i = units_available.length-1; i >= 0; i--) {
	    if (!units_to_retain.includes(i)) {
	      his_self.prependMove("destroy_unit_by_index\t"+faction+"\t"+units_available[i].spacekey+"\t"+units_available[i].idx);
	    }
	  }
	  his_self.endTurn();
	  return;
	}

        selectUnitsInterface(his_self, units_to_retain, units_available, selectUnitsInterface);

      });
    }

    selectUnitsInterface(his_self, units_to_retain, units_available, selectUnitsInterface);

    return 0;

  }

  returnPlayerFactions(player) {
    return this.game.state.players_info[player-1].factions;
  }

  returnActionMenuOptions(player=null, faction=null, limit="") {

    let menu = [];

if (faction === "france" && this.game.state.events.scots_raid == 1) {
    menu.push({
      factions : ['scotland'],
      cost : [2],
      name : "Regular",
      check : this.canPlayerBuyRegular,
      fnct : this.playerBuyRegular,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['scotland'],
      cost : [2],
      name : "Squadron",
      check : this.canPlayerBuyNavalSquadron,
      fnct : this.playerBuyNavalSquadron,
      category : "build" ,
      img : '/his/img/backgrounds/move/squadron.jpg',
    });
    menu.push({
      factions : ['france','scotland'],
      cost : [1,1],
      name : "Move",
      check : this.canPlayerMoveFormationInClear,
      fnct : this.playerMoveFormationInClear,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_in_clear.jpg',
    });
    menu.push({
      factions : ['france','scotland'],
      cost : [1,1],
      name : "Control",
      check : this.canPlayerControlUnfortifiedSpace,
      fnct : this.playerControlUnfortifiedSpace,
      category : "attack" ,
      img : '/his/img/backgrounds/move/control.jpg',
    });
    menu.push({
      factions : ['france', 'scotland'],
      cost : [0,0],
      name : "Assault",
      check : this.canPlayerAssaultTutorial,
      fnct : this.playerAssaultTutorial,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
    menu.push({
      factions : ['france', 'scotland'],
      cost : [1,1],
      name : "Assault",
      check : this.canPlayerAssault,
      fnct : this.playerAssault,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
} else {
if (limit === "build") {
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenaryOverLimit,
      fnct : this.playerBuyMercenaryOverLimit,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenary,
      fnct : this.playerBuyMercenary,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2,2,2],
      name : "Regular",
      check : this.canPlayerBuyRegularOverLimit,
      fnct : this.playerBuyRegularOverLimit,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2,2,2],
      name : "Regular",
      check : this.canPlayerBuyRegular,
      fnct : this.playerBuyRegular,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Squadron",
      check : this.canPlayerBuyNavalSquadron,
      fnct : this.playerBuyNavalSquadron,
      category : "build" ,
      img : '/his/img/backgrounds/move/squadron.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Cavalry",
      check : this.canPlayerBuyCavalry,
      fnct : this.playerBuyCavalry,
      category : "build" ,
      img : '/his/img/backgrounds/move/cavalry.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Corsair",
      check : this.canPlayerBuyCorsair,
      fnct : this.playerBuyCorsair,
      category : "build" ,
      img : '/his/img/backgrounds/move/corsair.jpg',
    });

} else {

    //
    // only burning books and theological debates
    //
    if (limit === "mary_i") {
      menu.push({
        factions : ['papacy','protestant'],
        cost : [3,3],
        name : "Convene Debate",
        check : this.canPlayerCallTheologicalDebateMaryI,
        fnct : this.playerCallTheologicalDebateMaryI,
        category : "special" ,
        img : '/his/img/backgrounds/move/theological_debate.jpg',
      });
      menu.push({
        factions : ['papacy'],
        cost : [2],
        name : "Burn Books",
        check : this.canPlayerBurnBooksMaryI,
        fnct : this.playerBurnBooksMaryI,
        category : "special" ,
        img : '/his/img/backgrounds/move/burn_books.jpg',
      });
    } else {

    menu.push({
      factions : ['hapsburg','england','france','papacy','ottoman','protestant'],
      cost : [0,0,0,0,0,0],
      name : "First Game / Need Help?",
      check : this.canPlayerShowTutorial,
      fnct : this.playerShowTutorial,
      category : "move" ,
      img : '/his/img/backgrounds/move/help.jpeg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Move",
      check : this.canPlayerMoveFormationInClear,
      fnct : this.playerMoveFormationInClear,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_in_clear.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Move Across Sea",
      check : this.canPlayerNavalTransport,
      fnct : this.playerNavalTransport,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_transport.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1],
      name : "Move Ships",
      check : this.canPlayerNavalMove,
      fnct : this.playerNavalMove,
      category : "move" ,
      img : '/his/img/backgrounds/move/move_fleet.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenaryOverLimit,
      fnct : this.playerBuyMercenaryOverLimit,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Regular",
      check : this.canPlayerBuyRegularOverLimit,
      fnct : this.playerBuyRegularOverLimit,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2,2,2],
      name : "Regular",
      check : this.canPlayerBuyRegular,
      fnct : this.playerBuyRegular,
      category : "build" ,
      img : '/his/img/backgrounds/move/regular.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france','papacy','protestant'],
      cost : [1,1,1,1,1],
      name : "Mercenary",
      check : this.canPlayerBuyMercenary,
      fnct : this.playerBuyMercenary,
      category : "build" ,
      img : '/his/img/backgrounds/move/mercenary.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Cavalry",
      check : this.canPlayerBuyCavalry,
      fnct : this.playerBuyCavalry,
      category : "build" ,
      img : '/his/img/backgrounds/move/cavalry.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy', 'genoa', 'scotland', 'venice'],
      cost : [2,2,2,2,2,2,2,2],
      name : "Squadron",
      check : this.canPlayerBuyNavalSquadron,
      fnct : this.playerBuyNavalSquadron,
      category : "build" ,
      img : '/his/img/backgrounds/move/squadron.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [1],
      name : "Corsair",
      check : this.canPlayerBuyCorsair,
      fnct : this.playerBuyCorsair,
      category : "build" ,
      img : '/his/img/backgrounds/move/corsair.jpg',
    });
    if (this.game.players.length == 2) {
      menu.push({
        factions : ['papacy','protestant'] ,
        cost : [1,1,1,1,1,1,1,1,1,1],
        name : "Remove Unrest",
        check : this.canPlayerRemoveUnrest,
        fnct : this.playerRemoveUnrest,
        category : "attack" ,
        img : '/his/img/backgrounds/move/control.jpg',
      });
    } else {
      menu.push({
        factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
        cost : [1,1,1,1,1,1,1,1,1,1],
        name : "Remove Unrest",
        check : this.canPlayerRemoveUnrest,
        fnct : this.playerRemoveUnrest,
        category : "attack" ,
        img : '/his/img/backgrounds/move/control.jpg',
      });
    }
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Control",
      check : this.canPlayerControlUnfortifiedSpace,
      fnct : this.playerControlUnfortifiedSpace,
      category : "attack" ,
      img : '/his/img/backgrounds/move/control.jpg',
    });
    menu.push({
      factions : ['ottoman','england'],
      cost : [1,1],
      name : "Foreign War",
      check : this.canPlayerFightForeignWar,
      fnct : this.playerFightForeignWar,
      category : "attack" ,
      img : '/his/img/backgrounds/move/foreign-war2.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [0,0,0,0,0,0,0,0,0,0],
      name : "Assault",
      check : this.canPlayerAssaultTutorial,
      fnct : this.playerAssaultTutorial,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant', 'genoa', 'hungary', 'scotland', 'venice'],
      cost : [1,1,1,1,1,1,1,1,1,1],
      name : "Assault",
      check : this.canPlayerAssault,
      fnct : this.playerAssault,
      category : "attack" ,
      img : '/his/img/backgrounds/move/assault.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [2,2,2],
      name : "Explore",
      check : this.canPlayerExplore,
      fnct : this.playerExplore,
      category : "special" ,
      img : '/his/img/backgrounds/move/explore.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [2,3,3],
      name : "Colonize",
      check : this.canPlayerColonize,
      fnct : this.playerColonize,
      category : "special" ,
      img : '/his/img/backgrounds/move/colonize.jpg',
    });
    menu.push({
      factions : ['hapsburg','england','france'],
      cost : [4,4,4],
      name : "Conquer",
      check : this.canPlayerConquer,
      fnct : this.playerConquer,
      category : "special" ,
      img : '/his/img/backgrounds/move/conquer.jpg',
    });
    menu.push({
      factions : ['ottoman'],
      cost : [2],
      name : "Piracy",
      check : this.canPlayerInitiatePiracyInASea,
      fnct : this.playerInitiatePiracyInASea,
      category : "attack" ,
      img : '/his/img/backgrounds/move/piracy.jpg',
    });
    menu.push({
      factions : ['protestant'],
      cost : [1],
      name : "Translate Scripture",
      check : this.canPlayerTranslateScripture,
      fnct : this.playerTranslateScripture,
      category : "special" ,
      img : '/his/img/backgrounds/move/translate.jpg',
    });
if (this.game.state.events.cranmer_active == 1) {
  if (this.game.state.events.cromwell != 0) {
    menu.push({
      factions : ['england','protestant'],
      cost : [2,2],
      name : "Publish Treatise",
      check : this.canPlayerPublishTreatise,
      fnct : this.playerPublishTreatise,
      category : "special" ,
      img : '/his/img/backgrounds/move/printing_press.jpg',
    });
  } else {
    menu.push({
      factions : ['england','protestant'],
      cost : [3,2],
      name : "Publish Treatise",
      check : this.canPlayerPublishTreatise,
      fnct : this.playerPublishTreatise,
      category : "special" ,
      img : '/his/img/backgrounds/move/printing_press.jpg',
    });
  }
} else {
    menu.push({
      factions : ['protestant'],
      cost : [2],
      name : "Publish Treatise",
      check : this.canPlayerPublishTreatise,
      fnct : this.playerPublishTreatise,
      category : "special" ,
      img : '/his/img/backgrounds/move/printing_press.jpg',
    });
}
    menu.push({
      factions : ['papacy','protestant'],
      cost : [3,3],
      name : "Convene Debate",
      check : this.canPlayerCallTheologicalDebate,
      fnct : this.playerCallTheologicalDebate,
      category : "special" ,
      img : '/his/img/backgrounds/move/theological_debate.jpg',
    });
    menu.push({
      factions : ['papacy'],
      cost : [1],
      name : "Build Saint Peters",
      check : this.canPlayerBuildSaintPeters,
      fnct : this.playerBuildSaintPeters,
      category : "special" ,
      img : '/his/img/backgrounds/move/saint_peters.png',
    });
    menu.push({
      factions : ['papacy'],
      cost : [2],
      name : "Burn Books",
      check : this.canPlayerBurnBooks,
      fnct : this.playerBurnBooks,
      category : "special" ,
      img : '/his/img/backgrounds/move/burn_books.jpg',
    });
if (this.game.state.events.society_of_jesus == 1) {
    // Loyola reduces Jesuit University Cost
    let university_founding_cost = 3;
    if (this.canPlayerCommitDebater("papacy", "loyola-debater") || parseInt(this.game.state.loyola_bonus_active) == 1) {
      university_founding_cost = 2;
    }
    menu.push({
      factions : ['papacy'],
      cost : [university_founding_cost],
      name : "Found University",
      check : this.canPlayerFoundJesuitUniversity,
      fnct : this.playerFoundJesuitUniversity,
      category : "special" ,
      img : '/his/img/backgrounds/move/university.png',
    });
}
    } // mary_i limit check
}
} // scots raid

    //
    // major powers have limited options in 2P version
    //
    if (this.game.players.length == 2 && (faction === "hapsburg" || faction === "england" || faction === "france" || faction == "ottoman")) {
      for (let i = menu.length-1; i >= 0; i--) {
	if (menu[i].category == "build") {
	  if (faction != this.game.state.events.foreign_recruits && this.game.player_last_card != "076") { menu.splice(i, 1); }
	} else {
	    if (menu[i].category == "special") { menu.splice(i, 1); } else {
  	    if (menu[i].name === "Move across Sea") { menu.splice(i, 1); }
          }
        }
      }
    } 

    if (player == null) { return menu; }

    let fmenu = [];

    for (let i = 0; i < menu.length; i++) {
      if (menu[i].factions.includes(faction)) {
        fmenu.push(menu[i]);
      }
    }

    return fmenu;

  }

  playerSelectFactionWithFilter(msg, filter_func, mycallback = null, cancel_func = null, permit_no_selection = false) {

    let his_self = this;
    let factions = this.returnImpulseOrder();
    let f = [];

    for (let i = 0; i < factions.length; i++) {
      if (filter_func(factions[i])) { f.push(factions[i]); }
    }

    let html = "<ul>";
    for (let i = 0; i < f.length; i++) {
      html += `<li class="option" id="${f[i]}">${f[i]}</li>`;
    }
    if (permit_no_selection){ html += `<li class="option" id="none">none</li>`; }
    html += "</ul>";

    his_self.updateStatusWithOptions(msg, html);
     
    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");
      $('.option').off();
      mycallback(id);
    });

    return 0;
  }

  playerSelectCardFromArrayWithFilter(msg, cardarray=[], filter_func, mycallback = null, cancel_func = null, permit_no_selection = false) {

    let cards = [];

    for (let i = 0; i < cardarray.length; i++) {
      if (filter_func(cardarray[i])) {
	cards.push(cardarray[i]);
      }
    }

    if (permit_no_selection) {
      cards.push("pass");
    }

    this.updateStatusAndListCards(msg, cards);
    this.attachCardboxEvents(function(card) {
      mycallback(card);
    });

  }

  countSpacesWithFilter(filter_func) {
    let count = 0;
    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) { count++; }
    }
    return count;
  }

  playerFactionSelectCardWithFilter(faction, msg, filter_func, mycallback = null, cancel_func = null, permit_no_selection = false) {

    let cards = [];
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      if (filter_func(this.game.deck[0].fhand[faction_hand_idx][i])) {
	cards.push(this.game.deck[0].fhand[faction_hand_idx][i]);
      }
    }

    if (permit_no_selection) {
      cards.push("pass");
    }

    this.updateStatusAndListCards(msg, cards);
    this.attachCardboxEvents(function(card) {
      if (card == "pass") {
	this.cardbox.hide();
      }
      mycallback(card, faction);
    });

  }

  playerSelectSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let callback_run = false;
    let at_least_one_option = false;
    let html = '';
    html += '<ul class="hide-scrollbar">';

    $('.option').off();
    $('.hextile').off();
    $('.space').off();

    this.theses_overlay.space_onclick_callback = mycallback;

    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) {

        at_least_one_option = true;
        html += '<li class="option '+key+'" id="' + key + '">' + his_self.returnSpaceName(key) + '</li>';

	//
	// the spaces that are selectable are clickable on the main board (whatever board shows)
	//
	if (board_clickable) {
	  let t = "."+key;
	  document.querySelectorAll(t).forEach((el) => {
	    his_self.addSelectable(el);
	    el.onclick = (e) => {
	      e.stopPropagation();
	      e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	      el.onclick = () => {};
	      $('.option').off();
	      $('.space').off();
	      $('.hextile').off();
              his_self.theses_overlay.space_onclick_callback = null;
	      his_self.removeSelectable();
    	      if (callback_run == false) {
	        callback_run = true;
	        mycallback(key);
	      }
	    }
	  });
	}
      }
    }
    if (cancel_func != null) {
      html += '<li class="option" id="cancel">cancel</li>';
    }
    html += '</ul>';

    this.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action = $(this).attr("id");

      //
      // and remove on-board clickability
      //
      if (board_clickable) {
        for (let key in his_self.game.spaces) {
          if (filter_func(his_self.game.spaces[key]) == 1) {
	    let t = "."+key;
	    document.querySelectorAll(t).forEach((el) => {
	      el.onclick = (e) => {};
	    });
	  }
	}
      }

      his_self.removeSelectable();

      $('.option').off();
      $('.space').off();
      $('.hextile').off();

      if (action == "cancel") {
        cancel_func();
        return 0;
      }

      his_self.theses_overlay.space_onclick_callback = null;
      his_self.theses_overlay.remove();
      mycallback(action);

    });

    if (at_least_one_option) { return 1; }
    return 0;
  }

  playerSelectSpaceOrNavalSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {
    return this.playerSelectNavalSpaceWithFilter(msg, filter_func, mycallback, cancel_func, board_clickable);
  }

  playerSelectNavalSpaceWithFilter(msg, filter_func, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let at_least_one_option = false;
    let callback_run = false;

    this.theses_overlay.space_onclick_callback = mycallback;

    // remove any previous events
    $('.option').off();
    $('.hextile').off();
    $('.space').off();

    let html = '';
    html += '<ul class="hide-scrollbar">';
    for (let key in this.game.navalspaces) {
      if (filter_func(this.game.navalspaces[key]) == 1) {
	at_least_one_option = true;
        html += '<li class="option" id="' + key + '">' + key + '</li>';
	if (board_clickable) {
	  document.querySelectorAll(`.${key}`).forEach((el) => { his_self.addSelectable(el); });
	  document.getElementById(key).onclick = (e) => {
	    $('.option').off();
     	    $('.hextile').off();
    	    $('.space').off();
	    if (callback_run == true) { return; }
	    callback_run = true;
	    e.stopPropagation();
	    e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	    his_self.removeSelectable();
            his_self.theses_overlay.space_onclick_callback = null;
    	    if (callback_run == false) {
	      callback_run = true;
    	      his_self.updateStatus("selected...");
	      mycallback(key);
	    }
	  }
	}
      }
    }
    for (let key in this.game.spaces) {
      if (filter_func(this.game.spaces[key]) == 1) {
        at_least_one_option = true;
        html += '<li class="option" id="' + key + '">' + key + '</li>';
	if (board_clickable) {
	  document.querySelectorAll(`.${key}`).forEach((el) => { his_self.addSelectable(el); });
	  document.getElementById(key).onclick = (e) => { 
	    document.getElementById(key).onclick = (e) => {};
	    $('.option').off();
     	    $('.hextile').off();
    	    $('.space').off();
	    if (callback_run == true) { return; }
	    callback_run = true;
	    e.stopPropagation();
	    e.preventDefault();   // clicking on keys triggers selection -- but clicking on map will still show zoom-in
	    his_self.removeSelectable();
            his_self.theses_overlay.space_onclick_callback = null;
    	    his_self.updateStatus("selected...");
	    mycallback(key);
	    return;
	  }
	}
      }
    }
    if (cancel_func != null) {
      html += '<li class="option" id="cancel">cancel</li>';
    }
    html += '</ul>';

    this.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let action = $(this).attr("id");

      // remove events to prevent re-firing
      $('.option').off();
      $('.hextile').off();
      $('.space').off();

      his_self.removeSelectable();

      if (action == "cancel") {
        cancel_func();
        return 0;
      }

      his_self.theses_overlay.space_onclick_callback = null;
      mycallback(action);

    });

    if (at_least_one_option) { return 1; }
    return 0;
  }




  playerTurn(faction, selected_card=null) {

    //   
    // back button should return us here, so unbind if here
    //
    this.unbindBackButtonFunction();

    this.startClock();

    let his_self = this;

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    let can_pass = true;

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length;i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (c === "001") { can_pass = false; }
      if (c === "002") { can_pass = false; }
      if (c === "003") { can_pass = false; }
      if (c === "004") { can_pass = false; }
      if (c === "005") { can_pass = false; }
      if (c === "006") { can_pass = false; }
      if (c === "007") { can_pass = false; }
      if (c === "008") { can_pass = false; }
      if (c === "009") { can_pass = false; }
      if (c === "010") { can_pass = false; }
      cards.push(this.game.deck[0].fhand[faction_hand_idx][i]);
      try {
        if (this.game.deck[0].cards[c].type == "mandatory") { can_pass = false; }
      } catch (err) {
	// cards removed by other cards -- force play to remove from deck
	can_pass = false;
      }

    } // no home card? can pass

    if (this.factions[faction].returnAdminRating(this) < this.game.deck[0].fhand[faction_hand_idx].length) {
      can_pass = false;
    }

    if (this.game.deck[0].fhand[faction_hand_idx].length == 0) {

      can_pass = true;
      if (!cards.includes("pass")) {
        cards.push("pass");
      }

      //
      // in faster_play mode, we will switch to HALTED if there are     
      // no other options. this halts OUR game but allows others to continue
      // to play more rapidly, which helps speed-up games where network connections
      // can be a little slow, at the cost of leaking a small amount of information
      // about player hands from the speed of the response (i.e. a fast response 
      // likely means an automatic response, which likely means no cards permitting
      // intervention are in-hand.
      //
      if (this.faster_play == 1) {
          
        //
        // we don't need to HALT the game because the game will not progress
        // until all players have hit RESOLVE anyway.
        //
        let my_specific_game_id = his_self.game.id;
        his_self.halted = 1;
        his_self.game.queue[his_self.game.queue.length-1] = "HALTED\tWaiting for Game to Continue\t"+his_self.publicKey;
        his_self.hud.back_button = false;
              
        his_self.updateStatusAndListCards(his_self.returnFactionName(faction) + " - You Must Pass", cards);
        his_self.attachCardboxEvents((card) => {
          try {
            $('.card').off();
            $('.card img').off();
          } catch (err) {}

          his_self.game = his_self.loadGame(my_specific_game_id);
            
          // tell game engine we can move
          his_self.halted = 0;
          his_self.gaming_active = 0;

          his_self.updateStatus('continuing...');

          //
          // our own move will have been ticked into the future queue, along with
          // anyone else's so we skip restartQueue() which will freeze if it sees
          // that we have moves still pending, but should clear if it now finds
          // UNHALT is the latest instruction and this resolve is coming from us!
          //
          his_self.processFutureMoves();

        });

        //
        // halt my game (copies from ACKNOWLEDGE)
        //
        his_self.addMove("pass\t"+faction+"\t0"); // 0 => no cards in hand
        his_self.endTurn();
        return 0;

      }
    }
    if (can_pass) {
      if (!cards.includes("pass")) {
        cards.push("pass");
      }
    }

    this.updateStatusAndListCards(this.returnFactionName(faction) + " - Select Your Card: ", cards);
    this.attachCardboxEvents((card) => {
      try {
        $('.card').off();
        $('.card img').off();
      } catch (err) {}
      this.game_help.hide();

      //
      //
      //
      if (card == "pass") {
        this.playerPlayCard(card, this.game.player, faction);
	return 1;
      }


      //
      // sanity check mandatory cards if we need confirm
      //
      if (this.confirm_moves && this.game.deck[0].cards[card].type == "mandatory") {

	let c = confirm("Play Mandatory Card?");
	if (c) {
          //
          // if faction is England and Mary I is ruler, we have 50% 
          //
          if (this.game.players.length > 2 && faction == "england" && this.game.state.leaders.mary_i == 1 && this.game.deck[0].cards[card].ops >= 2) {
  	    this.addMove("decide_if_mary_i_subverts_protestantism_in_6P\t"+card);
          }

          if (this.game.players.length == 2 && faction == "protestant" && this.game.state.leaders.mary_i) {
	    this.addMove("decide_if_mary_i_subverts_protestantism_in_2P");
          }

          //
          // set back button to move us back here
          //
          let his_self = this;
          his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.playerTurn(faction, selected_card); });
          this.playerPlayCard(card, this.game.player, faction);
	} else {
          his_self.displayBoard(); 
          his_self.moves = [];
          his_self.playerTurn(faction, selected_card);
	}

      } else {

        //
        // if faction is England and Mary I is ruler, we have 50% 
        //
        if (this.game.players.length > 2 && faction == "england" && this.game.state.leaders.mary_i == 1 && this.game.deck[0].cards[card].ops >= 2) {
  	  this.addMove("decide_if_mary_i_subverts_protestantism_in_6P\t"+card);
        }

        if (this.game.players.length == 2 && faction == "protestant" && this.game.state.leaders.mary_i) {
	  this.addMove("decide_if_mary_i_subverts_protestantism_in_2P");
        }

        //
        // set back button to move us back here
        //
        let his_self = this;
        his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.playerTurn(faction, selected_card); });
        this.playerPlayCard(card, this.game.player, faction);
      }  
    });  
  }


  playerReliefForcesJoinBattle(faction, spacekey) {
    
    let space = this.game.spaces[spacekey];
    let player = this.returnPlayerCommandingFaction(faction);

    let his_self = this;
    let units_to_move = [];
    let available_units = [];

    for (let f in space.units) {
      for (let i = 0; i < space.units[f].length; i++) {
	if (space.units[f][i].besieged != 0) {
          available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	}
      }
    }

    //
    // unfortify the units
    //
    let finishAndFortify = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let fa = {};
      for (let f in space.units) { fa[f] = []; };

      for (let i = 0; i < units_to_move.length; i++) {
        let tf = units_to_move[i].faction;
        let tu = units_to_move[i].idx;
        fa[tf].push(tu);
      }

      for (let f in fa) {
	for (let z = 0; z < fa[f].length; z++) {
          his_self.addMove("unfortify_unit_by_index\t"+spacekey+"\t"+f+"\t"+fa[f][z]);
	}
      }
      his_self.endTurn();
      return;
    }
 
    //
    // select the units to unfortify
    //
    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let unmoved_units = [];
      let moved_units = [];

      let msg = "Which Fortified Units Join the Field Battle: ";
      let html = "<ul>";

      for (let i = 0; i < available_units.length; i++) {
	let is_this_unit_moving = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (
	    units_to_move[z].faction == available_units[i].faction &&
	    units_to_move[z].idx == available_units[i].unit_idx
	  ) { 
	    is_this_unit_moving = true;
          }
        }
        let tf = available_units[i].faction;
        let tu = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (is_this_unit_moving) {
          html += `<li class="option" style="font-weight:bold" id="${i}">* ${tu.name} - ${his_self.returnFactionName(tf)} *</li>`;
	  moved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
	} else {
          html += `<li class="option" style="" id="${i}">${tu.name} - ${his_self.returnFactionName(tf)}</li>`;
	  unmoved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      let mobj = {
        spacekey : spacekey ,
        moved_units : moved_units ,
        unmoved_units : unmoved_units ,
      }

      his_self.fortification_overlay.render(mobj, [], selectUnitsInterface, finishAndFortify, 1); // 1 => "unfortifying"
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
          his_self.fortification_overlay.hide();
          finishAndFortify(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          return;
        }

	let x = id.split("-");
	let f = x[0];
	let idx = x[1];

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	}
	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	  }
	} else {

	  let unitno = 0;
	  for (let i = 0; i < units_to_move.length; i++) {
	    if (space.units[units_to_move[i].faction][units_to_move[i].idx].army_leader == false) { unitno++; }
	    if (unitno >= 4) {
	      alert("Max 4 Units Permitted in Fortification");
	      return;
	    }
	  }
	  units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	}

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);

      });
    }
 
    //
    // PLAYER STARTS HERE
    //
    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
    return 0;

  }



  playerFortifySpace(faction, attacker, spacekey, post_battle=false, relief_siege=0) {

    let space = this.game.spaces[spacekey];
    let faction_map = this.returnFactionMap(space, attacker, faction);
    let cp = this.returnControllingPower(attacker);
    let attacker_player = this.returnPlayerCommandingFaction(cp);
    let player = this.returnPlayerCommandingFaction(faction);

    let his_self = this;
    let units_to_move = [];
    let available_units = [];
    let anyone_in_relief_force = false;

    for (let f in faction_map) { 
      if (this.returnPlayerCommandingFaction(f) != attacker_player) {
        for (let i = 0; i < space.units[f].length; i++) {
          if (space.units[f][i].relief_force == 1) { anyone_in_relief_force = true; }
	}
      }
    }
    if (this.game.state.field_battle_relief_battle) { anyone_in_relief_force = true; }

    for (let f in faction_map) { 
      if (this.returnPlayerCommandingFaction(f) != attacker_player) {
        for (let i = 0; i < space.units[f].length; i++) {
	  if (space.units[f][i].type == "regular" || space.units[f][i].type == "mercenary" || space.units[f][i].type == "cavalry" || space.units[f][i].army_leader) {
	    if (anyone_in_relief_force == false) {
              available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	      if (space.units[f][i].besieged == 1) { units_to_move.push( { faction : f , idx : i } ); }
	    } else {
if (relief_siege == 1) {
	      if (space.units[f][i].relief_force != 1) {
                available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	        if (space.units[f][i].besieged == 1) { units_to_move.push( { faction : f , idx : i } ); }
	      } 
} else {
                available_units.push({ faction : f , unit_idx : i , type : space.units[f][i].type });
	        if (space.units[f][i].besieged == 1) { units_to_move.push( { faction : f , idx : i } ); }
}
	    } 
          }
        }
      }
    }

    //
    // fortify the units_to_move
    //
    let finishAndFortify = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let fa = {};
      for (let f in faction_map) { fa[f] = []; };

      for (let i = 0; i < units_to_move.length; i++) {
        let tf = units_to_move[i].faction;
        let tu = units_to_move[i].idx;
        fa[tf].push(tu);
      }

      for (let f in fa) {
	for (let z = 0; z < fa[f].length; z++) {
          his_self.addMove("fortify_unit_by_index\t"+spacekey+"\t"+f+"\t"+fa[f][z]);
	}
      }
      his_self.endTurn();
      return;
    }

    //
    // select the units to fortify
    //
    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, finishAndFortify) {

      let unmoved_units = [];
      let moved_units = [];

      let msg = "Fortification Holds 4 Units: ";
      let html = "<ul>";

      for (let i = 0; i < available_units.length; i++) {
	let is_this_unit_moving = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (
	    units_to_move[z].faction == available_units[i].faction &&
	    units_to_move[z].idx == available_units[i].unit_idx
	  ) { 
	    is_this_unit_moving = true;
          }
        }
        let tf = available_units[i].faction;
        let tu = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (is_this_unit_moving) {
          html += `<li class="option" style="font-weight:bold" id="${i}">* ${tu.name} - ${his_self.returnFactionName(tf)} *</li>`;
	  moved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
	} else {
          html += `<li class="option" style="" id="${i}">${tu.name} - ${his_self.returnFactionName(tf)}</li>`;
	  unmoved_units.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      let mobj = {
        spacekey : spacekey ,
        moved_units : moved_units ,
        unmoved_units : unmoved_units ,
      }

      his_self.fortification_overlay.render(mobj, [], selectUnitsInterface, finishAndFortify); // no destination interface
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "end") {
          his_self.fortification_overlay.hide();
          finishAndFortify(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          return;
        }

	let x = id.split("-");
	let f = x[0];
	let idx = x[1];

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	}
	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	  }
	} else {

	  let unitno = 0;
	  for (let i = 0; i < units_to_move.length; i++) {
	    if (space.units[units_to_move[i].faction][units_to_move[i].idx].army_leader == false) { unitno++; }
	    if (unitno >= 4) {
	      alert("Max 4 Units Permitted in Fortification");
	      return;
	    }
	  }
	  units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	}

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);

      });
    }


    //
    // PLAYER STARTS HERE
    //
    let can_we_quick_fortify = true;
    if (available_units.length > 4) {
      let overunits = 0;
      for (let i = 0; i < available_units.length; i++) {
	let u = space.units[available_units[i].faction][available_units[i].unit_idx];
	if (u.type == "regular" || u.type == "cavalry" || u.type == "mercenary") { overunits++; }
	if (u.relief_force == 1) { can_we_quick_fortify = false; }
      }
      if (overunits > 4) {
        can_we_quick_fortify = false; 
      }
    }

    if (can_we_quick_fortify == true) {

      //
      // prevents UI flickering to have AUTO copied here
      //
      if (post_battle == 0) {
        for (let i = 0; i < available_units.length; i++) {
          units_to_move.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
        }
        finishAndFortify(his_self, units_to_move);
	return 0;
      }

      let msg = "Choose Fortification Option: ";
      let html = "<ul>";
      html += `<li class="option" id="auto">fortify everything (auto)</li>`;
      if (post_battle == 1) {
        html += `<li class="option" id="manual">select units (manual)</li>`;
      }
      html += "</ul>";
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id === "auto") {
          for (let i = 0; i < available_units.length; i++) {
            units_to_move.push({ faction : available_units[i].faction , idx : available_units[i].unit_idx , type : available_units[i].type });
          }
          finishAndFortify(his_self, units_to_move);
          return 0;
        }

        if (id === "manual") {
	  try { his_self.field_battle_overlay.hide(); } catch (err) {}
          selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
          return 0;
        }

      });

      return 0;

    } else {

      //
      // we have to move manually, this implies post_battle
      //
      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
      return;

    }

    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, finishAndFortify);
    return 0;

  }


  playerPlayWinterRetreatToFortresses(f, player) {

    let his_self = this;

    //
    // this lets independent fill their own capitals before major powers...
    //
    let ofs = ["venice","hungary","genoa","scotland","independent","ottoman","hapsburg","england","france","papacy","protestant"];
    let fs = [];
    for (let z = 0; z < ofs.length; z++) {
      if (this.returnControllingPower(ofs[z]) == f) {
	fs.push(ofs[z]);
      }
    }

    let sources = [];
    let any_need_to_intervene = false;
    let confirm_leaders_move_with_troops = false;
    let confirm_leaders_move_with_troops_spacekey = false;
    let leaders_to_remove_moves = [];
    let units_to_remove_moves = [];

    //
    // handle non-naval units
    //
    for (let spacekey in this.game.spaces) {
      for (let mm = 0; mm < fs.length; mm++) {

        let faction = fs[mm];
        let space = this.game.spaces[spacekey];

        if (space.units[faction].length > 0 ) {

          //
          // we need to retreat from these spaces
          //
          if (
             ((this.isSpaceFortified(spacekey) && !this.isSpaceControlled(spacekey, faction)) || (!this.isSpaceFortified(spacekey)))
             &&
             (!(faction == "protestant" && this.isSpaceElectorate(space.key) && this.game.state.events.schmalkaldic_league != 1))
             &&
             (spacekey != "ireland" && spacekey != "persia" && spacekey != "egypt")
          ) {
             this.removeSiege(space.key);
	     if (this.returnFactionLandUnitsInSpace(faction, spacekey, 0) > 0) { 

               //
               // find the nearest friendly fortified space w/ less than 4 units
               //
               let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(faction, spacekey, 4);
	       sources.push({ spacekey : spacekey , res : res });
	       any_need_to_intervene = true;
	     }
	  }
        }
      }
    }

    if (any_need_to_intervene == false) {
      his_self.updateStatus("processing...");
      his_self.theses_overlay.hide();
      his_self.endTurn();
      return 1;
    }


    let next_unit_fnct = async (sources, sources_idx, unit_idx, next_unit_fnct) => {

      if (sources.length < (sources_idx+1)) {
        his_self.updateStatus("processing...");
        his_self.theses_overlay.hide();
	for (let z = leaders_to_remove_moves.length-1; z >= 0; z--) {
	  his_self.addMove(leaders_to_remove_moves[z]);
	}
	for (let z = units_to_remove_moves.length-1; z >= 0; z--) {
	  his_self.addMove(units_to_remove_moves[z]);
	}
	his_self.endTurn();
	return 1;
      }

      this.theses_overlay.renderAtSpacekey(sources[sources_idx].spacekey);
      let status = document.querySelector('.theses-overlay .status');
      status.style.display = 'block';
      let controls = document.querySelector('.theses-overlay .controls');
      controls.style.display = 'block';

      let res = this.returnNearestFriendlyFortifiedSpacesTransitPasses(f, sources[sources_idx].spacekey, 4);
      let destinations = []; 
      for (let z = 0; z < res.length; z++) { destinations.push(res[z].key); }

      let space = his_self.game.spaces[sources[sources_idx].spacekey];

      if (unit_idx >= 0) {

	let unit_type = space.units[f][unit_idx].type;
	let unit_name = "";
	if (unit_type == "mercenary") { unit_name = "Mercenary"; }
	if (unit_type == "regular") { unit_name = "Regular"; }
	if (unit_type == "cavalry") { unit_name = "Cavalry"; }
	if (space.units[f][unit_idx].army_leader == true) { unit_type = space.units[f][unit_idx].name; }

        if (unit_name == "" || res.length == 0) {
	   next_unit_fnct(sources, sources_idx, unit_idx-1, next_unit_fnct);
	} else {

          his_self.playerSelectSpaceWithFilter(
            "Winter "+unit_name+" ("+(parseInt(unit_idx)+1)+") from "+his_self.returnSpaceName(space.key) ,
            function(space) {
              if (destinations.includes(space.key)) { return 1; }
	      return 0;
            },
            function(spacekey) {

	      let move_leader_with_troops = false;
	      let moved_this_unit = false;
              let leader_idx = [];

	      for (let i = space.units[f].length-1; i >= 0; i--) {
		let u = space.units[f][i];
		if (i != unit_idx && (u.army_leader || u.navy_leader)) {
		  leader_idx.push(i);
		}
	      }

	      if (leader_idx.length > 0) {
		let c = confirm("Move Leader with Troops?");
	        if (c) { move_leader_with_troops = true; }
	      }

	      //
	      // auto-move with last unit
	      //
	      if (leader_idx.length == space.units[f].length-1) {
		move_leader_with_troops = true;
	      }


	      if (move_leader_with_troops) {
		for (let z = space.units[f].length-1; z >= 0; z--) {
		  if (space.units[f][z].army_leader || space.units[f][z].navy_leader) {
		    let u = space.units[f][z];
	            his_self.removeUnit(f, space.key, u.type);
	            his_self.addArmyLeader(f, spacekey, u.type);
	            leaders_to_remove_moves.push("move\t"+f+"\tland\t"+space.key+"\t"+spacekey+"\t"+z+"\t"+his_self.game.player);
		    if (z < unit_idx) { unit_idx--; }
		  }
		}
	      }

              his_self.addUnit(f, spacekey, unit_type);
	      his_self.removeUnit(f, space.key, unit_type);
	      units_to_remove_moves.push("move\t"+f+"\tland\t"+space.key+"\t"+spacekey+"\t"+unit_idx+"\t"+his_self.game.player);

	      //
	      // reorganize MOVES
	      //
	      for (let y = 0; y < his_self.moves.length-1; y++) {
  	        let tmpx = his_self.moves[y].split("\t");
  	        let tmpy = his_self.moves[y+1].split("\t");
	        if (tmpx[0] == "move") {
	          if (parseInt(tmpx[5]) > parseInt(tmpy[5])) {
		    let x = his_self.moves[y];
		    let y = his_self.moves[y+1];
		    his_self.moves[y] = y;
		    his_self.moves[y+1] = x;
		    y = -1; // we found problem, so loop again
	          }
	        }
	      }

	      his_self.displaySpace(space.key);
	      his_self.displaySpace(spacekey);
	      next_unit_fnct(sources, sources_idx, unit_idx-1, next_unit_fnct);
            },
            null ,
            true
          );

	}
      } else {
        let next_unit_idx = 100;
	if (sources.length > sources_idx+1) { next_unit_idx = his_self.game.spaces[sources[sources_idx+1].spacekey].units[f].length-1; }
        next_unit_fnct(sources, sources_idx+1, next_unit_idx, next_unit_fnct);
      }

    }

    if (sources.length > 0) {
      let next_unit_idx = 100;
      next_unit_idx = his_self.game.spaces[sources[0].spacekey].units[f].length-1;
      next_unit_fnct(sources, 0, next_unit_idx, next_unit_fnct);
    } else {
      his_self.updateStatus("processing...");
      his_self.theses_overlay.hide();
      his_self.endTurn();
    }
         
    return 0;

  }

  playerPlayDiplomacyCard(faction) {

    let p = this.returnPlayerOfFaction(faction);
    let his_self = this;

    this.updateStatusAndListCards(his_self.returnFactionName(faction) + " - Select Diplomacy Card", this.game.deck[1].hand);
    this.attachCardboxEvents(function(card) {

      this.updateStatus(`Playing ${this.popup(card)}`, this.game.deck[1].hand);
      his_self.addMove("diplomacy_card_event\t"+faction+"\t"+card);
      his_self.addMove("discard_diplomacy_card\t"+faction+"\t"+card);

      let faction_hand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
      his_self.addMove("cards_left\t"+faction+"\t"+his_self.game.deck[0].fhand[faction_hand_idx].length); // no -1 because we r just updating other hand

      his_self.endTurn();
    });

  }

  playerPlayCard(card, player, faction) {
  
    //
    // remove selectable elemets on board
    //
    this.removeSelectable();

    //
    // cards left
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    let cards_in_hand = this.game.deck[0].fhand[faction_hand_idx].length;

    this.cardbox.hide();
    this.game.state.active_card = card;

    if (card === "pass") {
      this.cardbox.hide();
      this.updateStatus("Passing this Round...");
      this.addMove("pass\t"+faction+"\t"+cards_in_hand);
      this.endTurn();
      return;
    } else {
      this.addMove("cards_left\t"+faction+"\t"+(cards_in_hand-1)); // -1 because we playing this card
    }


    //
    // check if the eventing of this card makes interventions impossible
    //
    if (this.game.state.events.intervention_on_movement_possible == 1) {}
    if (this.game.state.events.intervention_on_events_possible == 1) {
      if (card === "037") { this.game.state.events.intervention_on_events_possible = 0; }
    }
    if (this.game.state.events.intervention_on_assault_possible == 1) {}
    if (this.game.state.events.intervention_post_assault_possible == 1) {}
    if (this.game.state.events.intervention_post_naval_assault_possible == 1) {
      if (card === "034") { this.game.state.events.intervention_naval_avoid_battle_possible = 0; }
    }
    if (this.game.state.events.intervention_naval_avoid_battle_possible == 1) {
      if (card === "034") { this.game.state.events.intervention_naval_avoid_battle_possible = 0; }
    }
    if (this.game.state.events.intervention_naval_intercept_possible == 1) {
      if (card === "034") { this.game.state.events.intervention_naval_intercept_possible = 0; }
    }


    //
    // mandatory event cards effect first, then 2 OPS
    //
    let deck = this.returnDeck(true); // removed don't get evented
    let event_this = false;
    let can_event_this = false;

    try {
      if (deck[card].type === "mandatory" && deck[card].canEvent(this, faction)) {
        event_this = true;
      }
    } catch (err) {}

    if (event_this) {
      this.unbindBackButtonFunction();
      this.addMove("remove\t"+faction+"\t"+card);
      this.addMove("ops\t"+faction+"\t"+card+"\t"+2);
      this.playerPlayEvent(card, faction);
    } else {

      let html = `<ul>`;
      html    += `<li class="card" id="ops">play for ops</li>`;
      try {
        if (deck[card].canEvent(this, faction) && !this.game.state.cards_evented.includes(card)) {
  	  can_event_this = true;
	  if (card === "102") { can_event_this = false; }
        }
      } catch (err) {}

      //
      // Mary I cannot event combat/response cards if England
      //
      if (faction == "england" && this.game.state.leaders.mary_i != 0) {
	if (deck[card].type == "response" || deck[card].type == "combat") { can_event_this = false; }
      }

      if (can_event_this) {
        html    += `<li class="card" id="event">play for event</li>`;
      }
      html    += `</ul>`;

      let pick_card_function = () => {

        this.updateStatusWithOptions(`Playing ${this.popup(card)}`, html);
        this.attachCardboxEvents((user_choice) => {      

	  this.updateStatus("submitting...");

          if (user_choice === "ops") {
            let ops = this.game.deck[0].cards[card].ops;
            this.playerPlayOps(card, faction, ops);
            return;
          }
          if (user_choice === "event") {
            this.unbindBackButtonFunction();
            if (this.game.deck[0].cards[card].warn.includes(faction)) {
              let c = confirm("Unorthodox! Are you sure you want to event this card?");
              if (!c) {
                pick_card_function();
               return;
              }
              this.playerPlayEvent(card, faction);
              return;
            } else {
              this.playerPlayEvent(card, faction);
              return;
	    }
            return;
          }
        });
      }

      pick_card_function();
    }

  }


  //
  // when Mary I is in play, 50% chance English cards can be
  // used to burn books and convene theological debates
  //
  async playerPlayMaryI(card="", faction, limit="") {

    let his_self = this;
    let menu = this.returnActionMenuOptions(this.game.player, faction, "mary_i");
    let deck = this.returnDeck(true);
    let ops = deck[card].ops;
    let pfactions = this.returnPlayerFactions(this.game.player);

    let attachEventsToMenuOptions = () => {

      this.updateStatusWithOptions(`${this.returnFactionName(faction)}: ${ops} ops remaining`, html);
      this.attachCardboxEvents(async (user_choice) => {      

	his_self.menu_overlay.hide();

        if (user_choice === "end_turn") {
          this.endTurn();
          return;
        }

	let ops_to_spend = 0;

        for (let z = 0; z < menu[user_choice].factions.length; z++) {
          if (pfactions.includes(menu[user_choice].factions[z])) {
            ops -= menu[user_choice].cost[z];
	    ops_to_spend = menu[user_choice].cost[z];
  	    z = menu[user_choice].factions.length+1;
          }
        }

	//
	// we end if there is only 1 OP left
	//
        if (ops > 1) {
  	  this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
        }
        menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
        return;

      });

    } // attach events to menu options

    this.menu_overlay.render(menu, this.game.player, faction, ops, attachEventsToMenuOptions);
    attachEventsToMenuOptions();

  }

  async playerPlayOps(card="", faction, ops=null, limit="") {

    //
    // remove selectable elemets on board
    //
    this.removeSelectable();

    //
    // make sure this is whoever is in control
    //
    faction = this.returnControllingPower(faction);

    //
    // back button loses track of which card was played, but foreign
    // recruits submits with card="". we need to know the last card
    // played for a few reasons, including untriggering events
    //
    this.game.player_last_card = "";
    if (card != "") { this.game.player_last_card = card; }


    //
    // unbind in all cases except where OPS are max from card
    //
    if (card == "") {
      this.unbindBackButtonFunction();
    } else {
      try {
        let expected_ops = this.game.deck[0].cards[card].ops;
        if (expected_ops != ops || ops == null || card == "") {
          this.unbindBackButtonFunction();
        }
      } catch (err) {
        // probably mandatory card already removed from deck
        this.unbindBackButtonFunction();
      }
    }

    //
    // cards left
    //
    // you can play for minor allies that do not have cards in your hand, so in that case do not report...
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    if (-1 < faction_hand_idx) {
      if (this.game.deck[0].fhand[faction_hand_idx]) {
        this.addMove("cards_left\t"+faction+"\t"+this.game.deck[0].fhand[faction_hand_idx].length-1); // -1 because we playing this card
      }
    }

    //
    // discard the card
    //
    if (card != "") {
      this.addMove("discard\t"+faction+"\t"+card);
      if (this.game.deck[0]) {
        if (this.game.deck[0].cards[card]) {
          if (this.game.deck[0].cards[card].ops == ops) {
            this.addEndMove("NOTIFY\t" + this.returnFactionName(faction) + " plays " + this.popup(card) + " for ops");
          }
        }
      }
    }

    let his_self = this;
    let menu = this.returnActionMenuOptions(this.game.player, faction, limit);
    let pfactions = this.returnPlayerFactions(this.game.player);

    if (ops == null) { ops = 2; }
    if (ops == 0) { 
    
      if (this.game.player_last_card == "034") {
        this.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t0");
        this.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t0");
        this.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
      }       
      if (this.game.player_last_card == "037") {
        this.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t0");
      }   
      
      this.endTurn();
      return;
    }

    //
    // Roxelana offers free Assault
    //
    if (this.game.state.events.roxelana == 1 && faction == "ottoman") {
      for (let m in menu) {
	if (menu[m].name === "Assault") {
	  menu[m].cost = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	}
      }
    }

    //
    // "ACTIVATED POWERS" are those for whom players have the choice of moving.
    // this can be triggered through alliance with a minor power, or through a 
    // diplomacy card in the 2P game.
    //
    if (this.game.state.activated_powers[faction].length > 0) {

      let html = `<ul>`;
      html    += `<li class="card" id="${faction}">${faction}</li>`;
      for (let i = 0; i < this.game.state.activated_powers[faction].length; i++) {
	 let can_select = true;
	 let ap = this.game.state.activated_powers[faction][i];
	 if (faction === "france" && this.game.state.events.scots_raid == 1) {
	   if (ap != "scotland") { can_select = false; }
	 }
	 if (can_select == true) {
           html    += `<li class="card" id="${this.game.state.activated_powers[faction][i]}">${this.game.state.activated_powers[faction][i]}</li>`;
	 }
         for (let z = 0; z < this.game.state.activated_powers[this.game.state.activated_powers[faction][i]].length; z++) {
	   let mp = this.game.state.activated_powers[this.game.state.activated_powers[faction][i]][z];
	   let can_select = true;
	   if (faction === "france" && this.game.state.events.scots_raid == 1) {
	     if (!(mp == "france" || mp == "scotland")) { can_select = false; }
	   }
	   if (can_select) { html += `<li class="card" id="${this.game.state.activated_powers[this.game.state.activated_powers[faction][i]][z]}">${this.game.state.activated_powers[this.game.state.activated_powers[faction][i]][z]}</li>`; }
	 }
      }
      html    += `</ul>`;

      let ops_text = `${ops} op`;
      if (ops > 0) { ops_text += 's'; }

      this.updateStatusWithOptions(`Which Faction: ${ops_text}`, html);
      this.attachCardboxEvents(function(selected_faction) {



        menu = this.returnActionMenuOptions(this.game.player, selected_faction, limit);

        //
        // Roxelana offers free Assault
        //
        if (this.game.state.events.roxelana == 1 && faction == "ottoman") {
          for (let m in menu) {
	    if (menu[m].name === "Assault") {
	      menu[m].cost = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	    }
          }
        }

	//
	// duplicates code below
	//
        let html = `<ul>`;
        for (let i = 0; i < menu.length; i++) {
	  // added ops to check() for naval transport
          if (menu[i].check(this, this.game.player, selected_faction, ops)) {
            for (let z = 0; z < menu[i].factions.length; z++) {
              if (menu[i].factions[z] === selected_faction) {
  	        if (menu[i].cost[z] <= ops) {
		  if (menu[i].cost[z] > 0) {
                    html    += `<li class="card" id="${i}">${menu[i].name} [${menu[i].cost[z]} ops]</li>`;
                  }
                }
	        z = menu[i].factions.length+1;
              }
            }
          }
        }

        html    += `<li class="card" id="end_turn">end turn</li>`;
        html    += `</ul>`;

	let attachEventsToMenuOptions = () => {

        his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.playerPlayOps(card, faction, ops, limit); });
        his_self.updateStatusWithOptions(`${his_self.returnFactionName(selected_faction)}: ${ops} ops remaining`, html);
        this.attachCardboxEvents(async (user_choice) => {      

	  his_self.unbindBackButtonFunction();
	  his_self.updateStatus("acknowledge");
	  his_self.menu_overlay.hide();

          if (user_choice === "end_turn") {
            if (his_self.game.player_last_card == "034") {
              his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t0");
              his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t0");
              his_self.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
            }       
            if (this.game.player_last_card == "037") {
              his_self.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t0");
            }   
            his_self.endTurn();
            return;
          }

	  //
	  // cost of founding depends on Loyola
	  //
	  if (menu[user_choice].name.indexOf("University") != -1) {

	    let default_cost = 3;

    	    if (this.canPlayerCommitDebater("papacy", "loyola-debater")) {

	      let msg = "Commit Loyola to reduce cost to 2 OPs?";
      	      let html = `<ul>`;
              html += `<li class="option" id="commit">commit Loyola (2 OPs)</li>`;
              if (ops > 2) { html += `<li class="option" id="donot">do not commit (3 OPs)</li>`; }
	      html += '</ul>';

	      his_self.updateStatusWithOptions(msg, html);
      	      his_self.attachCardboxEvents(async (moar_user_choice) => {      

	        if (moar_user_choice === "commit") {
                  ops -= 2;
                  if (ops > 0) {
 		    his_self.addMove("continue\t"+his_self.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
		  }
                  his_self.addMove("commit\tpapacy\tloyola-debater\t1");
                  his_self.playerFoundJesuitUniversity(his_self, his_self.game.player, "papacy");
                  return;
		}

		if (moar_user_choice === "donot") {
                  ops -= 3;
		  if (ops > 0) {
 		    his_self.addMove("continue\t"+his_self.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
                  }
                  his_self.playerFoundJesuitUniversity(his_self, his_self.game.player, "papacy");
                  return;
		}

	      });

	    } else {
              ops -= 3;
	      if (ops > 0) {
 	        his_self.addMove("continue\t"+his_self.game.player+"\t"+selected_faction+"\t"+card+"\t"+ops+"\t"+limit); 
              }
              menu[user_choice].fnct(his_self, his_self.game.player, selected_faction, 3, ops);
              return;
	    }

	  } else {

	    //
	    // sub-menu to simplify translations / st peters
	    //
	    if (menu[user_choice].name.indexOf("Peters") != -1 || menu[user_choice].name.indexOf("Translate") != -1) {

	      //
	      // skip if only 1 ops
	      //
	      if (ops == 1) {

                  menu[user_choice].fnct(his_self, his_self.game.player, selected_faction, 1, 0);
                  return;

	      } else {

	        let msg = "How many OPs to Spend: ";
                let html = `<ul>`;
	        let desc = ['one', 'two', 'three', 'four', 'five', 'six'];
                for (let i = 1; i <= ops; i++) {
                  html += `<li class="card" id="${i}">${desc[i-1]}</li>`;
                }
                html += '</ul>';

                this.updateStatusWithOptions(msg, html);
                this.attachCardboxEvents(async (uc) => {      

	          let ops_to_spend = parseInt(uc);
	          let ops_remaining = ops - ops_to_spend;
 
                  if (ops_remaining > 0) {
    	            this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops_remaining+"\t"+limit);
                  }
                  menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops_remaining);
                  return;
	        });

	      }

	    } else {

	      let ops_to_spend = 0;
	      let cost = 0;

              for (let z = 0; z < menu[user_choice].factions.length; z++) {
                if (menu[user_choice].factions[z] === selected_faction) {
		  cost = menu[user_choice].cost[z];
                  ops -= menu[user_choice].cost[z];
		  ops_to_spend = menu[user_choice].cost[z];
	          z = menu[user_choice].factions.length+1;
                }
              }
	      if (cost == 0) {
                menu[user_choice].fnct(this, this.game.player, selected_faction, ops_to_spend, ops);
		this.playerPlayOps(card, faction, ops, limit);
                return;
	      }
              if (ops > 0) {
	        this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
              }
              menu[user_choice].fnct(this, this.game.player, selected_faction, ops_to_spend, ops);
              return;

	    }
	  }
        });

	} // function

	his_self.menu_overlay.render(menu, this.game.player, selected_faction, ops, attachEventsToMenuOptions);

	attachEventsToMenuOptions();

      });
    } else {

      //
      // duplicates code above
      //
      let html = `<ul>`;
      for (let i = 0; i < menu.length; i++) {

        if (menu[i].check(this, this.game.player, faction)) {
          for (let z = 0; z < menu[i].factions.length; z++) {
            if (menu[i].factions[z] === faction) {
  	      if (menu[i].cost[z] <= ops) {
		if (menu[i].cost[z] > 0) {
                  html += `<li class="card" id="${i}">${menu[i].name} [${menu[i].cost[z]} ops]</li>`;
                }
              }
	      z = menu[i].factions.length+1;
            }
          }
        }
      }

      html    += `<li class="card" id="end_turn">end turn</li>`;
      html    += `</ul>`;

      let attachEventsToMenuOptions = () => {

      this.updateStatusWithOptions(`${this.returnFactionName(faction)}: ${ops} ops remaining`, html);
      this.attachCardboxEvents(async (user_choice) => {      

        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge");
	his_self.menu_overlay.hide();

        if (user_choice === "end_turn") {
          if (his_self.game.player_last_card == "034") {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t0");
            his_self.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
          }       
          if (this.game.player_last_card == "037") {
            his_self.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t0");
          }   
          this.endTurn();
          return;
        }

	//
	// cost of founding depends on Loyola
	//
	if (menu[user_choice].name.indexOf("University") != -1) {

	  let default_cost = 3;

    	  if (this.canPlayerCommitDebater("papacy", "loyola-debater")) {

	    let msg = "Commit Loyola to reduce cost to 2 OPs?";
      	    let html = `<ul>`;
            html += `<li class="option" id="commit">commit Loyola (2 OPs)</li>`;
            if (ops > 2) { html += `<li class="option" id="donot">do not commit (3 OPs)</li>`; }
	    html += '</ul>';

	    his_self.updateStatusWithOptions(msg, html);
      	    his_self.attachCardboxEvents(async (moar_user_choice) => {      

	      if (moar_user_choice === "commit") {
                ops -= 2;
                if (ops > 0) {
 		  his_self.addMove("continue\t"+his_self.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
		}
                his_self.addMove("commit\tpapacy\tloyola-debater\t1");
                his_self.playerFoundJesuitUniversity(his_self, his_self.game.player, "papacy");
                return;
	      }

	      if (moar_user_choice === "donot") {
                ops -= 3;
	        if (ops > 0) {
 	          his_self.addMove("continue\t"+his_self.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
                }
                his_self.playerFoundJesuitUniversity(his_self, his_self.game.player, "papacy");
                return;
	      }

	    });

	  } else {
            ops -= 3;
	    if (ops > 0) {
 	      his_self.addMove("continue\t"+his_self.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit); 
            }
            menu[user_choice].fnct(his_self, his_self.game.player, faction, 3, ops);
	  }

	  return;
	}

	//
	// sub-menu to simplify translations / st peters
	//
	if (menu[user_choice].name.indexOf("Peters") != -1 || menu[user_choice].name.indexOf("Translate") != -1) {

	  //
	  // skip if only 1 ops
	  //
	  if (ops == 1) {
            menu[user_choice].fnct(this, this.game.player, faction, 1, 0);
            return;
	  }

	  let msg = "How many OPs to Spend: ";
          let html = `<ul>`;
	  let desc = ['one', 'two', 'three', 'four', 'five', 'six'];
          for (let i = 1; i <= ops; i++) {
            html += `<li class="card" id="${i}">${desc[i-1]}</li>`;
          }
          html += '</ul>';

          this.updateStatusWithOptions(msg, html);
          this.attachCardboxEvents(async (uc) => {      

	    let ops_to_spend = parseInt(uc);
	    let ops_remaining = ops - ops_to_spend;

            if (ops_remaining > 0) {
  	      this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops_remaining+"\t"+limit);
            }
            menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops_remaining);
            return;
	  });

	} else {

	  let ops_to_spend = 0;
	  let cost = 0;

          for (let z = 0; z < menu[user_choice].factions.length; z++) {
            if (faction == menu[user_choice].factions[z]) {
	      cost = menu[user_choice].cost[z];
              ops -= menu[user_choice].cost[z];
	      ops_to_spend = menu[user_choice].cost[z];
  	      z = menu[user_choice].factions.length+1;
            }
          }

	  if (cost == 0) {
            menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
	    this.playerPlayOps(card, faction, ops, limit);
            return;
	  }
          if (ops > 0) {
  	    this.addMove("continue\t"+this.game.player+"\t"+faction+"\t"+card+"\t"+ops+"\t"+limit);
          }
          menu[user_choice].fnct(this, this.game.player, faction, ops_to_spend, ops);
          return;

	}
      });

      } // attach events to menu options

      this.menu_overlay.render(menu, this.game.player, faction, ops, attachEventsToMenuOptions);
      attachEventsToMenuOptions();

    }
  }
  playerPlayEvent(card, faction, ops=null) {

    //
    // cards left
    //
    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);
    this.addMove("cards_left\t"+faction+"\t"+this.game.deck[0].fhand[faction_hand_idx].length-1); // -1 because we playing this card
    
    let deck = this.returnDeck(true);
    if (deck[card].removeFromDeckAfterPlay(this, faction)) {
      this.addMove("remove\t"+faction+"\t"+card);
    }

    //
    // sanity check in case a mandatory card is dealt mid-game
    // and not removed from the deck.
    //
    if (this.game.state.removed.includes(card)) {
      if (this.game.player_last_card == "034") {
        this.addMove("SETVAR\tstate\tevents\tintervention_naval_avoid_battle_possible\t0");
        this.addMove("SETVAR\tstate\tevents\tintervention_naval_intercept_possible\t0");
        this.addMove("SETVAR\tstate\tevents\tintervention_post_naval_battle_possible\t0");
      }       
      if (this.game.player_last_card == "037") {
        this.addMove("SETVAR\tstate\tevents\tintervention_on_events_possible\t0");
      }   
      this.endTurn();
      return;
    }

    this.addMove("event\t"+faction+"\t"+card);
    this.addMove("discard\t"+faction+"\t"+card);


    // counter_or_acknowledge if the player is the Protestants and Wartburg is not in the discard pile as
    // the Protestants might have it. Otherwise ACKNOWLEDGE to ensure players know what is happening but
    // don't halt the game for the player moving.

    //
    // Gout can cancel Holy Roman Emperor
    //
    if (card === "002") {
      if (this.game.state.events.intervention_on_movement_possible == 1) {
        this.addMove("counter_or_acknowledge\t" + this.returnFactionName(faction) + " triggers " + this.popup(card) + "\tevent\t"+card);
        this.addMove("RESETCONFIRMSNEEDED\tall");
        this.endTurn();
        return 0;
      }
    }


    //
    // wartburg is 037 -- mandatory events cannot be cancelled so we use ACKNOWLEDGE
    // this prevents things like DEFENDER OF THE FAITH or CLEMENT VII from halting 
    // gameplay mid-turn and slowing everything down.
    //
    // some cards skip this acknowledge -- such as Patron of the Arts 004
    //
    if (card !== "004") {
      if (deck[card].type == "mandatory" || !deck[card].canEvent(this, faction)) {
        this.addMove("ACKNOWLEDGE\t" + this.returnFactionName(faction) + " triggers " + this.popup(card));
      } else {

        //
        // otherwise, skip if Protestants cannot interfere
        //
        if ((faction == "england" && this.returnPlayerCommandingFaction("protestant") == this.returnPlayerCommandingFaction("england")) || faction == "protestant" || this.game.deck[0].discards["037"] || this.game.state.events.intervention_on_events_possible == false) {
          this.addMove("ACKNOWLEDGE\t" + this.returnFactionName(faction) + " triggers " + this.popup(card));
        } else {
          this.addMove("counter_or_acknowledge\t" + this.returnFactionName(faction) + " triggers " + this.popup(card) + "\tevent\t"+card);
          this.addMove("RESETCONFIRMSNEEDED\tall");
        }
      }
    }

    this.endTurn();
  }


  playerActionMenu(player) {
    let menu_options = this.returnActionMenuOptions();
  }

  async playerReformationAttempt(player) {
    this.updateStatus("Attempting Reformation Attempt");
    return;
  }
  async playerCounterReformationAttempt(player) {
return;
  }

  playerPlayPapacyDiplomacyPhaseSpecialTurn(enemies=[]) {

    let his_self = this;
    let player = this.returnPlayerOfFaction("papacy");
    if (this.game.player != player) { this.updateStatus("ERROR: you are not the papacy"); return; }

 
    let msg = `End a War? [`;
    for (let i = 0; i < enemies.length; i++) { if (i > 0) { msg += ", "; } msg += this.returnFactionName(enemies[i]); };
    msg += ']';
    let opt = "<ul>";
    opt += `<li class="option" id="yes">yes</li>`;
    opt += `<li class="option" id="no">no</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      his_self.unbindBackButtonFunction();
      his_self.updateStatus("acknowledge...");

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "no") {
	his_self.endTurn();
	return 0;
      }

      //
      // otherwise YES
      //
      let msg = `Which Faction?`;
      let opt = "<ul>";
      for (let i = 0; i < enemies.length; i++) {
        opt += `<li class="option" id="${enemies[i]}">${enemies[i]}</li>`;
      }
      opt += '</ul>';

      his_self.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {

	let enemy = $(this).attr('id');

        //
        // otherwise YES
        //
        let msg = `How would you like to End the War?`;
        let opt = "<ul>";
	let allow_bull = 0;

	if (enemy == "hapsburg" && his_self.game.state.excommunicated_factions["hapsburg"] != 1) { allow_bull = 1; }
	if (enemy == "france" && his_self.game.state.excommunicated_factions["france"] != 1) { allow_bull = 1; }

	if (allow_bull) {
          opt += `<li class="option" id="005">papal bull</li>`;
	}
        opt += `<li class="option" id="sue">sue for peace</li>`;
        opt += '</ul>';

        his_self.updateStatusWithOptions(msg, opt);

        $(".option").off();
        $(".option").on('click', function () {

	  let method = $(this).attr('id');

	  if (method === "005") {

	    //
	    // excommunicate faction 
	    //
	    his_self.addMove("excommunicate_faction\t"+enemy);

	    //
	    // factions no longer At War
	    //
	    his_self.addMove("unset_enemies\tpapacy\t"+enemy);

	    let do_any_foreign_occupied_spaces_exist = false;
	    for (let key in his_self.game.spaces) {
	      if (his_self.game.spaces[key].home == "papacy") {
		if (his_self.game.spaces[key].political != "" && his_self.game.spaces[key].political != "papacy") {
		  do_any_foreign_occupied_spaces_exist = true;
		}
	      }
	    }

	    //
	    // regain control of home space, or draw card
	    //
    	    let msg = `Regain Home Space or Draw Card?`;
    	    let opt = "<ul>";
	    if (do_any_foreign_occupied_spaces_exist == true) {
    	      opt += `<li class="option" id="regain">regain home space</li>`;
	    } 
   	    opt += `<li class="option" id="draw">draw card</li>`;
    	    opt += '</ul>';

	    his_self.updateStatusWithOptions(msg, opt);

	    $(".option").off();
	    $(".option").on('click', function () {

	      let action2 = $(this).attr('id');

	      if (action2 === "draw") {
                his_self.addMove("hand_to_fhand\t1\t"+his_self.game.player+"\t"+"papacy");
                his_self.addMove(`DEAL\t1\t${his_self.game.player}\t1`);
		his_self.endTurn();
	      }

	      if (action2 === "regain") {

    	        his_self.playerSelectSpaceWithFilter(

                  "Select Home Space to Recapture" ,

        	  function(space) {
	            if (space.home === "papacy" && (space.political !== "" && space.political !== "papacy")) {
		      return 1;
		    }
		  },

      		  function(spacekey) {
                    his_self.addMove(`control\tpapacy\t${spacekey}`);
                    his_self.addMove(`withdraw_to_nearest_fortified_space\t${enemy}\t${spacekey}`);
	            his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
	            his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);
		    his_self.endTurn();
		  },

	    	  () => { his_self.playerPlayPapacyDiplomacyPhaseSpecialTurn(); } , 

	    	  true 

	  	);

	      }

	    });

	  }

	  if (method === "sue") {

	    //
	    // factions no longer At War
	    //
	    his_self.addMove("unset_enemies\tpapacy\t"+enemy);
	    // unset activated power for protestants in 2P
	    if (his_self.isActivatedPower("protestant", enemy) && (enemy === "hapsburg" || enemy === "france")) {
	      his_self.addMove("unset_activated_power\tprotestant\t"+enemy);
	    }

	    //
	    // protestants get War Winner 1 VP
	    //
	    his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
            his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);

	    //
	    // papacy removes 2 units
	    //
            his_self.playerSelectSpaceOrNavalSpaceWithFilter(
              `Select Space to Remove 1st Unit` ,
              function(space) {
	        if (space.units["papacy"].length > 0) { return 1; }
		return 0;
              },
              function(spacekey) {
	        let land_or_sea = "land";
	        let space = null;
	        if (his_self.game.navalspaces[spacekey]) {
	  	  land_or_sea = "sea";
		  space = his_self.game.navalspaces[spacekey];
	        } else {
		  space = his_self.game.spaces[spacekey];
	        }
	        if (space == null) {
		  alert("ERROR: not sure where you clicked - reload to continue");
		  return 1;
	        }
	        let faction_to_destroy = "papacy";
   	        let msg = "Destroy Which Unit: ";
                let unittypes = [];
                let html = '<ul>';
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].command_value == 0 && space.units[faction_to_destroy][i].personage != true) {
                    if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                      html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                      unittypes.push(space.units[faction_to_destroy][i].key);
                    }
                  }
                }
                html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);
                $('.option').off();
                $('.option').on('click', function () {
                  let unittype = $(this).attr("id");
		  his_self.updateStatus("removing unit...");
                  his_self.removeUnit(faction_to_destroy, spacekey, unittype);
                  his_self.displaySpace(spacekey);
                  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
	    	  //
	          // papacy removes 2 units
	          //
                  his_self.playerSelectSpaceOrNavalSpaceWithFilter(
                    `Select Space to Remove 2nd Unit` ,
                    function(space) {
	              if (space.units["papacy"].length > 0) { return 1; }
		      return 0;
                    },
                    function(spacekey) {

		      his_self.updateStatus("removing unit...");

	              let land_or_sea = "land";
	              let space = null;
	              if (his_self.game.navalspaces[spacekey]) {
	  	        land_or_sea = "sea";
		        space = his_self.game.navalspaces[spacekey];
	              } else {
		        space = his_self.game.spaces[spacekey];
	              }
	              if (space == null) {
		        alert("ERROR: not sure where you clicked - reload to continue");
		        return 1;
	              }
	              let faction_to_destroy = "papacy";
   	              let msg = "Destroy Which Unit: ";
                      let unittypes = [];
                      let html = '<ul>';
                      for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                        if (space.units[faction_to_destroy][i].personage != true && space.units[faction_to_destroy][i].battle_rating != 1) {
                         if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                            html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                            unittypes.push(space.units[faction_to_destroy][i].key);
                          }
                        }
                      }
                      html += '</ul>';
                      his_self.updateStatusWithOptions(msg, html);
                      $('.option').off();
                      $('.option').on('click', function () {
                        let unittype = $(this).attr("id");
		        his_self.updateStatus("removing unit...");
                        his_self.removeUnit(faction_to_destroy, spacekey, unittype);
                        his_self.displaySpace(spacekey);
                        his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
			let z = false;
                        his_self.addMove("player_play_papacy_regain_spaces_for_vp\t"+enemy);
		        his_self.endTurn();
		      });
	            },
	            0 ,
	            1
	          );
		});
	      },
	      0 ,
	      1
	    );
	  }	
	});
      });
    });

    return 0;

  }



  playerRegainLeadersForVPOrCards(loser, winner) {
 
    let his_self = this;
    let target_leaders = [];

    if (!f.includes(io[i])) {
      for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
        if (his_self.game.state.players_info[p2-1].captured[z].faction == loser) {
          target_leaders.push(his_self.game.state.players_info[p2-1].captured[z]);
        }
      }
    } 
   
    let msg = "Regain Leader for 1 VP or 1 CARD DRAW: ";
    let opt = "<ul>";
    for (let z = 0; z < target_leaders.length; z++) {
      opt += `<li class="option" id="${z}">${target_leaders[z].type}</li>`;
    }
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let leader = $(this).attr('id');
      
      if (prize == "skip") {
	his_self.endTurn();
	return;
      }

      his_self.addMove("display_vp_track");
      if (target_leaders.length > 1) {
        his_self.addMove(`war_loser_regain_leaders_for_vp_or_cards\t${loser}\t${winner}`);
      }
      his_self.addMove("ransom\t"+leader);
      his_self.endTurn();
    });

  }




  playerRegainSpacesForVPOrCards(loser, winner) {
 
    let his_self = this;
    let target_spaces = his_self.countSpacesWithFilter(function(space) { if (space.home == loser && space.political == winner) { return 1; } return 0; });
    let target_faction = winner;

    let msg = "Do you wish to Regain TWO Non-Key Home Spaces for 1 VP or 1 CARD DRAW: ";
    let opt = "<ul>";
    opt += `<li class="option" id="vp">regain and give VP</li>`;
    opt += `<li class="option" id="card">regain and give card</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      let prize = $(this).attr('id');
      
      if (prize == "skip") {
	his_self.endTurn();
	return;
      }

      his_self.playerSelectSpaceWithFilter(
        "Select First Home Space to Recapture" ,
        function(space) {
          if (space.type != "key" && space.home === loser && space.political == winner) {
	    return 1;
	  }
	},
      	function(spacekey1) {

          his_self.playerSelectSpaceWithFilter(
            "Select First Home Space to Recapture" ,
            function(space) {
	      if (space.key != spacekey1 && space.type != "key" && space.home === loser && space.political == winner) {
	        return 1;
	      }
	    },
      	    function(spacekey2) {
	      if (target_spaces >= 4) {
                his_self.addMove(`war_loser_regain_spaces_for_vp_or_cards\t${loser}\t${winner}`);
	      }

              his_self.addMove("display_vp_track");
              his_self.addMove(`control\t${loser}\t${spacekey2}`);
              his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey2}`);
              his_self.addMove(`control\t${loser}\t${spacekey1}`);
              his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey1}`);

	      if (prize == "vp") {
	        let target_faction = winner;
                if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
                if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
                if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
                if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
                if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
                if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }
	      } else {
                his_self.addMove("pull_card\t"+winner+"\t"+loser);
	      }
	      his_self.endTurn();
	    },
	    null,
	    true,
	  );
	},
	null,
	true
      );
    });
  }




   playerRegainKeysForVP(loser, winner) {

    let his_self = this; 
    let captured_keys = 0;

    let spaces = his_self.returnSpacesWithFilter(
      function(spacekey) {
	if (his_self.game.spaces[spacekey].type == "key" && his_self.game.spaces[spacekey].home == loser && his_self.game.spaces[spacekey].political == winner) { return true; }
        return false;
      }
    ); 

    captured_keys = spaces.length;

    if (spaces.length == 0) {
      his_self.endTurn();
      return;
    }

    let msg = "Do you wish to Regain Home Keys for 1 VP Each: ";
    let opt = "<ul>";
    opt += `<li class="option" id="regain">regain and give VP</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "skip") {
	his_self.endTurn();
	return;
      }

      if (id === "regain") {
        his_self.playerSelectSpaceWithFilter(

          "Select Home Key to Recapture" ,

          function(space) {
	    if (space.type == "key" && space.home === loser && space.political == winner) {
	      return 1;
	    }
	  },

      	  function(spacekey) {

            his_self.addMove("display_vp_track");

	    if (captured_keys > 1) {
              his_self.addMove(`control\t${loser}\t${spacekey}`);
	    }

            his_self.addMove(`control\t${loser}\t${spacekey}`);
            his_self.addMove(`withdraw_to_nearest_fortified_space\t${winner}\t${spacekey}`);

	    let target_faction = winner;
            if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
            if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
            if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
            if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
            if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
            if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }

	    his_self.endTurn();
	  },

	  null,

	  true 

        );

      }

    });


   }

   playerPlayPapacyRegainSpacesForVP(faction) {

    let his_self = this; 

    let spaces = his_self.returnSpacesWithFilter(
      function(spacekey) {
	if (his_self.game.spaces[spacekey].home == "papacy" && his_self.game.spaces[spacekey].political == faction) { return true; }
        return false;
      }
    ); 

    if (spaces.length == 0) {
      his_self.endTurn();
      return;
    }

    let msg = "Do you wish to Regain Home Space for 1 VP: ";
    let opt = "<ul>";
    opt += `<li class="option" id="regain">regain and give VP</li>`;
    opt += `<li class="option" id="skip">skip</li>`;
    opt += '</ul>';

    this.updateStatusWithOptions(msg, opt);

    $(".option").off();
    $(".option").on('click', function () {

      $(".option").off();
      let id = $(this).attr('id');

      if (id === "skip") {
	his_self.endTurn();
	return;
      }

      if (id === "regain") {
        his_self.playerSelectSpaceWithFilter(

          "Select Home Space to Recapture" ,

          function(space) {
	    if (space.home === "papacy" && space.political !== "papacy") {
	      return 1;
	    }
	  },

      	  function(spacekey) {
            his_self.addMove("display_vp_track");
            his_self.addMove(`control\tpapacy\t${spacekey}`);
            his_self.addMove(`withdraw_to_nearest_fortified_space\t${faction}\t${spacekey}`);
	    his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`);
	    his_self.addMove(`NOTIFY\tProtestants +1 War Winner VP`);
	    his_self.endTurn();
	  },

	  null,

	  true 

        );

      }

    });

  }

  //
  // if we move into this function, we HAVE to endTurn() as we have a RESOLVE
  //
  playerReturnWinterUnits(faction) {

    let his_self = this;

    his_self.game.state.returning_winter_units = true;

    let capitals = this.returnCapitals(faction);
    let viable_capitals = [];
    let units_to_move = [];
    let cancel_func = null;

    let processed_spacekeys = [];
    let selected_destination = "";
    let source_spacekey = "";

    for (let i = 0; i < capitals.length; i++) {
      let c = capitals[i];
      if (this.isSpaceControlled(c, faction)) {
        if (!this.isSpaceInUnrest(c)) {
          viable_capitals.push(capitals[i]);
        }
      }
    }

    var finish_selecting_from_space_function = function() {};
    var select_units_function = function() {};
    var pick_capital_function = function() {};
    var select_spacekey_function = function() {};

    finish_selecting_from_space_function = function(his_self, units_to_move) {

      his_self.updateStatus("processing...");

      processed_spacekeys.push(source_spacekey);

      for (let i = 0; i < units_to_move.length; i++) {
        his_self.removeUnit(units_to_move[i].faction, units_to_move[i].spacekey, units_to_move[i].type);
        his_self.addMove("remove_unit\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+units_to_move[i].spacekey+"\t"+his_self.game.player);
        if (!capitals.includes(units_to_move[i].spacekey)) {
          his_self.addMove("build\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+selected_destination+"\t"+0);
	} else {
          his_self.addMove("build\tland\t"+units_to_move[i].faction+"\t"+units_to_move[i].type+"\t"+units_to_move[i].spacekey+"\t"+0);
	}
      }

      //
      // reset !
      //
      units_to_move = [];

      his_self.displayBoard();

      let count = his_self.countSpacesWithFilter((space) => {
        if (
          his_self.returnFactionLandUnitsAndLeadersInSpace(faction, space.key) > 0 &&
	  !capitals.includes(space.key) && 
	  !processed_spacekeys.includes(space.key)
	) { return 1; }
        return 0;
      });

      //
      // no viable spaces, so we exit
      //
      if (count == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " no more spaces with units to withdraw");
        his_self.endTurn(); 
        return;
      }

      let msg = his_self.returnFactionName(faction) + " - Winter Return to Capital?";
      if (viable_capitals.length == 1) { msg = his_self.returnFactionName(faction) + " - Winter Recall to " + his_self.returnSpaceName(viable_capitals[0]) + "?"; }
      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
	if (viable_capitals.length == 1) {
          opt += `<li class="option" id="${viable_capitals[i]}">yes</li>`;
	} else {
          opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
        }
      }
      opt += `<li class="option" id="finish">skip / finish</li>`;
      opt += '</ul>';

      his_self.updateStatusWithOptions(msg, opt);
      his_self.theses_overlay.pushHudUnderOverlay();

      $(".option").off();
      $(".option").on('click', function () {

        let id = $(this).attr('id');

        if (id == "finish") {
          his_self.updateStatus("processing winter relocation...");
          his_self.theses_overlay.hide();
          his_self.endTurn();
          return;
        }

        selected_destination = id;
        select_spacekey_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);
      });

    }


    select_units_function = function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function) {

      let unmoved_units = [];
      let moved_units = [];

      let space = his_self.game.spaces[source_spacekey];
      let max_formation_size = 100;
      let msg = his_self.returnFactionName(faction) + " - Select from " + his_self.returnSpaceName(source_spacekey);

      let html = "<ul>";

      for (let i = 0; i < space.units[faction].length; i++) {
        let u = space.units[faction][i];
        if (u.type != "corsair" && u.reformer != true && u.type != "squadron") {
	  let does_units_to_move_have_unit = false;
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].faction == faction && units_to_move[z].idx == i && units_to_move[z].spacekey == source_spacekey) { does_units_to_move_have_unit = true; break; }
	  }
	  if (does_units_to_move_have_unit) {
	    html += `<li class="option" style="font-weight:bold" id="${faction}-${i}">*${u.name} (${faction})*</li>`;
	    moved_units.push({ spacekey : source_spacekey , faction : faction , idx : i , type : u.type });
	  } else {
	    html += `<li class="option" id="${faction}-${i}">${u.name} (${faction})</li>`;
	    unmoved_units.push({ spacekey : source_spacekey, faction : faction , idx : i , type : u.type });
	  }
	}
      }

      let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : source_spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : selected_destination ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	    selectUnitsInterface : select_units_function ,
	    selectDestinationInterface : finish_selecting_from_space_function ,
      }

      his_self.movement_overlay.renderForceOpen(mobj, units_to_move, select_units_function, finish_selecting_from_space_function); // no destination interface
      his_self.movement_overlay.pushHudUnderOverlay();

      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";


      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

        if (id == "end") {
	    his_self.movement_overlay.hide();
	    finish_selecting_from_space_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);
	    return;
	}

	let x = id.split("-");
	let f = x[0];
	let idx = parseInt(x[1]);

	let does_units_to_move_have_unit = false;
	for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].spacekey == source_spacekey && units_to_move[z].faction == f  && units_to_move[z].idx == idx) {
	      does_units_to_move_have_unit = true; 
	      break; 
	    }
	}

	if (does_units_to_move_have_unit) {
	  for (let z = 0; z < units_to_move.length; z++) {
	    if (units_to_move[z].spacekey == source_spacekey && units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	      units_to_move.splice(z, 1);
	      his_self.available_units_overlay.fadeOut(true);
	      break;
	    }
	  }
	  if (units_to_move.length == 0) {
	    his_self.available_units_overlay.faded_out = false;
	  }
	} else {
          units_to_move.push( { spacekey : source_spacekey , faction : f , idx : idx , type : space.units[f][idx].type });
	}

	select_units_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);

      });
    }
  


    select_spacekey_function = function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function) {

      //
      // reset u2m
      //
      units_to_move = [];

      let count = his_self.countSpacesWithFilter((space) => {
        if (
          his_self.returnFactionLandUnitsInSpace(faction, space.key) > 0 &&
	  !capitals.includes(space.key) && 
	  !processed_spacekeys.includes(space.key)
	) { return 1; }
        return 0;
      });

      //
      // no viable spaces, so we exit
      //
      if (count == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " no more spaces with units to withdraw");
        his_self.endTurn(); 
        return;
      }

      if (faction == "protestant") { his_self.theses_overlay.render("german"); }
      if (faction == "papacy") { his_self.theses_overlay.render("italian"); }
      if (faction == "england") { his_self.theses_overlay.render("english"); }
      if (faction == "france") { his_self.theses_overlay.render("french"); }
      if (faction == "hapsburg") { his_self.theses_overlay.render("spanish"); }
      if (faction == "ottoman") { his_self.theses_overlay.render("ottoman"); }
      his_self.theses_overlay.pushHudUnderOverlay();

      his_self.playerSelectSpaceWithFilter(

        "Select Location to Move Units",

        //
        // any fortified non-capital space
        //
        function(space) {
          if (
            his_self.returnFactionLandUnitsAndLeadersInSpace(faction, space.key) > 0 &&
	    !capitals.includes(space.key) && 
	    !processed_spacekeys.includes(space.key)
	  ) { return 1; }
          return 0;
        },

        //
        // launch unit selection overlay
        //
        function(spacekey) {
	  source_spacekey = spacekey;
	  select_units_function(his_self, units_to_move, select_units_function, pick_capital_function, select_spacekey_function, finish_selecting_from_space_function);
        },
        null ,
        1 
      );
    }

    pick_capital_function = function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function) {

      let msg = his_self.returnFactionName(faction) + " - Winter Recall to Capital?";
      if (viable_capitals.length == 1) { msg = his_self.returnFactionName(faction) + " - Winter Recall to " + his_self.returnSpaceName(viable_capitals[0]) + "?"; }
      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
	if (viable_capitals.length == 1) {
          opt += `<li class="option" id="${viable_capitals[i]}">yes</li>`;
	} else {
          opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
        }
      }
      opt += `<li class="option" id="finish">finish</li>`;
      opt += '</ul>';

      if (viable_capitals.length == 0) {
        his_self.updateStatus(his_self.returnFactionName(faction) + " skipping wintering in capital");
        his_self.endTurn(); 
	return;
      }

      if (faction == "protestant") { his_self.theses_overlay.render("german"); }
      if (faction == "papacy") { his_self.theses_overlay.render("italian"); }
      if (faction == "england") { his_self.theses_overlay.render("english"); }
      if (faction == "france") { his_self.theses_overlay.render("french"); }
      if (faction == "hapsburg") { his_self.theses_overlay.render("spanish"); }
      if (faction == "ottoman") { his_self.theses_overlay.render("ottoman"); }
      his_self.theses_overlay.pushHudUnderOverlay();
      his_self.updateStatusWithOptions(msg, opt);
console.log("just attached options.... should be selectable..");

      $(".option").off();
      $(".option").on('click', function () {
        let id = $(this).attr('id');
	if (id == "finish") {
	  his_self.updateStatus("processing winter relocation...");
	  his_self.theses_overlay.hide();
	  his_self.endTurn();
	  return;
	}
        selected_destination = id;
        select_spacekey_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);
      });

    }

    //
    // start the magic
    //
    pick_capital_function(his_self, pick_capital_function, select_spacekey_function, select_units_function, finish_selecting_from_space_function);

  }

  playerPlaySpringDeployment(faction, player, removed_queue_instruction="") {

    let his_self = this;

    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("RESOLVE\t"+this.publicKey); his_self.playerPlaySpringDeployment(faction, player, removed_queue_instruction); });

    let capitals = this.returnCapitals(faction);
    let viable_capitals = [];
    let can_deploy = 0;
    let units_to_move = [];
    let cancel_func = null;
    let source_spacekey;
    let does_faction_have_spring_preparations = false;

    //
    // Spring Preparations 102
    //
    let fhand_idx = his_self.returnFactionHandIdx(his_self.game.player, faction);
    for (let z = 0; z < his_self.game.deck[0].fhand[fhand_idx].length; z++) {
      if (his_self.game.deck[0].fhand[fhand_idx][z] === "102") {
	does_faction_have_spring_preparations = true;
	let controls_capital = false;
        for (let i = 0; i < capitals.length; i++) {
          if (his_self.isSpaceControlled(capitals[i], faction)) {
	    controls_capital = true;
	  }
        }
	if (!controls_capital) { does_faction_have_spring_preparations = false; }
      }
    }

    for (let i = 0; i < capitals.length; i++) {
      let c = capitals[i];
      if (this.game.spaces[c].units[faction].length > 0) {
        if (this.game.spaces[c].unrest == 0) {
          can_deploy = 1;
          viable_capitals.push(capitals[i]);
        }
      }
    }

    if (can_deploy == 0) {
      this.updateStatus("Spring Deployment not possible");
      this.endTurn();
    } else {

      let msg = this.returnFactionName(faction) + " - Spring Deploy from:";     
      if (faction === "ottoman") { msg = "Ottomans - Spring Deploy from?"; }

      let opt = "<ul>";
      for (let i = 0; i < viable_capitals.length; i++) {
	opt += `<li class="option" id="${viable_capitals[i]}">${viable_capitals[i]}</li>`;
      }
      if (does_faction_have_spring_preparations == true) {
	opt += `<li class="option showcard" id="102">Spring Preparations</li>`;
      }
      opt += `<li class="option" id="pass">skip</li>`;
      opt += '</ul>';


      his_self.spring_deployment_overlay.render(faction);
      his_self.spring_deployment_overlay.pushHudUnderOverlay();

      this.updateStatusWithOptions(msg, opt);

      $(".option").off();
      $(".option").on('click', function () {

        let id = $(this).attr('id');

	his_self.cardbox.hide();

	if (id == "102") {
	  // remove RESOLVE, we want to play and re-trigger, including adding extra
	  his_self.moves = [];	  
	  if (removed_queue_instruction != "") { his_self.addMove(removed_queue_instruction); }
	  his_self.addMove("discard\t"+faction+"\t"+"102");
	  his_self.addMove("spring_preparations\t"+faction);
	  his_self.addMove("hide_overlay\tspring_deployment");
	  his_self.cardbox.hide();
	  his_self.endTurn();
	  return;
	}

	source_spacekey = id;
        $(".option").off();
        his_self.spring_deployment_overlay.hide();

	if (id === "pass") {
	  his_self.updateStatus("passing...");
	  his_self.endTurn();
	  return;
        }

        his_self.playerSelectSpaceWithFilter(

          "Select Destination for Units from Capital: ",

          function(space) {
            if (his_self.isSpaceFriendly(space, faction)) {
	      // 2 = transit seas
	      // source_spacekey => connect to this capital
	      if (space.unrest) { return 0; }
              if (his_self.isSpaceConnectedToCapitalSpringDeployment(space, faction, 2, source_spacekey)) { // 2 = no independent or enemy ships
                if (!his_self.isSpaceFactionCapital(space, faction)) {
		  if (his_self.game.state.events.schmalkaldic_league == 0) {
		    if (his_self.isSpaceElectorate(space.key)) {
		      return 0;
		    }
		  }
                  return 1;
		}
              }
            }
            return 0;
          },

          function(destination_spacekey) {

            let space = his_self.spaces[source_spacekey];

	    //
	    // spring deployment doesn't have this, so we wrap the sending/end-move
	    // action in this dummy function so that the same UI can be used for 
	    // multiple movement options, with the normal one including intervention
	    // checks etc.
	    //
	    let selectDestinationInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	      // MOVE THE UNITS
	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

              for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+source_spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
              }

	      his_self.unbindBackButtonFunction();

              //his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" spring deploys to "+his_self.game.spaces[destination_spacekey].name);
              his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;
              return;

	    };

            let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) { 
              let unmoved_units = [];
              let moved_units = [];
	      let space = his_self.game.spaces[source_spacekey];

	      let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, source_spacekey);
	      if (faction != his_self.game.state.events.spring_preparations) { 
  		if (his_self.isSpaceConnectedToCapitalSpringDeployment(destination_spacekey, faction, 0) == 0) {
		  if (max_formation_size > 5) { max_formation_size = 5; } 
	        }
  	      }

	      let msg = "Max Formation Size: " + max_formation_size + " units";
	      let html = '<ul>';

	      for (let key in space.units) {
                if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
                  for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
                    if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
                    if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
                      let does_units_to_move_have_unit = false;
                      for (let z = 0; z < units_to_move.length; z++) {
                        if (units_to_move[z].faction == key && units_to_move[z].idx == i) { 
does_units_to_move_have_unit = true; }
		      }
                      if (does_units_to_move_have_unit) {
                        html += `<li class="option" style="font-weight:bold" id="${key}-${i}">*${space.units[key][i].name} (${key})*</li>`;
                        moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
                      } else {
                        html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
                        unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
                      }
                    }
                    }
                    }
                  }
                }
	      }

              let mobj = {
                space : space ,
                faction : faction ,
                source : source_spacekey ,
                unmoved_units : unmoved_units ,
                moved_units : moved_units ,
                destination : destination_spacekey ,
		units_to_move : units_to_move ,
		max_formation_size : max_formation_size ,
              }


	      //
	      // auto-move if only 1 unit
	      //
	      let can_we_quick_move = false;
	      if (mobj.moved_units.length == 0 && mobj.unmoved_units.length == 1) { can_we_quick_move = true; } 

	      if (can_we_quick_move == false) {
   	        his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
              }

	      html += `<li class="option" id="end">finish</li>`;
              html += "</ul>";

              his_self.updateStatusWithOptions(msg, html);

              $('.option').off();
              $('.option').on('click', function () {

                let id = $(this).attr("id");

	        if (id === "end") {
	          his_self.movement_overlay.hide();
	          selectDestinationInterface(his_self, units_to_move);
	          return;
	        }

	        let x = id.split("-");
	        let f = x[0];
	        let idx = parseInt(x[1]);

	        let uob = his_self.returnOnBoardUnits(f);

	        let does_units_to_move_have_unit = false;
	        for (let z = 0; z < units_to_move.length; z++) {
	          if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		    does_units_to_move_have_unit = true;
		    break;
		  }
	        }

	        if (does_units_to_move_have_unit) {

	          if (uob.overcapacity == 1) {
	            alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of manually re-assigning by numbers");
		    his_self.spring_deployment_overlay.hide();
		    his_self.playerPlaySpringDeployment(faction, player, removed_queue_instruction);
	            return;
	          }

	          for (let z = 0; z < units_to_move.length; z++) {
	            if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		      units_to_move.splice(z, 1);
	              his_self.available_units_overlay.fadeOut(true);
		      break;
		    }
	          }
	        } else {

	          if (uob.overcapacity == 1) {
	            alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of manually re-assigning by numbers");
		    his_self.spring_deployment_overlay.hide();
		    his_self.playerPlaySpringDeployment(faction, player, removed_queue_instruction);
	            return;
	          }


	          //
	          // check for max formation size
	          //
	          let unitno = 0;
	          for (let i = 0; i < units_to_move.length; i++) {
	            if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	            if (unitno >= max_formation_size) { 
		      max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	              if (unitno >= max_formation_size) { 
	                alert("Maximum Formation Size: " + max_formation_size);
	                return;
		      }
	            }
	          }

	          units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	        }

                selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);

              });

	      if (can_we_quick_move) {
		units_to_move = JSON.parse(JSON.stringify(mobj.unmoved_units));
	        selectDestinationInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	        his_self.displaySpace(source_spacekey);
	        his_self.displaySpace(destination_spacekey);
		his_self.updateStatus("deploying...");
		return;
	      }
            }

            selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
          },

	  null ,

	  true

        );
      });
    }
  }

  returnMaxFormationSize(units_to_move, faction = "", spacekey = "") {

    let utm = [];
    if (units_to_move.length > 0) {
      if (typeof units_to_move[0] != "number") {
	for (let z = 0; z < units_to_move.length; z++) {
	  if (units_to_move[z].type && !units_to_move[z].owner) {
	    let added = 0;
	    for (let y = 0; added == 0 && y < this.game.spaces[spacekey].units[units_to_move[z].faction].length; y++) {
	      let u = this.game.spaces[spacekey].units[units_to_move[z].faction][y];
	      if (u.type !== "regular" && u.type !== "mercenary" && u.type !== "cavalry" && u.type !== "corsair" && u.type !== "squadron") {
		if (u.type === units_to_move[z].type) {
	    	  utm.push(this.game.spaces[spacekey].units[units_to_move[z].faction][y]);
		  added = 1;
		}
	      }
	    }
	    if (added == 0) {
	      utm.push(this.game.spaces[spacekey].units[units_to_move[z].faction][units_to_move[z].idx]);
	    }
	  } else {
	    utm.push(units_to_move[z]);
	  }
	}
      } else {
        for (let i = 0; i < units_to_move.length; i++) { utm.push(this.game.spaces[spacekey].units[faction][units_to_move[i]]); }
      }
    }

    let command_value_one = 0;
    let command_value_two = 0;
    let max_command_value = 0;

    for (let i = 0; i < utm.length; i++) {
      if (utm[i].command_value > 0) {
        // we can have up to two army leaders combine command values
	if (command_value_one == 0) {
	  command_value_one = utm[i].command_value; 
	} else {
	  if (command_value_two == 0) {
	    command_value_two = utm[i].command_value;
	  } else {
  	    if (command_value_one > command_value_two && utm[i].command_value > command_value_one) {
	      command_value_one = utm[i].command_value;
	    } else {
	      if (command_value_one < command_value_two && utm[i].command_value > command_value_two) {
	        command_value_two = utm[i].command_value;
	      }
	    }
	  }
	}
	max_command_value = command_value_one + command_value_two;
      }
    }

    if (max_command_value > 4) { return max_command_value; }
    return 4;

  }

  //
  // duplicates playerMoveFormationInClear -- this is the function we hit
  // if we use the shortcut "continue move". the reason we need to duplicate
  // is that the handling of the OPS is slightly different and there is a 
  // spacekey argument in the function call that doesn't exist otherwise.
  //
  async playerContinueToMoveFormationInClear(his_self, player, faction, spacekey, ops_to_spend, ops_remaining=0) {

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining, ""); });

    //
    // we add this before broadcasting, or the turn ends 
    //
    // blank is "card", which we don't care about anymore so don't include
    let continue_move = "continue\t"+this.game.player+"\t"+faction+"\t"+""+"\t"+(ops_remaining-ops_to_spend);

    let parent_faction = faction;
    let units_to_move = [];
    let cancel_func = null;
    let space = this.game.spaces[spacekey];
    let protestant_player = his_self.returnPlayerOfFaction("protestant");
    let parent_player = his_self.returnPlayerCommandingFaction(faction);

	//
	// first define the functions that will be used internally
	//
	let selectDestinationInterface = function(his_self, units_to_move) {  
    	  his_self.playerSelectSpaceWithFilter(

            "Select Destination for these Units",

      	    function(space) {
	      // no-one can move into electorates before schmalkaldic league forms
              if (his_self.game.player != protestant_player && his_self.game.state.events.schmalkaldic_league == 0) {
		if (space.type == "electorate") { return 0; }
	      }
	      // you cannot move into spaces that are not allied or enemies
              if (!his_self.canFactionMoveIntoSpace(faction, space.key)) { return 0; }
	      if (space.neighbours.includes(spacekey)) {
	        if (!space.pass) { 
		  return 1; 
		} else {
 		  if (!space.pass.includes(spacekey)) {
		    return 1;
		  } else {
		    if (ops_remaining > 1) {
		      // we have to flag and say, "this costs an extra op"
		      return 1;
		    } else {
		      return 0;
		    }
		  }
		}
	  	return 1;
              }
	      return 0;
            },

      	    function(destination_spacekey) {

	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});
	
	      let does_movement_include_cavalry = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
		if (units_to_move[i].type === "cavalry") {
		  does_movement_include_cavalry = 1;
		}
	      }

	      //
	      // modify "continue" instruction if this is a move over a pass
	      //
	      let space = his_self.game.spaces[spacekey];
	      if (space.pass) {
		if (space.pass.includes(destination_spacekey)) {
		  let y = continue_move.split("\t");
		  let new_ops_remaining = parseInt(y[4])-1;
	  	  continue_move = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
	        }
	      }

	      //
	      // "skip" interception check if we already have units in this space
	      //
	      if (his_self.returnFactionLandUnitsInSpace(faction, destination_spacekey) > 0) {
	        his_self.addMove("interception_check\t"+"skip"+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
	      } else {
	        his_self.addMove("interception_check\t"+faction+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
	      } 

              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

	      for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
	      }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination_spacekey].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination_spacekey].name + "\tmove\t" + destination_spacekey);
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.prependMove(continue_move);
	      his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;

	    },

	    cancel_func,

	    true 

	  );
	}

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];

          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player && (key == faction || his_self.returnControllingPower(key) == faction)) {
	      for (let i = 0; i < space.units[key].length; i++) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != 1 && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : "" ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = parseInt(x[1]);

	    let uob = his_self.returnOnBoardUnits(f);

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	        does_units_to_move_have_unit = true; 
		break; 
	      }
	    }

	    if (does_units_to_move_have_unit) {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of manually re-assigning by numbers");
		his_self.movement_overlay.hide();
		his_self.playerContinueToMoveFormationInClear(his_self, player, faction, spacekey, ops_to_spend, ops_remaining);
	        return;
	      }

	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		  units_to_move.splice(z, 1);
	          his_self.available_units_overlay.fadeOut(true);
		  break;
		}
	      }

	      if (units_to_move.length == 0) {
		his_self.available_units_overlay.faded_out = false;
	      }

	    } else {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of shifting forces in 1-UNIT increments");
		his_self.movement_overlay.hide();
		his_self.playerContinueToMoveFormationInClear(his_self, player, faction, spacekey, ops_to_spend, ops_remaining);
	        return;
	      }

	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
	}

	//
	// is this a rapid move ?
	//
	let max_formation_size = his_self.returnMaxFormationSize(space.units[faction]);
	let units_in_space = his_self.returnFactionLandUnitsInSpace(faction, space, true); // true ==> include minor allies
	let can_we_quick_move = false;
	if (max_formation_size >= units_in_space) { can_we_quick_move = true; }
	for (let f in space.units) {
	  for (let z = 0; z < space.units[f].length; z++) {
	    if (space.units[f][z].locked == 1) { can_we_quick_move = false; }
	  }
	}

	if (can_we_quick_move == true) {

	  let msg = "Choose Movement Option: ";
	  let html = "<ul>";
	  html += `<li class="option" id="auto">move everything (auto)</li>`;
	  html += `<li class="option" id="manual">select units (manual)</li>`;
	  html += "</ul>";
	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    for (let key in space.units) {
	      if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	        for (let i = 0; i < space.units[key].length; i++) {
	          if (space.units[key][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1 && id === "auto") {
		    alert("Foul Weather: units in this space have already been moved, so movement from this space must happen manually using only unmoved forces");
		    return;
	          }
	        }
	      }
	    }

	    $('.option').off();

	    if (id === "auto") {
	      for (let key in space.units) {
	        if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	          for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].type !== "squadron" && space.units[key][i].type !== "corsair") {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	            if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
		      units_to_move.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	            }
	            }
	          }
	        }
	      }
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    if (id === "manual") {
	      //
	      // we have to move manually
	      //
	      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	      return;
	    }

	  });

	} else {

	  //
	  // we have to move manually
	  //
	  selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  return;

	}

  }

  async playerMoveFormationInClear(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let parent_faction = faction;
    let units_to_move = [];
    let cancel_func = null;
    let spacekey = "";
    let space = null;
    let protestant_player = his_self.returnPlayerOfFaction("protestant");
    let parent_player = his_self.returnPlayerCommandingFaction(faction);

	//
	// first define the functions that will be used internally
	//
	let selectDestinationInterface = function(his_self, units_to_move) {  

    	  his_self.playerSelectSpaceWithFilter(

            "Select Destination for these Units",

      	    function(space) {
	      // no-one can move into electorates before schmalkaldic league forms
              if (his_self.game.player != protestant_player && his_self.game.state.events.schmalkaldic_league == 0) {
		if (space.type == "electorate") { return 0; }
	      }
	      // cannot move into the space you are leaving
	      if (space.key === spacekey) { return 0; }

	      // you cannot move into spaces that are not allied or enemies
              if (!his_self.canFactionMoveIntoSpace(faction, space.key)) { return 0; }
	      if (space.neighbours.includes(spacekey)) {
	        if (!space.pass) { 
		  return 1; 
		} else {
 		  if (!space.pass.includes(spacekey)) {
		    return 1;
		  } else {
		    if (ops_remaining >= 1) {
		      // we have to flag and say, "this costs an extra op"
		      return 1;
		    } else {
		      return 0;
		    }
		  }
		}
	  	return 1;
              }
	      return 0;
            },

      	    function(destination_spacekey) {

	      units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});
	
	      let does_movement_include_cavalry = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
		if (units_to_move[i].type === "cavalry") {
		  does_movement_include_cavalry = 1;
		}
	      }

	      //
	      // modify "continue" instruction if this is a move over a pass
	      //
	      let space = his_self.game.spaces[spacekey];
	      if (space.pass) {
		if (space.pass.includes(destination_spacekey)) {
	          for (let i = 0; i < his_self.moves.length; i++) {
		    let x = his_self.moves[i];
		    let y = x.split("\t");
		    let new_ops_remaining = parseInt(y[4])-1;
		    if (y[0] === "continue") {
		      if (new_ops_remaining) {
	  	        his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
  	  	      } else {
		        his_self.moves.splice(i, 1);
		      }
		    }
	          }
	        }
	      }

	      //
	      // "skip" interception check if we already have units in this space
	      //
	      if (his_self.returnFactionLandUnitsInSpace(faction, destination_spacekey) > 0) {
	        his_self.addMove("interception_check\t"+"skip"+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
	      } else {
	        his_self.addMove("interception_check\t"+faction+"\t"+destination_spacekey+"\t"+does_movement_include_cavalry);
	      } 

              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

	      for (let i = 0; i < units_to_move.length; i++) {
		his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination_spacekey+"\t"+units_to_move[i].idx);
	      }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination_spacekey].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination_spacekey].name + "\tmove\t" + destination_spacekey);
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
	      his_self.endTurn();
	      his_self.available_units_overlay.faded_out = false;

	    },

	    cancel_func,

	    true 

	  );
	}

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];

          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player && (key == faction || his_self.returnControllingPower(key) == faction)) {
	      for (let i = 0; i < space.units[key].length; i++) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != 1 && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : "" ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size , 
	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = parseInt(x[1]);

	    let uob = his_self.returnOnBoardUnits(f);

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
	        does_units_to_move_have_unit = true; 
		break; 
	      }
	    }

	    if (does_units_to_move_have_unit) {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of manually re-assigning by numbers");
		his_self.movement_overlay.hide();
		his_self.playerMoveFormationInClear(his_self, player, faction, ops_to_spend, ops_remaining);
	        return;
	      }

	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) {
		  units_to_move.splice(z, 1);
	          his_self.available_units_overlay.fadeOut(true);
		  break;
		}
	      }

	      if (units_to_move.length == 0) {
		his_self.available_units_overlay.faded_out = false;
	      }

	    } else {

	      if (uob.overcapacity == 1) {
	        alert("This faction is over-capacity (no more free 1-UNIT tokens). Please move by clicking on the circular tokens you wish to move instead of shifting forces in 1-UNIT increments");
		his_self.movement_overlay.hide();
		his_self.playerMoveFormationInClear(his_self, player, faction, ops_to_spend, ops_remaining);
	        return;
	      }

	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
	}
	//
	// end select units
	//


    his_self.playerSelectSpaceWithFilter(

      "Select Town from which to Move Units:",

      function(space) {
	let num_moveable = 0;
	if (space.key == "persia" || space.key == "egypt" || space.key == "ireland") { return 0; }
	if (space.besieged == 2) { return 0; } // you cannot move from a town just placed under siege

        //
        // no moving if you are besieged
        //
	if (space.besieged == 1) { 
	  for (let z in space.units) {
	    if (his_self.returnPlayerCommandingFaction(z) == his_self.game.player) {
	      for (let i = 0; i < space.units[z].length; i++) {
	        let u = space.units[z][i];
	        if (u.besieged == 1) { return 0; }
	      }
	    }
	  }
	}

	for (let z in space.units) {
	  if (space.units[z].length > 0 && his_self.returnPlayerCommandingFaction(z) == his_self.game.player && (z == faction || his_self.returnControllingPower(z) == faction)) {
	    //
	    // Foul Weather prevents spaces with already moved units
	    //
	    let army_and_navy_leaders = 0;
            if (his_self.returnPlayerCommandingFaction(z) == his_self.game.player) {
              for (let i = 0; i < space.units[z].length; i++) {
	        if (space.units[z][i].locked != 1) {
		  if (space.units[z][i].type === "cavalry") { num_moveable++; }
		  if (space.units[z][i].type === "regular") { num_moveable++; }
		  if (space.units[z][i].type === "mercenary") { num_moveable++; }
		  if (space.units[z][i].battle_rating > 0) { army_and_navy_leaders++; num_moveable++; }
                  if (space.units[z][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1) {
	            num_moveable--;
                  }
                }
              }
	      if (num_moveable <= 0) {
		return 0;
	      }
	      if (army_and_navy_leaders == num_moveable) {
		return 0;
	      }
            }

	    return 1;
	  }
	}
	return 0;
      },

      function(skey) {

	spacekey = skey;

        let space = his_self.game.spaces[spacekey];

	//
	// is this a rapid move ?
	//
	let max_formation_size = his_self.returnMaxFormationSize(space.units[faction]);
	let units_in_space = his_self.returnFactionLandUnitsInSpace(faction, space, true); // true ==> include minor allies
	let can_we_quick_move = false;
	if (max_formation_size >= units_in_space) { can_we_quick_move = true; }
	for (let f in space.units) {
	  for (let z = 0; z < space.units[f].length; z++) {
	    if (space.units[f][z].locked == 1) { can_we_quick_move = false; }
	  }
	}

	if (can_we_quick_move == true) {

	  let msg = "Choose Movement Option: ";
	  let html = "<ul>";
	  html += `<li class="option" id="auto">move everything (auto)</li>`;
	  html += `<li class="option" id="manual">select units (manual)</li>`;
	  html += "</ul>";
	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    for (let key in space.units) {
	      if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	        for (let i = 0; i < space.units[key].length; i++) {
	          if (space.units[key][i].already_moved == 1 && his_self.game.state.events.foul_weather == 1 && id === "auto") {
		    alert("Foul Weather: units in this space have already been moved, so movement from this space must happen manually using only unmoved forces");
		    return;
	          }
	        }
	      }
	    }

	    $('.option').off();

	    if (id === "auto") {
	      for (let key in space.units) {
	        if (his_self.returnPlayerCommandingFaction(key) == his_self.game.player) {
	          for (let i = 0; i < space.units[key].length; i++) {
	            if (space.units[key][i].type !== "squadron" && space.units[key][i].type !== "corsair") {
	            if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	            if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
		      units_to_move.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	            }
	            }
	          }
	        }
	      }
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    if (id === "manual") {
	      //
	      // we have to move manually
	      //
	      selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	      return;
	    }

	  });

	} else {

	  //
	  // we have to move manually
	  //
	  selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  return;

	}
      },

      cancel_func,

      true,

    );

  }

  //
  // players select a card with at least [cost] ops. this respects the "cannot pay with mandatory cards"
  // limitation.
  //
  canPlayerSelectOps(faction, cost) {

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (this.game.deck[0].cards[c].type != "mandatory" && this.game.deck[0].cards[c].ops >= cost) {
	return 1;
      }
    }

    return 0;
  }
  playerSelectOps(faction, cost, mycallback=null, optional_msg="", ignore_cards=[]) {

    let his_self = this;

    let faction_hand_idx = this.returnFactionHandIdx(this.game.player, faction);

    let cards = [];
    for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
      let c = this.game.deck[0].fhand[faction_hand_idx][i];
      if (this.game.deck[0].cards[c].type != "mandatory" && this.game.deck[0].cards[c].ops >= cost) {
	if (!ignore_cards.includes(c)) {
          cards.push(c);
	}
      }
    }

    if (optional_msg == "") { optional_msg = "Select a Card: "; }
    this.updateStatusAndListCards(optional_msg, cards);
    this.attachCardboxEvents((card) => {
      try {
        $('.card').off();
        $('.card img').off();
      } catch (err) {}
      mycallback(card);
    });  

  }


// faction is the attacker in pre-naval battles, but it should be the defender
//            this.playerEvaluateNavalRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey, defender);
//
// post battle this is:
//
// this.playerEvaluateNavalRetreatOpportunity(loser, spacekey, "", loser, true); 
//
  playerEvaluateNavalRetreatOpportunity(faction, spacekey, player_comes_from_this_spacekey="", defender="", post_battle=false) {

    let his_self = this;
    let retreat_destination = "";

    let is_port_battle = false;
    let space;
    if (his_self.game.spaces[spacekey]) { is_port_battle = true; space = his_self.game.spaces[spacekey]; }
    if (his_self.game.navalspaces[spacekey]) { space = his_self.game.navalspaces[spacekey]; }

    let neighbours = this.returnNavalAndPortNeighbours(spacekey);
    let retreat_options = 0;
    for (let i = 0; i < neighbours.length; i++) {
      if (his_self.canFactionRetreatToNavalSpace(faction, neighbours[i])) {
	retreat_options++;
      }
    }

    let surviving_units = 0;
    for (let f in space.units) {
      let cf = this.returnControllingPower(f);
      if (cf == faction || f == faction || this.areAllies(f, faction)) {
        for (let i = 0; i < space.units[f].length; i++) {
	  let u = space.units[f][i];
	  if (u.type == "squadron" || u.type == "corsair") {
	    surviving_units++;
	  }
	}
      }
    }

    if (surviving_units == 0) {
      his_self.updateLog("No units survive to retreat...");
      his_self.endTurn();
      return 0;
    }


    if (retreat_options == 0) {
      his_self.updateLog("Naval retreat not possible...");
      his_self.endTurn();
      return 0;
    }

    let onFinishSelect = function(his_self, destination_spacekey) {
      for (let f in space.units) {
        let cf = his_self.returnControllingPower(f);
        if (cf == faction || f == faction) {
	  if (post_battle) { 
	    // 1 at the end = lock the retreating units
            his_self.addMove("naval_retreat"+"\t"+f+"\t"+spacekey+"\t"+destination_spacekey+"\t1");
	  } else {
            his_self.addMove("naval_retreat"+"\t"+f+"\t"+spacekey+"\t"+destination_spacekey);
	  }
	}
      }
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {
      let available_destinations = false;
      let html = "<ul>";
      for (let i = 0; i < neighbours.length; i++) {
        if (his_self.canFactionRetreatToNavalSpace(defender, neighbours[i])) {
          available_destinations = true;
          html += `<li class="option" id="${neighbours[i]}">${his_self.returnSpaceName(neighbours[i])}</li>`;
	}
      }
      if (available_destinations == false) {
        html += `<li class="option" id="skip">skip (no options)</li>`;
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Naval Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");

	his_self.updateStatus("retreating...");

	if (id === "skip") {
	  his_self.endTurn();
	  return;
	}
        onFinishSelect(his_self, id);
      });
    };


    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">do not retreat</li>`;
    html    += `</ul>`;

    if (post_battle) {
      if (this.game.state.events.unexpected_war == 1) {
        this.updateStatusWithOptions(`${this.returnFactionName(faction)} must retreat. Retreat?`, html);
      } else {
	if (is_port_battle) {
          this.updateStatusWithOptions(`${this.returnFactionName(faction)} must retreat from Port Assault. Retreat?`, html);
	} else {
          this.updateStatusWithOptions(`${this.returnFactionName(faction)} loses the battle. Retreat?`, html);
	}
      }
    } else {
      this.updateStatusWithOptions(`${this.returnFactionName(defender)} - ${this.returnFactionName(faction)} approaches ${this.returnSpaceName(spacekey)}. Retreat?`, html);
      //
      // pre-battle, this swap is NEEDED as faction is what retreats
      //
      faction = defender;
    }
    this.attachCardboxEvents(function(user_choice) {

      if (user_choice === "retreat") {
        his_self.updateStatus("retreating...");
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	if (post_battle) {
          his_self.updateStatus("fleet is sacrificed...");
          his_self.addMove("destroy_faction_units_in_spacekey\t"+faction+"\t"+spacekey);
	} else {
          his_self.updateStatus("processing...");
	}
	his_self.endTurn();
        return;
      }
    });

  }



  playerEvaluateBreakSiegeRetreatOpportunity(attacker, spacekey) {

    let his_self = this;
    let retreat_destination = "";

    let onFinishSelect = function(his_self, destination_spacekey) {
      his_self.addMove("retreat"+"\t"+attacker+"\t"+spacekey+"\t"+destination_spacekey);
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      let html = "<ul>";
      for (let i = 0; i < space.neighbours.length; i++) {
        if (his_self.canFactionRetreatToSpace(attacker, space.neighbours[i])) {
          html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
        }
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");
	his_self.updateStatus("retreating...");
        onFinishSelect(his_self, id);
      });
    };

    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">sacrifice forces</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(attacker)} - siege broken in ${this.returnSpaceName(spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
        his_self.addMove("destroy_faction_units_in_spacekey\t"+attacker+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluatePostBattleRetreatOpportunity(loser, winner, attacker, spacekey, attacker_comes_from_this_spacekey="") {

    let his_self = this;
    let retreat_destination = "";
    let space_name = this.game.spaces[spacekey].name;

    let onFinishSelect = function(his_self, destination_spacekey) {
      his_self.addMove("retreat"+"\t"+loser+"\t"+spacekey+"\t"+destination_spacekey);
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      his_self.field_battle_overlay.hide();

      his_self.playerSelectSpaceWithFilter(

                  "Choose Destination for Retreat:" ,

        	  function(space2) {

	            if (space.neighbours.includes(space2.key)) {
		      if (his_self.returnPlayerCommandingFaction(loser) === his_self.returnPlayerCommandingFaction(attacker)) {
	  		if (space2.key === attacker_comes_from_this_spacekey) {
          		  return 1;
	  		}
		      } else {
          		if (his_self.canFactionRetreatToSpace(loser, space2.key, "") && space2.key !== attacker_comes_from_this_spacekey) {
          		  return 1;
	  		}
		      }
		    }
	            return 0;
		  },

      		  function(spacekey) {
		    his_self.updateStatus("retreating...");

                    onFinishSelect(his_self, spacekey);
		  },

	    	  null, 

	    	  true 

      );
    };

    
    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    html    += `<li class="card" id="skip">sacrifice forces</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(loser)} retreats, yes?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
        his_self.addMove("destroy_faction_units_in_spacekey\t"+loser+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluateRetreatOpportunity(attacker, spacekey, attacker_comes_from_this_spacekey="", defender, is_attacker_loser=false) {

    let his_self = this;
    let retreat_destination = "";
    let space_name = this.game.spaces[spacekey].name;

    let onFinishSelect = function(his_self, destination_spacekey) {
      if (is_attacker_loser) {
        his_self.addMove("retreat"+"\t"+attacker+"\t"+spacekey+"\t"+destination_spacekey);
      } else {
        his_self.addMove("retreat"+"\t"+defender+"\t"+spacekey+"\t"+destination_spacekey);
      }
      his_self.endTurn();
    };

    let selectDestinationInterface = function(his_self, selectDestinationInterface, onFinishSelect) {

      let space = his_self.game.spaces[spacekey];

      let html = "<ul>";
      for (let i = 0; i < space.neighbours.length; i++) {
	if (is_attacker_loser) {
          if (his_self.canFactionRetreatToSpace(attacker, space.neighbours[i], attacker_comes_from_this_spacekey)) {
            html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
	  }
	} else {
          if (his_self.canFactionRetreatToSpace(defender, space.neighbours[i], attacker_comes_from_this_spacekey)) {
            html += `<li class="option" id="${space.neighbours[i]}">${his_self.game.spaces[space.neighbours[i]].key}</li>`;
	  }
	}
      }
      html += "</ul>";

      his_self.updateStatusWithOptions("Choose Destination for Retreat: ", html);

      $('.option').off();
      $('.option').on('click', function () {
        let id = $(this).attr("id");
	his_self.updateStatus("retreating...");
        onFinishSelect(his_self, id);
      });

    };

    
    let html = `<ul>`;
    html    += `<li class="card" id="retreat">retreat</li>`;
    if (is_attacker_loser) { 
      html    += `<li class="card" id="skip">sacrifice forces</li>`;
    } else {
      html    += `<li class="card" id="skip">do not retreat</li>`;
    }
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(defender)} -- ${this.returnFactionName(attacker)} approaches ${this.returnSpaceName(spacekey)}. Retreat?`, html);
    this.attachCardboxEvents(function(user_choice) {

      if (user_choice === "retreat") {
	selectDestinationInterface(his_self, selectDestinationInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	if (is_attacker_loser) {
          his_self.addMove("destroy_faction_units_in_spacekey\t"+attacker+"\t"+spacekey);
	}
	his_self.endTurn();
        return;
      }
    });
  }


  playerEvaluateFortification(attacker, faction, spacekey, post_battle=0, relief_siege=0) {

console.log("Relief Siege? " + relief_siege);

    let his_self = this;

    let html = `<ul>`;
    html    += `<li class="card" id="fortify">withdraw into fortification</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${his_self.returnFactionName(faction)} - Withdraw Units into Fortification?`, html);
    this.attachCardboxEvents(function(user_choice) {
      this.unbindBackButtonFunction();
      this.updateStatus("acknowledge...");
      if (user_choice === "fortify") {
	his_self.addMove("fortification\t"+attacker+"\t"+faction+"\t"+spacekey+"\t"+post_battle+"\t"+relief_siege);
	his_self.endTurn();
        return;
      }
      if (user_choice === "skip") {
	his_self.game.state.rejected_pre_battle_fortification.push(faction);
	his_self.endTurn();
        return;
      }
    });

  }


  playerEvaluateReliefForce(faction, spacekey) {

    let his_self = this;

    let html = `<ul>`;
    html    += `<li class="card" id="break">participate in battle</li>`;
    html    += `<li class="card" id="skip">remain besieged</li>`;
    html    += `</ul>`;

    this.game.state.field_battle_relief_battle = true;

    this.updateStatusWithOptions(`Do Your Besieged Forces participate in this Field Battle?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "break") {
	his_self.addMove("relief_forces_join_battle\t"+faction+"\t"+spacekey);
	his_self.endTurn();
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }





  playerEvaluateInterceptionOpportunity(attacker, spacekey, attacker_includes_cavalry, defender, defender_spacekey) {

    let his_self = this;

    let units_to_move = [];
    let parent_player = his_self.returnPlayerCommandingFaction(defender);

    let onFinishSelect = function(his_self, units_to_move) {
      his_self.addMove("intercept"+"\t"+attacker+"\t"+spacekey+"\t"+attacker_includes_cavalry+"\t"+defender+"\t"+defender_spacekey+"\t"+JSON.stringify(units_to_move));
      his_self.endTurn();
    };

	let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface) {

	  let unmoved_units = [];
	  let moved_units = [];
          let space = his_self.game.spaces[defender_spacekey];

	  let max_formation_size = his_self.returnMaxFormationSize(units_to_move, defender, defender_spacekey);
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == parent_player) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
                if (space.units[key][i].type != "corsair" && space.units[key][i].type != "squadron") {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != 1 && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : defender ,
   	    source : defender_spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : spacekey ,
	    units_to_move : units_to_move ,
	    max_formation_size : max_formation_size ,
 	  }

          // 
          // auto-move if only 1 unit
          //
          let can_we_quick_move = false;
          if (mobj.moved_units.length == 0 && mobj.unmoved_units.length == 1) { can_we_quick_move = true; }

	  if (!can_we_quick_move) {
   	    his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  }

	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = x[1];

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	    }

	    if (does_units_to_move_have_unit) {
	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	      }
	    } else {


	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });


          if (can_we_quick_move) {
            units_to_move = JSON.parse(JSON.stringify(mobj.unmoved_units));
            selectDestinationInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
            his_self.displaySpace(source_spacekey);
            his_self.displaySpace(destination_spacekey);
            his_self.updateStatus("intercepting...");
            return;
          }

	}
	//
	// end select units
	//



    let html = `<ul>`;
    html    += `<li class="card" id="intercept">intercept</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`${this.returnFactionName(defender)} - Intercept from ${this.returnSpaceName(defender_spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      his_self.updateStatus("acknowledge");
      his_self.unbindBackButtonFunction();
      if (user_choice === "intercept") {
	his_self.updateStatus("attempting intercept...");
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
	his_self.endTurn();
        return;
      }
    });

  }






  playerEvaluateNavalInterceptionOpportunity(attacker, spacekey, defender, defender_spacekey) {

    let his_self = this;

    let units_to_move = [];
    let units_to_move_idx = [];

    let onFinishSelect = function(his_self, units_to_move) {

      let includes_naval_leader = false;
      let includes_naval_ship = false;

      let space;
      if (his_self.game.spaces[defender_spacekey]) {
        space = his_self.game.spaces[defender_spacekey];
      }
      if (his_self.game.navalspaces[defender_spacekey]) {
        space = his_self.game.navalspaces[defender_spacekey];
      }

      for (let i = 0; i < units_to_move.length; i++) {
	let id = units_to_move[i].idx;
	let f = units_to_move[i].faction;
	let u = space.units[f][id];
	if (u.navy_leader == true) { includes_naval_leader = true; }
	if (u.type == "squadron" || u.type == "corsair") { includes_naval_ship = true; }
      }

      if (includes_naval_leader == true && includes_naval_ship == false) {
        his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(defender)+" aborts high seas interception");
	his_self.addMove("RESETCONFIRMSNEEDED\tall");
        his_self.endTurn();
	return;
      }

      his_self.addMove("naval_intercept"+"\t"+attacker+"\t"+spacekey+"\t"+defender+"\t"+defender_spacekey+"\t"+JSON.stringify(units_to_move));

      if (his_self.game.state.events.intervention_naval_intercept_possible == 1) {

	//
	// look ahead, then restore to avoid desync
	//
	let x = his_self.game.dice;
	let atr = his_self.rollDice(6) + his_self.rollDice(6);
	his_self.game.dice = x;

	//
	// professional rowers will trigger if it changes outcomes
	//
	if (atr >= 7 && atr < 9) {
          his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(defender)+" attempting high seas interception\tnaval_intercept\t" + spacekey);
	  his_self.addMove("RESETCONFIRMSNEEDED\tall");
	}
      }

      his_self.endTurn();
    };

    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, onFinishSelect) {

      let msg = "Select Units to Intercept: ";
      let space;
      if (his_self.game.spaces[defender_spacekey]) {
        space = his_self.game.spaces[defender_spacekey];
      }
      if (his_self.game.navalspaces[defender_spacekey]) {
        space = his_self.game.navalspaces[defender_spacekey];
      }

      let html = "<ul>";

      for (let i = 0; i < space.units[defender].length; i++) {
        if (space.units[defender][i].locked != 1 && space.units[defender][i].army_leader != true) {
          if (space.units[defender][i].land_or_sea === "sea" || space.units[defender][i].land_or_sea === "both") {
            if (units_to_move_idx.includes(parseInt(i))) {
              html += `<li class="option" style="font-weight:bold" id="${defender}-${i}">* ${space.units[defender][i].name} *</li>`;
            } else {
              html += `<li class="option" id="${defender}-${i}">${space.units[defender][i].name}</li>`;
            }
          }
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let tmpx = $(this).attr("id");

        if (tmpx === "end") {
          onFinishSelect(his_self, units_to_move);
          return;
        }


	let id = parseInt(tmpx.split("-")[1]);
	let f = tmpx.split("-")[0];

        if (units_to_move_idx.includes(id)) {
          let idx = units_to_move_idx.indexOf(id);
          if (idx > -1) {
            units_to_move_idx.splice(idx, 1);
            units_to_move.splice(idx, 1);
          }
        } else {
          units_to_move_idx.push(parseInt(id));
          units_to_move.push({ idx : parseInt(id) , faction : f });
	}

        selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
      });
    };


    let html = `<ul>`;
    html    += `<li class="card" id="intercept">intercept</li>`;
    html    += `<li class="card" id="skip">skip</li>`;
    html    += `</ul>`;

    this.updateStatusWithOptions(`Intercept ${this.returnSpaceName(spacekey)} from ${this.returnSpaceName(defender_spacekey)}?`, html);
    this.attachCardboxEvents(function(user_choice) {
      if (user_choice === "intercept") {
        his_self.updateStatus("acknowledge");
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, onFinishSelect);
        return;
      }
      if (user_choice === "skip") {
        his_self.updateStatus("acknowledge");
	his_self.endTurn();
        return;
      }
    });

  }




  canPlayerNavalTransport(his_self, player, faction, ops_to_spend, ops_remaining) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    // no if no ships at sea
    let have_ships_at_sea = false;
    for (let key in his_self.game.navalspaces) {
      if (his_self.game.navalspaces[key].units[faction].length > 0) {
	have_ships_at_sea = true;
      }
    }
    if (!have_ships_at_sea) { return false; }

    if (ops_remaining < 2) { return 0; }
    let spaces_with_infantry = his_self.returnSpacesWithFactionInfantry(faction);
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      if (his_self.game.spaces[spaces_with_infantry[i]].ports.length == 0) {
	spaces_with_infantry.splice(i, 1);
	i--;
      } else {
	let s = his_self.game.spaces[spaces_with_infantry[i]];
	let any_valid_moves = false;
        for (let z = 0; z < s.ports.length; z++) {
          if (his_self.doesFactionHaveNavalUnitsInSpace(faction, s.ports[z]) == 1) {
	    any_valid_moves = true;
	  }
	}
	if (!any_valid_moves) {
	  spaces_with_infantry.splice(i, 1);
	  i--;
	}
      }
    }

    if (spaces_with_infantry.length == 0) { return 0; }

    for (let i = 0; i < spaces_with_infantry.length; i++) {
      let dest = his_self.returnNavalTransportDestinations(faction, spaces_with_infantry[i], ops_remaining);
      if (dest.length > 0) { return 1; }
    }

    return 0;

  }
  async playerNavalTransport(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let spacekey = "";
    let units_to_move = [];
    let cancel_func = null;
    let space = null;
    let destination = "";
    let cost_of_transport = 2;

    //
    // destination already set, so just fire the info out
    //
    let selectDestinationInterface = function(his_self, units_to_move) {

	      if (cost_of_transport > 2) {
	        for (let z = 0; z < his_self.moves.length; z++) {
		  let pma = his_self.moves[z].split("\t");
		  if (pma[0] === "continue") {
		    if ((parseInt(pma[4]) - (cost_of_transport-2)) > 0) {
                      his_self.moves[z] = "continue\t"+pma[1]+"\t"+pma[2]+"\t"+pma[3]+"\t"+(parseInt(pma[4])-(cost_of_transport-2))+"\t"+pma[5];
		    } else {
		      his_self.moves.splice(z, 1);
		      z--;
		    }
		  }
	        }
	      }

              units_to_move.sort(function(a, b){return parseInt(a.idx)-parseInt(b.idx)});

              let does_movement_include_cavalry = 0;
              for (let i = 0; i < units_to_move.length; i++) {
                if (units_to_move[i].type === "cavalry") {
                  does_movement_include_cavalry = 1;
                }
              }

	      //
	      // "skip" interception check if we already have units in this space
	      //
	      if (his_self.returnFactionLandUnitsInSpace(faction, destination) > 0) {
	        his_self.addMove("interception_check\t"+"skip"+"\t"+destination+"\t"+does_movement_include_cavalry);
	      } else {
	        his_self.addMove("interception_check\t"+faction+"\t"+destination+"\t"+does_movement_include_cavalry);
	      }
 
              for (let i = 0; i < units_to_move.length; i++) {
                his_self.addMove("move\t"+units_to_move[i].faction+"\tland\t"+spacekey+"\t"+destination+"\t"+units_to_move[i].idx);
              }
    	      if (his_self.game.state.events.intervention_on_movement_possible == 0) {
      		his_self.addMove("ACKNOWLEDGE\t" + his_self.returnFactionName(faction) + " moves to " + his_self.game.spaces[destination].name);
	      } else {
                his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" moving to "+his_self.game.spaces[destination].name + "\tmove\t" + destination);
	        his_self.addMove("RESETCONFIRMSNEEDED\tall");
	      }
              his_self.endTurn();

    }

    let selectUnitsInterface = function(his_self, units_to_move, selectUnitsInterface, cost=2) {

	  let unmoved_units = [];
	  let moved_units = [];
          let space = his_self.game.spaces[spacekey];
	  let max_formation_size = 5; // cannot naval transport more than 5 units
	  let msg = "Max Formation Size: " + max_formation_size + " units";
	  let html = "<ul>";
	  for (let key in space.units) {
	    if (his_self.returnPlayerCommandingFaction(key) == player) {
	      for (let i = 0; i < space.units[key].length; i++) {
	        if (space.units[key][i].reformer != true && space.units[key][i].navy_leader != true) {
	        if (space.units[key][i].land_or_sea === "land" || space.units[key][i].land_or_sea === "both") {
	          if (space.units[key][i].locked != 1 && (!(his_self.game.state.events.foul_weather == 1 && space.units[key][i].already_moved == 1))) {
	    	    let does_units_to_move_have_unit = false;
	    	    for (let z = 0; z < units_to_move.length; z++) {
	    	      if (units_to_move[z].faction == key && units_to_move[z].idx == i) { does_units_to_move_have_unit = true; break; }
	    	    }
	            if (does_units_to_move_have_unit) {
	              html += `<li class="option" style="font-weight:bold" id="${i}">*${space.units[key][i].name} (${key})*</li>`;
		      moved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            } else {
	              html += `<li class="option" id="${key}-${i}">${space.units[key][i].name} (${key})</li>`;
		      unmoved_units.push({ faction : key , idx : i , type : space.units[key][i].type });
	            }
	          }
	        }
	        }
	      }
	    }
	  }

	  let mobj = {
	    space : space ,
	    faction : faction ,
   	    source : spacekey ,
   	    unmoved_units : unmoved_units ,
   	    moved_units : moved_units ,
	    destination : destination ,
            units_to_move : units_to_move ,
            max_formation_size : max_formation_size ,  
 	  }

   	  his_self.movement_overlay.render(mobj, units_to_move, selectUnitsInterface, selectDestinationInterface); // no destination interface
	  html += `<li class="option" id="end">finish</li>`;
	  html += "</ul>";

	  his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {

            let id = $(this).attr("id");

	    if (id === "end") {
	      his_self.movement_overlay.hide();
	      selectDestinationInterface(his_self, units_to_move);
	      return;
	    }

	    let x = id.split("-");
	    let f = x[0];
	    let idx = x[1];

	    let does_units_to_move_have_unit = false;
	    for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { does_units_to_move_have_unit = true; break; }
	    }

	    if (does_units_to_move_have_unit) {
	      for (let z = 0; z < units_to_move.length; z++) {
	        if (units_to_move[z].faction === f && units_to_move[z].idx == idx) { units_to_move.splice(z, 1); break; }
	      }
	    } else {


	      //
	      // check for max formation size
	      //
	      let unitno = 0;
	      for (let i = 0; i < units_to_move.length; i++) {
	        if (space.units[units_to_move[i].faction][units_to_move[i].idx].command_value == 0) { unitno++; }
	        if (unitno >= max_formation_size) { 
		  max_formation_size = his_self.returnMaxFormationSize(units_to_move, faction, spacekey);
	          if (unitno >= max_formation_size) { 
	            alert("Maximum Formation Size: " + max_formation_size);
	            return;
		  }
	        }
	      }

	      units_to_move.push( { faction : f , idx : idx , type : space.units[f][idx].type });
	    }

	    selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
	  });
    }
    //
    // end select units
    //
    let spaces_with_infantry = his_self.returnSpacesWithFactionInfantry(faction);
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      if (his_self.game.spaces[spaces_with_infantry[i]].ports.length == 0) {
	spaces_with_infantry.splice(i, 1);
	i--;
      } else {
	let s = his_self.game.spaces[spaces_with_infantry[i]];
	let cf = his_self.returnFactionControllingSpace(spaces_with_infantry[i]);
	if (s.besieged > 0 && his_self.areAllies(faction, cf)) {
	  spaces_with_infantry.splice(i, 1);
	  i--;
	  z = s.ports.length + 2;
        } else {
	  let w = 0;
	  for (let z = 0; z < s.ports.length; z++) {
            if (his_self.doesFactionHaveNavalUnitsInSpace(faction, s.ports[z]) >= 0) {
	      w = 1;
	    }
	  }
	  if (w == 0) {
  	    spaces_with_infantry.splice(i, 1);
	    i--;
	    z = s.ports.length + 2;
	  }
	}
      }
    }

    let html = `<ul>`;
    for (let i = 0; i < spaces_with_infantry.length; i++) {
      html    += `<li class="option" id="${i}">${spaces_with_infantry[i]}</li>`;
    }
    html    += `</ul>`;

    his_self.updateStatusWithOptions(`Transport from Which Port?`, html);
    his_self.attachCardboxEvents(function(user_choice) {

      spacekey = spaces_with_infantry[user_choice];
      let dest = his_self.returnNavalTransportDestinations(faction, spaces_with_infantry[user_choice], (ops_remaining+ops_to_spend));

      let html = `<ul>`;
      for (let i = 0; i < dest.length; i++) {
	let c = ops_remaining + ops_to_spend - dest[i].cost;
        html    += `<li class="option" id="${i}">${dest[i].key} (${c} CP)</li>`;
      }
      html    += `</ul>`;

      his_self.updateStatusWithOptions(`Select Destination:`, html);
      his_self.attachCardboxEvents(function(d) {
	destination = dest[d].key;
	cost_of_transport = ops_remaining + ops_to_spend - dest[d].cost;
	selectUnitsInterface(his_self, units_to_move, selectUnitsInterface, selectDestinationInterface);
      });
    });

  }


  // 1 = yes, 0 = no / maybe
  canPlayerPlayCard(faction, card) {
    let player = this.returnPlayerOfFaction(faction);
    if (this.game.player == player) { 
      let faction_hand_idx = this.returnFactionHandIdx(player, faction);
      for (let i = 0; i < this.game.deck[0].fhand[faction_hand_idx].length; i++) {
        let c = this.game.deck[0].fhand[faction_hand_idx][i];
  	if (c === card) { return 1; }
      }
    }
    return 0;
  }

  canPlayerCommitDebater(faction, debater) {

    if (faction !== "protestant" && faction !== "papacy") { return false; }

    if (this.game.state.debater_committed_this_impulse[faction] == 1) { return false; }   
    if (this.isDisgraced(debater)) { return false; }
    if (this.isBurned(debater)) { return false; }

    let already_committed = false;
    let found_debater = false;
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {

        found_debater = true;

        if (this.game.state.debaters[i].active == 1 && this.game.state.debaters[i].faction === "papacy" && faction === "papacy") {}
        if (this.game.state.debaters[i].active == 1 && this.game.state.debaters[i].faction === "protestant" && faction !== "papacy") { return false; }
        if (this.game.state.debaters[i].committed == 1) { return false; }

        let is_mine = false;

        if (this.game.state.debaters[i].faction === "papacy" && faction === "papacy") {
          is_mine = true;               
        }
        if (this.game.state.debaters[i].faction !== "papacy" && faction === "protestant") {
          is_mine = true;
        }
    
        if (is_mine == true) {
          if (this.game.state.debaters[i].active == 1) { already_comitted = true; }
        }
      }
    }

    if (found_debater != true) { return false; }

    return !already_committed;
  } 
    

  canPlayerNavalMove(his_self, player, faction) {

    if (his_self.game.state.events.foul_weather) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    // 2P game, papacy+protestant can move minor + allied naval units during their own turn
    if (his_self.game.players.length == 2) {
      if (his_self.doesFactionHaveUnlockedNavalUnitsOnBoard(faction)) {
	if (his_self.game.player == his_self.returnPlayerCommandingFaction(faction)) {
	  return 1;
	}
      }
    }

    if (his_self.doesFactionHaveUnlockedNavalUnitsOnBoard(faction)) { return 1; }
    return 0;

  }
  async playerNavalMove(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    his_self.naval_movement_overlay.render();

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let units_to_move = [];
    let units_available = his_self.returnFactionNavalUnitsToMove(faction);

    for (let z = 0; z < units_available.length; z++) {
      if (units_available[z].locked == 1) { units_available.splice(z, 1); z--; }
    }

    let backup_units_to_move = units_to_move;

    let selectUnitsInterface = function(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface) {

      let msg = "Select Unit to Move";
      let html = "<ul>";

      for (let i = 0; i < units_available.length; i++) {
        if (units_to_move.includes(parseInt(i))) {
	  if (units_available[i].destination === "") {
            for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z] === parseInt(i)) {
                units_to_move.splice(z, 1);
		z--;
	      }
	    }
	  }
	  if (units_available[i].spacekey === units_available[i].destination) {
	    units_available[i].destination = "";
            for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z] === parseInt(i)) {
                units_to_move.splice(z, 1);
	      }
	    }
	  }	
	  if (units_available[i].destination === "end") {
	    units_available[i].destination = "";
            for (let z = 0; z < units_to_move.length; z++) {
	      if (units_to_move[z] === parseInt(i)) {
                units_to_move.splice(z, 1);
	      }
	    }
	  }	
	}
      }

      for (let i = 0; i < units_available.length; i++) {
	let spacekey = units_available[i].spacekey;
	let unit = units_available[i];
        if (units_to_move.includes(parseInt(i))) {
          html += `<li class="option source" style="font-weight:bold" id="${i}">${units_available[i].name} (${units_available[i].spacekey} -> ${units_available[i].destination})</li>`;
        } else {
          html += `<li class="option source" id="${i}">${units_available[i].name} (${his_self.returnSpaceName(units_available[i].spacekey)})</li>`;
        }
      }
      html += `<li class="option" id="end">finish</li>`;
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);
      his_self.naval_movement_overlay.selectUnits(msg, html);


      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");
	let is_source = $(this).hasClass('source');
	let is_destination = $(this).hasClass('destination');

	if (is_source) {
	  if (document.querySelector(".dcontrols ul .destination")) { 

	    his_self.hideDestination();

            for (let i = 0; i < units_available.length; i++) {
              if (units_to_move.includes(parseInt(i))) {
	  	if (units_available[i].destination === "") {
          	  for (let z = 0; z < units_to_move.length; z++) {
	  	    if (units_to_move[z] === parseInt(i)) {
          	      units_to_move.splice(z, 1);
		      z--;
		    }
		  }
		}
	        if (units_available[i].spacekey === units_available[i].destination) {
	          units_available[i].destination = "";
                  for (let z = 0; z < units_to_move.length; z++) {
	            if (units_to_move[z] === parseInt(i)) {
                      units_to_move.splice(z, 1);
	            }
	          }
	        }	
	      }
            }

            selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	    return;
	  }
	}
	if (is_destination) {
	  his_self.hideDestination();
          selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	  return;
	}

	his_self.updateStatus("moving...");

        if (id === "end") {

          his_self.naval_movement_overlay.hide();

	  let destinations = {};

	  //
	  // if there are no units to move...
	  //
	  if (units_to_move.length == 0) {
	    // "end" without anything selected is like clicking on the back button...
	    if (his_self.hud.back_button_callback != null) { his_self.hud.back_button_callback(); return; }
	  }


	  for (let i = 0; i < units_to_move.length; i++) {
	    let unit = units_available[units_to_move[i]];
	    if (!destinations[unit.destination]) {
	      his_self.addMove("naval_interception_check\t"+faction+"\t"+unit.destination+"\t"+unit.spacekey);
	      destinations[unit.destination] = 1;
	    }
	  }

	  let revised_units_to_move = [];
	  let entries_to_loop = units_to_move.length;	
	  for (let z = 0; z < entries_to_loop; z++) {

	    let highest_idx = 0;
	    let highest_num = 0;

	    for (let y = 0; y < units_to_move.length; y++) {
   	      let unit = units_available[units_to_move[y]];
	      let max_num = unit.idx;
	      let max_idx = y;
	      if (max_num > highest_num) {
		highest_idx = max_idx;
		highest_num = max_num;
	      }
	    }

	    revised_units_to_move.unshift(JSON.parse(JSON.stringify(units_available[units_to_move[highest_idx]])));
	    units_to_move.splice(highest_idx, 1);
	  }

	  //
	  // revised units to move is
	  //
	  for (let i = 0; i < revised_units_to_move.length; i++) {
	    let unit = revised_units_to_move[i];
            his_self.addMove("move\t"+revised_units_to_move[i].faction+"\tsea\t"+unit.spacekey+"\t"+unit.destination+"\t"+revised_units_to_move[i].idx);
	  }
    	  if (his_self.game.state.events.intervention_on_movement_possible == 0) {
	    his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" shifting naval forces\tnavalmove");
          } else {
	    his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" shifting naval forces\tnavalmove");
	    his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  }
	  his_self.endTurn();
	  return;

	}

	//
	// add unit to units available
	//
        if (units_to_move.includes(id)) {
          let idx = units_to_move.indexOf(id);
          if (idx > -1) {
            units_to_move.splice(idx, 1);
          }
        } else {
          if (!units_to_move.includes(parseInt(id))) {
            units_to_move.push(parseInt(id));
            selectDestinationInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
          } else {
            for (let i = 0; i < units_to_move.length; i++) {
              if (units_to_move[i] === parseInt(id)) {
                units_to_move.splice(i, 1);
      	        selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
                break;
              }
            }
          }
        }
      });
    }

    let selectDestinationInterface = function(his_self, unit_to_move, units_available, selectUnitsInterface, selectDestinationInterface) {

      //
      // unit selected will always be last in array
      //
      let unit = units_available[unit_to_move[unit_to_move.length-1]];

      let destinations = his_self.returnNavalMoveOptions(unit.spacekey);

      let msg = "Select Destination";
      let html = "<ul>";
      let any_options = false;
      let num_options = 0;
      for (let i = 0; i < destinations.length; i++) {
	let spacekey = destinations[i];
	if (his_self.game.spaces[spacekey]) {
	  if (his_self.isSpaceHostileOrIndependent(spacekey, faction)) {
	    if (his_self.doesSpaceHaveNonFactionNavalUnits(spacekey, faction)) {
              any_options = true;
  	      num_options++;
              html += `<li class="option destination" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
	    }
	  } else {
	    if (his_self.isSpaceFriendly(spacekey, faction)) {
              any_options = true;
  	      num_options++;
              html += `<li class="option destination" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
            }
          }
        } else {
          any_options = true;
	  num_options++;
          html += `<li class="option destination" style="font-weight:bold" id="${spacekey}">${his_self.returnSpaceName(spacekey)}</li>`;
	}
      }
      if (any_options == false) {
        html += `<li class="option destination" style="font-weight:bold" id="none">no valid options</li>`;
      }
      html += "</ul>";

      his_self.updateStatusWithOptions(msg, html);
      if (num_options > 1) { his_self.naval_movement_overlay.selectDestination(msg, html); }

      $('.option').off();
      $('.option').on('click', function () {

        let id = $(this).attr("id");

	//
	// this isn't possible except on naval overlay
	//
	if (id === "end") {
	  his_self.naval_movement_overlay.hideDestination();
          selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	}

	let is_source = $(this).hasClass('source');
	let is_destination = $(this).hasClass('destination');

	if (is_source) {

	  his_self.naval_movement_overlay.hideDestination();

          for (let i = 0; i < units_available.length; i++) {

            if (units_to_move.includes(parseInt(i))) {
	      if (units_available[i].destination === "" || !(units_available[i].destination)) {
          	for (let z = 0; z < units_to_move.length; z++) {
	  	  if (units_to_move[z] === parseInt(i)) {
          	    units_to_move.splice(z, 1);
		    z--;
		  }
		}
	      }
	      if (units_available[i].spacekey === units_available[i].destination) {
	        units_available[i].destination = "";
                for (let z = 0; z < units_to_move.length; z++) {
	          if (units_to_move[z] === parseInt(i)) {
                    units_to_move.splice(z, 1);
	          }
	        }
	      }	
	    }
          }

          selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	  return;
	}

	if (id === "none") {
          unit_to_move.splice(unit_to_move.length-1, 1);
          selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);
	  return;
	}

	unit.destination = id;
	his_self.naval_movement_overlay.hideDestination();
        selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);

      });

      if (num_options == 1) {
	document.querySelector(".option").click();
	return;
      }

    }

    selectUnitsInterface(his_self, units_to_move, units_available, selectUnitsInterface, selectDestinationInterface);

  }

  canPlayerMoveFormationInClear(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let spaces_with_units = his_self.returnSpacesWithFactionInfantry(faction);

    if (spaces_with_units.length > 0) { 
      let any_unlocked_units = false;
      for (let i = 0; i < spaces_with_units.length; i++) {
       for (let z = 0; z < his_self.game.spaces[spaces_with_units[i]].units[faction].length; z++) {
	  if (his_self.game.spaces[spaces_with_units[i]].units[faction][z].locked != 1) {
	    // if no neighbours, no move
	    if (his_self.game.spaces[spaces_with_units[i]].neighbours.length > 0) {
	      return 1;
	    }
	  }
	}
      }
    }
    return 0;
  }

  canPlayerBuyMercenaryOverLimit(his_self, player, faction) {
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "regular") == 0 && his_self.game.state.board[faction].overcapacity == 1) { return true; }
    return false;
  }
  async playerBuyMercenaryOverLimit(his_self, player, faction, ops_to_spend, ops_remaining) {
    his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, "");
    his_self.displayCustomOverlay("overcapacity", `${his_self.returnFactionName(faction)} is Overcapacity`);
    return 1;
  }
  canPlayerBuyMercenary(his_self, player, faction) {
    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "mercenary") == 0) { return false; }

    return 1;
  }
  playerBuyMercenary(his_self, player, faction, ops_to_spend, ops_remaining) {

    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    //
    // ui for building multiple units
    //
    his_self.build_overlay.render(faction, "mercenary", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and place
      //
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Mercenaries`,

        function(space) {
	  if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 4) {
	      if (space.key == "ireland") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "ireland") { return 1; }
	    }
	  }
	  if (faction != "protestant" && space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) {
	    return 0;
	  }
          if (space.besieged != 0) { return 0; }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
          his_self.unbindBackButtonFunction();
  	  his_self.updateStatus("acknowledge...");
          for (let i = 0; i < num; i++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

    });

  
    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Mercenary",

      function(space) {
	if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	    if (space.key == "ireland") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "ireland") { return 1; }
	  }
	}
        if (faction == "hapsburg" && space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) {
          return 0;
        }
        if (space.besieged != 0) { return 0; }
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (his_self.isSpaceFriendly(space, faction) && space.home == faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"mercenary"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }

  canPlayerBuyRegularOverLimit(his_self, player, faction) {
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "regular") == 0 && his_self.game.state.board[faction].overcapacity == 1) { return true; }
    return false;
  }
  async playerBuyRegularOverLimit(his_self, player, faction, ops_to_spend, ops_remaining) {
    his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, "");
    his_self.displayCustomOverlay("overcapacity", `${his_self.returnFactionName(faction)} is Overcapacity`);
    return 1;
  }
  canPlayerBuyRegular(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "regular") == 0) { return false; }

    return 1;
  }
  async playerBuyRegular(his_self, player, faction, ops_to_spend, ops_remaining) {

    //
    // UI for multiple-unit builds
    //
    his_self.build_overlay.render(faction, "regular", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and select destination for these units
      //
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Regular(s)`,

        function(space) {
  	  if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	      if (space.key == "persia") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "persia") {
		return 1;
	      }
	    }
	  }
	  if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	      if (space.key == "egypt") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "egypt") { return 1; }
	    }
	  }
	  if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	    // can only build corsairs in a pirate haven
	    if (space.key == "algiers" || space.pirate_haven == 1) { 
	      if (his_self.game.state.events.foreign_recruits != "ottoman") { return 0; }
	    }
	  }
	  if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	      if (space.key == "ireland") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "ireland") { return 1; }
	    }
	  }
	  if (faction != "protestant" && space.type == "electorate" && his_self.game.state.events.schmalkaldic_league == 0) {
	    return 0;
	  }
          if (space.besieged != 0) { return 0; }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
          his_self.unbindBackButtonFunction();
	  his_self.updateStatus("acknowledge...");
	  for (let z = 0; z < num; z++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"regular"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

      return 0;

    });
            

    //
    // fall through is to build a single regular
    //
    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Regular",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	  // can not build regulars in Algiers
	  if (space.key == "algiers" || space.pirate_haven == 1) { return 0; }
	}
	if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	    if (space.key == "persia") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "persia") { return 1; }
	  }
	}
	if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	    if (space.key == "egypt") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "egypt") { return 1; }
	  }
	}
	if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("england", "ireland") < 5) {
	    if (space.key == "ireland") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "ireland") { return 1; }
	  }
	}
        if (space.besieged != 0) { return 0; }
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (his_self.isSpaceFriendly(space, faction) && space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"regular"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }

  canPlayerBuyNavalSquadron(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "squadron") == 0) { return false; }

    return 1;
  }
  async playerBuyNavalSquadron(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Port for Naval Squadron",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	  if (space.key == "algiers" || space.pirate_haven == 1) { 
	    if (his_self.game.state.events.foreign_recruits != "ottoman") { return 0; }
	  }
	}
        if (space.ports.length === 0) { return 0; }
        if (space.besieged != 0) { return 0; }
	if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
        if (space.owner === faction) { return 1; }
        if (space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"squadron"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,
      true,
    );
  }

  async playerBuildChateaux(his_self, player, faction) {
    his_self.game.chateaux_overlay.render();
  }

  canPlayerFightForeignWar(his_self, player, faction) {
    if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("persia")) { return 1; } }
    if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("egypt")) { return 1; } }
    if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1) { if (!his_self.game.state.foreign_wars_fought_this_impulse.includes("ireland")) { return 1; } }
    return 0;
  }
  playerFightForeignWar(his_self, player, faction) {

    let msg = "Attack in Foreign War: ";
    let html = '<ul>';
    if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("persia")) {
      html += '<li class="option" id="persia">War in Persia</li>';	
    }
    if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("egypt")) {
      html += '<li class="option" id="egypt">Revolt in Egypt</li>';	
    }
    if (faction === "england" && his_self.game.state.events.revolt_in_ireland == 1 && !his_self.game.state.foreign_wars_fought_this_impulse.includes("ireland")) {
      html += '<li class="option" id="ireland">Revolt in Ireland</li>';	
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
      his_self.unbindBackButtonFunction();
      his_self.updateStatus("acknowledge");
      let key = $(this).attr("id");
      if (key == "persia") {
        his_self.addMove("field_battle\tpersia\tottoman");
      }
      if (key == "egypt") {
        his_self.addMove("field_battle\tegypt\tottoman");
      }
      if (key == "ireland") {
        his_self.addMove("field_battle\tireland\tengland");
      }
      his_self.endTurn();
    });

    return 0;
  }
  canPlayerAssaultTutorial(his_self, player, faction) {
    let assaultable_spaces = 0;
    let nonassaultable_spaces = 0;
    if (his_self.game.state.assaulted_this_impulse == 1) { return 0; }
    if (!his_self.canPlayerAssault(his_self, player, faction)) {
      let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);
      for (let i = 0; i < conquerable_spaces.length; i++) {
        if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
          if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
	    assaultable_spaces++;
            if (!his_self.isSpaceControlled(conquerable_spaces[i], faction)) {
              if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
	  	nonassaultable_spaces++;
              }
            }
          }
        }
      }
    }
    if (nonassaultable_spaces > 0 && nonassaultable_spaces >= assaultable_spaces) { return 1; }
    return 0;
  }
  playerAssaultTutorial(his_self, player, faction) {

    let player_warned = 0;
    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
        if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1) {
          if (!his_self.isSpaceControlled(conquerable_spaces[i], faction) && !his_self.isSpaceInLineOfControl(conquerable_spaces[i], faction) && player_warned == 0) {
	    salert("You have a space under siege, but to assault it you need to have a Line of Control connecting it to another fortified key you control.");
	    player_warned = 1;
          }
	  if (player_warned == 0) {

	    //
	    // now check if there are squadrons in the port or sea protecting the town
	    //
	    let space = his_self.game.spaces[conquerable_spaces[i]];

	    let squadrons_protecting_space = his_self.returnNumberOfSquadronsProtectingSpace(conquerable_spaces[i]);
      	    let attacker_squadrons_adjacent = 0;
	    for (let y = 0; y < his_self.game.spaces[conquerable_spaces[i]].ports.length; y++) {
	      let p = his_self.game.spaces[conquerable_spaces[i]].ports[y];
	      for (let f in his_self.game.navalspaces[p].units) {
		if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction)) {
	          for (let z = 0; z < his_self.game.navalspaces[p].units[f].length; z++) {
		    let u = his_self.game.navalspaces[p].units[faction][z];
		    if (u.type == "squadron") { attacker_squadrons_adjacent++; }
	          }
		}
	      }
	    }

	    if (attacker_squadrons_adjacent <= squadrons_protecting_space) {
	      if (999 < squadrons_protecting_space) {
	        alert("Space cannot be assaulted if protected by fleet in adjacent sea");
	        player_warned = 1;
	      } else {
	        alert("You have a space under siege, but it is protected by a fleet. To assault such a space, you need more naval forces adjacent to this space than the defender has protecting it.");
	        player_warned = 1;
	      }
	    }
	  }
	}
      }
    }

    return 1;

  }
  canPlayerAssault(his_self, player, faction) {

    if (his_self.game.state.events.foul_weather) { return 0; }

console.log("$");
console.log("$");
console.log("$");
console.log("$");

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction);

console.log(JSON.stringify(conquerable_spaces));

    let assaultable_spaces = 0;
    let nonassaultable_spaces = 0;

    for (let i = 0; i < conquerable_spaces.length; i++) {
console.log("cs: " + conquerable_spaces[i]);
      if (!his_self.isSpaceControlled(conquerable_spaces[i], faction)) {
        if (conquerable_spaces[i] !== "egypt" && conquerable_spaces[i] !== "persia" && conquerable_spaces[i] !== "ireland") {
console.log("not controlled by me");
	  if (his_self.isSpaceInLineOfControl(conquerable_spaces[i], faction)) {
console.log("in line of control!");
            if (his_self.game.spaces[conquerable_spaces[i]].besieged == 1 || (faction == "ottoman" && his_self.game.state.events.roxelana == 1) || (faction == his_self.returnControllingPower("scotland") && his_self.game.state.events.scots_raid == 1)) {
console.log("assaulted this turn: " + JSON.stringify(his_self.game.state.spaces_assaulted_this_turn));
	      if (!his_self.game.state.spaces_assaulted_this_turn.includes(conquerable_spaces[i])) {

	        //
	        // now check if there are squadrons in the port or sea protecting the town
	        //
	        let space = his_self.game.spaces[conquerable_spaces[i]];

	        let squadrons_protecting_space = his_self.returnNumberOfSquadronsProtectingSpace(conquerable_spaces[i]);
	        if (squadrons_protecting_space == 0) { assaultable_spaces++ } else {

console.log("checking if squadrons are protecting!");
		      let attacker_squadrons_adjacent = 0;

		      for (let y = 0; y < his_self.game.spaces[conquerable_spaces[i]].ports.length; y++) {
		        let sea = his_self.game.spaces[conquerable_spaces[i]].ports[y];
			for (let f in his_self.game.navalspaces[sea].units) {
			  if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction)) {
		            for (let z = 0; z < his_self.game.navalspaces[sea].units[f].length; z++) {
			      let u = his_self.game.navalspaces[sea].units[faction][z];
			      if (u.type == "squadron") { attacker_squadrons_adjacent++; }
		            }
		          }
		        }
	      	      }

	      	      if (attacker_squadrons_adjacent <= squadrons_protecting_space) { nonassaultable_spaces++; } else { assaultable_spaces++; }
	        }
	      }
	    }
	  }
        }
      }
    }

console.log("are there assaultable_spaces: " + assaultable_spaces);

    if (assaultable_spaces > 0 ) { return 1; }
    return 0;
  }
  async playerAssault(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      `${his_self.returnFactionName(faction)} - Select Space for Siege/Assault: `,

      function(space) {
	if (his_self.game.state.spaces_assaulted_this_turn.includes(space.key)) { return 0; }
	if (faction == "ottoman" && space.key == "persia" && his_self.game.state.events.war_in_persia == 1) { return 0; }
	if (faction == "ottoman" && space.key == "egypt" && his_self.game.state.events.revolt_in_egypt == 1) { return 0; }
	if (faction == "england" && space.key == "ireland" && his_self.game.state.events.revolt_in_ireland == 1) { return 0; }
        if (his_self.game.spaces[space.key].type !== "fortress" && his_self.game.spaces[space.key].type !== "electorate" && his_self.game.spaces[space.key].type !== "key") { return 0; }
        if (his_self.isSpaceInLineOfControl(space, faction) && !his_self.isSpaceControlled(space, faction) && his_self.returnFactionLandUnitsInSpace(faction, space) > 0 && (space.besieged == 1 || his_self.game.state.events.scots_raid == 1)) {
          //
          // now check if there are squadrons in the port or sea protecting the town
          //
          let squadrons_protecting_space = his_self.returnNumberOfSquadronsProtectingSpace(space.key);
          if (squadrons_protecting_space == 0) { return 1; }

          for (let y = 0; y < space.ports.length; y++) {
            let attacker_squadrons_adjacent = 0;
            let sea = space.ports[y];
	    for (let f in his_self.game.navalspaces[sea].units) {
              if (his_self.returnControllingPower(f) == his_self.returnControllingPower(faction)) {
                for (let z = 0; z < his_self.game.navalspaces[sea].units[f].length; z++) {
                  let u = his_self.game.navalspaces[sea].units[faction][z];
                  if (u.type == "squadron") { attacker_squadrons_adjacent++; }
                }
              }
            }
	    if (attacker_squadrons_adjacent <= squadrons_protecting_space) { return 0; }
          }

	  return 1;

        }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("assaulting...");
	if (faction == "ottoman" && destination_spacekey == "persia") { his_self.addMove("war\tottoman\tpersia"); his_self.endTurn(); return; }
	if (faction == "ottoman" && destination_spacekey == "egypt") { his_self.addMove("war\tottoman\tegypt"); his_self.endTurn(); return; }
	if (faction == "england" && destination_spacekey == "ireland") { his_self.addMove("war\tottoman\tireland"); his_self.endTurn(); return; }
	his_self.addMove("assault\t"+faction+"\t"+destination_spacekey);
	if (his_self.game.state.events.intervention_on_assault_possible == 0 || (his_self.game.deck[0].discards["031"] && his_self.game.deck[0].discards["032"])) {
	  let from_whom = his_self.returnArrayOfPlayersInSpacekey(destination_spacekey);
          his_self.addMove("ACKNOWLEDGE\t"+his_self.returnFactionName(faction)+" announces siege of "+his_self.game.spaces[destination_spacekey].name + "\tassault\t" + destination_spacekey);
	} else {
          his_self.addMove("counter_or_acknowledge\t"+his_self.returnFactionName(faction)+" announces siege of "+his_self.game.spaces[destination_spacekey].name + "\tassault\t" + destination_spacekey);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
	}
	his_self.endTurn();
      },

      null ,

      true ,
    );
  }

  canPlayerRemoveUnrest(his_self, player, faction) {

    let spaces_in_unrest = his_self.returnSpacesInUnrest();

    //
    // 2P requires only that it is in protestant or catholic religious influence
    // protestants can remove unrest even in catholic spaces before the League
    //
    if (his_self.game.players.length == 2) {
      for (let i = 0; i < spaces_in_unrest.length; i++) {
        if (his_self.game.spaces[spaces_in_unrest[i]].religion == "protestant" && faction == "protestant") { return 1; }
        if (faction == "protestant" && (his_self.game.spaces[spaces_in_unrest[i]].home != "independent" && his_self.game.spaces[spaces_in_unrest[i]].home == "") && his_self.game.spaces[spaces_in_unrest[i]].language == "german" && his_self.game.state.events.schmalkaldic_league == 0) { return 1; }
        if (his_self.game.spaces[spaces_in_unrest[i]].religion == "catholic" && faction == "papacy") { return 1; }
      }
    }

    //
    // protestants can always remove unrest in protestant home spaces pre-league (home = "" && language = "german")
    //
    if (faction == "protestant") {
      for (let i = 0; i < spaces_in_unrest.length; i++) {
        if ((his_self.game.spaces[spaces_in_unrest[i]].home != "independent" && his_self.game.spaces[spaces_in_unrest[i]].home == "") && his_self.game.spaces[spaces_in_unrest[i]].language == "german" && his_self.game.state.events.schmalkaldic_league == 0) { return 1; }
      }
    }

    //
    // otherwise, requires adjacent or direct military presence
    //
    let adjacent_influence = his_self.returnSpacesWithAdjacentFactionInfantry(faction);
    let direct_influence = his_self.returnSpacesWithFactionInfantry(faction);

    for (let i = 0; i < spaces_in_unrest.length; i++) {

      //
      // i have regulars / infantry in this space
      //
      if (direct_influence.includes(spaces_in_unrest[i])) { return true; }

      //
      // i have adjacent regulars / infantry, and no enemies do
      //
      if (adjacent_influence.includes(spaces_in_unrest[i])) {

	let neighbours = his_self.game.spaces[spaces_in_unrest[i]].neighbours;
	let pass = his_self.game.spaces[spaces_in_unrest[i]].pass;
	let do_any_enemies_impede_control = false;

	for (let z = 0; z < neighbours.length; z++) {

	  if (z > 0 && do_any_enemies_impede_control == false) { return 1; }
	  do_any_enemies_impede_control = false;

	  let number_of_hostiles = his_self.returnHostileLandUnitsInSpace(faction, neighbours[z]);
	  if (number_of_hostiles > 0) {
	    if (pass.includes(neighbours[z])) {
	    } else {
	      do_any_enemies_impede_control = true;
	    }
	  } else {
	    do_any_enemies_impede_control = false;
	  }
	}

      }
    }

    return 0;
  }
  canPlayerControlUnfortifiedSpace(his_self, player, faction) {
 
    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let conquerable_spaces = his_self.returnSpacesWithAdjacentFactionInfantry(faction);

    //
    // removed fortified spaces
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceFortified(n)) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.returnNonFactionLandUnitsInSpace(faction, n) > 0) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with adjacent other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let removed_space = false;
      let ns = his_self.game.spaces[conquerable_spaces[i]].neighbours;
      for (let z = 0; removed_space == false && z < ns.length; z++) {
        let n = his_self.game.spaces[ns[z]];
        if (his_self.returnHostileLandUnitsInSpace(faction, n) > 0) {
	  // unless we are there
          if (his_self.returnFactionLandUnitsInSpace(faction, conquerable_spaces[i]) > 0) {} else {
            conquerable_spaces.splice(i, 1); // remove
            removed_space = true;
          }
        }
      }
    }

    //
    // remove home spaces i control
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceControlled(s, faction)) { 
        conquerable_spaces.splice(i, 1); // remove
	i--;
      }
    }   
          

    //
    // remove non-independent, non-enemy spaces
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (!his_self.isSpaceHostileOrIndependent(s, faction)) {
        conquerable_spaces.splice(i, 1); // remove
        i--;
      }
    }

    for (let i = 0; i < spaces_in_unrest.length; i++) {
      if (!his_self.isSpaceControlled(spaces_in_unrest[i]), faction) { 
	let neighbours = his_self.game.spaces[spaces_in_unrest[i]];
	for (let z = 0; z < neighbours.length; z++) {
	  if (his_self.returnFactionLandUnitsInSpace(faction, neighbours[z]) > 0) {
	    return 1;
	  } 
	}
	if (his_self.returnFactionLandUnitsInSpace(faction, spaces_in_unrest[i]) > 0) {
	  return 1;
	} 
      }
    }

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (!his_self.isSpaceControlled(conquerable_spaces[i], faction)) { 
	if (his_self.game.spaces[conquerable_spaces[i]].besieged != 1 && his_self.game.spaces[conquerable_spaces[i]].besieged != 2) {
	  return 1;
	}
      } 
    }
    return 0;
  }
  async playerRemoveUnrest(his_self, player, faction, ops_to_spend, ops_remaining=0) {

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let spaces_to_fix = [];

    if (his_self.game.players.length == 2) {
      for (let i = 0; i < spaces_in_unrest.length; i++) {
        if (faction == "protestant" && his_self.game.spaces[spaces_in_unrest[i]].religion == "protestant"){spaces_to_fix.push(spaces_in_unrest[i]);}
        if (faction == "protestant" && his_self.game.spaces[spaces_in_unrest[i]].home == "" && his_self.game.spaces[spaces_in_unrest[i]].language == "german" && his_self.game.state.events.schmalkaldic_league == 0) {spaces_to_fix.push(spaces_in_unrest[i]);}
        if (faction == "papacy" && his_self.game.spaces[spaces_in_unrest[i]].religion == "catholic"){spaces_to_fix.push(spaces_in_unrest[i]);}
      }
    } else {

      let adjacent_influence = his_self.returnSpacesWithAdjacentFactionInfantry(faction);
      let direct_influence = his_self.returnSpacesWithFactionInfantry(faction);

      for (let i = 0; i < spaces_in_unrest.length; i++) {

        if (faction == "protestant" && his_self.game.state.events.schmalkaldic_league == 0 && his_self.game.spaces[spaces_in_unrest[i]].language == "german") {
          spaces_to_fix.push(spaces_in_unrest[i]);
        } else {

          //
          // i have regulars / infantry in this space
          //
	  if (direct_influence.includes(spaces_in_unrest[i])) {
	    spaces_to_fix.push(spaces_in_unrest[i]);
	  } else {
	    if (adjacent_influence.includes(spaces_in_unrest[i])) {

	      let neighbours = his_self.game.spaces[spaces_in_unrest[i]].neighbours;
	      let pass = his_self.game.spaces[spaces_in_unrest[i]].pass;
	      let any_violent_neighbours = false;

	      for (let z = 0; z < neighbours.length; z++) {

	        if (!his_self.game.spaces[spaces_in_unrest[i]].pass.includes(neighbours[z])) {	
	          let number_of_hostiles = his_self.returnHostileLandUnitsInSpace(faction, neighbours[z]);
	          if (number_of_hostiles > 0) {
	  	    if (!pass.includes(neighbours[z])) {
		      any_violent_neighbours = true;
		    }
	          }
	        }
	      }
	      if (any_violent_neighbours == false) {
	        spaces_to_fix.push(spaces_in_unrest[i]);
	      }
	    }
	  }
	}
      }
    }

    his_self.playerSelectSpaceWithFilter(

      "Select Space to Remove Unrest:",

      function(space) {
        if (spaces_to_fix.includes(space.key)) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.addMove("remove_unrest\t"+faction+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
    return 0;
  }
  canPlayerExplore(his_self, player, faction) {
    if (his_self.game.state.may_explore[faction] == 0) { return 0; }
    if (faction === "protestant") {  return false; }
    // already explored this round
    for (let i = 0; i < his_self.game.state.explorations.length; i++) {
      if (his_self.game.state.explorations[i].faction == faction && his_self.game.state.explorations[i].round >= his_self.game.state.round) { return 0; }
    }
    if (
      his_self.game.state.newworld['stlawrence'].claimed == 1 &&
      his_self.game.state.newworld['mississippi'].claimed == 1 &&
      his_self.game.state.newworld['greatlakes'].claimed == 1 &&
      his_self.game.state.newworld['amazon'].claimed == 1 &&
      his_self.game.state.newworld['pacificstrait'].claimed == 1 &&
      his_self.game.state.newworld['circumnavigation'].claimed == 1
    ) { return 0; }
    return 1;
  }
  async playerControlUnfortifiedSpace(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    // BACK moves us to OPS menu
    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.addMove("discard\t"+his_self.returnControllingPower(faction)+"\t"+his_self.game.player_last_card); his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let spaces_in_unrest = his_self.returnSpacesInUnrest();
    let pacifiable_spaces_in_unrest = [];
    for (let i = 0; i < spaces_in_unrest.length; i++) {
      if (!his_self.isSpaceControlled(spaces_in_unrest[i], faction)) { 
	let neighbours = his_self.game.spaces[spaces_in_unrest[i]];
	for (let z = 0; z < neighbours.length; z++) {
	  if (his_self.returnFactionLandUnitsInSpace(faction, neighbours[z]) > 0) { pacifiable_spaces_in_unrest.push(spaces_in_unrest[i]); } 
	}
	if (his_self.returnFactionLandUnitsInSpace(faction, spaces_in_unrest[i]) > 0) { pacifiable_spaces_in_unrest.push(spaces_in_unrest[i]); } 
      }
    }
    let conquerable_spaces = his_self.returnSpacesWithFactionInfantry(faction, true); // include adjacency

    //
    // removed any spaces controlled by non-independent major powers i am not at war with
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (n.political != "" && n.political != "genoa" && n.political != "hungary" && n.political != "venice" && n.political != "scotland") {
	if (!his_self.areEnemies(faction, n.political)) {
          conquerable_spaces.splice(i, 1); // remove
        }
      }
    }

    //
    // removed fortified spaces
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceFortified(n)) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let n = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.returnNonFactionLandUnitsInSpace(faction, n) > 0) {
        conquerable_spaces.splice(i, 1); // remove
      }
    }

    //
    // remove spaces with adjacent other infantry
    //
    for (let i = conquerable_spaces.length-1; i >= 0; i--) {
      let removed_space = false;
      let ns = his_self.game.spaces[conquerable_spaces[i]].neighbours;
      for (let z = 0; removed_space == false && z < ns.length; z++) {
        let n = his_self.game.spaces[ns[z]];
        if (his_self.returnHostileLandUnitsInSpace(faction, n) > 0) {
	  // unless we are there
          if (his_self.returnFactionLandUnitsInSpace(faction, conquerable_spaces[i]) > 0) {} else {
            conquerable_spaces.splice(i, 1); // remove
            removed_space = true;
          }
        }
      }
    }

    //
    // remove home spaces i control
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (his_self.isSpaceControlled(s, faction)) { 
        conquerable_spaces.splice(i, 1); // remove
	i--;
      }
    }   
          

    //
    // remove non-independent, non-enemy spaces
    //
    for (let i = 0; i < conquerable_spaces.length; i++) {
      let s = his_self.game.spaces[conquerable_spaces[i]];
      if (!his_self.isSpaceHostileOrIndependent(s, faction)) {
        conquerable_spaces.splice(i, 1); // remove
        i--;
      }
    }

    for (let i = 0; i < conquerable_spaces.length; i++) {
      if (his_self.isSpaceControlled(conquerable_spaces[i], faction) || his_self.game.spaces[conquerable_spaces[i]].besieged == 1 || his_self.game.spaces[conquerable_spaces[i]].besieged == 2) {
	conquerable_spaces.splice(i, 1);
	i--;
      }
    }

    his_self.playerSelectSpaceWithFilter(

      "Select Space to Pacify:",

      function(space) {
        if (pacifiable_spaces_in_unrest.includes(space.key)) { return 1; }
        if (conquerable_spaces.includes(space.key) && !his_self.isSpaceControlled(space.key, faction) && !his_self.isSpaceFriendly(space.key, faction)) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
	his_self.updateStatus("Controlling Space...");
	his_self.addMove("pacify\t"+faction+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
    return 0;
  }
  canPlayerColonize(his_self, player, faction) {

    if (his_self.game.state.may_colonize[faction] == 0) { return 0; }

    // no for protestants early-game
    if (faction === "protestant") { return false; }
    if (faction === "ottoman") { return false; }
    if (faction === "papacy") { return false; }

    for (let i = 0; i < his_self.game.state.colonies.length; i++) {
      if (his_self.game.state.colonies[i].faction == faction) {
        if (his_self.game.state.colonies[i].round >= his_self.game.state.round) { return 0; }
      }
    }
    if (faction === "england") {
      if (his_self.game.state.newworld['england_colony1'].claimed == 1 && his_self.game.state.newworld['england_colony2'].claimed == 1){ return 0; }
    }
    if (faction === "france") {
      if (his_self.game.state.newworld['france_colony1'].claimed == 1 && his_self.game.state.newworld['france_colony2'].claimed == 1){ return 0; }
    }
    if (faction === "hapsburg") {
      if (his_self.game.state.newworld['hapsburg_colony1'].claimed == 1 && his_self.game.state.newworld['hapsburg_colony2'].claimed == 1 && his_self.game.state.newworld['hapsburg_colony3'].claimed == 1){ return 0; }
    }

    //
    // Potosi takes the last colony
    //
    if (his_self.game.state.events.potosi_silver_mines_added == faction) {
      if (faction === "england") {
        if (his_self.game.state.newworld['england_colony1'].claimed == 1) { return 0; }
      }
      if (faction === "france") {
        if (his_self.game.state.newworld['france_colony1'].claimed == 1) { return 0; }
      }
      if (faction === "hapsburg") {
        if (his_self.game.state.newworld['hapsburg_colony1'].claimed == 1 && his_self.game.state.newworld['hapsburg_colony2'].claimed == 1) { return 0; }
      }
    }

    return 1;
  }

  async playerExplore(his_self, player, faction) {
    his_self.addMove("explore\t"+faction);
    his_self.endTurn();
    return 0;
  }
  async playerColonize(his_self, player, faction) {
    his_self.addMove("colonize\t"+faction);
    his_self.endTurn();
    return 0;
  }
  canPlayerConquer(his_self, player, faction) {
    if (his_self.game.state.may_conquer[faction] == 0) { return 0; }
    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    for (let i = 0; i < his_self.game.state.conquests.length; i++) {
      if (his_self.game.state.conquests[i].round == his_self.game.state.round && his_self.game.state.conquests[i].faction == faction) { return 0; }
    }
    // nothing left to take
    if (his_self.game.state.newworld['inca'].claimed == 1 && his_self.game.state.newworld['aztec'].claimed == 1 && his_self.game.state.newworld['maya'].claimed == 1) { return 0; }
    return 1;
  }
  async playerConquer(his_self, player, faction) {
    his_self.addMove("conquer\t"+faction);
    his_self.endTurn();
    return 0;
  }
  canPlayerInitiatePiracyInASea(his_self, player, faction, selected_card) {

    if (his_self.game.state.events.foul_weather) { return 0; }

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }

    if (faction === "ottoman" && his_self.game.state.events.ottoman_piracy_attempts < 4 && his_self.game.state.events.ottoman_piracy_enabled == 1) { 

      for (let key in his_self.game.navalspaces) {
        let targetsea = false;
        for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
  	  if (his_self.game.navalspaces[key].units[faction][i].type == "corsair") {
	    if (!his_self.game.state.events.ottoman_piracy_seazones.includes(key)) {
	      targetsea = true;
	    }
	  }
        }
        if (targetsea == true) {
          return 1;
        }
      }

    }

    return 0;
  }

  async playerInitiatePiracyInASea(his_self, player, faction, ops_to_spend=0, ops_remaining=0) {

    // relevant vars defined for this function
    //state.events.ottoman_piracy_enabled = 0;
    //state.events.ottoman_corsairs_enabled = 0;
    //state.events.ottoman_piracy_attempts = 0;
    //state.events.ottoman_piracy_seazones = [];

    his_self.bindBackButtonFunction(() => { his_self.displayBoard(); his_self.moves = []; his_self.playerPlayOps("", his_self.returnControllingPower(faction), ops_remaining+ops_to_spend, ""); });

    let msg = "Select Sea for Piracy: ";
    let html = '<ul>';
    for (let key in his_self.game.navalspaces) {
      let targetsea = false;
      for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
	if (his_self.game.navalspaces[key].units[faction][i].type == "corsair") { 
	  if (!his_self.game.state.events.ottoman_piracy_seazones.includes(key)) {
	    targetsea = true;
	  }
	}
      }
      if (targetsea == true) {
        html += '<li class="option" id="'+key+'">'+his_self.returnSpaceName(key)+'</li>';
      }
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
 
      // maybe no targets
      //his_self.unbindBackButtonFunction();
      his_self.updateStatus("acknowledge");
      let key = $(this).attr("id");
      let ports = [];
      let dragut = false;
      let barbarossa = false;

      let target_space = his_self.game.navalspaces[key];
      let adjacent_spaces = [];
      let io = his_self.returnImpulseOrder();
      let factions_at_war_with_ottoman = his_self.returnEnemies("ottoman", true); // true = include minor powers

      for (let i = 0; i < target_space.neighbours.length; i++) {
	adjacent_spaces.push(his_self.game.navalspaces[target_space.neighbours[i]]);
      }
      for (let i = 0; i < target_space.ports.length; i++) {
	adjacent_spaces.push(his_self.game.spaces[target_space.ports[i]]);
      }

      ports = his_self.game.navalspaces[key].ports;
      for (let i = 0; i < his_self.game.navalspaces[key].units[faction].length; i++) {
	if (his_self.game.navalspaces[key].units[faction][i].type == "dragut") { dragut = true; }
	if (his_self.game.navalspaces[key].units[faction][i].type == "barbarossa") { barbarossa = true; }
      }

      let msg = "Select Target for Piracy: ";
      let html = '<ul>';

      for (let z = 0; z < ports.length; z++) {
	let controller = his_self.game.spaces[ports[z]].political;
	if (his_self.game.spaces[ports[z]].political == "") { controller = his_self.game.spaces[ports[z]].home; }
        if (io.includes(controller) && controller != "ottoman") {
          html += '<li class="option" id="'+ports[z]+'">'+his_self.returnSpaceName(ports[z])+'</li>';
        }
      }
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_port = $(this).attr("id");
        his_self.unbindBackButtonFunction();
        his_self.updateStatus("acknowledge");
	his_self.addMove("piracy\t"+faction+"\t"+key+"\t"+target_port);
	his_self.endTurn();

      });
    });

    return 0;
  }
  canPlayerBuyCavalry(his_self, player, faction) {

    // no for protestants early-game
    if (faction === "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return false; }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "cavalry") == 0) { return false; }

    return 1;
  }
  async playerBuyCavalry(his_self, player, faction, ops_to_spend, ops_remaining) {

    //
    // ui for building multiple units
    //
    his_self.build_overlay.render(faction, "cavalry", (parseInt(ops_remaining)+parseInt(ops_to_spend)), parseInt(ops_to_spend), (num, costs) => {

      //
      // modify "continue" instruction if this is a move over a pass
      //
      for (let i = 0; i < his_self.moves.length; i++) {
        let x = his_self.moves[i];
        let y = x.split("\t");
        let new_ops_remaining = (parseInt(ops_remaining)+parseInt(ops_to_spend)) - (num*costs);
        if (y[0] === "continue") {
          if (new_ops_remaining) {
            his_self.moves[i] = y[0] + "\t" + y[1] + "\t" + y[2] + "\t" + y[3] + "\t" + new_ops_remaining + "\t" + y[5];
          } else {
            his_self.moves.splice(i, 1);
          }
        }
      }

      //
      // and place
      //
      name : "" ,
      his_self.playerSelectSpaceWithFilter(

        `Select Destination for ${num} Cavalry`,

        function(space) {
	  if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	    // can only build corsairs in a pirate haven
	    if (space.key == "algiers" || space.pirate_haven == 1) { 
	      if (his_self.game.state.events.foreign_recruits != "ottoman") { return 0; }
	    }
	  }
  	  if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	      if (space.key == "persia") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "persia") { return 1; }
	    }
	  }
	  if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	    if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	      if (space.key == "egypt") { return 1; }
	      else { return 0; }
	    } else {
	      if (space.key == "egypt") { return 1; }
	    }
	  }
          if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
	  if (his_self.game.state.events.foreign_recruits == faction && space.political == faction) { return 1; }
          if (space.owner === faction) { return 1; }
          if (space.home === faction) { return 1; }
          if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	  return 0;
        },

        function(destination_spacekey) {
          his_self.unbindBackButtonFunction();
	  his_self.updateStatus("acknowledge...");
	  for (let z = 0; z < num; z++) {
	    his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+destination_spacekey);
	  }
	  his_self.endTurn();
        },

        null,

        true

      );

    });

    his_self.playerSelectSpaceWithFilter(

      "Select Destination for Cavalry",

      function(space) {
	if (faction === "ottoman" && his_self.game.state.events.barbary_pirates == 1) {
	  // can only build corsairs in a pirate haven
	  if (space.key == "algiers" || space.pirate_haven == 1) { 
	    if (his_self.game.state.events.foreign_recruits != "ottoman") { return 0; }
	  }
	}
	if (faction === "ottoman" && his_self.game.state.events.war_in_persia == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "persia") < 5) {
	    if (space.key == "persia") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "persia") { return 1; }
	  }
	}
	if (faction === "ottoman" && his_self.game.state.events.revolt_in_egypt == 1) {
	  if (his_self.returnFactionLandUnitsInSpace("ottoman", "egypt") < 5) {
	    if (space.key == "egypt") { return 1; }
	    else { return 0; }
	  } else {
	    if (space.key == "egypt") { return 1; }
	  }
	}
        if (his_self.doesSpaceHaveEnemyUnits(space, faction)) { return 0; }
        if (space.owner === faction) { return 1; }
        if (space.home === faction) { return 1; }
        if (his_self.isSpaceControlled(space, faction) && his_self.game.state.events.foreign_recruits == faction) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"cavalry"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }
  canPlayerBuyCorsair(his_self, player, faction) {
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "squadron") == 0) { return 0; }   
    if (faction === "ottoman" && his_self.game.state.events.ottoman_corsairs_enabled == 1) {
      if (his_self.isSpaceControlled("algiers", "ottoman") && his_self.game.spaces["algiers"].besieged == 0) { return 1; }
      if (his_self.isSpaceControlled("tripoli", "ottoman") && his_self.game.spaces["tripoli"].pirate_haven == 1) { return 1; }
      if (his_self.isSpaceControlled("oran", "ottoman") && his_self.game.spaces["oran"].pirate_haven == 1) { return 1; }
    }
    if (his_self.returnNumberOfUnitsAvailableForConstruction(faction, "corsair") == 0) { return 0; }
    return 0;
  }
  async playerBuyCorsair(his_self, player, faction) {

    let count = his_self.countSpacesWithFilter((space) => {
      if (space.besieged != 0) { return 0; }
      if (space.pirate_haven == 1 && his_self.isSpaceControlled(space.key, "ottoman")) { return 1; }
      if (space.ports.length > 0 && space.home == "ottoman" && his_self.isSpaceControlled(space.key, "ottoman")) { return 1; }
      return 0;
    });


    his_self.playerSelectSpaceWithFilter(

      "Select Port for Corsair",

      function(space) {
        if (space.besieged != 0) { return 0; }
        if (space.pirate_haven == 1 && his_self.isSpaceControlled(space.key, "ottoman")) { return 1; }
        if (space.ports.length > 0 && space.home == "ottoman" && his_self.isSpaceControlled(space.key, "ottoman")) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addMove("build\tland\t"+faction+"\t"+"corsair"+"\t"+destination_spacekey);
	his_self.endTurn();
      },

      null,

      true

    );
  }
  canPlayerTranslateScripture(his_self, player, faction) {
    if (faction === "protestant") { return 1; }
    return 0;
  }
  async playerTranslateScripture(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {

    let msg = "Select Work to Translate:";
    let html = '<ul>';

    if (his_self.game.state.translations['new']['german'] < 6) {
      html += '<li class="option german" style="" id="1">German (new testament)</li>';
    }
    if (his_self.game.state.translations['new']['french'] < 6) {
      html += '<li class="option french" style="" id="2">French (new testament)</li>';
    }
    if (his_self.game.state.translations['new']['english'] < 6) {
      html += '<li class="option english" style="" id="3">English (new testament)</li>';
    }
    if (his_self.game.state.translations['full']['german'] < 10 && his_self.game.state.translations['new']['german'] >= 6) {
      html += '<li class="option german" style="" id="4">German (full bible)</li>';
    }
    if (his_self.game.state.translations['full']['french'] < 10 && his_self.game.state.translations['new']['french'] >= 6) {
      html += '<li class="option french" style="" id="5">French (full bible)</li>';
    }
    if (his_self.game.state.translations['full']['english'] < 10 && his_self.game.state.translations['new']['english'] >= 6) {
      html += '<li class="option english" style="" id="6">English (full bible)</li>';
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = parseInt($(this).attr("id"));
      his_self.updateStatus("selecting...");
      his_self.language_zone_overlay.hide();

      if (id == 1 || id == 4) {
	his_self.addMove("translation\tgerman\t"+ops_to_spend);
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in German Language Zone\ttranslation_german_language_zone\tgerman\t"+faction);
      }
      if (id == 2 || id == 5) { 
	his_self.addMove("translation\tfrench\t"+ops_to_spend); 
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in French Language Zone\ttranslation_french_language_zone\tfrench\t"+faction);
      }
      if (id == 3 || id == 6) { 
	his_self.addMove("translation\tenglish\t"+ops_to_spend);
	his_self.addMove("counter_or_acknowledge\tProtestants Translate in English Language Zone\ttranslation_english_language_zone\tenglish\t"+faction);
      }
      // we only ask for our own CONFIRMS
      his_self.addMove("RESETCONFIRMSNEEDED\t"+his_self.game.player);
      his_self.endTurn();

    });

  }
  canPlayerPublishTreatise(his_self, player, faction) {
    if (faction === "protestant") {
      if (his_self.canProtestantsReformInLanguageZone("german")) { return 1; }
      if (his_self.canProtestantsReformInLanguageZone("english")) { return 1; }
      if (his_self.canProtestantsReformInLanguageZone("french")) { return 1; }
      if (his_self.canProtestantsReformInLanguageZone("spanish")) { return 1; }
      if (his_self.canProtestantsReformInLanguageZone("italian")) { return 1; }
      return 0;
    }
    if (faction === "england") {
      let where_is_cranmer = his_self.isPersonageOnMap("england", "cranmer-reformer");
      if (where_is_cranmer != "") {
        return 1;
      }
    }
    return 0;
  }
  async playerPublishTreatise(his_self, player, faction) {

    if (faction === "protestant") {

      let msg = "Select Language Zone for Reformation Attempts:";
      let html = '<ul>';
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("german") || his_self.canProtestantsReformInLanguageZone("german")) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("english") || his_self.canProtestantsReformInLanguageZone("english")) {
        html += '<li class="option english" style="" id="english">English</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("french") || his_self.canProtestantsReformInLanguageZone("french")) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("spanish") || his_self.canProtestantsReformInLanguageZone("spanish")) {
        html += '<li class="option spanish" style="" id="spanish">Spanish</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("italian") || his_self.canProtestantsReformInLanguageZone("italian")) {
        html += '<li class="option italian" style="" id="italian">Italian</li>';
      }
      html += '</ul>';

      //
      // show visual language zone selector
      //
      his_self.language_zone_overlay.render();

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        $('.option').off();
        his_self.language_zone_overlay.hide();

        let id = $(this).attr("id");

	if (id === "french" && his_self.canPlayerCommitDebater("protestant", "calvin-debater") && his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {

          let msg = "Use Calvin Debater Bonus +1 Attempt:";
          let html = '<ul>';
          html += '<li class="option" style="" id="calvin-debater">Yes, Commit Calvin</li>';
          html += '<li class="option" style="" id="no">No</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('mouseover', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.show(action2);
            }
          });
          $('.option').on('mouseout', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.hide(action2);
            }
          });
          $('.option').on('click', function () {
            let id = $(this).attr("id");

	    his_self.updateStatus("submitting...");
	    his_self.addMove("hide_overlay\tpublish_treatise\tfrench");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    if (id === "calvin-debater") {
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench");
	    } else {
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench\t1");
	      his_self.addMove("protestant_reformation\t"+player+"\tfrench\t1");
	    }
	    his_self.addMove("show_overlay\tpublish_treatise\tfrench");
	    if (id === "calvin-debater") {
	      his_self.addMove("commit\tprotestant\tcalvin-debater\t1");
	    }
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	    his_self.endTurn();

	    return 0;
	  });

	  return 0;
        }


	if (id === "german" && his_self.canPlayerCommitDebater("protestant", "carlstadt-debater") && his_self.game.player === his_self.returnPlayerOfFaction("protestant")) {

          let msg = "Use Carlstadt Debater Bonus +1 Attempt:";
          let html = '<ul>';
          html += '<li class="option" style="" id="carlstadt-debater">Yes, Commit Carlstadt</li>';
          html += '<li class="option" style="" id="no">No</li>';
          html += '</ul>';

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('mouseover', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.show(action2);
            }
          });
          $('.option').on('mouseout', function () {
            let action2 = $(this).attr("id");
            if (his_self.debaters[action2]) {
              his_self.cardbox.hide(action2);
            }
          });
          $('.option').on('click', function () {
            let id = $(this).attr("id");

	    his_self.updateStatus("submitting...");
	    his_self.cardbox.hide();

	    his_self.addMove("hide_overlay\tpublish_treatise\tgerman");
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	    if (id === "carlstadt-debater") {
	      his_self.addMove("SETVAR\tstate\tevents\tcarlstadt_debater\t0");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman");
	    } else {
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman\t1");
	      his_self.addMove("protestant_reformation\t"+player+"\tgerman\t1");
	    }
	    his_self.addMove("show_overlay\tpublish_treatise\tgerman");
	    if (id === "carlstadt-debater") {
	      his_self.addMove("commit\tprotestant\tcarlstadt-debater\t1");
	      his_self.addMove("SETVAR\tstate\tevents\tcarlstadt_debater\t1");
	    }
	    his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");

	    his_self.endTurn();

	    return 0;
	  });

	  return 0;
        }

	his_self.addMove("hide_overlay\tpublish_treatise\t"+id);
	his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	his_self.addMove("protestant_reformation\t"+player+"\t"+id+"\t1");
	his_self.addMove("protestant_reformation\t"+player+"\t"+id+"\t1");
	his_self.addMove("show_overlay\tpublish_treatise\t"+id);
	his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	his_self.endTurn();
      });

    }


    if (faction === "england") {
      let id = "english";
      his_self.addMove("protestant_reformation\t"+player+"\t"+id);
      his_self.addMove("protestant_reformation\t"+player+"\t"+id);
      his_self.endTurn();
    }

    return 0;
  }
  canPlayerCallTheologicalDebateMaryI(his_self, player, faction) {
    if (his_self.returnDebatersInLanguageZone("english", "protestant", 0) || his_self.returnDebatersInLanguageZone("english", "protestant", 1)) {
      return his_self.canPlayerCallTheologicalDebate(his_self, player, faction, 1);
    } else {
      return 0;
    }
  }
  canPlayerCallTheologicalDebate(his_self, player, faction, mary_i=0) {
    if (his_self.returnNumberOfUncommittedDebaters(faction) <= 0) { return 0; }
    if (his_self.game.state.events.wartburg == 1) { if (faction === "protestant") { return 0; } }
    if (faction === "protestant") { return 1; }
    if (faction === "papacy") { return 1; }
    return 0;
  }
  async playerCallTheologicalDebateMaryI(his_self, player, faction) {
    return his_self.playerCallTheologicalDebate(his_self, player, faction, 1);
  }
  async playerCallTheologicalDebateInRegion(his_self, player, faction, region="", mary_i=0) {

      let language_zone = region;
      let opponent_faction = "protestant";
      if (faction != "papacy") { opponent_faction = "papacy"; }

      let msg = "Against Commited or Uncommited Debater?";
      let html = '<ul>';
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 1)) {
          html += '<li class="option committed" id="committed">Committed</li>';
      }
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 0)) {
          html += '<li class="option uncommitted" id="uncommitted">Uncommitted</li>';
      }
      html += '</ul>';

      //
      // show visual language zone selector
      //
      his_self.language_zone_overlay.render();
      his_self.language_zone_overlay.pushHudUnderOverlay();

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.committed').on('mouseover', function () {
        his_self.language_zone_overlay.hideDebaters();
        if (faction == "papacy") { 
	  his_self.language_zone_overlay.showDebaters(language_zone, "committed", "protestant"); 
	} else {
          his_self.language_zone_overlay.showDebaters(language_zone, "committed", "papacy");
	}
      });
      $('.committed').on('mouseout', function () {
        his_self.language_zone_overlay.hideDebaters();
      });
      $('.uncommitted').on('mouseover', function () {
        his_self.language_zone_overlay.hideDebaters();
	if (faction == "papacy") {
          his_self.language_zone_overlay.showDebaters(language_zone, "uncommitted", "protestant");
	} else {
          his_self.language_zone_overlay.showDebaters(language_zone, "uncommitted", "papacy");
	}
      });
      $('.uncommitted').on('mouseout', function () {
        his_self.language_zone_overlay.hideDebaters();
      });

      $('.option').on('click', function () {

        let committed = $(this).attr("id");

        his_self.language_zone_overlay.hide();

        if (committed === "committed") { committed = 1; } else { committed = 0; }

        if (faction === "papacy") {
	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+committed);
        } else {
    	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tProtestants call a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
    	  his_self.addMove("pick_first_round_debaters\tprotestant\tpapacy\t"+language_zone+"\t"+committed);
        }
        his_self.endTurn();

      });

    return 0;

  }
  async playerCallTheologicalDebate(his_self, player, faction, mary_i=0) {

    let msg = "Select Language Zone for Theological Debate:";
    let html = '<ul>';

    if (faction === "protestant" || faction === "england") {
      if (his_self.returnDebatersInLanguageZone("german", "protestant", 0)) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnDebatersInLanguageZone("french", "protestant", 0)) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnDebatersInLanguageZone("english", "protestant", 0)) {
	if (his_self.game.state.events.more_executed_limits_debates != 1) {
          html += '<li class="option english" style="" id="english">English</li>';
        }
      }
    }
    if (faction === "papacy") {
      if (mary_i == 1) {
        html += '<li class="option english" style="" id="english">English</li>';
      } else {
        html += '<li class="option german" style="" id="german">German</li>';
        if (his_self.returnDebatersInLanguageZone("french", "protestant", 0) || his_self.returnDebatersInLanguageZone("french", "protestant", 1)) {
          html += '<li class="option french" style="" id="french">French</li>';
        }
        if (his_self.returnDebatersInLanguageZone("english", "protestant", 0) || his_self.returnDebatersInLanguageZone("english", "protestant", 1)) {
          html += '<li class="option english" style="" id="english">English</li>';
        }
      }
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();
    his_self.language_zone_overlay.pushHudUnderOverlay();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', (e) => {

      $('.option').off();
      let language_zone = e.currentTarget.id;
      let opponent_faction = "protestant";
      if (faction != "papacy") { opponent_faction = "papacy"; }

      let msg = "Against Commited or Uncommited Debater?";
      let html = '<ul>';
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 1)) {
          html += '<li class="option committed" id="committed">Committed</li>';
      }
      if (0 < his_self.returnDebatersInLanguageZone(language_zone, opponent_faction, 0)) {
          html += '<li class="option uncommitted" id="uncommitted">Uncommitted</li>';
      }
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.committed').on('mouseover', function () {
        his_self.language_zone_overlay.hideDebaters();
        if (faction == "papacy") { 
	  his_self.language_zone_overlay.showDebaters(language_zone, "committed", "protestant"); 
	} else {
          his_self.language_zone_overlay.showDebaters(language_zone, "committed", "papacy");
	}
      });
      $('.committed').on('mouseout', function () {
        his_self.language_zone_overlay.hideDebaters();
      });
      $('.uncommitted').on('mouseover', function () {
        his_self.language_zone_overlay.hideDebaters();
	if (faction == "papacy") {
          his_self.language_zone_overlay.showDebaters(language_zone, "uncommitted", "protestant");
	} else {
          his_self.language_zone_overlay.showDebaters(language_zone, "uncommitted", "papacy");
	}
      });
      $('.uncommitted').on('mouseout', function () {
        his_self.language_zone_overlay.hideDebaters();
      });

      $('.option').on('click', function () {

        let committed = $(this).attr("id");

        his_self.language_zone_overlay.hide();

        if (committed === "committed") { committed = 1; } else { committed = 0; }

        if (faction === "papacy") {
	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tPapacy calls a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
	  his_self.addMove("pick_first_round_debaters\tpapacy\tprotestant\t"+language_zone+"\t"+committed);
        } else {
    	  his_self.addMove("theological_debate");
          his_self.addMove("counter_or_acknowledge\tProtestants call a theological debate\tdebate\t"+language_zone);
          his_self.addMove("RESETCONFIRMSNEEDED\tall");
    	  his_self.addMove("pick_first_round_debaters\tprotestant\tpapacy\t"+language_zone+"\t"+committed);
        }
        his_self.endTurn();

      });
    });

    return 0;

  }
  canPlayerBuildSaintPeters(his_self, player, faction) {
    if (faction === "papacy") {
      if (his_self.game.state.saint_peters_cathedral['vp'] < 5) { return 1; }
    }
    return 0;
  }
  async playerBuildSaintPeters(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {
    for (let z = 0; z < ops_to_spend; z++) {
      his_self.addMove("build_saint_peters\t"+player+"\t"+faction);
    }
    his_self.endTurn();
    return 0;
  }

  canPlayerShowTutorial(his_self, player, faction) {
    if (his_self.game.state.round == 1) { return 1; }
    return 0;
  }
  async playerShowTutorial(his_self, player, faction, ops_to_spend=1, ops_remaining=0) {

    his_self.game.state.may_explore['england'] = 1;
    his_self.game.state.may_explore['france'] = 1;
    his_self.game.state.may_explore['hapsburg'] = 1;
    his_self.game.state.may_conquer['england'] = 1;
    his_self.game.state.may_conquer['france'] = 1;
    his_self.game.state.may_conquer['hapsburg'] = 1;
    his_self.game.state.may_colonize['england'] = 1;
    his_self.game.state.may_colonize['france'] = 1;
    his_self.game.state.may_colonize['hapsburg'] = 1;

    let title = "";
    let text = "";
    let img = "";
    let card = "";

    let options = [];

    //
    // Protestant
    //
    if (faction == "protestant") {

      title = "Publish a Treatise?";
      text = "You get +1 roll for each adjacent Protestant space. Committing debaters give bonus but make debaters vulnerable in theological debates...";
      img = "/his/img/backgrounds/move/printing_press.jpg";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      title = "Watch the Discard Pile";
      text = "Play your home card to retrieve cards from the discard pile. Play immediately or hold for future use...";
      img = "/his/img/backgrounds/move/publish_treatise.jpg";
      card = his_self.returnCardImage("007");
      options.push({ title : title , text : text , img : img , card : card });

      if (ops_remaining == 1) {
        title = "Translate the Bible!";
        text = "Translate the New Testament for 6 reformation attempts. Translate the Full Bible for 6 more with +1 modifier on each roll and a 1 VP bonus.";
        img = "/his/img/backgrounds/move/translate.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // Papacy
    //
    if (faction == "papacy") {

      title = "Convene a Debate?";
      text = "Play Leipzig Debate and pick your strongest debater. You can burn opponents or force Luther to defend his flock, wasting 5 Protestant OPs";
      img = "/his/img/backgrounds/move/theological_debate.jpg";
      card = his_self.returnCardImage("007");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Conquer Florence";
      text = "Move your troops into Siena. Control Siena to create a line of control to Florence. Then besiege and assault the city.";
      img = "/his/img/backgrounds/move/papacy-florence.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (ops_remaining == 1) {
        title = "Build St. Peters!";
        text = "The Papacy earns VP for building St. Peter's Cathedral.";
        img = "/his/img/backgrounds/move/saint_peters.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }
    }

    //
    // Ottoman
    //
    if (faction == "ottoman") {

      title = "Crush the Hungarians";
      text = "Conquer Belgrade and Buda to earn 2 VP and force the Hapsburgs into war...";
      img = "/his/img/backgrounds/tutorials/ottoman-hungary.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      title = "Control the Mediterranean";
      text = "Piracy is harder around fortresses. Move ships into the Aegean Sea, and transport your units to Rhodes to assault the fortress...";
      img = "/his/img/backgrounds/tutorials/ottoman-rhodes.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.events.barbary_pirates == 1) {
        title = "Piracy?!";
        text = "Build corsairs in Algiers. Move them around the Mediterranean and target opponents with Piracy. Every hit earns VP or a card draw...";
        card = his_self.returnCardImage("009");
        img = "/his/img/backgrounds/move/piracy.jpg";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // Hapsburg
    //
    if (faction == "hapsburg") {

      if (his_self.game.spaces["metz"].besieged == 0) {
        title = "Control Metz";
        text = "Build troops on Becanson and move them north to Metz. Assault the city the following turn.";
        img = "/his/img/backgrounds/tutorials/hapsburg-metz.png";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      title = "Invade France";
      text = "Build infantry in Navarre and move them north to besiege Bordeaux. Assault the city the following turn.";
      img = "/his/img/backgrounds/tutorials/hapsburg-bordeaux.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_conquer['hapsburg'] == 1) {
        title = "New World Conquest";
        text = "Conquests are more difficult than Explorations, but can earn you bonus cards in the New World phase...";
        img = "/his/img/backgrounds/move/conquer.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['hapsburg'] == 1) {
        title = "Found a Colony";
        text = "At the end of every round each colony rolls dice to win bonus cards for the following round...";
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // France
    //
    if (faction == "france") {

      title = "Build a Chateaux";
      text = "Your Home Card earns VP and bonus cards, and your chance of success increases if France is not under attack.";
      img = "/his/img/backgrounds/chateaux.png";
      card = his_self.returnCardImage("004");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Conquer the New World";
      text = "Conquests are more difficult than Explorations, but can earn you bonus cards in the New World phase...";
      img = "/his/img/backgrounds/move/conquer.jpg";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_explore['france'] == 1) {
        title = "Explore the New World";
        text = "New World Explorations cost 2 OPs and earn VP if they succeed. Dice are rolled and discoveries are made at the end of each turn.";
        img = "/his/img/backgrounds/move/explore.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['france'] == 1) {
        title = "Found a Colony";
        text = "At the end of every round each colony rolls dice to win bonus cards for the following round...";
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_conquer['france'] == 1) {
        title = "Fortify Italy";
        text = "France struggles to move forces into Italy and Milan is vulnerable to attack. Protect and expand your Italian territories.";
        img = "/his/img/backgrounds/tutorials/france-milan.png";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    //
    // England
    //
    if (faction == "england") {

      title = "Unify the British Isles?";
      text = "Your Home Card lets you declare war on Scotland, which is necessary for attacking Edinburgh. Remember you will need 2 squadrons in the North Sea to assault the city.";
      img = "/his/img/backgrounds/tutorials/england-edinburgh.png";
      card = his_self.returnCardImage("003");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Henry VIII and Marriage";
      text = "From round 2 on, event your Home Card to advance Henry VIII's marital status. England earns 6 VP once a male heir is born.";
      img = "/his/img/backgrounds/henry_viii.jpeg";
      card = his_self.returnCardImage("003");
      options.push({ title : title , text : text , img : img , card : card });

      title = "Fortify Calais?";
      text = "Calais is vulnerable to attack from the French and offers your landing point for invasions of the continent. Consider reinforcing it sooner rather than later.";
      img = "/his/img/backgrounds/tutorials/england-calais.png";
      card = "";
      options.push({ title : title , text : text , img : img , card : card });

      if (his_self.game.state.may_conquer['england'] == 1) {
        title = "Conquer the New World";
        text = "Conquests are harder than Explorations. In addition to earning VP if they succeed, they also roll dice for bonus cards at the end of every turn. Consider sending an expedition!";
        img = "/his/img/backgrounds/move/conquer.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_explore['england'] == 1) {
        title = "Explore the New World";
        text = "New World Explorations cost 2 OPs and earn VP if they succeed. Dice are rolled and discoveries are made at the end of each turn.";
        img = "/his/img/backgrounds/move/explore.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

      if (his_self.game.state.may_colonize['england'] == 1) {
        title = "Found a Colony";
        text = "You are allowed up to three colonies. At the end of every turn your surviving colonies will roll dice for bonus cards. Having more cards can provide a crucial advantage later in the game."
        img = "/his/img/backgrounds/move/colonize.jpg";
        card = "";
        options.push({ title : title , text : text , img : img , card : card });
      }

    }

    let x = Math.floor(Math.random() * options.length);

    his_self.welcome_overlay.renderCustom({
      title : options[x].title ,
      text : options[x].text ,
      card : options[x].card ,
      img : options[x].img ,
    });

    return 0;

  }

  canPlayerBurnBooksMaryI(his_self, player, faction) {
    return his_self.canPlayerBurnBooks(his_self, player, faction, 1);
  }
  canPlayerBurnBooks(his_self, player, faction, mary_i=0) {
    if (faction === "papacy") { return 1; }
    return 0;
  }
  async playerBurnBooksMaryI(his_self, player, faction, ops_to_spend=0, ops_remaining=0, mary_i=1) {
    return his_self.playerBurnBooks(his_self, player, faction, ops_to_spend, ops_remaining, 1);
    return 0;
  }
  async playerBurnBooks(his_self, player, faction, ops_to_spend, ops_remaining, mary_i=0) {

    let msg = "Select Language Zone for Counter Reformations";
    let html = '<ul>';

    if (mary_i == 0) {
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("german")) {
        html += '<li class="option german" style="" id="german">German</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("english")) {
        html += '<li class="option english" style="" id="english">English</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("french")) {
        html += '<li class="option french" style="" id="french">French</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("spanish")) {
        html += '<li class="option spanish" style="" id="spanish">Spanish</li>';
      }
      if (his_self.returnNumberOfProtestantSpacesInLanguageZone("italian")) {
        html += '<li class="option italian" style="" id="italian">Italian</li>';
      }
    } else {
      html += '<li class="option english" style="" id="english">English</li>';
    }
    html += '</ul>';

    //
    // show visual language zone selector
    //
    his_self.language_zone_overlay.render();

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      $('.option').off();
      his_self.language_zone_overlay.hide();
      let id = $(this).attr("id");

      if ((his_self.canPlayerCommitDebater("papacy", "cajetan-debater") || his_self.canPlayerCommitDebater("papacy", "tetzel-debater") || his_self.canPlayerCommitDebater("papacy", "caraffa")) && his_self.game.player === his_self.returnPlayerOfFaction("papacy")) {

        let msg = "Commit Debater for Burn Books Bonus:";
        let html = '<ul>';
        html += '<li class="option" style="" id="no">No</li>';
	if (his_self.canPlayerCommitDebater("papacy", "tetzel-debater")) {
          html += '<li class="option" style="" id="tetzel-debater">Tetzel +1 to St Peters</li>';
	}
	if (his_self.canPlayerCommitDebater("papacy", "cajetan-debater")) {
          html += '<li class="option" style="" id="cajetan-debater">Cajetan +1 Attempt</li>';
	}
	if (his_self.canPlayerCommitDebater("papacy", "caraffa-debater")) {
          html += '<li class="option" style="" id="caraffa-debater">Caraffa +1 Attempt</li>';
        }
	html += '</ul>';

        his_self.updateStatusWithOptions(msg, html);

        $('.option').off();
        $('.option').on('mouseover', function () {
          let action2 = $(this).attr("id");
          if (his_self.debaters[action2]) {
            his_self.cardbox.show(action2);
          }
        });
        $('.option').on('mouseout', function () {
          let action2 = $(this).attr("id");
          if (his_self.debaters[action2]) {
            his_self.cardbox.hide(action2);
          }
        });
        $('.option').on('click', function () {
          let id2 = $(this).attr("id");

	  his_self.cardbox.hide();

	  if (id2 === "tetzel-debater") {
            his_self.addMove("build_saint_peters");
            his_self.addMove("commit\tpapacy\ttetzel-debater\t1");
	  }

	  his_self.addMove("hide_overlay\tburn_books\t"+id);
	  his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
	  if (id2 === "cajetan-debater" || id2 === "caraffa-debater") {
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id);
	    if (id2 === "cajetan-debater") { his_self.addMove("commit\tpapacy\tcajetan-debater"); }
	    if (id2 === "caraffa-debater") { his_self.addMove("commit\tpapacy\tcaraffa-debater"); }
	  } else {
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
            his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
	  }
	  his_self.addMove("show_overlay\tburn_books\t"+id);
	  his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
	  his_self.endTurn();

	  return 0;
	});

	return 0;
      }

      his_self.addMove("hide_overlay\tburn_books\t"+id);
      his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t0");
      his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
      his_self.addMove("catholic_counter_reformation\t"+player+"\t"+id+"\t1");
      his_self.addMove("SETVAR\tstate\tskip_counter_or_acknowledge\t1");
      his_self.addMove("show_overlay\tburn_books\t"+id);
      his_self.endTurn();
    });

    return 0;
  }
  canPlayerFoundJesuitUniversity(his_self, player, faction) {
    if (faction === "papacy" && his_self.game.state.events.papacy_may_found_jesuit_universities == 1) { return 1; }
    return 0;
  }
  async playerFoundJesuitUniversity(his_self, player, faction) {

    his_self.playerSelectSpaceWithFilter(

      "Select Catholic-Controlled Space for Jesuit University",

      function(space) {
        if (space.religion === "catholic" && space.university != 1) { return 1; }
	return 0;
      },

      function(destination_spacekey) {
        his_self.updateStatus("building university...");
        his_self.addMove("found_jesuit_university\t"+destination_spacekey);
        his_self.addMove("SETVAR\tstate\tloyola_bonus_active\t1");
	his_self.endTurn();
      },

      null,

      true

    );

    return 0;
  }

  playerPlaceUnitsInSpaceWithFilter(unittype, num, faction, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);

    if (count == 0) { his_self.endTurn(); return 0; }

    his_self.playerSelectSpaceWithFilter(

      `Place ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {
        
        his_self.unbindBackButtonFunction();
	his_self.updateStatus("acknowledge...");
	his_self.addUnit(faction, spacekey, unittype);
	his_self.displaySpace(spacekey);
        his_self.addMove("build\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
	if (mycallback != null) { mycallback(spacekey); }

	if (num == 1) {
          his_self.endTurn();
	} else {
  	  his_self.playerPlaceUnitsInSpaceWithFilter(unittype, num-1, faction, filter_func, mycallback, cancel_func, board_clickable);
	}
      },

      cancel_func ,

      board_clickable 
    );
  }


  playerRemoveUnitsInSpaceWithFilter(unittype, num, faction, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);
    if (count == 0) { 
      his_self.updateStatus("No Spaces Available for Unit Removal"); 
      his_self.endTurn();
      return 0;
    }

    his_self.playerSelectSpaceWithFilter(

      `Remove ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {

	his_self.updateStatus("removing unit...");

	his_self.removeUnit(faction, spacekey, unittype);

	his_self.displaySpace(spacekey);

        his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	

	if (num == 1) {
          his_self.endTurn();
	} else {
  	  his_self.playerRemoveUnitsInSpaceWithFilter(unittype, num-1, faction, filter_func, mycallback, cancel_func, board_clickable);
	}

      },

      cancel_func,

      true

    );
  }



  playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num, filter_func=null, mycallback = null, cancel_func = null, board_clickable = false) {

    let his_self = this;
    let placed = 0;

    let count = his_self.countSpacesWithFilter(filter_func);
    if (count == 0) { 
      his_self.updateStatus("No Spaces Available for Unit Removal"); 
      his_self.endTurn();
      return 0;
    }

    his_self.playerSelectSpaceWithFilter(

      `Remove ${his_self.units[unittype].name} (${num})` ,

      filter_func ,

      function(spacekey) {

	his_self.updateStatus("removing unit...");

	let s = his_self.game.spaces[spacekey];
	let factions_with_units = [];
	for (let f in s.units) {
	  for (let z = 0; z < s.units[f].length; z++) {
	    if (s.units[f][z].type === unittype && !factions_with_units.includes(f)) { factions_with_units.push(f); z = 100; }
	  }
        }

	if (factions_with_units.length == 1) {
	  let faction = factions_with_units[0];
	  his_self.removeUnit(faction, spacekey, unittype);
	  his_self.displaySpace(spacekey);
          his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
  	  if (num == 1) {
            his_self.endTurn();
	  } else {
  	    his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num-1, filter_func, mycallback, cancel_func, board_clickable);
	  }
	} else {

          let msg = "Remove Mercenary from which Faction?";
          let html = '<ul>';
          for (let z = 0; z < factions_with_units.length; z++) {
	    html += `<li class="option" id="${factions_with_units[z]}">${his_self.returnFactionName(factions_with_units[z])}</li>`;
	  }
          html += '</ul>';
          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let faction = $(this).attr("id");
	    his_self.removeUnit(faction, spacekey, unittype);
	    his_self.displaySpace(spacekey);
            his_self.addMove("remove_unit\tland\t"+faction+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);	
  	    if (num == 1) {
              his_self.endTurn();
	    } else {
  	      his_self.playerRemoveAnyFactionUnitsInSpaceWithFilter(unittype, num-1, filter_func, mycallback, cancel_func, board_clickable);
	    }
          });
	}
      },

      cancel_func,

      true

    );
  }

  playerAddUnrest(his_self, faction="", zone="", religion="") {

    his_self.playerSelectSpaceWithFilter(
      "Select Space to add Unrest" ,
      function(space) {
        if (space.language === zone && space.religion === religion) { return 1; }
      },
      function(spacekey) {
        his_self.addMove(`unrest\t${spacekey}`);
        his_self.endTurn();
      },
      null,
      true 
    );

  }


  playerManuallyRemoveExcommunication(his_self, faction) {

    let msg = "Give Papacy Card to Remove Excommunication?";
    let html = '<ul>';
    html += `<li class="option" id="yes">give random card</li>`;
    html += `<li class="option" id="no">remain excommunicated</li>`;
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");

      if (id == "yes") {
        his_self.addMove("unexcommunicate_faction\t"+faction);
        his_self.addMove("pull_card\t"+"papacy"+"\t"+faction);
        his_self.addMove("NOTIFY\t"+his_self.returnFactionName(faction) + " gives card to remove excommunication");
      }
      his_self.endTurn();

    });
  }


  canFactionSueForPeace(faction) {

    let his_self = this;
    let f = [];
    let io = this.returnImpulseOrder();

    for (let i = 0; i < io.length; i++) {
      if (this.areEnemies(faction, io[i])) {
	for (let key in this.game.spaces) {
	  if (this.game.spaces[key].home == faction) {
	    if (this.returnFactionControllingSpace(key) == io[i]) {
	      if (!f.includes(io[i])) {
	        f.push(io[i]);
	      }
	    }
	  }
	}
	if (!f.includes(io[i])) {
	  let p2 = this.returnPlayerCommandingFaction(io[i]);
          for (let z = 0; z < his_self.game.state.players_info[p2-1].captured.length; z++) {
	    if (his_self.game.state.players_info[p2-1].captured[z].faction == faction) {
	      if (!f.includes(io[i])) {
	        f.push(io[i]);
	      }
	    }
	  }
        }
      }
    }

    if (faction == "protestant") {
      for (let z = 0; z < f.length; z++) {
	if (f[z] == "hapsburg" || f[z] == "papacy") { 
	  f.splice(z, 1);
	  z--;
	}
      }
    }
    if (faction == "papacy" || faction == "hapsburg") {
      for (let z = 0; z < f.length; z++) {
	if (f[z] == "protestant") {
	  f.splice(z, 1);
	  z--;
	}
      }
    }

    return f;

  }

  playerSueForPeace(his_self, faction) {

    let f = this.canFactionSueForPeace(faction);

    let msg = `${his_self.returnFactionName(faction)} - Sue for Peace?`;
    let html = '<ul>';
    for (let i = 0; i < f.length; i++) {
      html += `<li class="option" id="${f[i]}">${his_self.returnFactionName(f[i])}</li>`;
    }
    html += `<li class="option" id="skip">skip</li>`;
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      his_self.bindBackButtonFunction(() => { his_self.moves = []; his_self.playerSueForPeace(his_self, faction); });

      let target_faction = $(this).attr("id");

      if (target_faction == "skip") {
	his_self.unbindBackButtonFunction();
        his_self.updateStatus("skipping...");
	his_self.endTurn();
	return;
      }

      //
      // notify us
      //
      his_self.addMove("NOTIFY\t" + his_self.returnFactionName(faction) + " sues for peace with " + his_self.returnFactionName(target_faction));

      //
      // no longer enemies
      //
      his_self.addMove("unset_enemies\t"+faction+"\t"+target_faction);

      //
      // +1 War Winner VP
      //
      let bonus_vp = 1;
      if (target_faction == "ottoman" || faction == "ottoman") { bonus_vp = 2; }

      his_self.addMove("display_vp_track");
      for (let z = 0; z < bonus_vp; z++) {
        if (target_faction == "protestant") { his_self.addMove(`SETVAR\tstate\tprotestant_war_winner_vp\t${parseInt(his_self.game.state.protestant_war_winner_vp)+1}`); }
        if (target_faction == "ottoman")    { his_self.addMove(`SETVAR\tstate\tottoman_war_winner_vp\t${parseInt(his_self.game.state.ottoman_war_winner_vp)+1}`); }
        if (target_faction == "papacy")     { his_self.addMove(`SETVAR\tstate\tpapacy_war_winner_vp\t${parseInt(his_self.game.state.papacy_war_winner_vp)+1}`); }
        if (target_faction == "france")     { his_self.addMove(`SETVAR\tstate\tfrance_war_winner_vp\t${parseInt(his_self.game.state.france_war_winner_vp)+1}`); }
        if (target_faction == "england")    { his_self.addMove(`SETVAR\tstate\tengland_war_winner_vp\t${parseInt(his_self.game.state.england_war_winner_vp)+1}`); }
        if (target_faction == "hapsburg")   { his_self.addMove(`SETVAR\tstate\thapsburg_war_winner_vp\t${parseInt(his_self.game.state.hapsburg_war_winner_vp)+1}`); }
      }

      //
      // loser returns winner home spaces
      //
      for (let key in his_self.game.spaces) {
	if (his_self.game.spaces[key].home === target_faction) {
	  if (his_self.returnControllingPower(his_self.game.spaces[key].political) === faction) {
            his_self.addMove(`control\t${target_faction}\t${key}`);
	    for (let f in his_self.game.spaces[key].units) {
	      if (his_self.returnControllingPower(f) == faction) {
                his_self.addMove(`withdraw_to_nearest_fortified_space\t${f}\t${key}`);
	      }
	    }
	  }
        }
      }

      //
      // loser removes 2 units
      //
      his_self.playerSelectSpaceOrNavalSpaceWithFilter(
        `Select Space to Remove 1st Unit` ,
        function(space) {
          if (space.units[faction].length > 0) {
	    for (let i = 0; i < space.units[faction].length; i++) {
	      let u = space.units[faction][i];
	      if (u.type == "regular" || u.type == "squadron" || u.type == "corsair" || u.type == "mercenary" || u.type == "cavalry") { return 1; }
	    }
	  }
          return 0;
        },
        function(spacekey) {
          let land_or_sea = "land";
          let space = null;
          if (his_self.game.navalspaces[spacekey]) {
            land_or_sea = "sea";
            space = his_self.game.navalspaces[spacekey];
          } else {
            space = his_self.game.spaces[spacekey];
          }
          if (space == null) {
            alert("ERROR: not sure where you clicked - reload to continue");
            return 1;
          }
          let faction_to_destroy = faction;
          let msg = "Destroy Which Unit: ";
          let unittypes = [];
          let html = '<ul>';
          for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
            if (space.units[faction_to_destroy][i].command_value == 0 && space.units[faction_to_destroy][i].personage != true) {
              if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                unittypes.push(space.units[faction_to_destroy][i].key);
              }
            }
          }
          html += '</ul>';
          his_self.updateStatusWithOptions(msg, html);
          $('.option').off();
          $('.option').on('click', function () {
            let unittype = $(this).attr("id");
            his_self.updateStatus("removing unit...");
            his_self.removeUnit(faction_to_destroy, spacekey, unittype);
            his_self.bindBackButtonFunction(() => { his_self.moves = []; his_self.addUnit(faction_to_destroy, spacekey, unittype); his_self.displayBoard(); his_self.playerSueForPeace(his_self, faction); });
            his_self.displaySpace(spacekey);
            his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
            //
            // loser removes 2 units
            //
            his_self.playerSelectSpaceOrNavalSpaceWithFilter(
              `Select Space to Remove 2nd Unit` ,
              function(space) {
                if (space.units[faction].length > 0) {
	          for (let i = 0; i < space.units[faction].length; i++) {
	          let u = space.units[faction][i];
	            if (u.type == "regular" || u.type == "squadron" || u.type == "corsair" || u.type == "mercenary" || u.type == "cavalry") { return 1; }
	          }
	        }
                return 0;
              },
              function(spacekey) {
                his_self.updateStatus("removing unit...");
                let land_or_sea = "land";
                let space = null;
                if (his_self.game.navalspaces[spacekey]) {
                  land_or_sea = "sea";
                  space = his_self.game.navalspaces[spacekey];
                } else {
                  space = his_self.game.spaces[spacekey];
                }
                if (space == null) {
                  alert("ERROR: not sure where you clicked - reload to continue");
                  return 1;
                }
                let faction_to_destroy = faction;
                let msg = "Destroy Which Unit: ";
                let unittypes = [];
                let html = '<ul>';
                for (let i = 0; i < space.units[faction_to_destroy].length; i++) {
                  if (space.units[faction_to_destroy][i].personage != true && space.units[faction_to_destroy][i].battle_rating != 1) {
                    if (!unittypes.includes(space.units[faction_to_destroy][i].key)) {
                      html += `<li class="option" id="${space.units[faction_to_destroy][i].key}">${space.units[faction_to_destroy][i].key}</li>`;
                      unittypes.push(space.units[faction_to_destroy][i].key);
                    }
                  }
                }
	        html += '</ul>';
                his_self.updateStatusWithOptions(msg, html);
                $('.option').off();
                $('.option').on('click', function () {
                  let unittype = $(this).attr("id");
                  his_self.updateStatus("removing unit...");
                  his_self.removeUnit(faction_to_destroy, spacekey, unittype);
		  his_self.unbindBackButtonFunction();
                  his_self.displaySpace(spacekey);
                  his_self.addMove("remove_unit\t"+land_or_sea+"\t"+faction_to_destroy+"\t"+unittype+"\t"+spacekey+"\t"+his_self.game.player);
                  let z = false;
                  his_self.prependMove("war_loser_regain_keys_for_vp\t"+faction+"\t"+target_faction);
                  his_self.prependMove("war_loser_regain_spaces_for_vp_or_cards\t"+faction+"\t"+target_faction);
                  his_self.prependMove("war_loser_regain_leaders_for_vp_or_cards\t"+faction+"\t"+target_faction);
                  his_self.endTurn();
                });
              },
              null ,
              1
            );
          });
        },
        null ,
        1
      );
    });
   

  }

  canPlayerDeclareWar(his_self, faction) {

    let t = his_self.returnDeclarationOfWarTargets(faction);
    for (let i = 0; i < t.length; i++) {
      if (t[i].cost > 0) { return 1; }
    }

    return 0;

  }

  //
  // similar to playerDeclareWar but permits choosing multiple
  // targets for war...
  //
  playerMakeDeclarationsOfWar(his_self, faction) {

    let t = his_self.returnDeclarationOfWarTargets(faction);
    let targets = [];

    let selectFactionsInterface = function(selectFactionsInterface, payCostsInterface) {

      his_self.war_overlay.render();

      let msg = `${his_self.returnFactionName(faction)} - Declarations of War?`;
      let existing_cost = 0;
      let html = '<ul>';
      let final_message = "do not declare war";

      for (let i = 0; i < targets.length; i++) {
	existing_cost += parseInt(targets[i].cost);
      }

      if (existing_cost > 0) { msg += " (cost: "+existing_cost+")"; }

      for (let i = 0; i < t.length; i++) {

	let include_faction = true;
	let already_declaring_war = false;
	for (let z = 0; z < targets.length; z++) {
	  if (targets[z].faction === t[i].faction) { 
	    already_declaring_war = true;
	  }
	}
	if (his_self.areEnemies(faction, t[i].faction)) {
	  include_faction = false;
	}

	if (include_faction) {
          if (already_declaring_war) {
  	    html += `<li class="option" id="${i}">* ${his_self.returnFactionName(t[i].faction)} (${t[i].cost} OPS) *</li>`;
            final_message = "declare war (and pay)";
	  } else {
            html += `<li class="option" id="${i}">${his_self.returnFactionName(t[i].faction)} (${t[i].cost} OPS)</li>`;
          }
        }
      }
      html += `<li class="option" id="end">${final_message}</li>`;
      html += '</ul>';

      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

	let action = $(this).attr("id");

        his_self.war_overlay.hide();

        let id = parseInt(action);
	$('.option').off();

	if (action == "end") {
	  if (targets.length == 0) {
	    his_self.endTurn();
	    return;
	  }
	  payCostsInterface(selectFactionsInterface, payCostsInterface);
	  return;
	}

        let enemy = t[id].faction;
        let cost = t[id].cost;

	let total_cost = 0;
	for (let i = 0; i < targets.length; i++) {
	  total_cost += targets[i].cost;
	}

	let already_in_targets = false;
	for (let i = 0; i < targets.length; i++) {
	  if (targets[i].faction == enemy) {
	    already_in_targets = true;
	    targets.splice(i, 1);
	  }
	}

	if (already_in_targets == false) {
	  targets.push({ faction : enemy , cost : cost });
	}

	selectFactionsInterface(selectFactionsInterface, payCostsInterface);

      });
    }


    let payCostsInterface = function(selectFactionsInterface, payCostsInterface) {

      let total_cost = 0;
      let total_cost_paid = 0;
      let cards_selected = [];

      for (let i = 0; i < targets.length; i++) {
        total_cost += targets[i].cost;
      }
  
      let selectCardsInterface = function(selectCardsInterface, selectFactionsInterface, payCostsInterface) {

        let msg = "Declare War: " + total_cost_paid + " of " + total_cost + " OPS"; 

        his_self.playerSelectOps(faction, 1, (card) => {

	  if (!cards_selected.includes(card)) { cards_selected.push(card); }
	  total_cost_paid += parseInt(his_self.game.deck[0].cards[card].ops);	 
          his_self.addMove(`discard\t${faction}\t${card}`);

	  if (total_cost_paid >= total_cost) {
	    his_self.updateStatus("acknowledge");
	    for (let i = 0; i < targets.length; i++) {
              his_self.addMove(`declare_war\t${faction}\t${targets[i].faction}`);
	    }
	    his_self.endTurn();
	  } else {
	    selectCardsInterface(selectCardsInterface, selectFactionsInterface, payCostsInterface);
	  }

        }, msg, cards_selected);
	
      }

      selectCardsInterface(selectCardsInterface, selectFactionsInterface, payCostsInterface);

    }

    selectFactionsInterface(selectFactionsInterface, payCostsInterface);

    return 0;

  }

  playerDeclareWar(his_self, faction, cost=-1, targets=[]) {

    let t = his_self.returnDeclarationOfWarTargets(faction);

    let msg = "Declare War on which Power?";
    let html = '<ul>';
    for (let i = 0; i < t.length; i++) {
      if ((this.canPlayerSelectOps(faction, t[i].cost) || cost == -1) || (this.canPlayerSelectOps(faction, cost))) {
	if (targets.length > 0) {
          if (targets.includes(t[i].faction)) {
	    html += `<li class="option" id="${i}">${t[i].faction}</li>`;
	  }
	} else {
          html += `<li class="option" id="${i}">${t[i].faction}</li>`;
        }
      }
    }
    html += '</ul>';

    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let id = $(this).attr("id");
      let enemy = t[id].faction;
      let cost = t[id].cost;

      his_self.playerSelectOps(faction, cost, (card) => {
        his_self.addMove(`discard\t${faction}\t${card}`);
        his_self.addMove(`declare_war\t${faction}\t${cost}`);
        his_self.endTurn();
      });

    });
     
    return 0;
  }


  
  returnDebaters(faction="papacy", type="uncommitted") {
    let debaters = [];
    let map = {};
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (faction == "papacy") {
        if (this.game.state.debaters[i].faction == faction) {
	  if (type == "uncommitted" && this.game.state.debaters[i].committed != 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	  if (type == "committed" && this.game.state.debaters[i].committed == 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	}
      } else {
        if (this.game.state.debaters[i].faction != "papacy") {
	  if (type == "uncommitted" && this.game.state.debaters[i].committed != 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	  if (type == "committed" && this.game.state.debaters[i].committed == 1) {
	    if (!map[this.game.state.debaters[i].type]) {
	      map[this.game.state.debaters[i].type] = 1;
	      debaters.push(this.game.state.debaters[i]);
	    }
	  }
	}
      }
    }
    return debaters;
  }




  returnDiplomacyMenuOptions(player=null, faction=null) {

    let menu = [];

    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Back",
      check : this.canPlayerCancel,
      fnct : this.playerCancel,
      img : "ambassadors.jpeg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "End War",
      check : this.canPlayerEndWar,
      fnct : this.playerEndWar,
      img : "dove.jpeg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Form Alliance",
      check : this.canPlayerFormAlliance,
      fnct : this.playerFormAlliance,
      img : "treaty.jpeg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Captured Leader",
      check : this.canPlayerGiveCapturedLeader,
      fnct : this.playerGiveCapturedLeader,
      img : "prison.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Get Captured Leader",
      check : this.canPlayerGetCapturedLeader,
      fnct : this.playerGetCapturedLeader,
      img : "prison.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Random Card",
      check : this.canPlayerIssueCards,
      fnct : this.playerIssueCards,
      img : "the-card-players.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Get Random Card",
      check : this.canPlayerPullCards,
      fnct : this.playerPullCards,
      img : "the-card-players.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Territory",
      check : this.canPlayerYieldTerritory,
      fnct : this.playerYieldTerritory,
      img : "diplomacy.png" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Get Territory",
      check : this.canPlayerGainTerritory,
      fnct : this.playerGainTerritory,
      img : "diplomacy.png" ,
    });
    menu.push({
      factions : ['england'],
      name : "Request Divorce",
      check : this.canPlayerRequestDivorce,
      fnct : this.playerRequestDivorce,
      img : "papal_decree.jpg" ,
    });
//
// this means only England can request
//
//    menu.push({
//      factions : ['papacy'],
//      name : "Approve Divorce",
//      check : this.canPlayerApproveDivorce,
//      fnct : this.playerApproveDivorce,
//      img : "papal_decree.jpg" ,
//    });
    menu.push({
      factions : ['papacy'],
      name : "Rescind Excommunication",
      check : this.canPlayerRescindExcommunication,
      fnct : this.playerRescindExcommunication,
      img : "excommunication.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Give Mercenaries",
      check : this.canPlayerGiveMercenaries,
      fnct : this.playerGiveMercenaries,
      img : "mercenary.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Get Mercenaries",
      check : this.canPlayerGetMercenaries,
      fnct : this.playerGetMercenaries,
      img : "mercenary.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Loan Squadrons",
      check : this.canPlayerLoanSquadrons,
      fnct : this.playerLoanSquadrons,
      img : "squadron.jpg" ,
    });
    menu.push({
      factions : ['ottoman','hapsburg','england','france','papacy','protestant'],
      name : "Borrow Squadrons",
      check : this.canPlayerBorrowSquadrons,
      fnct : this.playerBorrowSquadrons,
      img : "squadron.jpg" ,
    });

    return menu;

  }


  convertTermsToText(terms=[]) {

    let text = [];

    for (let i = 0; i < terms.length; i++) {

      let x = terms[i].split("\t");

      if (x[0] === "declare_peace" || x[0] === "end_war") {
	text.push(`${this.returnFactionName(x[1])} and ${this.returnFactionName(x[2])} end their war`);
      }
      if (x[0] === "set_allies") {
	text.push(`${this.returnFactionName(x[1])} and ${this.returnFactionName(x[2])} agree to ally`);
      }
      if (x[0] === "yield_cards" || x[0] === "pull_card") {
	text.push(`${this.returnFactionName(x[2])} offers ${this.returnFactionName(x[1])} a card`);
      }
      if (x[0] === "returns_captured" || x[0] === "ransom") {
	text.push(`${this.returnFactionName(x[1])} returns ${this.returnLeaderName(x[1])}`);
      }
      if (x[0] === "control" || x[0] === "yield_key") {
	text.push(`${this.returnFactionName(x[3])} yields ${this.returnSpaceName(x[2])} to ${this.returnFactionName(x[1])}`);
      }
      if (x[0] === "approve_divorce" || x[0] === "advance_henry_viii_marital_status") {
	text.push(`The Papacy approves Henry VIII's divorce`);
      }
      if (x[0] === "rescind_excommunication" || x[0] === "unexcommunicate_faction") {
	text.push(`Papacy rescinds ${this.returnFactionName(x[1])} excommunication`);
      }
      if (x[0] === "give_captured_leader") {
	text.push(`${this.returnFactionName(x[1])} gives ${this.returnFactionName(x[2])} ${x[3]}`);
      }
      if (x[0] === "give_squadron" || x[0] === "loan_squadron") {
	if (!text.includes(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} squadron(s)`)) {
	  text.push(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} squadron(s)`);
	}
      }
      if (x[0] === "offer_mercenaries" || x[0] === "give_mercenaries") {
	text.push(`${this.returnFactionName(x[1])} offers ${this.returnFactionName(x[2])} ${x[3]} mercenaries`);
      }
    }

    return text;
  }

  canPlayerCancel(his_self, player, faction, target="") {
    return 1;
  }

  async playerCancel(his_self, faction, mycallback=null) {
    his_self.diplomacy_overlay.render(faction);
    return 1;
  }

  canPlayerEndWar(his_self, player, faction, target="") {
    if (target != "") {
      if (his_self.areEnemies(faction, target)) { 
	if (
	  !((faction == "papacy" && target == "protestant") || (faction == "protestant" && target == "papacy"))
	    && 
	  !((faction == "hapsburg" && target == "protestant") || (faction == "protestant" && target == "hapsburg"))
	) {
	  return 1;
	}
      }
      return 0;
    }
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    for (let i = 0; i < io.length; i++) {
      if (his_self.areEnemies(faction, io[i])) { 
	if (
	  !((faction == "papacy" && io[i] == "protestant") || (faction == "protestant" && io[i] == "papacy"))
	    && 
	  !((faction == "hapsburg" && io[i] == "protestant") || (faction == "protestant" && io[i] == "hapsburg"))
	) {
	  return 1;
	}
      }
    }
    return 0;
  }

  canPlayerFormAlliance(his_self, player, faction, target="") {
    if (target != "") {
      let prohibited_alliance = false;
      if (faction === "papacy" && target === "hapsburg" && his_self.game.state.henry_viii_pope_approves_divorce == 1) {
	prohibited_alliance = true;
      }
      if (faction === "papacy" && target === "protestant") {
	prohibited_alliance = true;
      }
      if (faction === "protestant" && target === "papacy") {
	prohibited_alliance = true;
      }
      if (faction === "hapsburg" && target === "protestant") {
	prohibited_alliance = true;
      }
      if (faction === "protestant" && target === "hapsburg") {
	prohibited_alliance = true;
      }
      if (faction === "papacy" && target === "ottoman") {
	prohibited_alliance = true;
      }
      if (faction === "ottoman" && target === "papacy") {
	prohibited_alliance = true;
      }
      if (faction === target) {
	prohibited_alliance = true;
      }
      if (prohibited_alliance === false && !his_self.areAllies(faction, target) && faction !== target) { return 1; }
      return 0;
    }
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    for (let i = 0; i < io.length; i++) {
      let prohibited_alliance = false;
      if (faction === "papacy" && io[i] === "hapsburg" && his_self.game.state.henry_viii_pope_approves_divorce == 1) {
	prohibited_alliance = true;
      }
      if (faction === "papacy" && io[i] === "protestant") {
	prohibited_alliance = true;
      }
      if (faction === "protestant" && io[i] === "papacy") {
	prohibited_alliance = true;
      }
      if (faction === "hapsburg" && io[i] === "protestant") {
	prohibited_alliance = true;
      }
      if (faction === "protestant" && io[i] === "hapsburg") {
	prohibited_alliance = true;
      }
      if (faction === "papacy" && io[i] === "ottoman") {
	prohibited_alliance = true;
      }
      if (faction === "ottoman" && io[i] === "papacy") {
	prohibited_alliance = true;
      }
      if (faction === io[i]) {
	prohibited_alliance = true;
      }
      if (prohibited_alliance === false && !his_self.areAllies(faction, io[i]) && faction !== io[i]) { return 1; }
    }
    return 0;
  }

  canPlayerIssueCards(his_self, player, faction, target="") {
    if (target != "") { 
      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(target)) { return 0; }
    }
    if (his_self.game.state.cards_issued[faction] < 2) { return 1; }
    return 0;
  }
  canPlayerPullCards(his_self, player, faction, target="") {
    if (target != "") { 
      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(target)) { return 0; }
    }
    return 1;
  }

  canPlayerYieldTerritory(his_self, player, faction, target="") {
    if (target != "") { 
      if (target == "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return 0; }
      if (his_self.returnPlayerCommandingFaction(faction) == his_self.returnPlayerCommandingFaction(target)) { return 0; }
    }
    let target_spaces = his_self.countSpacesWithFilter(
      function(space) { 
        if (space.home == "independent") { return 1; } // not minor power spaces (venice, hungary, etc.)
        if (space.political == faction || (space.political == "" && space.home == faction)) { return 1; }
      }
    );
    if (target_spaces) { return 1; }
    return 0;
  }


  canPlayerGiveCapturedLeader(his_self, player, faction) {
    for (let i = 0; i < his_self.game.state.players_info.length; i++) {
      let c = his_self.game.state.players_info[i].captured;
      for (let z = 0; z < c.length; z++) {
	if (c[z].capturing_faction === faction) {
console.log("#");
console.log("#");
console.log("#");
console.log("CAPTURED LEADER: " + JSON.stringify(c[z]));
console.log("#");
console.log("#");
console.log("#");
	  return 1;
	}
      }
    }
    return 0;
  }

  canPlayerGetCapturedLeader(his_self, player, faction) {
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    for (let i = 0; i < his_self.game.state.players_info.length; i++) {
      let c = his_self.game.state.players_info[i].captured;
      for (let z = 0; z < c.length; z++) {
	if (c[z].owner === faction) {
	  if (io.includes(c[z].capturing_faction)) {
	    return 1;
	  }
	}
      }
    }
    return 0;
  }

  canPlayerGainTerritory(his_self, player, faction) {
    return 1;
  }

  canPlayerRequestDivorce(his_self, player, faction, target="") {
    if (target != "papacy") { return 0; }
    if (faction === "england" && his_self.game.state.henry_viii_marital_status == 1) { return 1; }
    return 0;
  }

  canPlayerApproveDivorce(his_self, player, faction, target="") {
    if (faction == "papacy" && his_self.game.state.henry_viii_marital_status == 1) { return 1; }
    return 0;
  }

  canPlayerRescindExcommunication(his_self, player, faction, target="") {
    if (target != "") { if (faction != "papacy" && target != "papacy") { return 0; } }
    if (his_self.game.state.excommunicated_factions["france"] == 1 && (faction == "france" || faction == "papacy")) { return 1; }
    if (his_self.game.state.excommunicated_factions["england"] == 1 && (faction == "england" || faction == "papacy")) { return 1; }
    if (his_self.game.state.excommunicated_factions["hapsburg"] == 1 && (faction == "hapsburg" || faction == "papacy")) { return 1; }
    return 0;
  }

  canPlayerGiveMercenaries(his_self, player, faction, target="") {
    if (faction == "ottoman" || target == "ottoman") { return 0; }
    for (let key in his_self.game.spaces) {
      if (his_self.game.spaces[key]) {
        if (his_self.game.spaces[key].units[faction]) {
          if (his_self.game.spaces[key].units[faction].length > 0 && key != "persia" && key != "egypt" && key != "ireland") {
  	    for (let i = 0; i < his_self.game.spaces[key].units[faction].length; i++) {
  	      if (his_self.game.spaces[key].units[faction][i].type === "mercenary") { return 1; }
            }
          }
        }
      }
    }
    return 0;
  }

  canPlayerGetMercenaries(his_self, player, faction, target="") {
    if (faction == "ottoman" || target == "ottoman") { return 0; }
    if (faction == "protestant" && his_self.game.state.events.schmalkaldic_league == 0) { return 0; }
    return 0;
  }

  canPlayerLoanSquadrons(his_self, player, faction, target="") {
    if (target == "protestant") { return 0; }
    if (faction != "protestant") {
      for (let key in his_self.game.spaces) {
	if (his_self.game.spaces[key]) {
	  let s = his_self.game.spaces[key];
	  if (s.units[faction]) {
	    for (let z = 0; z < s.units[faction].length; z++) {
	      if (s.units[faction][z].type == "squadron") { return 1; }
	    }
	  }
	}
      }
    }
    return 0;
  }



  canPlayerBorrowSquadrons(his_self, player, faction, target="") {
    if (target == "protestant") { return 0; }
    return 1;
  }


  async playerGetCapturedLeader(his_self, faction, mycallback=null) {

    let submit_choose_leader = function(giving_faction, receiving_faction) {

      let p = his_self.returnPlayerCommandingFaction(giving_faction);
      let msg = `${his_self.returnFactionName(faction)} - Return which Leader? `;
      let html = '<ul>';
      for (let i = 0; i < his_self.game.state.players_info[p-1].captured.length; i++) {
        let u = his_self.game.state.players_info[p-1].captured[i];
        if (u.capturing_faction == giving_faction) {
          html += `<li class="option" id="${u.type}">${u.type}</li>`;
        }
      }
      html += '</ul>';
      
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {
        let give_which_leader = $(this).attr("id");
        his_self.updateStatus("submitted");
        if (mycallback == null) { return; }
        mycallback([`give_captured_leader\t${giving_faction}\t${receiving_faction}\t${give_which_leader}`]);      
      });

      return; 

    }

    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }

    let terms = [];
    let msg = `${his_self.returnFactionName(faction)} - Get from Whom?`;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let factions_with_leaders = [];
    let other_factions_with_leaders = [];
    let html = '<ul>';
    let auto_select_target = true;
    for (let i = 0; i < io.length; i++) {
      if (io[i] != faction) {
	let p1 = his_self.returnPlayerCommandingFaction(io[i]);
	let p2 = his_self.returnPlayerCommandingFaction(faction);
	if (p1 != p2) {
	  for (let z = 0; z < his_self.game.state.players_info[p1-1].captured.length; z++) {
	    if (his_self.game.state.players_info[p1-1].captured[z].capturing_faction == io[i]) {
    	      factions_with_leaders.push(io[i]);
	      if (io[i] != target_faction) { other_factions_with_leaders.push(io[i]); }
              html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
	    }
	  }
	}
      }
    }
    html += '</ul>';

    let html2 = '<ul>';
    html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
    if (other_factions_with_leaders.length > 0) {
      html2 += `<li class="option" id="other">another faction</li>`;
    }
    html2 += '</ul>';

    his_self.updateStatusWithOptions(msg, html2);     
    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (action2 !== target_faction) {

        his_self.updateStatusWithOptions(msg, html);

        $('.option').off();
        $('.option').on('click', function () {
          let action3 = $(this).attr("id");
          if (mycallback == null) { return; }
          submit_choose_leader(action3, faction);
        });

      } else {
        if (mycallback == null) { return; }
        submit_choose_leader(target_faction, faction);
      }

    });

    return 0;
  }

  async playerGiveCapturedLeader(his_self, faction, mycallback=null) {

    let submit_choose_leader = function(giving_faction, receiving_faction) {

      let p = his_self.returnPlayerCommandingFaction(giving_faction);
      let msg = `${his_self.returnFactionName(faction)} - Return which Leader? `;
      let html = '<ul>';
      for (let i = 0; i < his_self.game.state.players_info[p-1].captured.length; i++) {
        let u = his_self.game.state.players_info[p-1].captured[i];
        if (u.capturing_faction == faction) {
          html += `<li class="option" id="${u.type}">${u.type}</li>`;
        }
      }
      html += '</ul>';
      
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {
        let give_which_leader = $(this).attr("id");
        his_self.updateStatus("submitted");
        if (mycallback == null) { return; }
        mycallback([`give_captured_leader\t${giving_faction}\t${receiving_faction}\t${give_which_leader}`]);      
      });

      return; 

    }

    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }

    let terms = [];
    let msg = `${his_self.returnFactionName(faction)} - Give to Whom?`;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    let auto_select_target = true;
    for (let i = 0; i < io.length; i++) {
      html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
    }
    html += '</ul>';

    let html2 = '<ul>';
    html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
    html2 += `<li class="option" id="other">another faction</li>`;
    html2 += '</ul>';

    his_self.updateStatusWithOptions(msg, html2);     
    $('.option').off();
    $('.option').on('click', function () {

      let action2 = $(this).attr("id");
      if (action2 !== target_faction) {

        his_self.updateStatusWithOptions(msg, html);

        $('.option').off();
        $('.option').on('click', function () {
          let action3 = $(this).attr("id");
          if (mycallback == null) { return; }
          submit_choose_leader(faction, action3);
        });

      } else {
        if (mycallback == null) { return; }
        submit_choose_leader(faction, target_faction);
      }

    });

    return 0;
  }



  async playerEndWar(his_self, faction, mycallback=null) {

    let submit_end_war = function(action2) {
      his_self.updateStatus("submitted");
      mycallback([`declare_peace\t${faction}\t${action2}`]);      
    }

    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }

    let terms = [];
    let msg = `${his_self.returnFactionName(faction)} - End War with Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    let auto_select_target = true;
    for (let i = 0; i < io.length; i++) {
      if (his_self.areEnemies(faction, io[i]) && faction != io[i]) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
        if (io[i] !== target_faction) {
	  auto_select_target = false;
	}
      }
    }
    html += '</ul>';

    if (auto_select_target == false) {

      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';

      his_self.updateStatusWithOptions(msg, html2);     
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
	if (action2 !== target_faction) {

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
            submit_end_war(action3);
          });

	} else {
          if (mycallback == null) { return; }
          submit_end_war(target_faction);
	}

      });

    } else {

      let action2 = target_faction;
      if (mycallback == null) { return; }
      submit_end_war(action2);

    }

    return 0;
  }

  async playerFormAlliance(his_self, faction, mycallback=null) {

    let submit_form_alliance = function(action2) {
      his_self.updateStatus("submitted");
      mycallback([`set_allies\t${faction}\t${action2}`,`unset_enemies\t${faction}\t${action2}`]);
    }
    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }
    let auto_select_target = true;


    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Form Alliance with Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      let prohibited_alliance = false;
      if (faction == "papacy" && io[i] == "hapsburg" && his_self.game.state.henry_viii_pope_approves_divorce == 1) {
	prohibited_alliance = true;
      }
      if (faction == "papacy" && io[i] == "ottoman") {
	prohibited_alliance = true;
      }
      if (faction == "ottoman" && io[i] == "papacy") {
	prohibited_alliance = true;
      }
      if (faction == io[i]) {
	prohibited_alliance = true;
      }
      if (prohibited_alliance == false && !his_self.areAllies(faction, io[i])) {
        if (io[i] != target_faction) { auto_select_target = false; }
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';

    if (auto_select_target == false) {

      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';

      his_self.updateStatusWithOptions(msg, html2);     
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
	if (action2 !== target_faction) {

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
            submit_form_alliance(action3);
          });

	} else {
          if (mycallback == null) { return; }
          submit_form_alliance(target_faction);
	}

      });

    } else {

      let action2 = target_faction;
      if (mycallback == null) { return; }
      submit_form_alliance(action2);

    }

    return 0;
  }

  async playerIssueCards(his_self, faction, mycallback=null) {

    let submit_issue_cards = function(action2) {
      his_self.updateStatus("submitted");
      his_self.game.state.cards_issued[faction] += 1;
      mycallback([`pull_card\t${action2}\t${faction}`,`NOTIFY\t${his_self.returnFactionName(action2)} pulls card from ${his_self.returnFactionName(faction)}`]);
    }
    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }
    let auto_select_target = true;

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Issue Random Card Draw to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
	if (io[i] != target_faction) { auto_select_target = false; }
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';

    if (auto_select_target == false) {

      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';

      his_self.updateStatusWithOptions(msg, html2);
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
        if (action2 !== target_faction) {

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
            submit_issue_cards(action3);
          });

        } else {
          if (mycallback == null) { return; }
          submit_issue_cards(target_faction);
        }

      });

    } else {
        if (mycallback == null) { return; }
        submit_issue_cards(target_faction);
    }

    return 0;
  }

  async playerPullCards(his_self, faction, mycallback=null) {

    let submit_pull_cards = function(action2) {
      his_self.updateStatus("submitted");
      his_self.game.state.cards_issued[action2] += 1;
      mycallback([`pull_card\t${faction}\t${action2}`,`NOTIFY\t${his_self.returnFactionName(faction)} pulls card from ${his_self.returnFactionName(action2)}`]);
    }

    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }
    let auto_select_target = true;


    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Pull Random Card from Whom? `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i]) {
	if (his_self.game.state.cards_issued[io[i]] < 2) {
	  if (io[i] != target_faction) { auto_select_target = false; }
          html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
        }
      }
    }
    html += '</ul>';

    if (auto_select_target == false) {

      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';

      his_self.updateStatusWithOptions(msg, html2);
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
        if (action2 !== target_faction) {

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
            submit_pull_cards(action3);
          });

        } else {
          if (mycallback == null) { return; }
          submit_pull_cards(target_faction);
        }

      });

    } else {
        if (mycallback == null) { return; }
	submit_pull_cards(target_faction);
    }

    return 0;
  }

  async playerGainTerritory(his_self, faction, mycallback=null) {

    let submit_gain_territory = function(giving_faction, spacekey) {
      his_self.updateStatus("submitted");
      mycallback([`evacuate\t${giving_faction}\t${spacekey}`,`control\t${faction}\t${spacekey}\t${giving_faction}`,`NOTIFY\t${his_self.returnFactionName(giving_faction)} yields ${his_self.returnSpaceName(spacekey)} to ${his_self.returnFactionName(faction)}`]);
    }   
    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }
    let auto_select_target = true;

      
    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Gain Territory from Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i] && !(io[i] == "protestant" && his_self.game.state.events.schmalkaldic_league == 0)) {
        if (his_self.returnPlayerCommandingFaction(faction) != his_self.returnPlayerCommandingFaction(io[i])) {
	  if (target_faction != io[i]) { auto_select_target = false; }
          html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
        }
      }
    }
    html += '</ul>';

    if (auto_select_target == false) {

      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';

      his_self.updateStatusWithOptions(msg, html2);
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
        if (action2 !== target_faction) {

          his_self.updateStatusWithOptions(msg, html);

          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
	    let giving_faction = action3;
      	    his_self.playerSelectSpaceWithFilter(
              "Gain which Space?",
              function(space) {
                if (space.political === giving_faction || (space.home == giving_faction && space.political == "")) {
	          return 1;
	        }
	        return 0;
              },
              function(spacekey) {
                if (mycallback == null) { return; }
	        submit_gain_territory(giving_faction, spacekey);
              },
              null,
              true
            );
          });
        } else {
          if (mycallback == null) { return; }
          let giving_faction = target_faction;
      	  his_self.playerSelectSpaceWithFilter(
              "Gain which Space?",
              function(space) {
                if (space.political === giving_faction || (space.home == giving_faction && space.political == "")) {
	          return 1;
	        }
	        return 0;
              },
              function(spacekey) {
                if (mycallback == null) { return; }
	        submit_gain_territory(giving_faction, spacekey);
              },
              null,
              true
          );
        }
      });
    } else {

      let giving_faction = target_faction;
      his_self.playerSelectSpaceWithFilter(
        "Gain which Space?",
        function(space) {
            if (space.political === giving_faction || (space.home == giving_faction && space.political == "")) {
	      return 1;
	    }
	    return 0;
        },
        function(spacekey) {
            if (mycallback == null) { return; }
	    submit_gain_territory(giving_faction, spacekey);
        },
        null,
        true
      );

    }

    return 0;
  }

  async playerYieldTerritory(his_self, faction, mycallback=null) {

    let submit_give_territory = function(receiving_faction, spacekey) {
      his_self.updateStatus("submitted");
      mycallback([`evacuate\t${faction}\t${spacekey}`,`control\t${receiving_faction}\t${spacekey}\t${faction}`,`NOTIFY\t${his_self.returnFactionName(faction)} yields ${his_self.returnSpaceName(spacekey)} to ${his_self.returnFactionName(receiving_faction)}`]);
    }   
    let target_faction = "";
    if (his_self.diplomacy_overlay.proposal.target) { target_faction = his_self.diplomacy_overlay.proposal.target; }
    let auto_select_target = true;

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Yield Territory to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i] && his_self.returnPlayerCommandingFaction(faction) != his_self.returnPlayerCommandingFaction(io[i]) && !(io[i] == "protestant" && his_self.game.state.events.schmalkaldic_league == 0)) {
	if (target_faction != io[i]) { auto_select_target = false; }
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';


    if (auto_select_target == false) {
    
      let html2 = '<ul>';
      html2 += `<li class="option" id="${target_faction}">${his_self.returnFactionName(target_faction)}</li>`;
      html2 += `<li class="option" id="other">another faction</li>`;
      html2 += '</ul>';
        
      his_self.updateStatusWithOptions(msg, html2);
      $('.option').off();
      $('.option').on('click', function () {

        let action2 = $(this).attr("id");
        if (action2 !== target_faction) {
            
          $('.option').off();
          $('.option').on('click', function () {
            let action3 = $(this).attr("id");
            if (mycallback == null) { return; }
            let receiving_faction = action3;
      	    his_self.playerSelectSpaceWithFilter(
        	"Yield which Space?",
         	function(space) {
         	   if (space.political === faction || (space.home == faction && space.political == "")) {
	 	     return 1;
	 	   }
	 	   return 0;
         	},
          	function(spacekey) {
          	  if (mycallback == null) { return; }
          	  his_self.updateStatus("submitted");
          	  submit_give_territory(receiving_faction, spacekey);
          	},
          	null,
          	true
            );
          });

	} else {
	  let receiving_faction = target_faction;
          if (mycallback == null) { return; }
      	  his_self.playerSelectSpaceWithFilter(
        	"Yield which Space?",
         	function(space) {
         	   if (space.political === faction || (space.home == faction && space.political == "")) {
	 	     return 1;
	 	   }
	 	   return 0;
         	},
          	function(spacekey) {
          	  if (mycallback == null) { return; }
          	  his_self.updateStatus("submitted");
          	  submit_give_territory(receiving_faction, spacekey);
          	},
          	null,
          	true
          );
	}
      });

    } else {
      let receiving_faction = target_faction;
      if (mycallback == null) { return; }
      his_self.playerSelectSpaceWithFilter(
        	"Yield which Space?",
         	function(space) {
         	   if (space.political === faction || (space.home == faction && space.political == "")) {
	 	     return 1;
	 	   }
	 	   return 0;
         	},
          	function(spacekey) {
          	  if (mycallback == null) { return; }
          	  his_self.updateStatus("submitted");
          	  submit_give_territory(receiving_faction, spacekey);
          	},
          	null,
          	true
      );
    }
    return 0;
  }

  async playerRequestDivorce(his_self, faction, mycallback) {
    mycallback([`advance_henry_viii_marital_status`,`SETVAR\tstate\thenry_viii_pope_approves_divorce_round\t${his_self.game.state.round}`,`SETVAR\tstate\thenry_viii_pope_approves_divorce\t1`, `NOTIFY\tThe Papacy accedes to Henry VIII's request for a divorce.`]);
    return 0;
  }

  async playerApproveDivorce(his_self, faction, mycallback) {
    mycallback([`advance_henry_viii_marital_status`,`SETVAR\tstate\thenry_viii_pope_approves_divorce_round\t${his_self.game.state.round}`,`SETVAR\tstate\thenry_viii_pope_approves_divorce\t1`, `NOTIFY\tThe Papacy accedes to Henry VIII's request for a divorce.`]);
    return 0;
  }

  async playerRescindExcommunication(his_self, faction, mycallback) {

    let msg = `Rescind Excommunication of Whom: `;
    let html = '<ul>';
    if (his_self.game.state.excommunicated_factions["france"] == 1) {
      html += `<li class="option" id="france">France</li>`;
    }
    if (his_self.game.state.excommunicated_factions["england"] == 1) {
      html += `<li class="option" id="england">England</li>`;
    }
    if (his_self.game.state.excommunicated_factions["hapsburg"] == 1) {
      html += `<li class="option" id="hapsburg">Hapsburg</li>`;
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {
      let beneficiary = $(this).attr("id");
      his_self.updateStatus("submitted");
      mycallback([`unexcommunicate_faction\t${beneficiary}`,`NOTIFY\tThe Papacy rescinds the excommunication of ${his_self.returnFactionName(beneficiary)}`]);

    });
    return 0;
  }




  async playerGiveMercenaries(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Give Mercenaries to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i] && io[i] != "ottoman" && !(io[i] == "protestant" && his_self.game.state.events.schmalkaldic_league == 0)) {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      $('.option').off();
      his_self.updateStatus("submitted");
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[faction].length; i++) {
	  let u = s.units[faction][i];
	  if (u.type == "mercenary") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Mercenaries? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

        his_self.updateStatus("submitted");
        mycallback([`place_mercenaries\t${faction}\t${target_faction}\t${target_number}`,`give_mercenaries\t${faction}\t${target_faction}\t${target_number}`]);

      });
    });

    return 0;
  }


  async playerGetMercenaries(his_self, faction, mycallback=null) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Get Mercenaries from Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i] && io[i] != "ottoman") {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      $('.option').off();
      his_self.updateStatus("submitted");
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[target_faction].length; i++) {
	  let u = s.units[target_faction][i];
	  if (u.type == "mercenary") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Mercenaries? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

        his_self.updateStatus("submitted");
        mycallback([`place_mercenaries\t${target_faction}\t${faction}\t${target_number}`,`give_mercenaries\t${target_faction}\t${faction}\t${target_number}`]);

      });
    });

    return 0;
  }


  async playerLoanSquadrons(his_self, faction, mycallback) {

    let terms = [];

    let msg = `${his_self.returnFactionName(faction)} - Give Squadrons to Whom: `;
    let io = his_self.returnDiplomacyImpulseOrder(faction);
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (faction != io[i] && io[i] != "protestant") {
        html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      his_self.updateStatus("submitted");
      $('.option').off();
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[faction].length; i++) {
	  let u = s.units[faction][i];
	  if (u.type == "squadron") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Squadrons? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

	let instructions = [];
        his_self.updateStatus("submitted");

	for (let z = 0; z < target_number; z++) {
	  instructions.push(`give_squadron\t${faction}\t${target_faction}\t${target_number}`);
	}
        mycallback(instructions);
      });
    });

    return 0;
  }



  async playerBorrowSquadrons(his_self, faction, mycallback) {

    let terms = [];
    let io = his_self.returnDiplomacyImpulseOrder(faction);

    //
    // check factions with squadrons
    //
    let factions_with_squadrons = {};
    for (let key in his_self.game.spaces) {
      if (his_self.game.spaces[key].ports) {
	for (let f in his_self.game.spaces[key].units) {
	  if (!factions_with_squadrons[f]) {
	    for (let z = 0; z < his_self.game.spaces[key].units[f].length; z++) {
	      if (his_self.game.spaces[key].units[f][z].type == "squadron") {
	        factions_with_squadrons[f] = 1;
	      }
	    }
	  }
        }
      }
    }

    let msg = `${his_self.returnFactionName(faction)} - Get Squadrons from Whom: `;
    let html = '<ul>';
    for (let i = 0; i < io.length; i++) {
      if (factions_with_squadrons[io[i]]) {
        if (factions_with_squadrons[io[i]] == 1 && faction != io[i] && io[i] != "protestant") {
          html += `<li class="option" id="${io[i]}">${his_self.returnFactionName(io[i])}</li>`;
        }
      }
    }
    html += '</ul>';
    his_self.updateStatusWithOptions(msg, html);

    $('.option').off();
    $('.option').on('click', function () {

      let target_faction = $(this).attr("id");
      his_self.updateStatus("submitted");
      $('.option').off();
      let num = 0;
      for (let key in his_self.game.spaces) {
	let s = his_self.game.spaces[key];
	for (let i = 0; i < s.units[target_faction].length; i++) {
	  let u = s.units[target_faction][i];
	  if (u.type == "squadron") { num++; }
	}
      }
      if (mycallback == null) { return; }

      msg = `${his_self.returnFactionName(faction)} - How Many Squadrons? `;
      html = '<ul>';
      for (let i = 1; i <= num && i <= 4; i++) {
        html += `<li class="option" id="${i}">${i}</li>`;
      }
      html += '</ul>';
      his_self.updateStatusWithOptions(msg, html);

      $('.option').off();
      $('.option').on('click', function () {

        let target_number = parseInt($(this).attr("id"));
        $('.option').off();

	let instructions = [];
        his_self.updateStatus("submitted");

	for (let z = 0; z < target_number; z++) {
	  instructions.push(`give_squadron\t${target_faction}\t${faction}\t${target_number}`);
	}
        mycallback(instructions);
      });
    });

    return 0;
  }











  returnArrayOfFactionsInSpace(spacekey="") {
    return this.returnArrayOfFactionsInSpacekey(spacekey);
  }
  returnArrayOfFactionsInSpacekey(spacekey="") {
    let res = [];
    let s = this.game.spaces[spacekey];
    if (s) {
      for (let f in s.units) {
	if (s.units[f].length > 0) { res.push(f); }
      }
    };
    return res;
  }

  isPlayerControlledFaction(faction="") {
    if (faction === "") { return false; }
    if (this.isAlliedMinorPower(faction)) { return true; }
    if (this.isMajorPower(faction)) { return true; }
    return false;
  }

  returnFactionAdminRating(faction="") {
    if (this.factions[faction]) {
      return this.factions[faction].returnAdminRating(this);
    }
    return 0;
  }
 
  returnFactionName(f) {
    if (f == "france") { return "France"; }
    if (f == "ottoman") { return "Ottoman"; }
    if (f == "hapsburg") { return "Hapsburg"; }
    if (f == "england") { return "England"; }
    if (f == "papacy") { return "Papacy"; }
    if (f == "protestant") { return "Protestant"; }
    if (f == "venice") { return "Venice"; }
    if (f == "scotland") { return "Scotland"; }
    if (f == "hungary") { return "Hungary"; }
    if (f == "genoa") { return "Genoa"; }
    if (f == "independent") { return "Independent"; }
    if (this.factions[f]) {
      return this.factions[f].name;
    }
    return "Unknown";
  }

  importFaction(name, obj) {

    if (obj.id == null)                 { obj.id = "faction"; }
    if (obj.name == null)               { obj.name = "Unknown Faction"; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.key == null)	        { obj.key = name; }
    if (obj.ruler == null)		{ obj.ruler = ""; }
    if (obj.cards == null)		{ obj.cards = 0; }
    if (obj.capitals == null)	        { obj.capitals = []; }
    if (obj.admin_rating == null)	{ obj.admin_rating = 0; } // cards "holdable"
    if (obj.cards_bonus == null)	{ obj.cards_bonus = 0; }
    if (obj.vp == null)			{ obj.vp = 0; }
    if (obj.vp_base == null)		{ obj.vp_base = 0; }
    if (obj.vp_special == null)		{ obj.vp_special = 0; }
    if (obj.vp_bonus == null)		{ obj.vp_bonus = 0; }
    if (obj.allies == null)		{ obj.allies = []; }
    if (obj.minor_allies == null)	{ obj.minor_allies = []; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.faction == null)		{ obj.faction = name; }
    if (obj.passed == null)		{ obj.passed = false; }
    if (obj.calculateBaseVictoryPoints == null) {
      obj.calculateBaseVictoryPoints = function() { return 0; }
    }
    if (obj.calculateBonusVictoryPoints == null) {
      obj.calculateBonusVictoryPoints = function() { return 0; }
    }
    if (obj.returnAdminRating == null) {
      obj.returnAdminRating = function(game_mod) { return this.admin_rating; }
    }
    if (obj.calculateSpecialVictoryPoints == null) {
      obj.calculateSpecialVictoryPoints = function() { return 0; }
    }
    if (obj.returnFactionSheet == null) {
      obj.returnFactionSheet = function(faction) {
        return `
	  <div class="faction_sheet" id="faction_sheet" style="background-image: url('/his/img/factions/${obj.img}')">
	    <div class="faction_sheet_ruler" id="faction_sheet_ruler"></div>
	    <div class="faction_sheet_vp" id="faction_sheet_vp"></div>
	  </div>
	`;
      }
    }
    if (obj.returnCardsDealt == null) {
      obj.returnCardsDealt = function(faction) {
	return 1;
      }
    }

    obj = this.addEvents(obj);
    this.factions[obj.key] = obj;

  }

  gainVictoryPoints(faction, points, type="special") {
    for (let i = 0; i < this.game.state.players_info.length; i++) {
      for (let ii = 0; ii < this.game.state.players_info[i].factions.length; ii++) {
	if (faction === this.game.state.players_info[i].factions[ii]) {
	  if (type == "base") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_base += points;
	  }
	  if (type == "special") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_special += points;
	  }
	  if (type == "bonus") {
            this.game.state.players_info[i].factions[ii].vp += points;
            this.game.state.players_info[i].factions[ii].vp_bonus += points;
	  }
	  break;
        }
      }
    }
    return -1;
  }


  returnControlledCapitals(faction) {
    let x = this.returnCapitals(faction);
    for (let i = 0; i < x.length; i++) {
      if (!this.isSpaceControlled(x[i], faction)) {
	x.splice(i, 1);
	i--;
      }
    }
    return x;
  }

  returnCapitals(faction) {
    let x = [];
    if (this.factions[faction]) {
      for (let i = 0; i < this.factions[faction].capitals.length; i++) {
        x.push(this.factions[faction].capitals[i]);
      }
    }
    return x;
  }

  returnFactionHandIdx(player, faction) {
    for (let i = 0; i < this.game.state.players_info[player-1].factions.length; i++) {
      if (this.game.state.players_info[player-1].factions[i] === faction) {
	return i;
      }
    }
    return -1;
  }




  importUnit(name, obj) {

    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.active == null)		{ obj.active = 0; } // if bonus is active for debaters
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)             { obj.loaned = false; }
    if (obj.key == null)                { obj.key = name; }
    if (obj.gout == null)               { obj.gout = false; }
    if (obj.locked == null)		{ obj.locked = 0; }
    if (obj.lost_field_battle == null)	{ obj.lost_field_battle = 0; }
    if (obj.lost_naval_battle == null)	{ obj.lost_naval_battle = 0; }
    if (obj.relief_force == null)	{ obj.relief_force = false; }
    if (obj.already_moved == null)	{ obj.already_moved = 0; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (obj.returnCardImage == null) {
      obj.returnCardImage = () => { return ""; }
    }

    this.addEvents(obj);
    this.units[name] = obj;

  }

  newUnit(faction, type) {
    for (let key in this.units) {
      if (this.units[key].type === type) {
        let new_unit = JSON.parse(JSON.stringify(this.units[key]));
        new_unit.owner = faction;
        return new_unit;
      }
    }
    return null;
  }

  importArmyLeader(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = true; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.army[name]) {
      this.addEvents(obj);
      this.army[name] = obj;
    }
  }

  importNavyLeader(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "both"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = true; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.navy[name]) {
      this.addEvents(obj);
      this.navy[name] = obj;
    }
  }

  importWife(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.wives[name]) {
      this.addEvents(obj);
      this.wives[name] = obj;
    }
  }

  importReformer(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = false; }
    if (obj.reformer == null)           { obj.reformer = true; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (!this.reformers[name]) {
      this.addEvents(obj);
      this.reformers[name] = obj;
    }
  }

  returnReformerName(ref) {
    if (this.reformers[ref]) { return this.reformers[ref].name; }
    return "Unknown";
  }

  importDebater(name, obj) {
    if (obj.type == null)               { obj.type = "unit"; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.spacekey == null)           { obj.spacekey = ""; }
    if (obj.personage == null)          { obj.personage = true; }
    if (obj.debater == null)            { obj.debater = true; }
    if (obj.reformer == null)           { obj.reformer = false; }
    if (obj.land_or_sea == null)        { obj.land_or_sea = "land"; }
    if (obj.army_leader == null)        { obj.army_leader = false; }
    if (obj.navy_leader == null)        { obj.navy_leader = false; }
    if (obj.piracy_rating == null)      { obj.piracy_rating = 0; }
    if (obj.command_value == null)      { obj.command_value = 0; }
    if (obj.battle_rating == null)      { obj.battle_rating = 0; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.committed == null)          { obj.committed = 0; }
    if (obj.besieged == null)           { obj.besieged = 0; }
    if (obj.captured == null)           { obj.captured = false; }
    if (obj.loaned == null)		{ obj.loaned = false; }
    if (obj.power == null)		{ obj.power = 0; }
    if (obj.key == null)		{ obj.key = name; }
    if (obj.onCommitted == null) {
      obj.onCommitted = function(his_self, faction) { return 1; }
    }
    if (obj.returnCardImage == null) {
      obj.returnCardImage = () => {
        let tile_f = "/his/img/tiles/debaters/" + obj.img;
        let tile_b = tile_f.replace('.svg', '_back.svg');
	return `
	  <div class="debater-card" id="${obj.key}" style="background-image: url('${tile_f}'); background-size: cover"></div>	
	`;
      }
    }

    if (!this.debaters[name]) {
      this.debaters[name] = obj;
      this.addEvents(obj);
    }
  }

  importConquistador(name, obj) {
    if (obj.faction == null)            { obj.faction = ""; }
    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.power == null)		{ obj.power = 0; }
    if (!this.conquistadors[name]) {
      this.addEvents(obj);
      this.conquistadors[name] = obj;
    }
  }

  importExplorer(name, obj) {
    if (obj.faction == null)            { obj.faction = ""; }
    if (obj.type == null)               { obj.type = name; }
    if (obj.name == null)               { obj.name = "Unit"; }
    if (obj.personage == null)          { obj.personage = false; }
    if (obj.img == null)                { obj.img = ""; }
    if (obj.power == null)		{ obj.power = 0; }
    if (!this.explorers[name]) {
      this.addEvents(obj);
      this.explorers[name] = obj;
    }
  }

  returnLeaderName(key) {
    if (this.army[leader]) { return this.army[leader].name; }
    if (this.name[leader]) { return this.navy[leader].name; }
    return key;
  }

  returnConquistadorName(key) {
    if (this.conquistadors[key]) { return this.conquistadors[key].name; }
    return "Conquistador";
  }
  returnExplorerName(key) {
    if (key == "Cabot" || key == "cabot") { return "Sebastian Cabot"; }
    if (this.explorers[key]) { return this.explorers[key].name; }
    return "Explorer";
  }

  returnAvailableExplorers(faction="") {
    let unavailable = [];
    let available = [];
    for (let z = 0; z < this.game.state.explorations.length; z++) {
      let exp = this.game.state.explorations[z];
      if (exp.faction == faction) {
	if (exp.explorer_lost == 1) {
	  unavailable.push(exp.explorer);
        }
      }
    }
    for (let key in this.explorers) {
      if (this.explorers[key].faction == faction) {
        if (!unavailable.includes(key)) {
	  available.push(key);
        }
      }
    }
    return available;
  }

  returnAvailableConquistadors(faction="") {
    let unavailable = [];
    let available = [];
    for (let z = 0; z < this.game.state.conquests.length; z++) {
      let exp = this.game.state.conquests[z];
      if (exp.faction == faction) {
	if (exp.conquistador_lost == 1) {
	  unavailable.push(exp.conquistador);
        }
      }
    }
    for (let key in this.conquistadors) {
      if (this.conquistadors[key].faction == faction) {
        if (!unavailable.includes(key)) {
	  available.push(key);
        }
      }
    }
    return available;
  }

  removeArmyLeader(faction, space, leader) {

    if (!this.army[leader]) {
      console.log("ARMY LEADER: " + leader + " not found");
      return;
    }

    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (space.units[faction][i].type === leader) {
	space.units[faction].splice(i, 1);
      }
    }

    for (let i = 0; i < this.game.state.players_info.length; i++) {
      let c = this.game.state.players_info[i].captured;
      for (let ii = 0; ii < c.length; ii++) {
        if (c[ii].leader == leader) {
	  c.splice(ii, 1);
	}
      }
    }

  }


  addArmyLeader(faction, space, leader) {
    if (!this.army[leader]) {
      console.log("ARMY LEADER: " + leader + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.army[leader]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
  }


  addNavyLeader(faction, space, leader) {
    if (!this.navy[leader]) {
      console.log("NAVY LEADER: " + leader + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    try { if (this.game.navalspaces[space]) { space = this.game.navalspaces[space]; } } catch (err) {}
    for (let z = 0; z < space.units[faction].length; z++) {
      if (space.units[faction][z].type == leader) { return 1; }
    }
    space.units[faction].push(this.navy[leader]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
  }


  removeReformer(faction, space, reformer) {
    if (!this.reformers[reformer]) {
      console.log("REFORMER: " + reformer + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    for (let i = 0; i < space.units[faction].length; i++) {
      if (space.units[faction][i].type === reformer) {
	space.units[faction].splice(i, 1);
      }
    }
  }

  addReformer(faction, space, reformer) {
    if (!this.reformers[reformer]) {
      console.log("REFORMER: " + reformer + " not found");
      return;
    }
    try { if (this.game.spaces[space]) { space = this.game.spaces[space]; } } catch (err) {}
    space.units[faction].push(this.reformers[reformer]);
    space.units[faction][space.units[faction].length-1].owner = faction; 
    if (reformer == "cranmer-reformer") { this.game.state.events.cranmer_active = 1; }
  }

  returnDebaterName(key) {
    if (this.debaters[key]) { return this.debaters[key].name; }
    return "Debater";
  }

  removeDebater(faction, debater) {
    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type == debater) { 
	this.game.state.debaters.splice(i, 1);
      }
    }
  }

  disgraceDebater(debater) { return this.burnDebater(debater, 1); }
  burnDebater(debater, disgraced = 0) {

    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }

    //
    // remove the debater
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type == debater) { 

	if (this.game.state.debaters[i].owner == "papacy") {
	  this.updateLog("Protestants gain " + this.game.state.debaters[i].power + " VP");
	  this.updateLog(this.popup(debater) + " disgraced");
	} else {
	  this.updateLog("Papacy gains " + this.game.state.debaters[i].power + " VP");
	  this.updateLog(this.popup(debater) + " burned");
	}

	this.game.state.debaters.splice(i, 1);
        this.game.state.burned.push(debater);

        let x = debater.split("-");

	//
	// also remove reformer (if exists)
	//
	try {
	  let reformer = x[0] + "-reformer";
          let s = this.returnSpaceOfPersonage(this.debaters[debater].faction, reformer);
	  if (s) { this.removeReformer(this.debaters[debater].faction, reformer); }
	  // re-display space
	  this.displaySpace(s);
	} catch (err) {
	  // reformer does not exist
	}
      }
    }

    //
    //
    //
    this.displayVictoryTrack();

  }

  addDebater(faction, debater) {

    if (!this.debaters[debater]) {
      console.log("DEBATER: " + debater + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].type === debater) {
	console.log("DEBATER: " + debater + " already added");
	return;
      }
    }

    this.game.state.debaters.push(this.debaters[debater]);
    this.game.state.debaters[this.game.state.debaters.length-1].owner = faction; 
    this.game.state.debaters[this.game.state.debaters.length-1].committed = 0; 
    if (debater == "cranmer-debater") { this.game.state.events.cranmer_active = 1; }

  }

  removeConquistador(faction, conquistador) {
    for (let i = 0; i < this.game.state.conquistadors.length; i++) {
      if (this.game.state.conquistadors[i].type === conquistador) {
	this.game.state.conquistadors.splice(i, 1);
	return;
      }
    }
  }

  removeExplorer(faction, explorer) {
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].type === explorer) {
	this.game.state.explorers.splice(i, 1);
	return;
      }
    }
  }

  addExplorer(faction, explorer) {

    if (!this.explorers[explorer]) {
      console.log("EXPLORER: " + explorer + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].type === explorer) {
	console.log("EXPLORER: " + explorer + " already added");
	return;
      }
    }

    this.game.state.explorers.push(this.explorers[explorer]);
  }

  addConquistador(faction, conquistador) {

    if (!this.conquistadors[conquistador]) {
      console.log("CONQUISTADOR: " + conquistador + " not found");
      return;
    }

    for (let i = 0; i < this.game.state.conquistador.length; i++) {
      if (this.game.state.conquistador[i].type === conquistador) {
	return;
      }
    }

    this.game.state.conquistador.push(this.conquistadors[conquistador]);

  }

  isActive(debater) { return this.isDebaterActive(debater); }
  isDebaterActive(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].active == 1) { return 1; }
      }
    }
    return 0;
  }

  isDebaterDisgraced(debater) { return this.isBurned(debater); }
  isDisgraced(debater) { return this.isBurned(debater); }
  isDebaterBurned(debater) { return this.isBurned(debater); }
  isBurned(debater) { if (this.game.state.burned.includes(debater)) { return true; } return false; }
  isCommitted(debater) { return this.isDebaterCommitted(debater); }
  isDebaterCommitted(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].committed == 1) { return 1; }
      }
    }
    // sometimes debaters will be excommunicated without being committed
    for (let i = 0; i < this.game.state.excommunicated.length; i++) {
      if (this.game.state.excommunicated[i].debater) {
	if (this.game.state.excommunicated[i].debater.type == debater) {
	  if (this.game.state.debaters[i].committed == 1) { return 1; }
	  // sorry, you're committed !
	  return 1;
        }
      }
    }
    return 0;
  }

  isDebaterAvailable(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	if (this.game.state.debaters[i].committed == 0) { return 1; }
      }
    }
    return 0;
  }

  deactivateDebater(debater) {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key === debater) {
        this.game.state.debaters[i].active = 0;
      }
    }
  }
  deactivateDebaters() {
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      this.game.state.debaters[i].active = 0;
    }
  }

  commitDebater(faction, debater, activate=1) {

    let his_self = this;

    //
    // we can only commit 1 debater for the bonus each impulse, so note it if so
    //
    if (activate == 1) {
      this.game.state.debater_committed_this_impulse[faction] = 1;
    }

    for (let i = 0; i < this.game.state.debaters.length; i++) {
      if (this.game.state.debaters[i].key == debater) {
	this.game.state.debaters[i].committed = 1;
	this.game.state.debaters[i].active = activate; // if the bonus is active
	this.debaters[debater].onCommitted(his_self, this.game.state.debaters[i].owner);
      }
    }
  }

  commitExplorer(faction, explorer) {
    let his_self = this;
    for (let i = 0; i < this.game.state.explorers.length; i++) {
      if (this.game.state.explorers[i].key == explorer) {
	this.game.state.explorer[i].committed = 1;
	this.explorers[explorer].onCommitted(his_self, this.game.state.explorers[i].owner);
      }
    }
  }

  commitConquistador(faction, explorer) {
    let his_self = this;
    for (let i = 0; i < this.game.state.conquistadors.length; i++) {
      if (this.game.state.conquistadors[i].key == explorer) {
	this.game.state.conquistadors[i].committed = 1;
	this.conquistadors[conquistador].onCommitted(his_self, this.game.state.conquistadors[i].owner);
      }
    }
  }

  //
  // each faction has a limited number of physical tokens to use to 
  // represent units that are available. the game will auto-reallocate
  // these tokens to teh extent possible.
  // 
  updateOnBoardUnits() { this.game.state.board_updated = 0; } // setting to 0 forces update next displaySpace
  returnOnBoardUnits(faction="") {

    let my_spaces = {};
    let available_units = {};
        available_units['regular'] = {};
        available_units['squadron'] = {};
        available_units['cavalry'] = {};
        available_units['corsair'] = {};
    let deployed_units = {};

    //
    // each faction has a separate token mix
    //
    if (faction == "protestant") {
      available_units['regular']['1'] = 8;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;    
    }
    if (faction == "england") {
      available_units['regular']['1'] = 9;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 5;    
    }
    if (faction == "ottoman") {
      available_units['regular']['1'] = 11;    
      available_units['regular']['2'] = 7;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 4;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 9;
    }
    if (faction == "france") {
      available_units['regular']['1'] = 10;    
      available_units['regular']['2'] = 5;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 3;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 5;    
    }
    if (faction == "papacy") {
      available_units['regular']['1'] = 7;    
      available_units['regular']['2'] = 4;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 2;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 2;
    }
    if (faction == "hapsburg") {
      available_units['regular']['1'] = 12;    
      available_units['regular']['2'] = 6;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 3;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 1;    
      available_units['squadron']['1'] = 6;    
    }

    if (faction == "scotland") {
      available_units['regular']['1'] = 2;    
      available_units['regular']['2'] = 1;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 1;
    }
    if (faction == "genoa") {
      available_units['regular']['1'] = 2;    
      available_units['regular']['2'] = 2;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 1;    
    }
    if (faction == "venice") {
      available_units['regular']['1'] = 4;    
      available_units['regular']['2'] = 4;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;
      available_units['squadron']['1'] = 4;    
    }
    if (faction == "hungary") {
      available_units['regular']['1'] = 3;    
      available_units['regular']['2'] = 3;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 1;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;
    }
    if (faction == "independent") {
      available_units['regular']['1'] = 3;    
      available_units['regular']['2'] = 3;    
      available_units['regular']['3'] = 0;    
      available_units['regular']['4'] = 0;    
      available_units['regular']['5'] = 0;    
      available_units['regular']['6'] = 0;    
      available_units['squadron']['1'] = 0;
    }

    //
    // find out what units I supposedly have deployed
    //
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].units) {
        if (this.game.spaces[key].units[faction].length > 0) {
          for (let i = 0; i < this.game.spaces[key].units[faction].length; i++) {
      	    if (!my_spaces[key]) { my_spaces[key] = {}; }
	    let u = this.game.spaces[key].units[faction][i];
	    if (u.type == "squadron" || u.type == "corsair" || u.type == "regular" || u.type == "mercenary" || u.type == "cavalry") {
              if (!my_spaces[key][u.type]) { my_spaces[key][u.type] = 0; }
              my_spaces[key][this.game.spaces[key].units[faction][i].type]++;
	    }
          }
        }
      }
    }
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key].units) {
        if (this.game.navalspaces[key].units[faction].length > 0) {
          for (let i = 0; i < this.game.navalspaces[key].units[faction].length; i++) {
      	    if (!my_spaces[key]) { my_spaces[key] = {}; }
	    let u = this.game.navalspaces[key].units[faction][i];
	    if (u.type == "squadron" || u.type == "corsair") {
              if (!my_spaces[key][u.type]) { my_spaces[key][u.type] = 0; }
              my_spaces[key][u.type]++;
            }
          }
        }
      }
    }

    //
    //
    //
    for (let key in my_spaces) {
      deployed_units[key] = {};
      deployed_units[key]['regular'] = {};
      deployed_units[key]['regular']['1'] = 0;
      deployed_units[key]['regular']['2'] = 0;
      deployed_units[key]['regular']['3'] = 0;
      deployed_units[key]['regular']['4'] = 0;
      deployed_units[key]['regular']['5'] = 0;
      deployed_units[key]['regular']['6'] = 0;
      deployed_units[key]['mercenary'] = {};
      deployed_units[key]['mercenary']['1'] = 0;
      deployed_units[key]['mercenary']['2'] = 0;
      deployed_units[key]['mercenary']['3'] = 0;
      deployed_units[key]['mercenary']['4'] = 0;
      deployed_units[key]['mercenary']['5'] = 0;
      deployed_units[key]['mercenary']['6'] = 0;
      deployed_units[key]['cavalry'] = {};
      deployed_units[key]['cavalry']['1'] = 0;
      deployed_units[key]['cavalry']['2'] = 0;
      deployed_units[key]['cavalry']['3'] = 0;
      deployed_units[key]['cavalry']['4'] = 0;
      deployed_units[key]['cavalry']['5'] = 0;
      deployed_units[key]['cavalry']['6'] = 0;
      deployed_units[key]['squadron'] = {};
      deployed_units[key]['squadron']['1'] = 0;
      deployed_units[key]['corsair'] = {};
      deployed_units[key]['corsair']['1'] = 0;
    }


    //
    // order spaces 
    //
    let continue_to_apportion = true;
    while (continue_to_apportion == true) {

      continue_to_apportion = false;
      let changed_anything = false;

      for (let key in my_spaces) {

	if (my_spaces[key]['regular'] >= 6 && available_units['regular']['6'] > 0) { 
	  my_spaces[key]['regular'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['regular']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 6 && available_units['regular']['6'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['mercenary']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 6 && available_units['cavalry']['6'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 6;
	  available_units['regular']['6']--;
	  deployed_units[key]['cavalry']['6']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !5

	if (my_spaces[key]['regular'] >= 4 && available_units['regular']['4'] > 0) { 
	  my_spaces[key]['regular'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['regular']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 4 && available_units['regular']['4'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['mercenary']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 4 && available_units['regular']['4'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 4;
	  available_units['regular']['4']--;
	  deployed_units[key]['cavalry']['4']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !3

	if (my_spaces[key]['regular'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['regular'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['regular']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['mercenary']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 2 && available_units['regular']['2'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 2;
	  available_units['regular']['2']--;
	  deployed_units[key]['cavalry']['2']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	// !1

	if (my_spaces[key]['regular'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['regular'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['regular']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['mercenary'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['mercenary'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['mercenary']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['cavalry'] >= 1 && available_units['regular']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['cavalry'] -= 1;
	  available_units['regular']['1']--;
	  deployed_units[key]['cavalry']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

	if (my_spaces[key]['squadron'] >= 1 && available_units['squadron']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['squadron'] -= 1;
	  available_units['squadron']['1']--;
	  deployed_units[key]['squadron']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}
	if (my_spaces[key]['corsair'] >= 1 && available_units['squadron']['1'] > 0 && continue_to_apportion == false) { 
	  my_spaces[key]['corsair'] -= 1;
	  available_units['squadron']['1']--;
	  deployed_units[key]['corsair']['1']++;
	  continue_to_apportion = true;
          changed_anything = true;
	}

      }

      if (changed_anything == true) {
        continue_to_apportion = true;
      }

    }

    let results = {};
    results.deployed = deployed_units;
    results.available = available_units;
    results.missing = {};
    for (let key in this.game.spaces) {
      results.missing[key] = {};
      results.missing[key]['regular'] = {}
      results.missing[key]['regular']['1'] = 0;
      results.missing[key]['regular']['2'] = 0;
      results.missing[key]['regular']['3'] = 0;
      results.missing[key]['regular']['4'] = 0;
      results.missing[key]['regular']['5'] = 0;
      results.missing[key]['regular']['6'] = 0;
      results.missing[key]['mercenary'] = {};
      results.missing[key]['mercenary']['1'] = 0;
      results.missing[key]['mercenary']['2'] = 0;
      results.missing[key]['mercenary']['3'] = 0;
      results.missing[key]['mercenary']['4'] = 0;
      results.missing[key]['mercenary']['5'] = 0;
      results.missing[key]['mercenary']['6'] = 0;
      results.missing[key]['cavalry'] = {};
      results.missing[key]['cavalry']['1'] = 0;
      results.missing[key]['cavalry']['2'] = 0;
      results.missing[key]['cavalry']['3'] = 0;
      results.missing[key]['cavalry']['4'] = 0;
      results.missing[key]['cavalry']['5'] = 0;
      results.missing[key]['cavalry']['6'] = 0;
      results.missing[key]['squadron'] = {};
      results.missing[key]['squadron']['1'] = 0;
    }

    //
    // pieces we are having difficulty assigning
    //
    for (let key in my_spaces) {
      if (my_spaces[key]['regular'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['regular']['1'] = my_spaces[key]['regular'];
	results.overcapacity = 1;
      }	
      if (my_spaces[key]['mercenary'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['mercenary']['1'] = my_spaces[key]['mercenary'];
	results.overcapacity = 1;
      }	
      if (my_spaces[key]['cavalry'] > 0) { 
	if (!results.missing[key]) { results.missing[key] = {}; }
	results.missing[key]['cavalry']['1'] = my_spaces[key]['cavalry'];
	results.overcapacity = 1;
      }	
    }

    this.game.state.board_updated = new Date().getTime();

    return results;

  }


  returnNumberOfUnitsAvailableForConstruction(faction, unittype) {

    //
    // TODO -- implement limits on squadron and corsair construction
    //
    if (unittype === "corsair") { unittype = "squadron"; }
    if (unittype === "cavalry" && faction == "ottoman") { unittype = "regular"; }
    if (unittype === "mercenary") { unittype = "regular"; }

    let res = this.returnOnBoardUnits(faction);

    let amount_over_capacity = 0;
    for (let key in res.missing) {
      if ((unittype == "regular" && res.missing[key]['regular']['1'] > 0) || (unittype == "mercenary" && res.missing[key]['mercenary']['1'] > 0) || (unittype == "regular" && res.missing[key]['cavalry']['1'] > 0)) {
        return 0;
      }
    }

    let x = 0;

    if (res.available[unittype]['1'] > 0) { x += (1 * res.available[unittype]['1']); }
    if (res.available[unittype]['2'] > 0) { x += (2 * res.available[unittype]['2']); }
    if (res.available[unittype]['3'] > 0) { x += (3 * res.available[unittype]['3']); }
    if (res.available[unittype]['4'] > 0) { x += (4 * res.available[unittype]['4']); }
    if (res.available[unittype]['5'] > 0) { x += (5 * res.available[unittype]['5']); }
    if (res.available[unittype]['6'] > 0) { x += (6 * res.available[unittype]['6']); }

    //
    // squadrons and corsairs have construction limits
    //
    if (unittype == "squadron") {
      if (this.game.state.ships_destroyed[faction]) {
        if (this.game.state.ships_destroyed[faction] > 0) {
	  x -= this.game.state.ships_destroyed[faction];
	  if (x < 0) { x = 0; }
	}
      }
    }

    return x;

  }





//
// NEW WORLD
//
// When factions explore or send a conquest or found a colony an extry is added into one
// of these three main arrays with the data structure that follows:
//
// 	this.game.state.colonies 
// 	this.game.state.explorations		
// 	this.game.state.conquests		
//
//    		{
//            		faction : faction,
//            		resolved :  0 ,
//            		round :   this.game.state.round,
//    		}
//
// at the end of the turn, we have three functions -- resolveColonies(), resolveConquests(), 
// and resolveExplorations() that loop through all of the "unresolved" items in these lists
// and roll the dice to figure out who has founded what. If user-intervention is required
// to pick a bonus, users will be invited to do so. data is added to these data structures
//
//
//
//

  returnNextColonyTile(faction="") {
    if (faction == "england") {
      if (this.game.state.newworld['england_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/Roanoke.svg";
      } else {
	return "/his/img/tiles/colonies/Jamestown.svg";
      }
    }

    if (faction == "france") {
      if (this.game.state.newworld['france_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/Charlesbourg.svg";
      } else {
	return "/his/img/tiles/colonies/Montreal.svg";
      }
    }

    if (faction == "hapsburg") {
      if (this.game.state.newworld['hapsburg_colony1'].claimed != 1) {
        return "/his/img/tiles/colonies/PuertoRico.svg";
      } else {
	if (this.game.state.newworld['hapsburg_colony2'].claimed != 1) {
          return "/his/img/tiles/colonies/Cuba.svg";
	} else {
          return "/his/img/tiles/colonies/Hispaniola.svg";
	}
      }
    }

    return "/his/img/tiles/colonies/PuertoRico.svg";

  }

  resolveColonies() {

    for (let z = 0; z < this.game.state.colonies.length; z++) {
      if (this.game.state.colonies[z].resolved != 1) {

	this.game.state.colonies[z].resolved = 1;

        if (this.game.state.colonies[z].faction === "england") {
	  if (this.game.state.newworld['england_colony1'].claimed != 1) {
	    this.game.state.newworld['england_colony1'].claimed = 1;
	    this.game.state.colonies[z].colony = "england_colony1";
	    this.game.state.colonies[z].name = "Roanoke";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Roanoke.svg";
	    this.updateLog("England founds Roanoke");
          } else {
	    this.game.state.newworld['england_colony2'].claimed = 1;
	    this.game.state.colonies[z].colony = "england_colony2";
	    this.game.state.colonies[z].name = "Jamestown";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Jamestown.svg";
	    this.updateLog("England founds Jamestown");
	  }
        }

        if (this.game.state.colonies[z].faction === "france") {
	  if (this.game.state.newworld['france_colony1'].claimed != 1) {
	    this.game.state.newworld['france_colony1'].claimed = 1;
	    this.game.state.colonies[z].colony = "france_colony1";
	    this.game.state.colonies[z].name = "Charlesbourg";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Charlesbourg.svg";
	    this.updateLog("France founds Charlesbourg");
          } else {
	    this.game.state.newworld['france_colony2'].claimed = 1;
	    this.game.state.colonies[z].colony = "france_colony2";
	    this.game.state.colonies[z].name = "Montreal";
	    this.game.state.colonies[z].img = "/his/img/tiles/colonies/Montreal.svg";
	    this.updateLog("France founds Montreal");
	  }
        }

        if (this.game.state.colonies[z].faction === "hapsburg") {
	  if (this.game.state.newworld['hapsburg_colony1'].claimed != 1) {
	      this.game.state.newworld['hapsburg_colony1'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony1";
	      this.game.state.colonies[z].name = "Puerto Rico";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/PuertoRico.svg";
	      this.updateLog("Hapsburgs found Puerto Rico");
          } else {
	    if (this.game.state.newworld['hapsburg_colony2'].claimed != 1) {
	      this.game.state.newworld['hapsburg_colony2'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony2";
	      this.game.state.colonies[z].name = "Cuba";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/Cuba.svg";
	      this.updateLog("Hapsburgs found Cuba");
	    } else {
	      this.game.state.newworld['hapsburg_colony3'].claimed = 1;
	      this.game.state.colonies[z].colony = "hapsburg_colony3";
	      this.game.state.colonies[z].name = "Hispaniola";
	      this.game.state.colonies[z].img = "/his/img/tiles/colonies/Hispaniola.svg";
	      this.updateLog("Hapsburgs found Hispaniola");
	    }
	  }
        }
      }
    }

    //
    // resolve potosi mines if outstanding
    //
    if (this.game.state.events.potosi_silver_mines != "") {

      let have_we_added_potosi_mines = false;
      let have_we_added_potosi_mines_idx = 0;

      for (let z = 0; z < this.game.state.colonies.length; z++) {
	if (this.game.state.colonies[z].img == "/his/img/tiles/colonies/Potosi.svg") {
	  have_we_added_potosi_mines = true;
	  have_we_added_potosi_mines_idx = z;
	}
      }

      if (!have_we_added_potosi_mines) {

	let pbox = "england_colony2";
	if (this.game.state.events.potosi_silver_mines == "france") { pbox = "france_colony2"; }
	if (this.game.state.events.potosi_silver_mines == "hapsburg") { pbox = "hapsburg_colony3"; }

	this.game.state.colonies.push({
	  faction : this.game.state.events.potosi_silver_mines ,
	  resolved : 1 ,
	  round : this.game.state.round ,
	  img : "/his/img/tiles/colonies/Potosi.svg" ,
	  name : "Potosi Silver Mines" ,
	  colony : pbox ,	  
	});

	this.game.state.events.potosi_silver_mines_added = this.game.state.events.potosi_silver_mines;
	this.game.state.events.potosi_silver_mines = "";
	this.game.state.newworld[pbox].claimed = 1;

      }

    }


    this.displayNewWorld();
    return 1;
  }

  resolveConquests() {

    let active_conquests = [];
    let sorted_conquests = [];
    
    for (let z = 0; z < this.game.state.conquests.length; z++) {
      let con = this.game.state.conquests[z];
      if (con.resolved == 0) {

        let available_conquistadors = this.returnAvailableConquistadors(con.faction);
	if (available_conquistadors.length > 0) {

	  //
	  // find explorer
	  //
	  let x = this.rollDice(available_conquistadors.length) - 1;
	  let conquistador = available_conquistadors[x];
	  con.conquistador = conquistador;

	  //
	  // calculate hits
	  //
	  let yy = this.rollDice(6);
	  let zz = this.rollDice(6);

	  let total_hits = yy + zz;

          let base_hits = total_hits;
	  let modifiers = 0;

	  //
	  // conquistador power
	  //
	  total_hits += this.conquistadors[conquistador].power;
	  modifiers += this.conquistadors[conquistador].power;

	  //
	  // smallpox
	  //
	  if (this.game.state.events.smallpox === con.faction) {
	    total_hits += 2;
	    modifiers += 2;
	    this.game.state.events.smallpox = 0;
	  }

	  con.base_roll = base_hits;
	  con.modifiers = modifiers;
	  con.modified_roll = total_hits;
	  con.hits = total_hits;
	  con.conquistador = conquistador;
	  con.img = this.conquistadors[conquistador].img;

	  active_conquests.push(z);

	}
      }
    }

    //
    // now determine sorted_explorations (order of resolution)
    //
    let hapsburg_done = 0;
    let england_done = 0;
    let france_done = 0;
    for (let i = 0; i < 3; i++) {
      target_faction = "hapsburg";
      if (i == 1) { target_faction = "england"; }
      if (i == 2) { target_faction = "france"; }
      for (let k = 0; k < active_conquests.length; k++) {
 	if (this.game.state.conquests[active_conquests[k]].faction === target_faction) { 
	  sorted_conquests.push(active_conquests[k]);
	}
      }
    }

    //
    // now resolve in order
    //
    for (let z = sorted_conquests.length-1; z >= 0; z--) {
      this.game.queue.push("resolve_conquest\t"+sorted_conquests[z]);
    }

    return 1;

  }

  resolveExplorations() {

    let active_explorations = [];
    let sorted_explorations = [];

    let cabot_england_found = 0;
    let cabot_france_found = 0;
    let cabot_hapsburg_found = 0;

    for (let z = 0; z < this.game.state.explorations.length; z++) {
      let exp = this.game.state.explorations[z];

      if (exp.cabot == 1) { 
	if (exp.faction == "england") { cabot_england_found = 1; }
	if (exp.faction == "france") { cabot_france_found = 1; }
	if (exp.faction == "hapsburg") { cabot_hapsburg_found = 1; }
      }

      if (exp.resolved == 0) {

        let available_explorers = this.returnAvailableExplorers(exp.faction);
	if (available_explorers.length > 0) {

	  //
	  // find explorer
	  //
	  let x = this.rollDice(available_explorers.length) - 1;
	  let explorer = available_explorers[x];

	  exp.explorer = explorer;

	  //
	  // calculate hits
	  //
	  let yy = this.rollDice(6);
	  let zz = this.rollDice(6);

	  let total_hits = yy + zz;
	  let base_hits = total_hits;
	  let modifiers = 0;

	  //
	  // modifications
	  //
	  if (this.game.state[`${exp.faction}_uncharted`]) {
	    total_hits--;
	    this.game.state[`${exp.faction}_uncharted`] = 0;
	  }

	  //
	  // explorer power
	  //
	  total_hits += this.explorers[explorer].power;
	  modifiers += this.explorers[explorer].power;

	  //
	  // mercators map
	  //
	  if (this.game.state.events.mercators_map === exp.faction) {
	    total_hits += 2;
	    modifiers += 2;
	    this.game.state.events.mercators_map = 0;
	  }
	  

	  if (!this.game.state[`${exp.faction}_uncharted`]) { total_hits++; }
	
	  exp.base_roll = base_hits;
	  exp.modified_roll = total_hits;
	  exp.explorer = explorer;
	  exp.prize = "-";
	  exp.hits = total_hits;
	  exp.modifiers = modifiers;
          exp.explorer = explorer;
          exp.explorer_img = this.explorers[explorer].img;
          exp.cabot = 0;

	  active_explorations.push(z);
 
	}
      }
    }

    //
    // sebastian cabot is a special case
    //
    if ((this.game.state.events.cabot_england == 1 && cabot_england_found == 0) || (this.game.state.events.cabot_france == 1 && cabot_france_found == 0) || (this.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0)) {

      //
      // which faction has
      //
      let f = "england";
      if (this.game.state.events.cabot_france == 1 && cabot_france_found == 0) { f = "france"; }
      if (this.game.state.events.cabot_hapsburg == 1 && cabot_hapsburg_found == 0) { f = "hapsburg"; }

      this.game.state.explorations.push({
	faction : f ,
	round : this.game.state.round ,
	resolved : 0 ,
      });
      let idx = this.game.state.explorations.length - 1;
      let exp = this.game.state.explorations[idx];

      let yy = this.rollDice(6);
      let zz = this.rollDice(6);

      let total_hits = yy + zz;
      let base_hits = total_hits;
      let modifiers = 1;
      total_hits += modifiers;

      exp.base_roll = base_hits;
      exp.modified_roll = total_hits;
      exp.prize = "-";
      exp.hits = total_hits;
      exp.modifiers = modifiers;
      exp.cabot = 1;
      exp.explorer = "Cabot";
      exp.explorer_img = "/his/img/tiles/explorers/Cabot_English.svg";
      if (f == "france") { exp.explorer_img = "/his/img/tiles/explorers/Cabot_French.svg"; }
      if (f == "hapsburg") { exp.explorer_img = "/his/img/tiles/explorers/Cabot_Hapsburg.svg"; }

      active_explorations.push(idx);

    }


    //
    // now determine sorted_explorations (order of resolution)
    //
    for (let z = 5; z >= -1; z--) {
      let idx = 0;
      let highest = -5;
      let highest_faction = "";

      //
      // sort resolution
      //
      while (active_explorations.length > sorted_explorations.length) {
        for (let k = 0; k < active_explorations.length; k++) {
  	  let exp = this.game.state.explorations[active_explorations[k]];
	  if (exp.sorted != 1) {
	    let explorer = exp.explorer;
	    let f = exp.faction;
	    let p = 0;
	    if (explorer === "Cabot") { p = 1; } else { p = this.explorers[explorer].power; }
	    if (p == highest) {
	      if (f == "england") { highest = -5; } // force next IF to execute
    	      if (f == "france" && highest_faction == "hapsburg") { highest = -5; } //force next-IF to execute
	    }
	    if (p > highest) {
	      idx = k;
	      highest = p;
	      highest_faction = f;
	    }
          }
	  exp.sorted = 1;
	  sorted_explorations.push(active_explorations[k]);
        };
      }
    }

    //
    // now resolve in order
    //
    for (let z = sorted_explorations.length-1; z >= 0; z--) {
      this.game.queue.push("resolve_exploration\t"+sorted_explorations[z]);
    }

    return 1;

  }



  displayCustomOverlay(c="", msg="") {

    //
    // move HUD above winter if winter is showing
    //
    this.welcome_overlay.pullHudOverOverlay();
    this.welcome_overlay.pushHudUnderOverlay();

    if (document.querySelector(".winter")) {
      this.welcome_overlay.overlay.zIndex = this.winter_overlay.overlay.zIndex + 2;
    }

    if (c === "all_corsairs_destroyed") {
        this.welcome_overlay.renderCustom({
          title : "Piracy Fails" , 
          text : "All Corsairs destroyed by Defensive Fire" ,
          card : "" ,
          img : '/his/img/backgrounds/corsairs_destroyed.jpg',
          styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
    }

    if (c === "depleted") {
        this.welcome_overlay.renderCustom({
          title : "Depleted Conquest" , 
          text : msg ,
          card : "" ,
          img : '/his/img/backgrounds/newworld/depleted_conquest.jpeg',
          styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
    }

    if (c === "deserted") {
      this.welcome_overlay.renderCustom({
        title : "Deserted Colony" , 
        text : msg ,
        card : "" ,
        img : '/his/img/backgrounds/newworld/deserted_colony.png',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "protestants") {
      this.welcome_overlay.renderCustom({
        title : "New to the Protestants?" , 
        text : "Why not play cards for OPS and publish treatises in Germany? " ,
        card : this.returnCardImage("065") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "excommunication") {
      this.welcome_overlay.renderCustom({
        title : "Excommunicated!" , 
        text : this.returnFactionName(msg) + " has been excommunicated by Papal Decree" ,
        card : this.returnCardImage("005") ,
        img : '/his/img/backgrounds/events/excommunication.jpg',
      });
      return;
    }
    if (c === "protestant") {
      this.welcome_overlay.renderCustom({
        title : "New to the Protestants?" , 
        text : "Use OPS to publish treatises and convert more spaces to Protestantism" ,
        card : this.returnCardImage("007") ,
        img : '/his/img/backgrounds/move/printing_press.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "papacy") {
      this.welcome_overlay.renderCustom({
        title : "New to the Papacy?" , 
        text : "Why not use your OPS to control Siena and move an invasion force to Florence?" ,
        card : this.returnCardImage("067") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "ottoman") {
      this.welcome_overlay.renderCustom({
        title : "New to the Ottomans?" , 
        text : "Why not use your OPS to invade Hungary and expand your empire?" ,
        card : this.returnCardImage("042") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "england") {
      this.welcome_overlay.renderCustom({
        title : "New to England?" , 
        text : "Why not use your Home Card to declare war on Scotland or France?" ,
        card : this.returnCardImage("003") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "france") {
      this.welcome_overlay.renderCustom({
        title : "New to France?" , 
        text : "Establishing Colonies and building Chateaux is crucial early-game! " ,
        card : this.returnCardImage("004") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "hapsburg") {
      this.welcome_overlay.renderCustom({
        title : "New to the Hapsburgs?" , 
        text : "Are there any independent keys you can conquer this turn? ",
        card : this.returnCardImage("002") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "lost-at-sea") {
      this.welcome_overlay.renderCustom({
        title : "New World Losses" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/lost_at_sea.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "killed") {
      this.welcome_overlay.renderCustom({
        title : "New World Losses" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/killed.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "stlawrence") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/st_lawrence.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "mississippi") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/mississippi.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      return;
    }

    if (c === "greatlakes") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/greatlakes.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "amazon") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/amazon3.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "pacificstrait") {
      this.welcome_overlay.renderCustom({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/pacificstrait.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "circumnavigation") {
      this.welcome_overlay.renderCustom({
        title : "New World Achievement" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/circumnavigation.jpg',
      });
      return;
    }

    if (c === "aztec") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/aztec.jpg',
      });
      return;
    }

    if (c === "maya") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/inca.jpg',
      });
      return;
    }

    if (c === "inca") {
      this.welcome_overlay.renderCustom({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/inca2.jpg',
      });
      return;
    }

    if (c === "battle-of-mohacs") {
      let t = "The Ottoman subjugation of Hungary-Bohemia forces the Hapsburg Empire to intervene on the side of Christian Europe and in pre-emptive defense of Vienna";
      if (this.areEnemies("hapsburg", "ottoman")) {  
      t = "The Ottoman subjugation of Hungary-Bohemia prompts a Hapsburg-Hungarian Alliance in defense of Christian Europe and the city of Vienna";
      }
      this.welcome_overlay.renderCustom({
        title : "War between the Hapsburg and Ottoman Empires" ,
	text : t,
        img : '/his/img/backgrounds/battle-of-mohacs.jpeg',
      });
      return;
    }

    if (c === "war") {
      this.welcome_overlay.renderCustom({
        title : "War!" ,
        text : msg ,
        img : '/his/img/backgrounds/war_horse.png',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "colonize") {
      this.welcome_overlay.renderCustom({
        title : msg ,
        text : "Colonies earn factions bonus cards in the New World Phase",
        img : '/his/img/backgrounds/move/colonize.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "translate") {
      this.welcome_overlay.renderCustom({
        title : msg ,
        text : "Protestants advance in biblical translation",
        img : '/his/img/backgrounds/move/translate.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "stpeters") {
      this.welcome_overlay.renderCustom({
        title : msg ,
        text : "The Papacy continues to build St. Peter's Basilica",
        img : '/his/img/backgrounds/move/saint_peters.png',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "overcapacity") {
      this.welcome_overlay.renderCustom({
        title : msg ,
        text : "Merge units until you have a 1-unit token free and can build more. See <b>Info > Units</b> for faction limits.",
        img : '/his/img/backgrounds/move/regular.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "conquest") {
      this.welcome_overlay.renderCustom({
        title : msg ,
        text : "Conquests earn factions Victory Points and bonus cards in the New World Phase",
        img : '/his/img/backgrounds/newworld/inca2.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      return;
    }

    if (c === "spring_deployment") {
      this.welcome_overlay.renderCustom({
        title : "Spring Deployment" ,
        text : "At the start of each round, players may move troops from their capital along any line of spaces controlled by them or their allies. Units may not cross passes or seas containing enemy ships. <b>New players can safely ignore Spring Deployment first turn</b>.",
        img : '/his/img/backgrounds/spring-deployment.jpeg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "diet_of_worms") {
      if (this.game.players.length == 2) {
        this.welcome_overlay.renderCustom({
          title : "Diet of Worms" ,
          text : "Protestants pick a card and add 4. Papacy picks a card and adds the value of a card drawn randomly from the deck. Dice are rolled and the winner flips the difference in hits to the Protestant or Catholic religion.",
          img : '/his/img/backgrounds/diet_of_worms.jpeg',
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
      } else {
        this.welcome_overlay.renderCustom({
          title : "Diet of Worms" ,
          text : "Protestants pick a card and add 4. Papacy and Hapsburg both pick cards and combine their values. Dice are rolled and the winner flips the difference in hits to the Protestant or Catholic religion.",
          img : '/his/img/backgrounds/diet_of_worms.jpeg',
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
      }
    }

    if (c === "explore") {
      this.welcome_overlay.renderCustom({
        title : msg,
        text : "Explorations earn Victory Points for strategic discoveries in the New World Phase",
        img : '/his/img/backgrounds/move/explore.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    let deck = this.returnDeck(true); // include removed
    if (deck[c]) {
      if (deck[c].returnCustomOverlay) {

        let obj = deck[c].returnCustomOverlay();    
        let title = obj.title;
        let text = obj.text;
        let img = obj.img;
        let card = this.returnCardImage(c);

        if (msg == "") {
    	  msg = this.popup(c) + " triggers";
        }
  
        this.welcome_overlay.renderCustom({
          text : text,
          title : title,
          img : img,
          card : card,
        });
      }
    }

  }

  displayHudPopup(c="", msg="") {

    if (c === "all_corsairs_destroyed") {
        this.hud_popup.render({
          title : "Piracy Fails" , 
          text : "All Corsairs destroyed by Defensive Fire" ,
          card : "" ,
          img : '/his/img/backgrounds/corsairs_destroyed.jpg',
          styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
    }

    if (c === "depleted") {
        this.hud_popup.render({
          title : "Depleted Conquest" , 
          text : msg ,
          card : "" ,
          img : '/his/img/backgrounds/newworld/depleted_conquest.jpeg',
          styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
    }

    if (c === "war") {
      this.hud_popup.render({
        title : "War" ,
        text : msg ,
        img : '/his/img/backgrounds/war_horse.png',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "deserted") {
      this.hud_popup.render({
        title : "Deserted Colony" , 
        text : msg ,
        card : "" ,
        img : '/his/img/backgrounds/newworld/deserted_colony.png',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "protestants") {
      this.hud_popup.render({
        title : "New to the Protestants?" , 
        text : "Why not play cards for OPS and publish treatises in Germany? " ,
        card : this.returnCardImage("065") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "excommunication") {
      this.hud_popup.render({
        title : "Excommunicated!" , 
        text : this.returnFactionName(msg) + " has been excommunicated by Papal Decree" ,
        card : this.returnCardImage("005") ,
        img : '/his/img/backgrounds/events/excommunication.jpg',
      });
      return;
    }
    if (c === "protestant") {
      this.hud_popup.render({
        title : "New to the Protestants?" , 
        text : "Use OPS to publish treatises and convert more spaces to Protestantism" ,
        card : this.returnCardImage("007") ,
        img : '/his/img/backgrounds/move/printing_press.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "papacy") {
      this.hud_popup.render({
        title : "New to the Papacy?" , 
        text : "Why not use your OPS to control Siena and move an invasion force to Florence?" ,
        card : this.returnCardImage("067") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "ottoman") {
      this.hud_popup.render({
        title : "New to the Ottomans?" , 
        text : "Why not use your OPS to invade Hungary and expand your empire?" ,
        card : this.returnCardImage("042") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "england") {
      this.hud_popup.render({
        title : "New to England?" , 
        text : "Why not use your Home Card to declare war on Scotland or France?" ,
        card : this.returnCardImage("003") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "france") {
      this.hud_popup.render({
        title : "New to France?" , 
        text : "Establishing Colonies and building Chateaux is crucial early-game! " ,
        card : this.returnCardImage("004") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }
    if (c === "hapsburg") {
      this.hud_popup.render({
        title : "New to the Hapsburgs?" , 
        text : "Are there any independent keys you can conquer this turn? ",
        card : this.returnCardImage("002") ,
        img : '/his/img/backgrounds/tutorials/95theses.jpg',
        styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "lost-at-sea") {
      this.hud_popup.render({
        title : "New World Losses" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/lost_at_sea.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "killed") {
      this.hud_popup.render({
        title : "New World Losses" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/killed.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "stlawrence") {
      this.hud_popup.render({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/st_lawrence.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "mississippi") {
      this.hud_popup.render({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/mississippi.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      return;
    }

    if (c === "greatlakes") {
      this.hud_popup.render({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/greatlakes.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "amazon") {
      this.hud_popup.render({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/amazon3.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "pacificstrait") {
      this.hud_popup.render({
        title : "New World Discovery" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/pacificstrait.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "circumnavigation") {
      this.hud_popup.render({
        title : "New World Achievement" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/circumnavigation.jpg',
      });
      return;
    }

    if (c === "aztec") {
      this.hud_popup.render({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/aztec.jpg',
      });
      return;
    }

    if (c === "maya") {
      this.hud_popup.render({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/inca.jpg',
      });
      return;
    }

    if (c === "inca") {
      this.hud_popup.render({
        title : "New World Conquest" ,
        text : msg ,
        img : '/his/img/backgrounds/newworld/inca2.jpg',
      });
      return;
    }

    if (c === "battle-of-mohacs") {
      let t = "The Ottoman subjugation of Hungary-Bohemia forces the Hapsburg Empire to intervene on the side of Christian Europe and in pre-emptive defense of Vienna";
      if (this.areEnemies("hapsburg", "ottoman")) {  
        t = "The Ottoman subjugation of Hungary-Bohemia prompts a Hapsburg-Hungarian Alliance in defense of Christian Europe and the city of Vienna";
      }
      this.hud_popup.render({
        title : "War between the Hapsburg and Ottoman Empires" ,
	text : t,
        img : '/his/img/backgrounds/battle-of-mohacs.jpeg',
      });
      return;
    }

    if (c === "colonize") {
      this.hud_popup.render({
        title : msg ,
        text : "Colonies earn factions bonus cards in the New World Phase",
        img : '/his/img/backgrounds/move/colonize.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "conquest") {
      this.hud_popup.render({
        title : msg ,
        text : "Conquests earn factions Victory Points and bonus cards in the New World Phase",
        img : '/his/img/backgrounds/newworld/inca2.jpg',
	styles : [{ key : "backgroundPosition" , val : "center" }],
      });
      return;
    }

    if (c === "spring_deployment") {
      this.hud_popup.render({
        title : "Spring Deployment" ,
        text : "At the start of each round, players may move troops from their capital along any line of spaces controlled by them or their allies. Units may not cross passes or seas containing enemy ships. <b>New players can safely ignore Spring Deployment first turn</b>.",
        img : '/his/img/backgrounds/spring-deployment.jpeg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "diet_of_worms") {
      if (this.game.players.length == 2) {
        this.hud_popup.render({
          title : "Diet of Worms" ,
          text : "Protestants pick a card and add 4. Papacy picks a card and adds the value of a card drawn randomly from the deck. Dice are rolled and the winner flips the difference in hits to the Protestant or Catholic religion.",
          img : '/his/img/backgrounds/diet_of_worms.jpeg',
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
      } else {
        this.hud_popup.render({
          title : "Diet of Worms" ,
          text : "Protestants pick a card and add 4. Papacy and Hapsburg both pick cards and combine their values. Dice are rolled and the winner flips the difference in hits to the Protestant or Catholic religion.",
          img : '/his/img/backgrounds/diet_of_worms.jpeg',
	  styles : [{ key : "backgroundPosition" , val : "bottom" }],
        });
        return;
      }
    }

    if (c === "explore") {
      this.hud_popup.render({
        title : msg,
        text : "Explorations earn Victory Points for strategic discoveries in the New World Phase",
        img : '/his/img/backgrounds/move/explore.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "translate") {
      this.hud_popup.render({
        title : msg ,
        text : "Protestants advance in biblical translation",
        img : '/his/img/backgrounds/move/translate.jpg',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    if (c === "stpeters") {
      this.hud_popup.render({
        title : msg ,
        text : "The Papacy continues to build St. Peter's Basilica",
        img : '/his/img/backgrounds/move/saint_peters.png',
	styles : [{ key : "backgroundPosition" , val : "bottom" }],
      });
      return;
    }

    let deck = this.returnDeck(true); // include removed
    if (deck[c]) {
      if (deck[c].returnCustomOverlay) {

        let obj = deck[c].returnCustomOverlay();    
        let title = obj.title;
        let text = obj.text;
        let img = obj.img;
        let card = this.returnCardImage(c);

        if (msg == "") {
    	  msg = this.popup(c) + " triggers";
        }

        this.hud_popup.render({
          text : text,
          title : title,
          img : img,
          card : card,
        });
      }
    }

  }

  hideOverlays() {
    this.debate_overlay.hide();
    this.treatise_overlay.hide();
    this.religious_overlay.hide();
    this.faction_overlay.hide();
    this.diet_of_worms_overlay.hide();
    this.council_of_trent_overlay.hide();
    this.theses_overlay.hide();
    this.reformation_overlay.hide();
    this.language_zone_overlay.hide();
    this.debaters_overlay.hide();
    this.schmalkaldic_overlay.hide();
    this.assault_overlay.hide();
    this.field_battle_overlay.hide();
    this.movement_overlay.hide();
    this.welcome_overlay.hide();
    this.deck_overlay.hide();
    this.menu_overlay.hide();
    this.winter_overlay.hide();
    this.units_overlay.hide();
  }

  returnReligionImage(religion) {
    if (religion === "protestant") { return "/his/img/tiles/abstract/protestant.png"; }
    if (religion === "catholic") { return "/his/img/tiles/abstract/catholic.png"; }
    return "/his/img/tiles/abstract/independent.svg";
  }

  returnLanguageImage(language) {

    if (language == "english") { return "/his/img/tiles/abstract/english.png"; }
    if (language == "french") { return "/his/img/tiles/abstract/french.png"; }
    if (language == "spanish") { return "/his/img/tiles/abstract/spanish.png"; }
    if (language == "italian") { return "/his/img/tiles/abstract/italian.png"; }
    if (language == "german") { return "/his/img/tiles/abstract/german.png"; }

    return "/his/img/tiles/abstract/other.png";

  }

  returnControlImage(faction) {

    if (faction == "papacy") { return "/his/img/tiles/abstract/papacy.svg"; }
    if (faction == "protestant") { return "/his/img/tiles/abstract/protestant.svg"; }
    if (faction == "england") { return "/his/img/tiles/abstract/england.svg"; }
    if (faction == "france") { return "/his/img/tiles/abstract/france.svg"; }
    if (faction == "ottoman") { return "/his/img/tiles/abstract/ottoman.svg"; }
    if (faction == "hapsburg") { return "/his/img/tiles/abstract/hapsburg.svg"; }

    return "/his/img/tiles/abstract/independent.svg";   

  }

  displayCardsLeft() {
    try {
    for (let key in this.game.state.cards_left) {

      let qs = ".game-factions .game-menu-sub-options ";
      if (key === "hapsburg") { 
        qs += ".game-hapsburg .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Hapsburgs (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "france") { 
        qs += ".game-france .game-menu-option-label";
	document.querySelector(qs).innerHTML = `France (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "ottoman") { 
        qs += ".game-ottoman .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Ottoman (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "england") { 
        qs += ".game-england .game-menu-option-label";
	document.querySelector(qs).innerHTML = `England (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "protestants" || key == "protestant") { 
        qs += ".game-protestants .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Protestants (${this.game.state.cards_left[key]} cards)`;
      }
      if (key === "papacy") { 
        qs += ".game-papacy .game-menu-option-label";
	document.querySelector(qs).innerHTML = `Papacy (${this.game.state.cards_left[key]} cards)`;
      }
    }
    } catch (err) {}
  }

  displayTurnTrack() {
    try {
      let obj = document.querySelector(".turntrack");
      obj.classList.remove(`turntrack1`);
      obj.classList.remove(`turntrack${this.game.state.round-1}`);
      obj.classList.add(`turntrack${this.game.state.round}`);
    } catch (err) {}
  }

  displayDiplomacyTable() { this.displayWarBox(); }
  displayWarBox() {
    try {
    let factions = ["ottoman","hapsburg","england","france","papacy","protestant","genoa","hungary","scotland","venice"];
    for (let i = 0; i < factions.length; i++) {
      for (let ii = 0; ii < factions.length; ii++) {
	if (ii > i) {
	  let obj = null;
	  let box = '#' + factions[i] + "_" + factions[ii];
	  obj = document.querySelector(box);
	  if (obj) {
	    if (this.areAllies(factions[i], factions[ii], 0)) {
	      obj.innerHTML = '<img src="/his/img/Allied.svg" />';
	      obj.style.display = "block";
	    } else {
	      if (this.areEnemies(factions[i], factions[ii], 0)) {
	        obj.innerHTML = '<img src="/his/img/AtWar.svg" />';
	        obj.style.display = "block";
	      } else {
	        obj.style.display = "none";
	      }
	    }
	  }
	}
      }
    }
    } catch (err) {}
  }

  displayDebaters() {
    this.debaters_overlay.render();
  }

  displayExplorers() {
    this.explorers_overlay.render();
  }

  displayConquistadors() {
    this.conquistadors_overlay.render();
  }

  displayPersia() {
    let obj = document.querySelector("#persia");
    obj.style.display = "block";
  }
  hidePersia() {
    let obj = document.querySelector("#persia");
    obj.style.display = "none";
  }
  displayEgypt() {
    let obj = document.querySelector("#egypt");
    obj.style.display = "block";
  }
  hideEgypt() {
    let obj = document.querySelector("#egypt");
    obj.style.display = "none";
  }
  displayIreland() {
    let obj = document.querySelector("#ireland");
    obj.style.display = "block";
  }
  hideIreland() {
    let obj = document.querySelector("#ireland");
    obj.style.display = "none";
  }

  displayPregnancyChart() {

    let his_self = this;

    document.querySelectorAll(".pregnancy_chart").forEach((el) => {
      el.classList.remove("active");
    });

    if (!his_self.game.state.henry_viii_rolls) { his_self.game.state.henry_viii_rolls = []; }
    if (!his_self.game.state.henry_viii_wives) { his_self.game.state.henry_viii_wives = []; }
    for (let i = 0; i < his_self.game.state.henry_viii_wives.length && i < his_self.game.state.henry_viii_rolls.length; i++) {

      let dd = his_self.game.state.henry_viii_rolls[i];
      let wife = his_self.game.state.henry_viii_wives[i];
      let wife_tile = "/his/img/tiles/wives/";

      if (wife == "boleyn")  { wife_tile += "AnneBoleyn.svg"; }
      if (wife == "cleves")  { wife_tile += "AnneCleves.svg"; }
      if (wife == "aragon")  { wife_tile += "CatherineAragon.svg"; }
      if (wife == "seymour") { wife_tile += "JaneSeymour.svg"; }
      if (wife == "parr")    { wife_tile += "KatherineParr.svg"; }
      if (wife == "howard")  { wife_tile += "KathrynHoward.svg"; }

      if (dd == 1) { document.querySelector("#pregnancy1").style.backgroundImage = `url("${wife_tile}")`; }
      if (dd == 2) { document.querySelector("#pregnancy2").style.backgroundImage = `url("${wife_tile}")`; }
      if (dd == 3) { document.querySelector("#pregnancy3").style.backgroundImage = `url("${wife_tile}")`; }
      if (dd == 4) { document.querySelector("#pregnancy4").style.backgroundImage = `url("${wife_tile}")`; }
      if (dd == 5) { document.querySelector("#pregnancy5").style.backgroundImage = `url("${wife_tile}")`; }
      if (dd == 6) { document.querySelector("#pregnancy6").style.backgroundImage = `url("${wife_tile}")`; }

    }

  }

  displayTheologicalDebater(debater, attacker=true) {

    let tile_f = "/his/img/tiles/debaters/" + this.debaters[debater].img;
    let tile_b = tile_f.replace('.svg', '_back.svg');

    if (this.isDebaterCommitted(debater)) { let x = tile_f; tile_f = tile_b; tile_b = x; } // reverse default sides if committed

    if (attacker) {
      $('.attacker_debater').css('background-image', `url('${tile_f}')`);
      $('.attacker_debater').mouseover(function() { 
	$('.attacker_debater').css('background-image', `url('${tile_b}')`);
      }).mouseout(function() {
	$('.attacker_debater').css('background-image', `url('${tile_f}')`);
      });
    } else {
      $('.defender_debater').css('background-image', `url('${tile_f}')`);
      $('.defender_debater').mouseover(function() { 
	$('.defender_debater').css('background-image', `url('${tile_b}')`);
      }).mouseout(function() {
	$('.defender_debater').css('background-image', `url('${tile_f}')`);
      });
    }
  }

  displayTheologicalDebate(res) {
    this.debate_overlay.render(res);
  }


  displayReligiousConflictSheet() {

    let num_protestant_spaces = 0;
    let rcc = this.returnReligiousConflictChart();
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion === "protestant") {
        num_protestant_spaces++;
      }
    }
    if (num_protestant_spaces > 50) { num_protestant_spaces = 50; }
    let cid = "s" + num_protestant_spaces;

    let html = `
      <div class="religious_conflict_sheet" id="religious_conflict_sheet" style="background-image: url('/his/img/reference/religious.jpg')">
	<div class="religious_conflict_sheet_tile" id="religious_conflict_sheet_tile"></div>
	<div class="papal_debaters"></div>
	<div class="lutheran_debaters"></div>
	<div class="calvinist_debaters"></div>
	<div class="anglican_debaters"></div>
	<div class="protestant_debaters"></div>
      </div>
    `;

    this.overlay.showOverlay(html);

    //
    // list all debaters
    //
    for (let i = 0; i < this.game.state.debaters.length; i++) {
      let d = this.game.state.debaters[i];
      let dtile = `<img class="debater_tile" id="${i}" src="/his/img/tiles/debaters/${d.img}" />`;
      if (d.owner === "papacy") {
	this.app.browser.addElementToSelector(dtile, '.papal_debaters');
      }
      if (d.owner === "england") {
	this.app.browser.addElementToSelector(dtile, '.anglican_debaters');
      }
      if (d.owner === "hapsburg") {
	this.app.browser.addElementToSelector(dtile, '.calvinist_debaters');
      }
      if (d.owner === "protestant") {
	this.app.browser.addElementToSelector(dtile, '.protestant_debaters');
      }
    }

    let obj = document.getElementById("religious_conflict_sheet_tile");
    obj.style.top = rcc[cid].top;
    obj.style.left = rcc[cid].left;

  }

  returnProtestantSpacesTrackVictoryPoints() {

    let num_protestant_spaces = 0;
    for (let key in this.game.spaces) {
      if (this.game.spaces[key].religion === "protestant") {
	if (!this.game.spaces[key].unrest) {
          num_protestant_spaces++;
	}
      }
    }
    if (num_protestant_spaces > 50) { num_protestant_spaces = 50; }

    let x = [];
    for (let i = 0; i < 51; i++) { 

      x[i] = {}; x[i].protestant = 0; x[i].papacy = 15;

      if (i >= 4)  { x[i].protestant++; x[i].papacy--; }
      if (i >= 7)  { x[i].protestant++; x[i].papacy--; }
      if (i >= 10) { x[i].protestant++; x[i].papacy--; }
      if (i >= 14) { x[i].protestant++; x[i].papacy--; }
      if (i >= 17) { x[i].protestant++; x[i].papacy--; }
      if (i >= 20) { x[i].protestant++; x[i].papacy--; }
      if (i >= 24) { x[i].protestant++; x[i].papacy--; }
      if (i >= 27) { x[i].protestant++; x[i].papacy--; }
      if (i >= 30) { x[i].protestant++; x[i].papacy--; }
      if (i >= 34) { x[i].protestant++; x[i].papacy--; }
      if (i >= 37) { x[i].protestant++; x[i].papacy--; }
      if (i >= 40) { x[i].protestant++; x[i].papacy--; }
      if (i >= 44) { x[i].protestant++; x[i].papacy--; }
      if (i >= 47) { x[i].protestant++; x[i].papacy--; }
      if (i >= 50) { x[i].protestant+=100; x[i].papacy--; }
    }

    return x[num_protestant_spaces];

  }


  displayFactionSheet(faction) {
    this.faction_overlay.render(faction);
  }

  returnFactionSheetKeys() {
  }

  displayBoard() {

    try {
      if (this.game.state.events.war_in_persia) { this.displayPersia(); }
      if (this.game.state.events.revolt_in_egypt) { this.displayEgypt(); }
      if (this.game.state.events.revolt_in_ireland) { this.displayIreland(); }
    } catch (err) {
      //console.log("error displaying foreign wars... " + err);
    }

    try {
      this.displayPregnancyChart();
    } catch (err) {
      //console.log("error displaying turn track... " + err);
    }
    try {
      this.displayTurnTrack();
    } catch (err) {
      //console.log("error displaying turn track... " + err);
    }
    try {
      this.displayWarBox();
    } catch (err) {
      //console.log("error displaying diplomacy box... " + err);
    }
    try {
      this.displayColony();
    } catch (err) {
      //console.log("error displaying colonies... " + err);
    }
    try {
      this.displayConquest();
    } catch (err) {
      //console.log("error displaying conquest... " + err);
    }
    try {
      this.displayElectorateDisplay();
    } catch (err) {
      //console.log("error displaying electorates... " + err);
    }
    try {
      this.displayNewWorld();
    } catch (err) {
      //console.log("error displaying new world... " + err);
    }
    try {
      this.displaySpaces();
    } catch (err) {
      //console.log("error displaying spaces... " + err);
    }
    try {
      this.displayNavalSpaces();
    } catch (err) {
      //console.log("error displaying naval spaces... " + err);
    }
    try {
      this.displayVictoryTrack();
    } catch (err) {
      //console.log("error displaying victory track... " + err);
    }
  }

  displayNewWorldBonuses() {
    try {

      document.querySelector(".france_colony1_bonus").innerHTML = "";
      document.querySelector(".france_colony2_bonus").innerHTML = "";
      document.querySelector(".england_colony1_bonus").innerHTML = "";
      document.querySelector(".england_colony2_bonus").innerHTML = "";
      document.querySelector(".hapsburg_colony1_bonus").innerHTML = "";
      document.querySelector(".hapsburg_colony2_bonus").innerHTML = "";
      document.querySelector(".hapsburg_colony3_bonus").innerHTML = "";

      //
      // Galleons Colony #1
      //
      if (this.game.state.galleons['france'] == 1) {
	document.querySelector(".france_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      if (this.game.state.galleons['england'] == 1) {
	document.querySelector(".england_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      if (this.game.state.galleons['hapsburg'] == 1) {
	document.querySelector(".hapsburg_colony1_bonus").innerHTML = `<img class="army_tile" src="/his/img/Galleons.svg" />`;
      }
      //
      // Plantations Colony #2
      //
      if (this.game.state.plantations['france'] == 1) {
	document.querySelector(".france_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".france_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "france") {
	document.querySelector(".france_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }

      if (this.game.state.plantations['england'] == 1) {
	document.querySelector(".england_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".england_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "england") {
	document.querySelector(".england_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }

      if (this.game.state.plantations['hapsburg'] == 1) {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML = `<img class="army_tile" src="/his/img/tiles/colonies/Plantations.svg" />`;
      } else {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML = ``;
      }
      if (this.game.state.events.colonial_governor == "hapsburg") {
	document.querySelector(".hapsburg_colony2_bonus").innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/ColonialGovernor.svg" />`;
      }
      //
      // Raiders Colony #3
      //
      if (this.game.state.raiders['protestant'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML = `<img class="army_tile" src="/his/img/Raider_Protestant.svg" />`;
      }
      if (this.game.state.raiders['england'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML += `<img class="army_tile" src="/his/img/Raider_French.svg" />`;
      }
      if (this.game.state.raiders['france'] == 1) {
	document.querySelector(".hapsburg_colony3_bonus").innerHTML += `<img class="army_tile" src="/his/img/Raider_English.svg" />`;
      }
      //
      // Mercator's Map
      //
      if (this.game.state.events.mercators_map != "") {
	if (document.querySelector(".crossing_atlantic").innerHTML.indexOf("Mercator") == -1) {
	  document.querySelector(".crossing_atlantic").innerHTML += `<img class="army_tile" src="/his/img/Mercator.svg" />`;
        }
      }
    } catch (err) {
      console.log("error displaying New World bonuses: " + JSON.stringify(err));
    }
  }


  displayColony() {

    let obj = document.querySelector(".crossing_atlantic");
    obj.innerHTML = "";

    document.querySelector('.england_colony1').innerHTML  = ``;
    document.querySelector('.england_colony2').innerHTML  = ``;
    document.querySelector('.france_colony1').innerHTML   = ``;
    document.querySelector('.france_colony2').innerHTML   = ``;
    document.querySelector('.hapsburg_colony1').innerHTML = ``;
    document.querySelector('.hapsburg_colony2').innerHTML = ``;
    document.querySelector('.hapsburg_colony3').innerHTML = ``;

    for (let i = 0; i < this.game.state.colonies.length; i++) {

      let c = this.game.state.colonies[i];

      if (c.resolved != 1) {
        obj.innerHTML += `<img class="army_tile" src="${this.returnNextColonyTile(c.faction)}" />`;
      }

      if (c.resolved == 1 && c.destroyed != 1) {
        if (c.colony === "england_colony1")  { document.querySelector('.england_colony1').innerHTML  = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "england_colony2")  { document.querySelector('.england_colony2').innerHTML  = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "france_colony1")   { document.querySelector('.france_colony1').innerHTML   = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "france_colony2")   { document.querySelector('.france_colony2').innerHTML   = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "hapsburg_colony1") { document.querySelector('.hapsburg_colony1').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "hapsburg_colony2") { document.querySelector('.hapsburg_colony2').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
        if (c.colony === "hapsburg_colony3") { document.querySelector('.hapsburg_colony3').innerHTML = `<img class="nw_tile" src="${c.img}" />`; }
      }
    }

    //
    // this will be set when unresolved...
    //
    if (this.game.state.events.potosi_silver_mines != "") {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/colonies/Potosi.svg" />`;
    }

  }


  displayConquest() {

    let obj = document.querySelector(".crossing_atlantic");

    for (let z = 0; z < this.game.state.conquests.length; z++) {

      let con = this.game.state.conquests[z];
      let faction = con.faction;
      let round = con.round;

      //      
      // current round are unresolved      
      //      
      if (round == this.game.state.round) {
        if (faction == "hapsburg") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_Conquest.svg" />`;
        }
        if (faction == "france") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_Conquest.svg" />`;
        }
        if (faction == "england") {
          obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_Conquest.svg" />`;
        }
	if (this.game.state.events.smallpox == faction) {
          obj.innerHTML += `<img class="army_tile" src="/his/img/Smallpox.svg" />`;
	}
      }
    }

    let ec = [];
    let fc = [];
    let hc = [];

    if (this.game.state.newworld['aztec'].claimed == 1) {
      if (this.game.state.newworld['aztec'].faction == "england") { ec.push("aztec"); }
      if (this.game.state.newworld['aztec'].faction == "france") { fc.push("aztec"); }
      if (this.game.state.newworld['aztec'].faction == "hapsburg") { hc.push("aztec"); }
    }
    if (this.game.state.newworld['inca'].claimed == 1) {
      if (this.game.state.newworld['inca'].faction == "england") { ec.push("inca"); }
      if (this.game.state.newworld['inca'].faction == "france") { fc.push("inca"); }
      if (this.game.state.newworld['inca'].faction == "hapsburg") { hc.push("inca"); }
    }
    if (this.game.state.newworld['maya'].claimed == 1) {
      if (this.game.state.newworld['maya'].faction == "england") { ec.push("maya"); }
      if (this.game.state.newworld['maya'].faction == "france") { fc.push("maya"); }
      if (this.game.state.newworld['maya'].faction == "hapsburg") { hc.push("maya"); }
    }

    for (let z = 0, zz = 1; z < ec.length; z++) {
      let depl = ""; if (this.game.state.newworld[ec[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 2) {
	document.querySelector(`.england_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[ec[z]].img}" />`;
        zz++;
      }
    }
    for (let z = 0, zz = 1; z < fc.length; z++) {
      let depl = ""; if (this.game.state.newworld[fc[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 2) {
	document.querySelector(`.france_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[fc[z]].img}" />`;
        zz++;
      }
    }
    for (let z = 0, zz = 1; z < hc.length; z++) {
      let depl = ""; if (this.game.state.newworld[hc[z]].deleted == 1) { depl = "depleted"; }
      if (zz < 3) {
	document.querySelector(`.hapsburg_conquest${zz}`).innerHTML = `<img class="nw_tile ${depl}" src="${this.game.state.newworld[hc[z]].img}" />`;
        zz++;
      }
    }

    if (this.game.state.newworld['maya'].claimed == 1) {
      let f = this.game.state.newworld['maya'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.maya').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['aztec'].claimed == 1) {
      let f = this.game.state.newworld['aztec'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.aztec').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['inca'].claimed == 1) {
      let f = this.game.state.newworld['inca'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.inca').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }

  }

  displayExploration() {

    let obj = document.querySelector(".crossing_atlantic");

    let cabot_england_found = 0;
    let cabot_france_found = 0;
    let cabot_hapsburg_found = 0;

    for (let z = 0; z < this.game.state.explorations.length; z++) {

      let exp = this.game.state.explorations[z];
      let faction = exp.faction;
      let round = exp.round;

      if (exp.cabot == 1) { if (faction == "england") { cabot_england_found = 1; } }
      if (exp.cabot == 1) { if (faction == "france") { cabot_france_found = 1; } }
      if (exp.cabot == 1) { if (faction == "hapsburg") { cabot_hapsburg_found = 1; } }

      //      
      // current round are unresolved      
      //      
      if (round == this.game.state.round) {
        if (faction == "hapsburg") {
          if (this.game.state.hapsburg_uncharted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_Exploration.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/hapsburg/Hapsburg_ExplorationCharted.svg" />`;
          }
        }
        if (faction == "france") {
          if (this.game.state.france_uncharted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_Exploration.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/france/French_ExplorationCharted.svg" />`;
          }
        }
        if (faction == "england") {
          if (this.game.state.england_uncharted == 1) {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_Exploration.svg" />`;
          } else {
            obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/england/English_ExplorationCharted.svg" />`;
          }
        }
      }
    }

    if (this.game.state.newworld['stlawrence'].claimed == 1) {
      let f = this.game.state.newworld['stlawrence'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.stlawrence').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['greatlakes'].claimed == 1) {
      let f = this.game.state.newworld['greatlakes'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.greatlakes').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['mississippi'].claimed == 1) {
      let f = this.game.state.newworld['mississippi'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.mississippi').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['amazon'].claimed == 1) {
      let f = this.game.state.newworld['amazon'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.amazon').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['pacificstrait'].claimed == 1) {
      let f = this.game.state.newworld['pacificstrait'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.pacificstrait').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }
    if (this.game.state.newworld['circumnavigation'].claimed == 1) {
      let f = this.game.state.newworld['circumnavigation'].faction;
      let t = this.returnExplorationTile(f);
      document.querySelector('.circumnavigation').innerHTML = `<img class="nw_tile" src="/his/img/tiles/${f}/${this.returnExplorationTile(f)}" />`;
    }

    if (cabot_england_found == 0 && this.game.state.events.cabot_england == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_English.svg" />`;
    }
    if (cabot_france_found == 0 && this.game.state.events.cabot_france == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_French.svg" />`;
    }
    if (cabot_hapsburg_found == 0 && this.game.state.events.cabot_hapsburg == 1) {
      obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/explorers/Cabot_Hapsburg.svg" />`;
    }

  }

  returnExplorationTile(f="") {
    if (f == "hapsburg") { return "Hapsburg_key.svg"; }
    if (f == "england") { return "England_key.svg"; }
    if (f == "france") { return "France_key.svg"; }
    return "";
  }

  displayNewWorld() {
try {
    document.querySelector(".crossing_atlantic").innerHTML = "";
    this.displayColony();
    this.displayConquest();
    this.displayExploration();
    this.displayNewWorldBonuses();
} catch (err) {
console.log("ERROR DISPLAYING NEW WORLD STUFF: " + JSON.stringify(err));
    }
  }

  displaySpaceDetailedView(name) {
    let html = "";
    if (this.spaces[name]) { html = this.spaces[name].returnView(); }
    if (this.navalspaces[name]) { html = this.navalspaces[name].returnView(); }
    if (html != "") { this.overlay.show(html); }
  }

  displayElectorateDisplay() {
    let elecs = this.returnElectorateDisplay();
    for (let key in elecs) {
      let obj = document.getElementById(`ed_${key}`);
      let tile = this.returnSpaceTile(this.game.spaces[key]);
      obj.innerHTML = ` <img class="hextile" src="${tile}" />`;      
      if (this.returnElectoralBonus(key) != 0) {
        obj.innerHTML += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-${this.returnElectoralBonus(key)}.svg" />`;
      }
    }
  }


  // returns 1 if the bonus for controlling is still outstanding
  returnElectoralBonus(space) {

    if (space === "augsburg" && this.game.state.augsburg_electoral_bonus == 0) {
      return 2;
    }
    if (space === "mainz" && this.game.state.mainz_electoral_bonus == 0) {
      return 1;
    }
    if (space === "trier" && this.game.state.trier_electoral_bonus == 0) {
      return 1;
    }
    if (space === "cologne" && this.game.state.cologne_electoral_bonus == 0) {
      return 1;
    }
    if (space === "wittenberg" && this.game.state.wittenberg_electoral_bonus == 0) {
      return 2;
    }
    if (space === "brandenburg" && this.game.state.brandenburg_electoral_bonus == 0) {
      return 1;
    }

    return 0;

  }

  returnSpaceTile(space) {

    let owner = space.political;
    if (owner == "") { owner = space.home; }
    let tile = "";
    let stype = "hex";

    if (space.type == "town") { stype = "hex"; owner = this.returnControllingPower(owner); }
    if (space.type == "key") { stype = "key"; owner = this.returnControllingPower(owner); }
    if (owner == "protestant") { stype = "hex"; owner = this.returnControllingPower(owner); }


    //
    //
    //
    if (space.home === space.political || (space.home !== "" && space.political == "")) {
      if (space.home !== this.returnControllingPower(space.home)) {
	owner = this.returnControllingPower(space.home);
      }
    }

    if (owner != "") {
      if (owner === "hungary") {
        if (owner === "hungary") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "scotland") {
	if (owner === "scotland") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "venice") {
	if (owner === "venice") {
          tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }
      if (owner === "genoa") {
        if (owner === "genoa") {
	  tile = "/his/img/tiles/independent/";	  
          if (space.religion === "protestant") {
            tile += `Independent_${stype}_back.svg`;
          } else {
            tile += `Independent_${stype}.svg`;
          }
        }
      }

      if (owner === "hapsburg") {
        tile = "/his/img/tiles/hapsburg/";	  
        if (space.religion === "protestant") {
          tile += `Hapsburg_${stype}_back.svg`;
        } else {
          tile += `Hapsburg_${stype}.svg`;
        }
      }
      if (owner === "england") {
        tile = "/his/img/tiles/england/";	  
        if (space.religion === "protestant") {
          tile += `England_${stype}_back.svg`;
        } else {
          tile += `England_${stype}.svg`;
        }
      }
      if (owner === "france") {
        tile = "/his/img/tiles/france/";	  
        if (space.religion === "protestant") {
          tile += `France_${stype}_back.svg`;
        } else {
          tile += `France_${stype}.svg`;
        }
      }
      if (owner === "papacy") {
        tile = "/his/img/tiles/papacy/";	  
        if (space.religion === "protestant") {
          tile += `Papacy_${stype}_back.svg`;
	} else {
	  tile += `Papacy_${stype}.svg`;
	}
      }
      if (owner === "protestant") {
        tile = "/his/img/tiles/protestant/";	  
        if (space.religion === "protestant") {
          tile += `Protestant_${stype}_back.svg`;
        } else {
          tile += `Protestant_${stype}.svg`;
        }
      }
      if (owner === "ottoman") {
        tile = "/his/img/tiles/ottoman/";	  
        if (space.religion === "protestant") {
          tile += `Ottoman_${stype}_back.svg`;
        } else {
          tile += `Ottoman_${stype}.svg`;
        }
      }
      if (owner === "independent") {
        tile = "/his/img/tiles/independent/";	  
        if (space.religion === "protestant") {
          tile += `Independent_${stype}_back.svg`;
        } else {
          tile += `Independent_${stype}.svg`;
        }
      }
    }

    return tile;

  }

  returnNavalTiles(faction, spacekey) {

      let html = "";
      let tile = "";
      let space = this.game.navalspaces[spacekey];
      if (!space) {
	// might be at a port
        space = this.game.spaces[spacekey];
      }
      let z = faction;
      let squadrons = 0;
      let corsairs = 0;

      //
      // if the squadron is on-loan, show the original tile not the 
      // owner
      //
      let squadrons_loaned = [];


      for (let zz = 0; zz < space.units[z].length; zz++) {
	if (space.units[z][zz].type === "squadron") {
	  squadrons += 2;
	  if (space.units[z][zz].owner != faction) { 
	    squadrons_loaned.push(space.units[z][zz].owner);
	  }
	}
	if (space.units[z][zz].type === "corsair") {
	  corsairs += 1;
	}
      }

      while (squadrons >= 2) {

	let zzz = z;

	if (squadrons_loaned.length > 0) {
	  zzz = squadrons_loaned[0];
	  squadrons_loaned.splice(0, 1);
	}

        if (zzz === "hapsburg") {
          tile = "/his/img/tiles/hapsburg/";	  
	  if (squadrons >= 2) {
            tile += `Hapsburg_squadron.svg`;
	    squadrons -= 2;
	  }
        }
        if (zzz === "england") {
          tile = "/his/img/tiles/england/";	  
	  if (squadrons >= 2) {
            tile += `English_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (zzz === "france") {
          tile = "/his/img/tiles/france/";	  
	  if (squadrons >= 2) {
            tile += `French_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (zzz === "papacy") {
          tile = "/his/img/tiles/papacy/";	  
	  if (squadrons >= 2) {
            tile += `Papacy_squadron.svg`;
	    squadrons -= 2;
	  }
        }
        if (zzz === "ottoman") {
          tile = "/his/img/tiles/ottoman/";	  
	  if (squadrons >= 2) {
            tile += `Ottoman_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (zzz === "venice") {
          tile = "/his/img/tiles/venice/";	  
	  if (squadrons >= 2) {
            tile += `Venice_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (zzz === "genoa") {
          tile = "/his/img/tiles/genoa/";	  
	  if (squadrons >= 2) {
            tile += `Genoa_squadron.svg`;
	    squadrons -= 2;
          }
        }
        if (zzz === "scotland") {
          tile = "/his/img/tiles/scotland/";	  
	  if (squadrons >= 2) {
            tile += `Scottish_squadron.svg`;
	    squadrons -= 2;
          }
        }

        html += `<img class="navy_tile" src="${tile}" />`;
      }

      while (corsairs >= 1) {
        if (z === "ottoman") {
          tile = "/his/img/tiles/ottoman/";	  
	  if (corsairs >= 1) {
            tile += `Ottoman_corsair.svg`;
	    corsairs -= 1;
          }
        }

        html += `<img class="navy_tile" src="${tile}" />`;

      }

    return html;
  }

  returnNavies(space) {

    let html = '<div class="space_navy" id="">';
    let tile = "";

    for (let z in space.units) {
      html += this.returnNavalTiles(z, space.key);
      tile = html;
    }
    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnArmyTiles(faction, spacekey) {

    let z = faction;
    let space = this.game.spaces[spacekey];
    let html = "";

    try {

    if (this.game.state.board[z]) {
      if (this.game.state.board[z].deployed[spacekey]) {
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-1.svg" />`;
	    }
	  }

      }


      //
      // surplus units that should not technically be available according to
      // tile limitations will be in the "missing" section. we do not want
      // pieces appearing and disappearing from the board, so we display them
      // as single-unit tiles.
      //
      if (this.game.state.board[z].missing[spacekey]) {
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgReg-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanReg-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyReg-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandReg-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchReg-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantReg-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceReg-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaReg-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryReg-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishReg-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['regular']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentReg-1.svg" />`;
	    }
	  }
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanMerc-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-1.svg" />`;
	    }
	  }
          if (z === "venice") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/venice/VeniceMerc-1.svg" />`;
	    }
	  }
          if (z === "genoa") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/genoa/GenoaMerc-1.svg" />`;
	    }
	  }
          if (z === "hungary") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hungary/HungaryMerc-1.svg" />`;
	    }
	  }
          if (z === "scotland") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/scotland/ScottishMerc-1.svg" />`;
	    }
	  }
          if (z === "independent") {
	    for (let i = 0; i < this.game.state.board[z].missing[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/independent/IndependentMerc-1.svg" />`;
	    }
	  }
      }
    }
    //
    // if there is an error
    //
    } catch (err) {
	console.log("ERROR: need to run returnOnBoardUnits: " + JSON.stringify(err));
	this.returnOnBoardUnits();
    }

    return html;
  }

  returnArmies(space) {

    let html = '<div class="space_army" id="">';
    let tile = "";
    let spacekey = space.key;
    let controlling_faction = "";
    if (space.political != "") { controlling_faction = space.political; } else {
      if (space.home != "") { controlling_faction = space.home; }
    }

    for (let z in space.units) {

      //
      // ideally our space is "pre-calculated" and we can display the correct
      // mix of tiles. this should be saved in this.game.state.board["papacy"]
      // etc. see his-units for the returnOnBoardUnits() function that organizes
      // this data object.
      //
      // independent spaces may not be pre-calculated, so we handle them manually
      //
      if (this.game.state.board[z] && (space.political != "independent" || space.home != "independent")) {
	// mercenary also handles cavalry
        html += this.returnMercenaryTiles(z, spacekey);
        html += this.returnArmyTiles(z, spacekey);
	tile = html;
      } else {


        new_units = false;

	//
	// AUTO - ARMIES
	//
        let army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
  	  if (space.units[z][zz].type === "regular") {
	    new_units = true;
	    army++;
	  }
        }

        while (army >= 1) {
          if (z === "hapsburg") {
            tile = "/his/img/tiles/hapsburg/";	  
	    if (army >= 4) {
              tile += `HapsburgReg-4.svg`;
	      army -= 4;
	    } else {
	      if (army >= 2) {
                tile += `HapsburgReg-2.svg`;
	        army -= 2;
	      } else {
	        if (army >= 1) {
                  tile += `HapsburgReg-1.svg`;
	          army -= 1;
	        }
	      }
            }
	  }
          if (z === "england") {
            tile = "/his/img/tiles/england/";	  
	    if (army >= 4) {
              tile += `EnglandReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `EnglandReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `EnglandReg-1.svg`;
	          army -= 1;
                }
              }
	    }
          }
          if (z === "france") {
            tile = "/his/img/tiles/france/";	  
	    if (army >= 4) {
              tile += `FrenchReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `FrenchReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `FrenchReg-1.svg`;
	          army -= 1;
                }
	      }
	    }
          }
          if (z === "papacy") {
            tile = "/his/img/tiles/papacy/";	  
            if (army >= 4) {
              tile += `PapacyReg-4.svg`;
              army -= 4;
            } else {
	      if (army >= 2) {
                tile += `PapacyReg-2.svg`;
	        army -= 2;
	      } else {
	        if (army >= 1) {
                  tile += `PapacyReg-1.svg`;
	          army -= 1;
	        }
	      }
	    }
          }
          if (z === "protestant") {
            tile = "/his/img/tiles/protestant/";	  
	    if (army >= 4) {
              tile += `ProtestantReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `ProtestantReg-2.svg`;
	        army -= 2;
               } else {
	         if (army >= 1) {
                   tile += `ProtestantReg-1.svg`;
	           army -= 1;
                 }
	       }
            }
          }
          if (z === "ottoman") {
            tile = "/his/img/tiles/ottoman/";	  
	    if (army >= 4) {
              tile += `OttomanReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `OttomanReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `OttomanReg-1.svg`;
	          army -= 1;
                }
              }
            }
          }
          if (z === "independent") {
            tile = "/his/img/tiles/independent/";	  
	    if (army >= 2) {
              tile += `IndependentReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `IndependentReg-1.svg`;
	        army -= 1;
              } 
	    }
          }
          if (z === "venice") {
            tile = "/his/img/tiles/venice/";	  
	    if (army >= 2) {
              tile += `VeniceReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `VeniceReg-1.svg`;
	        army -= 1;
              }
	    }
          }
          if (z === "hungary") {
            tile = "/his/img/tiles/hungary/";	  
	    if (army >= 4) {
              tile += `HungaryReg-4.svg`;
	      army -= 4;
            } else {
	      if (army >= 2) {
                tile += `HungaryReg-2.svg`;
	        army -= 2;
              } else {
	        if (army >= 1) {
                  tile += `HungaryReg-1.svg`;
	          army -= 1;
                }
              }
            }
          }
          if (z === "genoa") {
            tile = "/his/img/tiles/genoa/";	  
	    if (army >= 2) {
              tile += `GenoaReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `GenoaReg-1.svg`;
	        army -= 1;
              }
            }
          }
          if (z === "scotland") {
            tile = "/his/img/tiles/scotland/";	  
	    if (army >= 2) {
              tile += `ScottishReg-2.svg`;
	      army -= 2;
            } else {
	      if (army >= 1) {
                tile += `ScottishReg-1.svg`;
	        army -= 1;
              }
            } 
          }
        }

        if (new_units == true) {
          if (controlling_faction != "" && controlling_faction !== z) {
            html += `<img class="army_tile army_tile" src="${tile}" />`;
  	  } else {
            html += `<img class="army_tile" src="${tile}" />`;
	  }
        }

        new_units = false;

        army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
          if (space.units[z][zz].type === "mercenary") {
  	    new_units = true;
            army++;
          }
        }

        while (army > 0) {
          if (z != "") {
            if (z === "hapsburg") {
              tile = "/his/img/tiles/hapsburg/";	  
	      if (army >= 4) {
                tile += `HapsburgMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2) {
                tile += `HapsburgMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1) {
                tile += `HapsburgMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "england") {
              tile = "/his/img/tiles/england/";	  
	      if (army >= 4) {
                tile += `EnglandMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `EnglandMerc-2.svg`;
	        army -= 4;
              } else {
	      if (army >= 1) {
                tile += `EnglandMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "france") {
              tile = "/his/img/tiles/france/";	  
	      if (army >= 4) {
                tile += `FrenchMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `FrenchMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `FrenchMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "papacy") {
              tile = "/his/img/tiles/papacy/";	  
	      if (army >= 4) {
                tile += `PapacyMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "protestant") {
              tile = "/his/img/tiles/protestant/";	  
	      if (army >= 4) {
                tile += `ProtestantMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `ProtestantMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `ProtestantMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "ottoman") {
              tile = "/his/img/tiles/ottoman/";	  
	      if (army >= 4) {
                tile += `OttomanMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `OttomanMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `OttomanMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
          }


          if (new_units == true) {
            if (controlling_faction != "" && controlling_faction !== z) {
              html += `<img class="army_tile army_tile" src="${tile}" />`;
  	    } else {
              html += `<img class="army_tile" src="${tile}" />`;
	    }
          }
        }
      }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnMercenaryTiles(faction, spacekey) {

    let z = faction;
    let space = this.game.spaces[spacekey];
    let html = "";

    if (this.game.state.board[z]) {
      if (this.game.state.board[z].deployed[spacekey]) {

	  let tile = "";
          if (z === "hapsburg") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/hapsburg/HapsburgMerc-1.svg" />`;
	    }
	  }
          if (z === "ottoman") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['cavalry']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/ottoman/OttomanCav-1.svg" />`;
	    }
	  }
          if (z === "papacy") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/papacy/PapacyMerc-1.svg" />`;
	    }
	  }
          if (z === "england") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/england/EnglandMerc-1.svg" />`;
	    }
	  }
          if (z === "france") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/france/FrenchMerc-1.svg" />`;
	    }
	  }
          if (z === "protestant") {
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['6']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-6.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['5']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-5.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['4']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-4.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['3']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-3.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['2']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-2.svg" />`;
	    }
	    for (let i = 0; i < this.game.state.board[z].deployed[spacekey]['mercenary']['1']; i++) {
              html += `<img class="army_tile" src="/his/img/tiles/protestant/ProtestantMerc-1.svg" />`;
	    }
	  }
      }
    }

    return html;

  }


  returnMercenaries(space) {

    let html = '<div class="space_mercenaries" id="">';
    let tile = "";
    let spacekey = space.key;

    for (let z in space.units) {

      //
      // ideally our space is "pre-calculated" and we can display the correct
      // mix of tiles. this should be saved in this.game.state.board["papacy"]
      // etc. see his-units for the returnOnBoardUnits() function that organizes
      // this data object.
      //
      if (this.game.state.board[z]) {
        html += this.returnMercenaryTiles(z, spacekey);
	tile = html;
      } else {

        new_units = false;

        let army = 0;
        for (let zz = 0; zz < space.units[z].length; zz++) {
          if (space.units[z][zz].type === "mercenary") {
  	    new_units = true;
            army++;
          }
        }

        while (army > 0) {
          if (z != "") {
            if (z === "hapsburg") {
              tile = "/his/img/tiles/hapsburg/";	  
	      if (army >= 4) {
                tile += `HapsburgMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2) {
                tile += `HapsburgMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1) {
                tile += `HapsburgMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "england") {
              tile = "/his/img/tiles/england/";	  
	      if (army >= 4) {
                tile += `EnglandMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `EnglandMerc-2.svg`;
	        army -= 4;
              } else {
	      if (army >= 1) {
                tile += `EnglandMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "france") {
              tile = "/his/img/tiles/france/";	  
	      if (army >= 4) {
                tile += `FrenchMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `FrenchMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `FrenchMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "papacy") {
              tile = "/his/img/tiles/papacy/";	  
	      if (army >= 4) {
                tile += `PapacyMerc-4.svg`;
	        army -= 4;
	      } else {
	      if (army >= 2 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-2.svg`;
	        army -= 2;
	      } else {
	      if (army >= 1 && tile.indexOf("svg") == -1) {
                tile += `PapacyMerc-1.svg`;
	        army -= 1;
	      }
	      }
	      }
            }
            if (z === "protestant") {
              tile = "/his/img/tiles/protestant/";	  
	      if (army >= 4) {
                tile += `ProtestantMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `ProtestantMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `ProtestantMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
            if (z === "ottoman") {
              tile = "/his/img/tiles/ottoman/";	  
	      if (army >= 4) {
                tile += `OttomanMerc-4.svg`;
	        army -= 4;
              } else {
	      if (army >= 2) {
                tile += `OttomanMerc-2.svg`;
	        army -= 2;
              } else {
	      if (army >= 1) {
                tile += `OttomanMerc-1.svg`;
	        army -= 1;
              }
              }
              }
            }
          }
          html += `<img class="mercenary_tile" src="${tile}" />`;
        }
      }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  returnPersonagesTiles(faction, spacekey) {

    let z = faction;
    let space = this.game.spaces[spacekey];
    let is_naval_space = false;

    if (!space || space == undefined) { space = this.game.navalspaces[spacekey]; is_naval_space = true; }

    let html = "";

      for (let zz = 0; zz < space.units[z].length; zz++) {
	let added = 0;
	if (space.units[z][zz].debater === true) {
          html += `<img src="/his/img/tiles/debater/${space.units[z][zz].img}" />`;
	  tile = html;
	  added = 1;
	}
	if (space.units[z][zz].army_leader && added == 0) {
          html += `<img src="/his/img/tiles/army/${space.units[z][zz].img}" />`;
	  added = 1;
	}
        if (space.units[z][zz].navy_leader && added == 0) {
	  html += `<img src="/his/img/tiles/navy/${space.units[z][zz].img}" />`;
	  added = 1;
	} 
        if (space.units[z][zz].reformer && added == 0) {
	  html += `<img src="/his/img/tiles/reformers/${space.units[z][zz].img}" />`;
	  added = 1;
	}
      }
    return html;
  }

  returnPersonages(space) {

    let html = '<div class="figures_tile" id="">';
    let owner = space.political;
    if (owner == "") { owner = space.home; }
    let tile = "";

    for (let z in space.units) {
      html += this.returnPersonagesTiles(z, space.key);
      if (html != "") { tile = html; }
    }

    html += '</div>';

    if (tile === "") { return tile; }

    return html;

  }

  refreshBoardUnits() {
    this.game.state.board["protestant"] = this.returnOnBoardUnits("protestant");
    this.game.state.board["papacy"] = this.returnOnBoardUnits("papacy");
    this.game.state.board["england"] = this.returnOnBoardUnits("england");
    this.game.state.board["france"] = this.returnOnBoardUnits("france");
    this.game.state.board["ottoman"] = this.returnOnBoardUnits("ottoman");
    this.game.state.board["hapsburg"] = this.returnOnBoardUnits("hapsburg");
    this.game.state.board["independent"] = this.returnOnBoardUnits("independent");
    this.game.state.board["venice"] = this.returnOnBoardUnits("venice");
    this.game.state.board["genoa"] = this.returnOnBoardUnits("genoa");
    this.game.state.board["scotland"] = this.returnOnBoardUnits("scotland");
    this.game.state.board["hungary"] = this.returnOnBoardUnits("hungary");
  }


  displaySpace(key) {

    if (this.game.navalspaces[key]) { this.displayNavalSpace(key); return; }

    let ts = new Date().getTime();
    let no_keytiles_in_keys = [];
    if (this.game.state.board_updated < ts + 20000) {
      this.refreshBoardUnits();
    }

    if (!this.game.spaces[key]) { return; }

    let space = this.game.spaces[key];
    let tile = this.returnSpaceTile(space);

    let stype = "hex";

    if (space.type == "fortress") { stype = "hex"; }
    if (space.type == "town") { stype = "hex"; }
    if (space.type == "key") { stype = "key"; }

    //
    // sanity check on removing siege
    //
    if (space.besieged > 0) {
      let f = this.returnFactionControllingSpace(space.key);
      let anyone_at_war = false;
      let anyone_here = true;
      if (!this.doesSpaceHaveNonAlliedIndependentUnits(space.key, f)) {
	for (let f in space.units) {
	  for (let ff in space.units) {
	    if (space.units[f].length > 0 && space.units[ff].length > 0) {
	      if (f != ff) {
		anyone_here = true;
		if (this.areEnemies(f, ff)) { anyone_at_war = true; }
	      }
	    }
	  }
	}

	if (anyone_at_war == false) {
	  if (anyone_here == true && this.returnFactionLandUnitsInSpace(f, space.key, 1) == 0) {} else {
     	    this.removeSiege(space.key);
	  }
	}
      }
    }


    //
    // should we show the tile?
    //
    let show_tile = 1;

    //
    // do not show under some conditions
    //
    if (space.political == space.home && space.religion != "protestant") { show_tile = 0; }
    if (space.political === "" && space.religion != "protestant") { show_tile = 0; }
    if (space.political == "protestant" && space.religion != "protestant") { show_tile = 1; }
    if (
      space.religion === "catholic" && 
      (
	(space.home == "venice" || space.home == "genoa" || space.home == "scotland" || space.home == "hungary") &&
	(space.home == space.political || space.political == "")
      )
    ) {
      let allied_to_major_power = false;
      if (space.type === "key" || space.type == "electorate") {
        if (this.areAllies(space.home, "protestant", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "papacy", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "france", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "england", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "ottoman", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "hapsburg", 0)) { allied_to_major_power = true; }
      }
      if (space.type === "town" || stype == "hex") {
        if (this.areAllies(space.home, "protestant", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "papacy", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "france", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "england", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "ottoman", 0)) { allied_to_major_power = true; }
        if (this.areAllies(space.home, "hapsburg", 0)) { allied_to_major_power = true; }
      }
      if (allied_to_major_power == false) {
        no_keytiles_in_keys.push(space.key);
        show_tile = 0;
      }
    }

    if (space.language == "german" && space.units["protestant"].length > 0) { show_tile = 1; }

    //
    // and force for keys
    //
    if (space.home === "" && space.political !== "") { show_tile = 1; }
    if (space.type === "key") { show_tile = 1; }
    if (space.type === "electorate") { show_tile = 1; }

    //
    // and force for minor
    //
    if (space.home === space.political || (space.home !== "" && space.political == "")) {
      if (stype === "hex" && space.home !== this.returnControllingPower(space.home)) {
        show_tile = 1;
      }   
    }   

    //
    // and force if has units
    //
    let has_units = 0;
    for (let key in space.units) {
      if (space.units[key].length > 0) {
        has_units = 1;
      }
    }

    //
    // sanity check
    //
    if (tile === "") { show_tile = 0; }

    let t = "."+key;
    document.querySelectorAll(t).forEach((obj) => {

      obj.innerHTML = "";

      if (has_units === 1 || show_tile === 1) {
	if (!no_keytiles_in_keys.includes(key) && show_tile == 1) {
          obj.innerHTML = `<img class="${stype}tile" src="${tile}" />`;
	}
        obj.innerHTML += this.returnArmies(space);
        obj.innerHTML += this.returnNavies(space);
        obj.innerHTML += this.returnPersonages(space);
      }

      if (space.fortified == 1) {
	if (this.game.state.knights_of_st_john == space.key) {
          obj.innerHTML += `<img class="fortified" src="/his/img/tiles/KnightsFortress.png" />`;
	} else {
          obj.innerHTML += `<img class="fortified" src="/his/img/tiles/Fortress.svg" />`;
        }
      }
      if (space.pirate_haven == 1) {
        obj.innerHTML += `<img class="pirate-haven" src="/his/img/tiles/ottoman/PirateHaven.svg" />`;
      }
      if (space.university == 1) {
        obj.innerHTML += `<img class="university" src="/his/img/tiles/papacy/Jesuit_Univ.svg" />`;
      }
      if (this.isSpaceInUnrest(space)) {
        obj.innerHTML += `<img class="unrest" src="/his/img/tiles/unrest.svg" />`;
      }
      if (this.isSpaceBesieged(space)) {
        obj.innerHTML += `<img class="siege" src="/his/img/tiles/siege.png" />`;
      }
    });

  }

  showPiracyMarker(key) {
    try {
      document.querySelector(`.piracy_marker.${key}`).style.display = "block";
    } catch (err) {}
  }

  hidePiracyMarker(key) {
    try {
      document.querySelector(`.piracy_marker.${key}`).style.display = "none";
    } catch (err) {}
  }

  displayNavalSpace(key) {

    if (this.game.spaces[key]) {
      this.displaySpace(key);
      return;
    }

    if (!this.game.navalspaces[key]) { return; }

    let obj = document.getElementById(key);
    let space = this.game.navalspaces[key];

    //
    // to prevent desyncs we make sure all units are in the same order
    //
    for (let key in space.units) {
      if (space.units[key].length > 0) {
	space.units[key].sort((a, b) => {
    	  if (a.type < b.type) return -1;
    	  if (a.type > b.type) return 1;
    	  return 0;
	});
        for (let z = 0; z < space.units[key].length; z++) {
	  space.units[key][z].idx = z;
	}
      }
    }

    //
    // should we show the tile?
    //
    let show_tile = 1;

    //
    // show piracy marker if needed
    //
    if (this.game.state.events.ottoman_piracy_seazones.includes(key)) {
      this.showPiracyMarker(key);
    } else {
      this.hidePiracyMarker(key);
    }

    //
    // do not show under some conditions
    //
    if (show_tile === 1) {
      obj.innerHTML = "";
      obj.innerHTML += this.returnNavies(space);
      obj.innerHTML += this.returnPersonages(space);
    }

  }

  displayNavalSpaces() {

    //
    // add tiles
    //
    for (let key in this.game.navalspaces) {
      if (this.game.navalspaces[key]) {
	this.displayNavalSpace(key);
      }
    }

  }

  addSelectable(el) {
    if (!el.classList.contains("selectable")) {
      el.classList.add('selectable');
    }
  }

  removeSelectable() {
    document.querySelectorAll(".selectable").forEach((el) => {
      el.onclick = (e) => {};
      el.classList.remove('selectable');
    });
    $('.space').off();
  }

  displaySpaces() {

    let his_self = this;

    //
    // generate faction tile info
    //
    if (!this.game.state.board) {
      this.game.state.board["protestant"] = this.returnOnBoardUnits("protestant");
      this.game.state.board["papacy"] = this.returnOnBoardUnits("papacy");
      this.game.state.board["england"] = this.returnOnBoardUnits("england");
      this.game.state.board["france"] = this.returnOnBoardUnits("france");
      this.game.state.board["ottoman"] = this.returnOnBoardUnits("ottoman");
      this.game.state.board["hapsburg"] = this.returnOnBoardUnits("hapsburg");
    }


    //
    // add tiles
    //
    for (let key in this.spaces) {
      if (this.spaces.hasOwnProperty(key)) {
	this.displaySpace(key);
      }
    }

    let xpos = 0;
    let ypos = 0;


    if (!his_self.bound_gameboard_zoom) {

      $('.gameboard').on('mousedown', function (e) {
        if (e.currentTarget.classList.contains("space")) { return; }
        xpos = e.clientX;
        ypos = e.clientY;
      });
      $('.gameboard').on('mouseup', function (e) { 
        if (Math.abs(xpos-e.clientX) > 4) { return; }
        if (Math.abs(ypos-e.clientY) > 4) { return; }
	//
	// if this is a selectable space, let people select directly
	//
	// this is a total hack by the way, but it captures the embedding that happens when
	// we are clicking and the click actino is technically on the item that is INSIDE
	// the selectable DIV, like a click on a unit in a key, etc.
	//
	if (e.target.classList.contains("selectable")) {
	  // something else is handling this
	  return;
	} else {
	  let el = e.target;
	  if (el.parentNode) {
	    if (el.parentNode.classList.contains("selectable")) {
	      // something else is handling this
	      return;
	    } else {
	      if (el.parentNode.parentNode) {
	        if (el.parentNode.parentNode.classList.contains("selectable")) {
	          return;
	        }
	      }
	    }
	  }
	}
	// otherwise show zoom
        //if (e.target.classList.contains("space")) {
          his_self.theses_overlay.renderAtCoordinates(xpos, ypos);
	  //e.stopPropagation();
	  //e.preventDefault();	
	  //return;
	//}
      });

      his_self.bound_gameboard_zoom = 1;

    }


  }


  displayVictoryTrack() {

    let factions_and_scores;
    let x;

try {
    factions_and_scores = this.calculateVictoryPoints();
} catch (err) {
    console.log("#");
    console.log("# error in calculate victory points : " + err);
    console.log("#");
}

try {
    x = this.returnVictoryPointTrack();
} catch (err) {
    console.log("#");
    console.log("# error in return victory point track : " + err);
    console.log("#");
}

    let tiles = [];
    let zindex = 1;
    for (let i = 0; i < 30; i++) { tiles.push(0); }

    for (let f in factions_and_scores) {
try {
      let total_vp = factions_and_scores[f].vp;
      let ftile = f + "_vp_tile";
      obj = document.getElementById(ftile);
      obj.style.left = x[total_vp.toString()].left + "px";
      obj.style.top = x[total_vp.toString()].top + "px";
      obj.style.display = "block";
      if (tiles[total_vp] > 0) {
	let shift = 2 * tiles[total_vp];
        obj.style.transform = `translateY(-${shift}rem) translateX(${shift}rem)`;
	zindex = zindex-1;
        obj.style.zIndex = zindex;
        tiles[total_vp]++;
      } else {
	tiles[total_vp]++;
        obj.style.transform = ``;
        obj.style.zIndex = zindex;
      }
} catch (err) {
}

    }

  }



  returnCardImage(cardname, faction="") {

    let cardclass = "cardimg";
    let deckidx = -1;
    let card;
    let cdeck = this.returnDeck(true); // include removed cards
    let ddeck = this.returnDiplomaticDeck();

    if (cardname === "pass") {
      return `<img class="${cardclass}" src="/his/img/cards/PASS.png" /></div>`;
    }
    if (cardname === "autopass") {
      return `<img class="${cardclass}" src="/his/img/cards/AUTOPASS.png" /></div>`;
    }

    if (this.debaters[cardname]) { return this.debaters[cardname].returnCardImage(); }

    for (let i = 0; i < this.game.deck.length; i++) {
      var c = this.game.deck[i].cards[cardname];
      if (c == undefined) { c = this.game.deck[i].discards[cardname]; }
      if (c == undefined) { c = this.game.deck[i].removed[cardname]; }
      if (c !== undefined) { 
	deckidx = i;
        card = c;
      }
    }
    if (c == undefined) { c = cdeck[cardname]; card = cdeck[cardname]; }
    if (c == undefined) { c = ddeck[cardname]; card = ddeck[cardname]; }


    //
    // triggered before card deal
    //
    if (cardname === "008") { return `<img class="${cardclass}" src="/his/img/cards/HIS-008.svg" />`; }

    if (deckidx === -1 && !cdeck[cardname] && !ddeck[cardname]) {
      //
      // this is not a card, it is something like "skip turn" or cancel
      //
      return `<div class="noncard" id="${cardname.replaceAll(" ","")}">${cardname}</div>`;
    }

    var html = `<img class="${cardclass}" src="/his/img/${card.img}" />`;

    //
    // add cancel button to uneventable cards
    //
    let active_faction = faction;
    if (active_faction == "") { active_faction = this.game.state.active_faction; }

    if (deckidx == 0) { 
      if (this.deck[cardname]) {
        if (!this.deck[cardname].canEvent(this, active_faction)) {
          html += `<img class="${cardclass} cancel_x" src="/his/img/cancel_x.png" />`;
        }
      }
    }
    if (deckidx == 1) { 
      if (!this.diplomatic_deck[cardname].canEvent(this, active_faction)) {
        html += `<img class="${cardclass} cancel_x" src="/his/img/cancel_x.png" />`;
      }
    }

    return html

  }


  displayDebaterPopup(debater) {
    
  }



  async preloadImages() {
    var allImages = [
      "img/factions/protestant.png",
      "img/factions/papacy.png",
      "img/factions/england.png",
      "img/factions/france.png",
      "img/factions/ottoman.png",
      "img/factions/hapsburgs.png",
      "img/backgrounds/reformation.jpg",
      "img/backgrounds/theological-debate.jpg",
      "img/backgrounds/theological-debate2.jpg",
      "img/backgrounds/diet_of_worms.jpeg",
      "img/backgrounds/language-zone.jpg",
      "img/backgrounds/95_theses.jpeg",
      "img/backgrounds/war_horse.png",
      "img/backgrounds/move/assault.jpg",
      "img/backgrounds/move/colonize.jpg",
      "img/backgrounds/move/explore.jpg",
      "img/backgrounds/move/conquer.jpg",
      "img/backgrounds/language_zone.jpg",
      "img/cards/PASS.png",
    ];

    this.preloadImageArray(allImages);
  }

  async preloadMoreImages() {
    var allImages = [
      "img/backgrounds/war-horse.png",
      "img/backgrounds/winter_background.png",
      "img/backgrounds/corsairs_destroyed.jpg",
      "img/backgrounds/diplomacy/excommunication.png",
      "img/backgrounds/henry_viii.png",
      "img/backgrounds/marital_status.png",
      "img/backgrounds/naval_battle.png",
      "img/backgrounds/new_world.png",
    ];

    this.preloadImageArray(allImages);
  }

  preloadImageArray(imageArray=[], idx=0) {

    let pre_images = [imageArray.length];

    if (imageArray && imageArray.length > idx) {
      pre_images[idx] = new Image();
      pre_images[idx].onload = () => {
        this.preloadImageArray(imageArray, idx+1);
      }
      pre_images[idx].src = "/his/" + imageArray[idx];
    }

  }







  addCard(faction, card) {
    let p = this.returnPlayerOfFaction(faction);
    if (p) {
      for (let z = 0; z < this.game.state.players_info[p-1].factions.length; z++) {
	if (this.game.state.players_info[p-1].factions[z] == faction) {
	  if (this.game.player == p) {
  	    this.game.deck[0].fhand[z].push(card);
	  }
	}
      }
    }
  }



} // end and export

module.exports = HereIStand;


